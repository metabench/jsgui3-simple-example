(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const jsgui = require('jsgui3-client');
const {controls, Control, mixins} = jsgui;
const {dragable} = mixins;

const Active_HTML_Document = require('jsgui3-server/controls/Active_HTML_Document');

// Maybe better to include it within an Active_HTML_Document.

// Is currently a decent demo of a small active control running from the server, activated on the client.
//   This square box is really simple, and it demonstrates the principle of the code for the draggable square box not being all that complex
//   compared to a description of it.

// A container with reorderable internal draggable items could help.

// would be nice to be able to have all code in 1 file...???
//  Though the sever code should be separate.


// Relies on extracting CSS from JS files.
// Usage of windows should be very easy on this level.


class Demo_UI extends Control {
    constructor(spec = {}) {
        spec.__type_name = 'demo_ui';
        super(spec);
        const {context} = this;
        
        this.add_class('demo-ui');

        const compose = () => {
            // put 20 of them in place.

            // Then how to arrange them...?

            const window = new controls.Window({
                context: context,
                title: 'jsgui3-html Window Control',
                pos: [10, 10]
            })
            this.add(window);

            


        }
        if (!spec.el) {
            compose();
        }
    }
}

// Include this in bundling.
//  Want CSS bundling so that styles are read out from the JS document and compiled to a stylesheet.
/*...*/

//controls.Demo_UI = Demo_UI;

// A css file may be an easier way to get started...?
//  Want to support but not require css in js.

// But need to set up the serving of the CSS both on the server, and on the client.
//  Ofc setting it up on the server first is important - then can that stage set it up in the doc sent to the client?

// Including the CSS from the JS like before.
//  Needs to extract the CSS and serve it as a separate CSS file.
//  Should also have end-to-end regression tests so this does not break again in the future.
//   The code was kind of clunky and got refactored away.
//   

// Would need to parse the JS files to extract the CSS.
//  Maybe could do it an easier way??? Now that it's easy, want a faster way.


Demo_UI.css = `

* {
    margin: 0;
    padding: 0;
}

body {
    overflow-x: hidden;
    overflow-y: hidden;
    background-color: #E0E0E0;
}

.demo-ui {
    
    /* 

    display: flex;
    flex-wrap: wrap;
    
    flex-direction: column; 
    justify-content: center;
    align-items: center;
    text-align: center;
    min-height: 100vh;
    */
    
}
`;

controls.Demo_UI = Demo_UI;
module.exports = jsgui;
},{"jsgui3-client":11,"jsgui3-server/controls/Active_HTML_Document":377}],2:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],3:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":2,"buffer":3,"ieee754":9}],4:[function(require,module,exports){
(function (Buffer){(function (){

// args all in one objet?
// then we have a monitoring callback?
//  optional?


// monitored-arg-transformations as well?
//  though, these themselves could be observables or promises.
//  possibly callback events would be more efficient, especially within the implementation of observables and other function calling system.
// right now though, function arg transformations are not built into observable.
//  a monitoring callback could be the best way?
// does not quite fit the next, complete, error framework.
// an events callback makes the most sense.
//  
//  do need some kind of callback system anyway.
//   events callback makes the most sense.
const {deep_sig} = require('lang-mini');
// monitored_arg_transformations too?

// should be able to wrap this in a monitoring function to be able to monitor function io.
//  monitoring params / args themselves directly could work better as we wouldn't make duplicate measurements.

// so in stages, monitoring the input, output, and intermediate objects makes sense.
//  then consider inner stage monitoring / stage events API.
//   stages / stage events API does seem useful, but it can't be a huge amount of repetitive code.
//   needs proper abstractions.



// promise, resolving to anything.

// *, P

// anything, can be got from a promise.
//  or keep promise resolution separate?

// o, i?

// i, o probably makes more sense.

// easier for processing promise input.

// capitalise P for promise?



/*



    'R': {

        // just a default change to buffer...

        'B': (input_readable_stream, cb_events) => {
            // No monitoring here right now.
            //  Maybe make monitored transformations.
            // Argument (and result object) monitoring seems best to get io data.
            // transformation event start?
            const chunks = [];
            // maybe data-in-start will make for nicer programming. not sure.
            // pre-data-in-start?
            input_readable_stream.on('data', data => {
                // monitoring event?
                chunks.push(data);
            });
            input_readable_stream.on('end', () => {
                fn_ready_args = Buffer.concat(chunks);
                if (cb_events) cb_events({
                    name: 'complete',
                    io_sigs: ['R', 'B'],
                    value: fn_ready_args
                });
                // no events at present to raise
                / *
                raise_stage_event('pre-data-in-complete', {
                    //'sig_from': 'R',
                    //'sig_to': 'B',
                    //'from': next_apply_args,
                    //'to': fn_ready_args
                });
                // does not seem to be a pre-processing output process / stream.
                //  do not need to have data-in and data-out in all cases.
                raise_stage_event('pre-complete', {
                    'sig_from': 'R',
                    'sig_to': 'B',
                    'from': next_apply_args,
                    'to': fn_ready_args
                });
                */
                /*
                raise_stage_event('post-input-transform', {
                    'from': 'R',
                    'to': 'B'
                });
                * /
                // monitoring / length recording / events?
                //exec_fn();
            });
            input_readable_stream.on('error', err => {
                console.log('error reading stream for param transformation in stages()');
                // callback with the error event.
                error(err);
            });
        }
    }

*/

// Default transformations...
//  but would be nice to annotate with the result type. maybe with mfp.

const transformations = {
    'O': (obs, cb_events) => {
        // build up the chunks?
        // or could use then.
        obs.then(res => {
            // get the res sig...
            const sig = deep_sig(res);
            if (cb_events) cb_events({
                name: 'complete',
                io_sigs: ['O', sig],
                sig: sig,
                value: res
            });
        }, err => {});
        /*
        obs.on('complete', complete_data => {
        });
        */
    },

    'p': (p, cb_events) => {
        p.then(res => {
            // get the res sig...
            const sig = deep_sig(res);
            if (cb_events) cb_events({
                name: 'complete',
                io_sigs: ['p', sig],
                sig: sig,
                value: res
            });
        }, err => {});
    },
    'R': (input_readable_stream, cb_events) => {
        // Only transforms to a buffer.
        // No monitoring here right now.
        //  Maybe make monitored transformations.
        // Argument (and result object) monitoring seems best to get io data.
        // transformation event start?
        const chunks = [];
        // maybe data-in-start will make for nicer programming. not sure.
        // pre-data-in-start?
        // may as well monitor number of ms taken
        // timing monitoring elsewhere?
        //  could have another external layer that logs the times of the various events?
        // for the moment, ms_taken would help here.
        const ms_start = Date.now();
        // raise a start event.
        input_readable_stream.on('data', data => {
            // monitoring event?
            // Could raise the data event.
            //  A version with integrated monitoring as well?
            chunks.push(data);
        });
        input_readable_stream.on('end', () => {
            //fn_ready_args = ;
            const ms_complete = Date.now();
            const buf = Buffer.concat(chunks);
            const ms_taken = ms_complete - ms_start;
            //  byte_rate (per s)
            const byte_rate = buf.length / (ms_taken / 1000);
            if (cb_events) cb_events({
                name: 'complete',
                sig: 'B',
                io_sigs: ['R', 'B'],
                value: buf,
                bytes: buf.length,
                ms: ms_complete,
                ms_taken: ms_taken,
                byte_rate: byte_rate
            });
            // monitoring / length recording / events?
            //exec_fn();
        });
        input_readable_stream.on('error', err => {
            console.log('error reading stream for param transformation in stages()');
            // callback with the error event.
            error(err);
        });
    }
    // this level: param sig required
    // this level: param sig given: function to transform
    // promise resolution here?
}

module.exports = transformations;
}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":3,"lang-mini":379}],5:[function(require,module,exports){


// If it's useful for obs and stages, then input and output transformation in one function with integrated monitoring could work well.



// Separate version for monitored transformations?
//  Keep this as a core?
//  A way to extend this?


// Could make a new fn-io-monitored-transform
//  And different options for what gets monitored.
//  Seems easy already to add timings for various things.
//  Not so sure we need another module.




// fn-io-monitored-transform???
//  that seems like it would be more applicable to stages()
//  seems useful for getting io data rates, and transformation rates?

// https://www.npmjs.com/package/bson
//  Would be quite simple to get BSON up and running quickly as an optional encoding method.





const {deep_sig} = require('lang-mini');


/*
    Definition / map of input transformations by sig

    This will also wrap a function to create another callable function.


    // such as: returned promises are to be resolved.

    // This is going to use asyncronous transformations.


    // and with some functions, could provide transform streams?

    fn_io_transform(fn, sig_map_input_transformations, sig_map_input_transformations)


    // A status wrapper function?
    //  So we can define what the status of the function is when it's been called.

    // pre, main, post ... complete?
    //  always ends with complete? or 'done'.


    // Would allow for a nice complete / done / finished aliasing.


    // 


    // Integrating its own monitoring here could be useful.

    


*/

// a non-fp version of this?
//  just to do the transformation, get the callback
//   including transformation event callbacks?


// and a transformation event callback too?
// options?
//  enable monitoring
//  

// const obj_transform = (obj, map_transformations)

// cb_transformation_events(evt)
//  

// auto_promise_resolve?
//   promise resolution 


// Are transformations defined backwards right now?
//  Easier to start with what we currently have.
//  Be able to set up a transformation so that looks at the params we have.

const isArguments = ( item ) => Object.prototype.toString.call( item ) === '[object Arguments]';


// And a transformation event callback too?


// including monitoring in the function definition???
//  may be implicit and set up when using stages ().
//  or an easy to set option.





const fn_transformation = (fn, map_transformations) => {

    //console.log('');
    //console.log('fn_transformation');
    //console.log('');

    //console.log('Object.keys(map_transformations)', Object.keys(map_transformations));
    //console.trace();


    // both input and output tranform, as defined, if defined.
    //  not even automatic promise resolution assured here - needs to be provided in the map.

    const input_transformations = map_transformations.i;
    const output_transformations = map_transformations.o;

    // needs to return a function.

    // function will always be async?
    //  will use event callback rather than observable.

    const fn_res = function() {
        const args = arguments;

        if (args.length === 2 && typeof args[1] === 'function') {
            let [a, cb_transform_exec_events] = args;
            if (isArguments(a)) {
                if (a.length === 1) {
                    a = a[0];
                }
            }

            // so now a is the proper function call args???
            //  check to see if a is an arguments object.
            //   only one object there? swap it for item 0

            // maybe was not given an arguments object?
            // a could be an object?

            //let fn_ready_args;
            const sig_called_with = deep_sig(a);
            const sig_arguments = deep_sig(arguments);
            // fishing the argument out of the arguments object?

            //console.log('transformed fn called with sig', sig_called_with);
            //const exec_output_transformations = () => {
            //}

            const exec_fn = () => {

                //console.log('fn transform exec');


                //console.log('!!fn.skip', !!fn.skip);

                // decide if we skip the function call - returning the input.


                // exec start, exec complete

                // And will also measure exec timings.


                cb_transform_exec_events({
                    'name': 'exec-start'//,
                    //sig: evt_output_transform.sig,
                    //value: evt_output_transform.value
                });

                const fn_res = fn.call(null, a);

                cb_transform_exec_events({
                    'name': 'exec-complete'//,
                    //sig: evt_output_transform.sig,
                    //value: evt_output_transform.value
                });


                const sig_fn_res = deep_sig(fn_res);
                if (output_transformations) {
                    if (output_transformations[sig_fn_res]) {
                        output_transformations[sig_fn_res].call(null, fn_res, (evt_output_transform) => {
                            cb_transform_exec_events({
                                'name': 'complete',
                                sig: evt_output_transform.sig,
                                value: evt_output_transform.value
                            });
                        });
                    } else {
                        cb_transform_exec_events({
                            'name': 'complete',
                            sig: sig_fn_res,
                            value: fn_res
                        });
                    }
                } else {
                    // probably should have been given an events cb function.
                    cb_transform_exec_events({
                        'name': 'complete',
                        sig: sig_fn_res,
                        value: fn_res
                    });
                }
            }

            const skip_fn = () => {
                // complete callback.
                cb_transform_exec_events({
                    'name': 'complete',
                    //sig: sig_fn_res,
                    value: a,
                    skipped: true
                });

            }
        
            if (input_transformations) {

                // do we skip the stage?
                let do_skip = false;
                //console.log('!!fn.skip', !!fn.skip);
                if (fn.skip) {
                    do_skip = fn.skip(a);
                }

                // Only do / try the input transformation if we don't already have accepted parameters?

                //console.log('have input transformations');
                //console.log('Object.keys(input_transformations)', Object.keys(input_transformations));

                //console.log('sig_called_with', sig_called_with);


                // if the sig_called_with is already in the accepted sigs?

                //console.log('fn', fn);
                //console.trace();
                //throw 'stop';

                //console.log('do_skip', do_skip);

                if (do_skip) {
                    //console.log('skipping function call');
                    skip_fn();
                } else {

                    if (fn.map_sigs && fn.map_sigs[sig_called_with]) {
                        exec_fn();
                    } else {
                        if (input_transformations[sig_called_with]) {
                            // run that transformation function.
        
                            // need to add the extra callback argument?
                            // apply not call?
        
                            // call seems better.
                            //  call it with an arguments object?
        
                            //console.trace();
                            //throw 'stop';
        
                            // 
    
                            // input transform start.
    
                            
    
                            cb_transform_exec_events({
                                'name': 'input-transform-start'
                            });
                            
    
    
        
                            input_transformations[sig_called_with].call(null, a, (evt_input_transform) => {
                                //console.log('evt_input_transform', evt_input_transform);
                                const {name, sig, value, io_sigs} = evt_input_transform;
                                if (name === 'complete') {
                                    a = value;
                                    evt_input_transform.name = 'input-transform-complete';
                                    // then report this event to a listener?
                                    //cb_transform_exec_events
                                    cb_transform_exec_events(evt_input_transform);
                                    exec_fn();
                                } else {
                                    console.trace();
                                    throw 'NYI';
                                }
                                //console.trace();
                                //throw 'stop';
                                // replace the argument(s) a with the value
                            });
                        } else {
                            // just call it
                            //fn_ready_args = a[0][0];
                            exec_fn();
                        }
                    }


                }

                

                
                // arguments object has already been sorted out.



                /*




                if (isArguments(a[0]) && typeof a[1] === 'function') {
                    console.log('carry out input_transformations', fn.name);
                    console.trace();

                    //const input_transformation_sigs = Object.keys(input_transformations);

                    console.log('!!input_transformations[sig_called_with]', !!input_transformations[sig_called_with]);
                    console.log('sig_called_with', sig_called_with);

                    
                } else {

                    console.log('a.length', a.length);
                    console.log('Object.keys(a)', Object.keys(a));

                    console.log('sig_called_with', sig_called_with);


                    if (input_transformations[sig_called_with]) {
                        input_transformations[sig_called_with].call(null, fn_res, (evt_output_transform) => {
                            //console.log('evt_output_transform', evt_output_transform);
        
                            console.trace();
                            throw 'stop';
        
        
                            // Could have been a promise resolution.
                            //const sig_fn_res = deep_sig(fn_res);
                            console.log('Object.keys(evt_output_transform)', Object.keys(evt_output_transform));
        

                            // / *

                            //cb_transform_exec_events({
                            //    'name': 'complete',
                            //    sig: evt_output_transform.sig,
                            //    value: evt_output_transform.value
                            //});
                            // * /
        
        
        
        
                            // probably want something for 'sig' which corresponds to the value.
        
        
        
        
        
                        });
                    } else {
                        console.log('89347812 pre exec');
                        exec_fn();

                    }


                    //console.trace();
                    //throw 'NYI';
                }

                */

                // transformation sigs
        
                // process them....
                //if (input_transformations)
        
                
        
        
        
            } else {
                //fn_ready_args = arguments;
                exec_fn();
            }

            //console.log('');
            //console.log('calling transformed function fn.name', fn.name);
            //console.trace();





        } else {
            throw 'Expected args: normal_args, cb_transform_event';
        }



        


        
    }

    if (fn.name) fn_res.name = fn.name;
    if (fn.main) fn_res.main = fn.main;
    if (fn.skip) fn_res.skip = fn.skip;

    // 



    return fn_res;


   

}


module.exports = fn_transformation;
},{"lang-mini":379}],6:[function(require,module,exports){

//const lang = require('lang-mini');
//const Evented_Class = lang.Evented_Class;
//const get_a_sig = lang.get_a_sig;
//const get_truth_map_from_arr = lang.get_truth_map_from_arr;
const {each, Evented_Class, get_a_sig, get_truth_map_from_arr, tof, tf, mfp, deep_sig, clone, def, is_array} = require('lang-mini');
const fn_io_transform = require('./fn-io-transform');


/*
    18/06/2019 - New version, will use io transform and measurement abstractions.


    21/06/2019 - Get it working (basically) using function io wrappers.
        Now need the abstractions for monitoring / stage monitoring / arg & param & res monitoring.


    // Also the initial arg?
    // For the moment, monitor the arguments between the stages.
    // Also the result arg.

    //  can monitor arrays too?
    // monitor_item(item, evt_monitoring => ())

    // The event callback system makes a lot of sense to use.







    // function monitoring


    // io transformations

    // monitoring the io transformations

    overall fn input = first stage fn input = first stage pre-processing input


    // Tracking where the same arguments are used?

    // Tracking execution stage - where the execution is between?



    // really want to know the input and output of each function call.


    //  arguments watcher?
    //  arguments info and watcher?


    // call a function on the args.
    //  gets the sig
    //  monitors any streams and observables.

    // observe_args?


    //  monitor-args?
    //   seems best as a callback function? or multi-callback function?
    //    event callback function.
    //     


    // Monitoring the args at various io / function call stages will be useful so we don't wind up monitoring the same arguments / io too many times.











*/



// Most likely will leave out a separate status() function wrapper.
//  Maybe that should be part of the normal observable?

// Anyway, need to have the monitoring and io transforms


// input to the whole function
// output to the whole function.


//  Monitoring of io transforms too....


// monitoring functions with stages, and output transformed stages:
//  do we need to monitor the same stream twice? 3 times?

// monitoring the variables involved is important.
//  output from one function is (often?) input to the next.

//  so monitoring the variables / parameters will mean that we have both the output of one part and input to the next.

//  see about just wrapping all of the functions with io_transform.
//   leave monitoring out of it for the moment.












const log = () => {};

//const log = console.log;

// Could have one overriding fnl function?
//  Not yet.


// Stages could be redone in the near future so that it makes use of a pre / main / post function call system.
//  mfp+

// For the moment, continue and finish the implementation here.
//  But possibly a lower level observable function call system will help?

// Observable function call with preprocessing.
//  So each stage is an observable.
//   observables with a 'start' event?

// or each stage as an Evented_Function?
//  like an observable in some ways, but raises events that can be listened to.

// efn?
//  efp?
//   evented functional polymorphism?

// iofn? 
//  allows input and output processing


// .io , .i, .o interfaces?
//  quick to type :)

// measure(fn)
// measure_io(fn)
// io_events = measure_io(fn_call)


// finishing of the current system would make sense though
//  will create the io object.

//  will create the stages object?

//  .info?
//   the information object that contains info about things such as io?


// .io_events
//  get an event_stream function / object?
//   and is that possible to make here?

// subscribe to all function events....
//  measure those function events

// measure timings

// possibilities such as getting the event processing info as its own observable?

// move stages processing out of observable?


//  





// 12/06/2019 - Stages working so far, want to try it on some more important functions such as dl.
//  Each stage can provide an observable
//   when data needs to be batched and decompressed that won't be so useful in some cases.
//  Allow data to be used as soon as available.
//   Can integrate download / transfer / process rates more easily in some cases.

// 12/06/2019 - quite effectine in storing stage execution timing info so far.

// More work on data rate analysis here?
//  Or worth having real code that deals with these buffers first
//   That would make sense.
//    See where is can send over such data if necessary

/*

14/06/2019

Further events: ??

input-stream-start
input-stream-complete / end?

// observable end?
//  change from complete?

// and next becomes data?
// Observables are very much like readable streams.
//  Not quite the same.

// Time from input start to output complete

// start

// input-start
// input-complete
// output-start
// output-complete

// complete

// an events callback on an observable?
//  or io object is enough?


// observable.io seems fine.
//  maybe make it optional? later?
// does make sense for basic timings.

// function call io tracking definitely makes sense as a separate part.
//  encapsulating this seems like it would definitely help. maybe with performance too?

// then a system of [pre, main, post] would be wrapped like this.

// .stages.events?

// .events
//  execution events? io events?

// stage api...

// execution times wrappers.
//  argument transformation events?


// could likely make this simpler through making further wrapping functions.
//  would only work on an observable function?
//  

// monitor observable
//  monitor(fn_obs)
//  monitor(obs)

// io_transforming(fn)
//  itself with 3 stags?


// function io monitoring seems like it would be generally useful.


//  functionally / event driven involving hooks or similar?
//   could directly give it an event handler function.

// maybe want some different ways of using these advanced function calls.



// oobs.io.rate
//  but getting the rates of different stages is important too.

//     .io.stages




// 





// option: monitor: true


// o_dl.monitor?






//  ms (absolute)
//  ms since start of the observable
//  ms since start of the stage

// do want detailed timing information.
//  but could have a time updater on 1 ms ticks for performance reasons.
//   means we just measure the time 1000 times a second.

*/


// fnl()
// fns-es6 ?

// could use the word 'obs'.
// observe, observable
// res, result
// resolve
// done
// then
// to
// wait
// after
// go
// open
// r() gets result
// sequence
// seq
// let obs = seq(definition).go();
// let res_all = await(seq(definition)).go();
// complete
// end
// begin
// start
// stop
// finish
//  autostart
//   auto
// args?

// listen   |
// hear     |
// follow   |

// monitor
// map

// observable.filter
// observable.map
// observable.stop, pause, resume
// observable.status (get)

// Decoding options in observable too (possibly)
// An observable that does the decoding?

// Observable and observer in one...
//  observer.observe(other_observable, (my_next, my_complete, my_data))???

// spread operators could be useful.

// so, we want a function sequencer
//  could change every function that gets called into an observable if it is not already

// stages now involves each stage having pre, main, and post, each having possible intermediate data events.
//  possibly a long download will help to illustrate this better.

// need to be better at raising timing events

// input start to input complete during each stage


//  know how long the input takes
//   be able to calculate input rate b/s
// output start to output complete during each stage


// could be more concise and on-point with an imo input, main, output abstraction.
//  with automatic input and output processing.


// Getting the event & timing working with the current code structure makes most sense.

// Possible to log all event names?

// We don't exactly have a function for preprocessing.
//  may be nice to use the right abstraction(s) there.

// For the moment, implement it without them, and then use regression testing to check that code improvements keep the right API and measurements.

// pre-input-start
// pre-input-data
// pre-input-complete
// pre-exec-start???

// main-exec-input-start
// main-exec-input-data
// main-exec-input-complete ??? where will this occurr?

// main-exec-start

// main-exec-run-complete  ????? before the input has necessarily complete ?????
//  main-exec-fn-complete?


// main-exec-complete ?????          exec_complete? because maybe it's not complete, as in all data processed.

// main-exec-output-start
// main-exec-output-data
// main-exec-output-complete



// don't want function monitoring and io transformations to only be part of stages.
//  it's come about because it's needed for the stages to work, be instrumented, but it could be used elsewhere too.


// create the packages later.


// monitor and transform could likely be brought in under fnl, returned with it too.



// 




// monitor-function ???

// function-monitor is available within npm. unabbreviated names better for SEO. abbreviated quicker to type.
// could bring function-monitor into vhl, and through the functions, such as dl, that vhl provides.

// function-io-transform
//  as part of mfp? or extended from it?





// mf???

// mfp - monitored functional polymorphism?
//  maybe monitor-function could use this
//   input and output types, sizes, data events.
//    this should be able to calculate rates.


// function monitoring, as well as io transformations.



// even put function monitoring in mfp?








// Want rates and stage rates easily available in staged fn results.
//  Can have rates for various streams
//  For various transformations (2 streams?)

// calculating rates and ratios is nearner now.






const nce = (obs, next, complete, error) => {
    obs.on('next', next);
    obs.on('complete', complete);
    obs.on('error', error);
    return obs;
}


const monitor_item = require('./monitor-item');
/*
const obs = (next, complete, error) => {
    let res = new Evented_Class();
}
*/

// This is essentially a function wrapper.
//  creates an observable function.
//  Defining params in the function could really help.
// definitely want more examples and tests of this observable type system.
//  this seems like one of my best developments so far.
// ofn?
//  an object and a function together as parameters for a function call
//  always returns a function?
// a variety of standard functions such as...? all functions?
//  obext, vhl, fnl, obs, fp, mfp, ofp, ofn
// ofp and ofn could be useful general purspose functional modules.
// ofn - executes a function, taking the parameters and re-ordering them?
// allow mfp to do function reordering.
//  that could work very nicely.
// Definitely need some very cool and efficient functional programming tools.
// redoing observable makes a bit of sense here.
// remove always_plural
//  it's been there, but have not been using it for advanced tech.

// the new observable function...
//  seems to be malfunctioning a little.
//  fixed now. Has more flexibility with opts object.

// mfp could be really useful here.
//  could put it in later though.

// would be nice to give the return type, other parts of grammar.

// paused?
//  definitely seems relevant / useful.

const tm_status_strings = {
    'init': true,
    'ok': true,
    'complete': true,
    'error': true,
    'paused': true
}

// observable could do with a way of implementing different stages
//  defining the stages?
//   want them to be readable

// or even give an object with functions instead of fn_inner?
//  better to store stages in an array?
//   seems more conventional.

// array of stages does make sense.
//  and a function for each stage

// maybe a stages([fn, fn]) function?
// stages below observable?
//  or a more like a lang-mini upgrade to call_multi
// stages is a better idiom.
//  possibly could / should return an object
//   a staged_fn?

// seems like the staged_fn could be a building block for obs.

// what would it return?
//  result of the last stage.
//   not some kind of staged obs?

// but then async stages being specifically important
//  defining stages as an array.....
//   seems better within the observable function body for the moment?
//  therefore a stages function.
//   lang-mini?
//    worth giving it a go.

// observable stages will be useful.
// for the moment, make the 'stages' function do some things, but don't have a specic stages array enclosure function.

// looks like the right way to do it.
// itself tracks its timings.

// got a lot more support for stages.
//  the stages() function now is built on top of obs, and provides syntactic sugar to use it well.

// active rate monitoring events, say every 1s, would help.
//  it could traverse back through its own next data info array.
//   calculate the rate going back for the last 1s.

// and want to be able to calculate the average_rate of a stage for all its data.
//  bytes per second (by default)
//   other rates could cauls problems if we expect bytes per second.
//   data_rate?
//    plus there will maybe be input_rate.
//    output_rate is what we are referring to, maybe processing rate.
//     output_rate sounds nice.

// be able to watch the output rate.
//  or be able to get readouts, like for the last 5s.

// getting the output_rate for any stage seems very useful.

// will be a slightly complex function.
//  need to think of the best API / APIs.

// possibly an analysis API.
//  possibly feed stages next data through further.
//   the stages observable next event?
//    maybe it could cover all next events, feed them through.
//     and we look at .stage to see when it changes stage.
//      not sure.
//   want a decent idiom / convention.

// however, maybe we want stage exec start
// stage exec complete
//  or end?
//  going with complete for the moment.
//   may have an 'end' synonym in the observable
//    Evented_Class event name alises / syonyms.

// pre-exec
// post-exec
//  could measure the complete time there.
//   pre and post is shorter than start and complete.
//   makes sense here.
// would be called in stages(...);

// input-start definitely seems like a good start or a stage.
//  
// Observable will measure its ms_complete value
//  How long it takes to complete.
// ms_error as well?

// o_something.i, .o, .io
// .io.rate
//  .io.ratio?
//  .io.stages[name].rate / ratio?

// .io.stages[name] seems OK in terms of following the same pattern. separately breaking down io.
//  ????

// .i.stages[name] is the input data
// .o.stages[name] is the output data

// .io as array of input and output.

// res.io
//  one single object there.
//   simpler API.

// .stages[name].ms?
//   the stages relative to the staer, all together work quite nicely.
//   leaving .ms.rel.stages for the moment.
//  maybe .ms will have more detailed timing info.

// .stages[name].io.rate?


// Obs has come on well for use in stages
// Could do with a bit more clarity about status feature.

// Will now make it raise .io complete when its not waiting for a readable stream (or other?)

// Having stages make a note that there is ongoing io?


// io.ongoing?

// a 'done' synonym / alias could work well.
//  done being more concise than 'complete'. Same / very similar meaning too.


// some kind of status saying io is ongoing?
//  not always having an io object?



// 


// Named observables may be of use
//  Where the returned observable object has a name

// Identified observables
//  Where the returned observable object has a unique (probably ascending) id


// Event name aliasing could help.
// It can be convenient and intuitive to program a 'data' event rather than a 'next' event.
// Raising them both would help.

const observable = function(fn_inner, opts) {
    // 12/06/2019 - much improved.
    // 13/06/2019 - working on stages events API
    //  An observable will be able to run in stages
    //  use stages() call to set it up easily.

    const a = arguments;
    const l = a.length;
    const sig = get_a_sig(a);
    let _opts, _fn_inner;

    // will have .i, .o, .io in the result.

    // stages will write expanded io data there.
    //  input_bytes
    //  output_bytes

    // input_rate
    // output_rate

    // will have plenty of nice and interesting measurements from a variety of function calls.

    //  Application instrumentation of a function call will definitely help.
    //   Choose the params for running it.
    //   Observe the (nested) results.
    //    View profiling / timing info.

    // Could do that with with dl quite soon.
    //  A simple version at least.
    //   Maybe then make the simple version extensible.
    //   Still simple to use.
    // Maybe could keep it simple, but allow complex functions and UIs to be plugged in.

    // .i
    // .o
    // .io = [.i, .o];
    // Anyway, need to obs_instance.io array.

    // work out rates over time
    // case?
    
    if (sig === '[f]' || sig === '[f,u]') {
        _opts = {};
        _fn_inner = a[0];
    } else if (sig === '[f,o]') {
        _fn_inner = a[0];
        _opts = a[1];
    } else if (sig === '[o,f]') {
        _opts = a[0];
        _fn_inner = a[1];
    } else {

        if (sig === '[O]' || sig === '[O,u]') {
            return a[0];
        } else {
            console.log('sig', sig);
            console.trace();
            throw 'NYI';
        }
        // when we already have an observable - not sure why wrapping would again be attempted.

        
    }


    // not on the specific function...?
    //  may be nice to have an obs_fn?
    //  




    

    const obs_res = ((opts, fn_inner) => {
        // get values from the opts....
        //  name option is becoming important now.
        // then this will need to return something.
        const ms_start = Date.now();
        // ms.abs, ms.rel
        const ms_since_start = () => Date.now() - ms_start;
        const res = new Evented_Class();

        // make that optional?
        const io = res.io = new Evented_Class();



        // io.ongoing?
        //  would be a decent place for that flag.

        // io.status?
        //  be able to tell / automatically tell when the status is complete.
        //   may be better there than the function's overall status
        //    io status being automatically set in function execution?
        //     in stages function execution?





        // Flagging whether we are waiting for io makes sense.
        //  Want to say the io is complete when the function call is totally complete.
        //  For the moment the .io complete event is what we'll use
        //   maybe it's not perfect.

        // .io complete event is important...
        //  want to detect cases where there is ongoing io.

        // maybe the complete event will also contain the/an io complete callback.

        // io complete will be the completion of the last uncomplete stage.
        //res.io = new Evented_Class();

        // Save res time?
        //  record res time
        //  record_res_ms
        // Absolute and relative timings 
        // Only have stages there when using stages???

        // not so sure about res.ms right now.
        //  changing the time that measurement works during staged functions.

        // probably not using .ms and .io for the moment.

        /*

        res.ms = {
            abs: {
                start: ms_start
            },
            rel: {
                start: {
                    //stages: {

                    //}
                }
            }
        }

        */
        // res is the evented class.
        //res.i = {};
        //res.o = {};
        //res.io = [res.i = {}, res.o = {}];

        // write stage output io?
        // want the stage names as objects.

        //  And functions to get the recent rate?
        //  logging data events too?
        //   could track the number per second?

        // Want to send events through .io.

        // and will raise io events at various points in time
        //  for the overall function
        //  for the stages
        //   for substages of those stages      (encapsulate the 3 stage input(transform), main, output(transform))

        // input_main_output
        //  probably best not to use the 'stages' api for this, stages will use the IO transform system. call it a 'substage'.
        //res.io = {};
        // then it will have stages too for the io.
        // res.ms.latency
        // res.ms.taken?
        // res.ms.total?
        /*
        const record_res_ms = (name) => {
            const now = Date.now();
            res.ms.abs[name] = now;
            res.ms.rel.start[name] = now - ms_start;
        }
        */

        let llog = [];
        let _status = 'init';
        
        //log('ms_start', ms_start);
        // obext read_only?

        Object.defineProperty(res, "ms_start", {
            value: ms_start,
            writable: false
        });
        // latency property as well.
        //  until it is in the 'ok' stage
        // just the raw timings stored here.

        let ms_ok, ms_complete, ms_error;
        let ms_to_ok, ms_to_complete, ms_to_error;

        // automatic timing measurements of observables will be very useful.
        // time_taken?
        //  since the start, as it continues

        // time_to_complete
        //  undefined if it's errored.
        // time_to_error
        const map_status_data = {};

        // total ms, as in full time. wont be 0 in map at least.
        const map_ms_reached_status = {};

        let stage_number = -1;
        let stage_name = 'init';  // automatic stage.  or 'start' stage?
        // respond to the stage function call.
        // it's stage -1. unindexed.

        // for example:
        //const stage_execution_info = [_stage_number, stage_name, stage_call_type_abbreviation, stage_res_type_abbreviation, time_started, time_into_observable];

        // also make the stage event API available?
        //  and stage info API?

        // stage info being the info needed for simpler monitoring.
        // as a map or array?
        //  array does make more sense.

        /*

        const stages_execution_info = [
            // any further execution info?
            // it could go here.
            // how many ms into the stages execution / since start.
            // anything about data type here?
            //[stage_number, stage_name, '', ms_start, 0]
            // leaving this init stage out for the moment.
        ];
        */

        // seems basically unused now.
        //const arr_stage_log = [];
        // stage execution info.
        //  mapped by name
        //   in an array too?

        // want decent stage execution info.

        // map of stage indexes by name
        //  vice versa?

        // stages can't share names.
        //  seems easy enough, decent restriction.

        // stage timings.
        //  want to record specific info about stages and statuses

        // log gets the status and the stages too?
        //  and inner obs log data?
        const log = (data) => {
            const log_item = [Date.now(), data];
            llog.push(log_item);
            res.raise('log', log_item);
        }

        // stages will simply be names.
        //  status can have accompanying data.

        // Could there just be a status object?
        //  Maybe don't need to map / track status changes.

        const status = (str_status, data) => {
            if (tm_status_strings[str_status]) {
                const old_status = _status;
                if (!map_ms_reached_status[str_status]) {
                    map_ms_reached_status[str_status] = Date.now();
                }
                map_status_data[str_status] = data;
                _status = str_status;
                res.raise('status', {
                    old: old_status,
                    value: str_status,
                    data: data
                });
            } else {
                console.trace();
                log('str_status', str_status);
                throw 'invalid str_status ' + str_status;
            }
        }
        // initial stage?
        //  'init' by default?

        let _stage;
        let current_stage_info;

        // stage events API will solve it.

        /*
        const _____begin_stage = stage_name => {
            _stage = stage_name;
            const now = Date.now();
            const ms_into = now - ms_start;
            current_stage_info = [stage_name, ms_into, now];
            arr_stage_log.push(current_stage_info);
        }

        // autocall this if beginning new stage, or if complete is called.
        const ____stage_complete = (stage_name, stage_res) => {
            const [_stage_name, ms_into, ms_stage_start] = current_stage_info;
            const now = Date.now();
            const ms_time_taken = now - ms_stage_start;
            current_stage_info.push(ms_time_taken);
            _stage = null;
        }
        */
        // also stage input data given here?
        //  could be optional??
        //   being given the stage number here as an arg would help.
        //    do that from 'stages'. maybe autoincrement if undefined?
        //     error stage is -2?

        // lets see if /that we can do it.

        //  maybe we do need stage_complete for when non-obs promises resolve.
        //   think it's just promises for the moment that needs it.

        //   but that would be in the stages part.
        //    could give an event to this function for promise resolution?
        //     that may need to be within the 'stages' section.
        //     promise resolution happens there.
        //      maybe could also send observable events here? not sure....

        // a num_stages property could help.
        //  need to know if a promise is the last stage?
        //   as that promise needs to resolve, and be returned in the obs res.

        // the last promise in the chain is a bit of an odd case.
        //  functions are OK at getting the result of a promise as its param,
        //   but with the last function if it's a promise, need to wait for the promise result.

        // maybe should keep this as minimal as possible.

        //  unsure about stage resolution / further systems within obs.
        //   or that obs provides the stage facility / API for it, then stages() makes it easy to use.
        //   keep it like this for the moment, or similar.

        // ec_stage_events

        //  seems necessary to observe a stage, but don't want to use another observable for it.

        // Monitor stage IO.
        //  a stage could have stages in a sense.
        //   dont want it to become confusing.

        // Don't give it the result immediately?
        //  This part could also cover the pre-stage steps such as input param transformation.
        //   eg getting a buffer from a stream means waiting for the stream to complete, want to get info about the data transfer rate

        // Stage Events API.
        //  That would make more sense.

        // Be able to say what stage an observable is in.
        //  stages() sets it up nicely for normal usage.
        // Evented_Class_That_Remembers???
        // stage_events API
        // stage name, stage events evented class
        // Probably best to redo this function.
        //  change to stage_api.
        // and a stage info API?
        // this part is only for measurement / monitoring / instrumentation.
        /// will be very interesting to measure a large amout of dls at once.
        //   instrument it with a monitoring app too.
        // Including timing data within io would help a lot.
        //  time taken only - that is what is used to calculate the rate.
        // io.stages.stage.ms_taken?
        //  .ms?

        // a stage could have a .ms measurement, within the io part.
        //  absolute and other more detailed timing info would be stored elsewhere.

        // separate input and output rates.

        // Most likely, will remove all or most of this.
        //  will make use of the io transformation and monitoring on each of the stages

        // io transformation monitoring too.
        //  seems somewhat important, integrating them at least.

        // maybe going a little slower to make this now makes sense.
        //  need to make sure that we make the right use of abstractions.

        // observing the io on the stages
        // applying io transformations to the stages.

        // examples and tests of io transformations.
        //  abstracting away io transformations and monitored io transformations will be very useful.


        // get rid of this and some other stage monitoring.
        //  it's going to be done with some other (slightly lower level) functions.


        //const stage = (stage_name, ec_stage_api) => {


        // another abstraction for dealing with function status, and its timing?
        //  function status could work well for pre, main, awaiting-result, post

        //  fn_status would be a nice and simple abstraction.
        //   can specify the status values.
        //    will understand simple works like 'pre', 'post', 'main'.
        //     status will be less sophisticated than stages.

        /*

        //  as in stage io timings.
        Object.defineProperty(res, "latency", {
            get: () => {
                if (map_ms_reached_status['ok']) {
                    // calc it here
                    return map_ms_reached_status['ok'] - ms_start;
                }
            }//,
            //writable: false
        });
        */

        /*
        Object.defineProperty(res, "ms_to_complete", {
            get: () => {
                if (map_ms_reached_status['complete']) {
                    // calc it here
                    return map_ms_reached_status['complete'] - ms_start;
                }
            }//,
            //writable: false
        });
        */

        // stages_execution_info
        //  logs are different. still consider them.
        //   including summary such as data size where applicable would help.

        // doesnt show as a key.

        /*
        Object.defineProperty(res, "stages_execution_info", {
            get: () => stages_execution_info//,
            //writable: false
        });
        */

        // stages list?
        //  num_stages

        // stage_names?

        /*
        Object.defineProperty(res, "stage_log", {
            get: () => arr_stage_log//,
            //writable: false
        });
        */
        // log and status a little neglected recently.

        Object.defineProperty(res, 'log', {
            get() {
                // Could clone it for security so it can't be changed
                return llog;
            }
        });

        // More work / clarity on obs status?
        //  Want to get the doc website up first.

        Object.defineProperty(res, 'status', {
            get() {
                // Could clone it for security so it can't be changed
                return _status;
            }
        });

        // .ms and .io as a property?
        //  not doing that right now.

        // We call the inner function on each function call.
        //  This provides the closure.
        //  Could change fnl stages so that it calls function inner upon the function call.
        //   not just at the beginning?
        //    or not at the beginning?

        // Maybe better not to have the timeout when debugging / looking at the callstack.

        let had_next = false, had_complete = false, had_error = false;

        setTimeout(() => {
            //console.log('fn_inner', fn_inner);

            // the inner function could be an async function....
            //console.trace();

            // Inner function should not be async???
            //  Should be sync to return these functions as results.

            // If it is async, we can't use those fns?

            const res_fn_inner = fn_inner(data => {
                // And could apply a filter here.
                //  Could apply a number of filters.

                // can not have raised complete or error.

                let passes = true;

                had_next = true;
                // but only if not had an error or complete.
                if (!had_complete && !had_error) {
                    if (this.filters) {
                        for (let filter of this.filters) {
                            passes = filter(data);
                            if (!passes) break;
                        }
                    }
                } else {
                    if (had_complete) {
                        // Only a warn I think?
                        console.warn('Observable can not raise "next" event after having raised its "complete" event.')
                    }
                    if (had_error) {
                        console.warn('Observable can not raise "next" event after having raised its "error" event.')
                    }
                }


                // Maybe remove filtering?
                //  Or filtering here is more efficient?

                

                // check the type of what's bein returned here?
                // keep track of it?

                // meaning if we don't see any R objects (maybe some others) then there is no need to wait for anything to say that the obs is complete.
                //  special cases for identifying ongoing io?
                //   the function status makes a lot of sense there.

                // as does .io complete.

                if (passes) {
                    res.raise('next', data);
                    res.raise('data', data);
                }
            }, last_data => {
                // The observable complete event
                //  Are we still waiting on any output?
                //   This is an important thing to know.
                //    Is this the final at least slightly tricky thing to solve?

                if (!had_complete && !had_error) {
                    had_complete = true;
                    const tld = tf(last_data);
                    //console.log('obs complete function called');
                    //console.log('should now check if any io is still going. if not, raise io.complete');

                    //console.log('tld', tld);
                    //console.trace();


                    // Give more thought towards if .io complete is the best way.
                    //setImmediate(() => {
                    //log('!!last_data', !!last_data);
                    // Seems like we could do with noticing output-start event. <- do that now.
                    // stage.input, stage.output?
                    //  clearer definitions there?
                    //   output based on a description of what happens to the input? can be calculated / known in advance anyway???
                    //  especially when it's a stream / observable.
                    // definitely want the io timings
                    //  then will work on collecting io sizes
                    //  then will work on calculating io rates
                    // set the ms_complete value as well.
                    //  make it a read_only property? enumerable as well?
                    // An error doesn't seem to appear in here. look into it.
                    // optimize date calls?
                    // observable complete.
                    // do this for has-response as well.
                    //  that's an event (where the latency gets set)
                    //record_res_ms('complete');
                    const ms_complete = Date.now();

                    res.ms_complete = ms_complete;
                    res.ms_taken = ms_complete - ms_start;

                    // ms_latency for consistency.
                    //  only for staged functions so far?
                    //  or could respond to the 'have-response' / 'response' / 'main-response' event.
                    // listen for the main stage response?
                    //  to begin with, want to build up more detailed stages data in the res.stages array.
                    //res.ms.taken = res.ms.rel.start.complete;
                    //res.ms_taken = ms_since_start();
                    //res.ms_complete = Date.now();
                    // and ms.taken is the relative measurement between start and complete.
                    // ms complete is the absolute time measurement
                    //  or ms_taken is better
                    //log('res.ms_complete', res.ms_complete);

                    if (tld !== 'u') {
                        // See if it's an (ongoing?) readable stream?
                        if (tld === 'R') {
                            // Can we see the stage or status of the R?
                            // listen for the complete event...?
                            // Need to put the last data inside a wrapper object?
                            // 
                            io.ongoing = true;
                            // Monitoring not standard within observable.
                            last_data.on('complete', () => {
                                io.ongoing = false;
                                io.raise('complete');
                            });
                        } else {
                            //console.log('not an R, will raise complete and .io complete now');

                            res.raise('complete', last_data);
                            // io.complete = true?
                            // raise the io.complete event?
                            io.raise('complete');

                            // 
                            // Should be complete enough...?
                        }
                        
                    } else {
                        res.raise('complete');
                    }

                } else {
                    if (had_complete) {
                        // Only a warn I think?
                        console.warn('WARNING: Observable can not raise "complete" event after having raised it already.')
                    }
                    if (had_error) {
                        console.warn('WARNING: Observable can not raise "complete" event after having raised its "error" event.')
                    }

                }

                
                //});
            }, error => {

                if (!had_complete && !had_error) {
                    had_error = true;
                    // Can only raise error once.
                    //  After an error, it should stop, and will not produce further results.
                    //console.log('error being raised', error);
                    //console.log('tof error', tof(error));
                    res.raise('error', error);
                } else {
                    if (had_complete) {
                        // Only a warn I think?
                        console.warn('WARNING: Observable can not raise "error" event after having raised its "complete" event.')
                    }
                    if (had_error) {
                        console.warn('WARNING: Observable can not raise "error" event after having raised it already.')
                    }
                }


                
            }, status, log) || [];

            if (is_array(res_fn_inner)) {
                const [stop, pause, resume] = res_fn_inner;

                if (stop) res.stop = stop;
                if (pause) res.pause = pause;
                if (resume) res.resume = resume;
            
                if (pause && resume) {
                    res.delay = (ms) => {
                        pause();
                        res.raise('paused');
                        setTimeout(() => {
                            res.resume();
                            res.raise('resumed');
                        }, ms);
                    }
                }

            }


            //

            // status before log!!!
    
            
        }, 0);
    
        res.next = handler => {
            res.on('next', handler);
            return res;
        }
        res.data = res.next;
        res.complete = handler => {
            res.on('complete', handler);
            return res;
        }


        // and a res.statud handler?

        // copy the result when complete?
        //  the .data to .res
    
        res.on('complete', data => {
            // set the status
            // don't have status data here though.
            //  maybe could integrate that
            status('complete');

            // is it still doing io there?
            //  need to be clever and clear about that.
            //  it's a bit of a complication, and solving it means that we will have a source of confusion in programming more solved.



            // an ongoing io flag that gets set somewhere would be useful?


            // More explicit way of recognising ongoing io?
            //  The dl function does that
            //  As do some of the stages
            //   But it is only when all the stages are over does io complete get called.

            // and stage to 'complete'.
            // don't store res?
            //  leads to memory leak?
            const store_res = () => {
                if (data) {
    
                    if (data.data) {
                        res.res = data.data;
                    } else {
                        res.res = data;
                    }
                }
            }
        })
    
        res.done = res.end = res.complete;
        res.error = handler => {
            res.on('error', handler);
            return res;
        }
    
        res.then = handler => {
            // the whole thing in set immediate?
            //log('then');
            // what if it's already resolved?
            let res_all = [];


            res.next(data => {
                res_all.push(data);
                had_next = true;
            });
    
            if (res.completed) {

                if (res.singular_result) {
                    handler(res_all[0]);
                } else {
                    handler(res_all);
                }

                //res.ms.taken = res.ms.rel.start.complete;
                
            } else {
                res.complete(last => {
                    //res.ms.taken = res.ms.rel.start.complete;
                    // not sure when we had the 'last' here.
                    //log('complete last', last);
                    //log('had_next', had_next);
                    //log('res_all', res_all);
                    if (had_next && res_all.length > 0) {
                        if (res.singular_result) {
                            handler(res_all[0]);
                        } else {
                            handler(res_all);
                        }


                    } else {
                        handler(last);
                    }
                })
            }
            // and error handling
        }
        res.__type_name = 'observable';
        // Could make these static read-only.
        res._is_obs = res._is_observable = true;
        // Not been using the _ ec.
        //  Worth declaring earlier?
        res._ = new Evented_Class();
        // a bit (too) unconventional programming?
        res.meta = (k, v) => {
            if (v === undefined) {
                // just the key
            } else {
                res._[key] = value;
                res._.raise('change', {
                    key: k,
                    value: v
                })
            }
        }
        return res;
    })(_opts, _fn_inner);

    /*

    const _ = obs_res._ = {
        async: true,
        return_type: 'observable'
    }

    // Should be a nice improvement.

    console.log('observable create res._', obs_res._);
    console.trace();

    //throw 'stop';
    */

    return obs_res;
    // Looks like a decent and performent startup pattern here.
}

// but observable itself is a function. seems ok like this.
observable._ = {
    name: 'observable',
    return_type: 'observable',
    async: true
}

//observable.return_type = 'observable';
//observable.async = true;


// need to look into the observable examples in detail.
//const observable = observable;

//const observable = _observable;

//obsfilter
// by default will filter the 'next'
//  returns a new observable that's filtered.
//   So we can get a filtered output but also process the original because its still there.

// a filter function.

// obs.filter could generate a new observable with the filtering function.
// but the obsfilter function would compress better.

const obsfilter = (obs, next_filter) => observable((next, complete, error) => {
    obs.on('next', data => {
        if (next_filter(data)) {
            next(data);
        }
    })
    obs.on('complete', data => {
        if (data) {
            complete(data)
        } else {
            complete();
        }
    })
    obs.on('error', err => {
        error(err);
    })
});
// Examples, tests!!!

const obsmap = (obs, fn_map) => observable((next, complete, error) => {
    obs.on('next', data => next(fn_map(data)));
    obs.on('complete', complete);
    obs.on('error', error);
});

const obsalias = (obs_like, mapping) => {

    let next, complete, error;

    // mfp would help here.
    //  Compiler has improved a lot in many cases since fp was first made.
    const tmapping = tof(mapping);
    if (tmapping === 'array') {
        [next, complete, error] = mapping;
    } else if (tmapping === 'object') {
        //{next, complete, error} = mapping;
        next = mapping.next;
        complete = mapping.complete;
        error = mapping.error;
    }
    return observable((n, c, e) => {
        if (next) {
            obs_like.on(next, n);
        } else {
            obs_like.on('next', n);
        }
        //log('!!complete', !!complete);
        //log('complete', complete);

        if (complete) {
            obs_like.on(complete, c);
        } else {
            obs_like.on('complete', c);
        }

        if (error) {
            obs_like.on(error, e);
        } else {
            obs_like.on('error', e);
        }
    })
    // should be strings...
    /*
    log('Object.keys(obs_like)', Object.keys(obs_like));
    const k = Object.keys(obs_like);
    // make a map from them...
    const km = get_truth_map_from_arr(k);
    log('km', km);

    if (km._events) {
        log('Object.keys(km._events)', Object.keys(km._events));
        log('obs_like._events', obs_like._events);
        log('obs_like._eventsCount', obs_like._eventsCount);
    }

    throw 'stop';
    */
}

const obscollect = (obs, fn_collect, arr_res) => {
    obs.on('next', data => {
        const item_res = fn_collect(data);
        arr_res.push(item_res);
    })
    return obs; // built for chaining fns.
}

// need to make sure mfp works properly for this...
// also will help to give the function a name using mfp.
// mfp now gets used during fnl setup
// maybe obspool will be obselete or better explained in the future.
// should remove obspool until mfp is (more) complete.

const obspool = () => {
    console.trace();
    throw 'out of order';
}

// mfp works so this may be worth bringing back.

/*
const _obspool = mfp({

    // 07/06/2019 - making mfp more capable & flexible - need to fix it though so it handles simple sig matching again...
    //  or it's now f,a?
    //   be able to recognise an 'a' in a sig.
    //   would be useful for sig matching.
    //    also be able to give / use details inside an array.


    '[f,a]': (fn_obs, arr_params) => {
        log('[f,a]');
        log('arr_params', arr_params);
        //log('arguments', arguments);
        // each of the arr params - create the observable
        return observable((next, complete, error, status, log) => {
            let c = arr_params.length;
            // not pooling the complete data...?
            each(arr_params, param => {
                const res_obs = fn_obs(param);
                res_obs.on('next', next);
                res_obs.on('error', err => {
                    c--;
                    //error(err);

                    // next(err)
                    //  then need to check it's not an error object?
                    // {type: 'error'}
                    //  could be easier?
                    // next with an error object?
                    //  log it?
                    log(err);

                    if (c === 0) complete();
                });
                res_obs.on('complete', err => {
                    c--;
                    if (c === 0) complete();
                });

                // then will need to listen to see if they are all complete?
                //  or all errored?

                // Rules / option to allow this to stop_on_error
                //  default being false.
            })
        })
    }
})
*/

// fcall
//  an enhanced way of calling a function
// Pausable sequence

// not so sure about the usage right now.
const seq = (q_obs) => {
    return observable((next, complete, error) => {
        let c = 0,
            obs_q_item;
        let process = () => {
            if (c < q_obs.length) {
                let q_item = q_obs[c];
                obs_q_item = q_item[1].apply(q_item[0], q_item[2]);
                obs_q_item.on('next', data => {
                    next(data);
                });
                obs_q_item.on('error', error => {
                    error(error);
                });
                obs_q_item.on('complete', data => {
                    c++;
                    process();
                });
            } else {
                complete();
            }
        }
        process();
        let stop = () => {
            obs_q_item.stop();
            complete();
        }
        let pause = () => {
            obs_q_item.pause();
        }
        let resume = () => {
            obs_q_item.resume();
            //complete();
        }
        return [stop, pause, resume];
    });
}

const obs_to_cb = (obs, callback) => {
    let _obs = observable(obs);
    let arr_all = [];
    //log('obs_to_cb callback', callback);
    //console.trace();
    _obs.on('next', data => arr_all.push(data));
    _obs.on('error', err => callback(err));
    _obs.on('complete', last => {
        //log('arr_all.length ', arr_all.length);
        /*
        if (arr_all.length === 0) {
            callback(null, last);
        } else {
            callback(null, arr_all);
        }
        */
        if (typeof last !== 'undefined') {
            // don't return the array of all, they are only interim results
            // or have it as the 3rd callback param!
            callback(null, last, arr_all);
        } else {
            //log('callback', callback);
            callback(null, arr_all);
        }
    });
}
// an unpaging version...
//  or put unpaging elsewhere, around the definition of observable function.

// page / chunked

// unpaged function
// takes an observable that gives arrays (pages), breaks them up

const unpage = (obs) => {
    return observable((next, complete, error) => {
        obs.on('next', arr_data => {
            //log('arr_data', arr_data);
            // Specialised processing for Command_Response_Message?
            // An unpage function would be nice there.
            //  or each_record
            // Unpage would make sense because it can be used here, it's generic.
            if ('unpaged' in arr_data) {
                let unpaged = arr_data.unpaged;
                for (let c = 0, l = unpaged.length; c < l; c++) {
                    //log('unpaged[c]', unpaged[c]);
                    next(unpaged[c]);
                }
            } else {
                for (let c = 0, l = arr_data.length; c < l; c++) {
                    next(arr_data[c]);
                }
            }
        });
        obs.on('complete', () => {
            complete();
        });
        obs.on('error', err => error(err));
        // Stop, pause, resume
        return [];
    });
}

const obs_or_cb = (obs, callback, always_plural) => {
    //log('obs_or_cb callback', callback);
    if (callback) {
        //log('is cb');
        //log('has obs', obs);
        obs_to_cb(obs, callback);
    } else {
        return observable(obs, always_plural);
    }
}

const sig_obs_or_cb = (a, inner) => {
    // then if the last is a callback (function)
    let a2;
    //let using_cb = false;
    let callback;
    // 
    if (typeof a[a.length - 1] === 'function') {
        // its a callback
        //log('its a cb');
        a2 = Array.prototype.slice.call(a, 0, -1);
        callback = a[a.length - 1];
        //using_cb = true;
    } else if (typeof a[a.length - 1] === 'undefined') {
        // its a callback
        //log('its a cb');
        a2 = Array.prototype.slice.call(a, 0, -1);
        //using_cb = true;
    } else {
        a2 = Array.prototype.slice.call(a);
    }
    // if the last one is undefined
    //  (as in a missing callback)

    let sig = get_a_sig(a2);

    let obs = observable((next, complete, error) => {
        // no, can't return that...
        //  need to return the observable???
        //  
        return inner(a2, sig, next, complete, error, a2.length);
    });

    //log('obs', obs);
    //throw 'stop';
    return obs_or_cb(obs, callback);
    //let [stop, pause, resume] = inner();
    // need to call the inner function as though an observable gets made.
    //  maybe it's not possible / justifyable to put that handling here.
    //return obs_or_cb()
    // then call the inner function?
}

// -------------- Promises ----------------
// ________________________________________

// Just give it a function...?

const cb_to_prom_or_cb = (inner_with_cb, opt_cb) => {
    if (typeof opt_cb !== 'undefined') {
        inner_with_cb(opt_cb);
    } else {
        return new Promise((resolve, reject) => {
            inner_with_cb((err, res) => {
                if (err) {
                    reject(err);
                } else {
                    resolve(res);
                }
            })
        })
    }
}

const prom_or_cb = (prom, opt_cb) => {
    let _prom;
    if (prom instanceof Promise) {
        //return prom;
        _prom = prom;
    } else {
        // assuming its a function.
        _prom = new Promise(prom);
    }

    if (opt_cb) {
        _prom.then((res) => {
            opt_cb(null, res);
        }, err => {
            opt_cb(err);
        });
    } else {
        return _prom;
    }
}

const prom = (prom) => {
    if (prom instanceof Promise) {
        return prom;
    } else {
        // assuming its a function.
        return new Promise(prom);
    }
}

/*
    Advanced Function

    // Will have a function call that assists with typing / signatures.
    //  Regex and wildcard checking would be nice.
    //   Regex too slow
    //   Check if the signatures match a few regular expressions and parse the 

*/

// Data_Source
//  a closure where 3 functions next, complete, error can be called.
const is_obs = obj => {
    return obj.is_obs === true;
}
const is_prom = obj => {
    return obj instanceof Promise || obj.is_obs === true;
}

//  Not sure what this is for.
// Multi-type specifier
const obs_prom_arr_item = (obj, obs, prom, arr, item) => {
    if (obj.is_obs === true) {
        return obs(obj);
    } else {
        if (obj instanceof Promise) {
            return prom(obj);
        } else {
            if (Array.isArray(obj)) {
                return arr(obj)
            } else {
                return item(obj);
            }
        }
    }
}
// limit

// limit the number of results from an observable
//  then stop

// Will this take an obs-multi wrapper? Like vml?

// Definitely need examples and tests.

// This is lower level than ofp.
//  A full understanding and testing of this and ofp will help.
//   ofp will be a platform for quite a few functions.
//   maybe in combination with moft or omfp?
//    could incorporate upgrades here too.

// but will use mfp as a module in its own right.

// obs.collect? etc...

// Summary:
// 1. obs() does allow for and implement functionality to support stages
// 2. stages() uses and returns an obs. it's to help set up an observable that uses stages.
//  no inner observable
//  it's a way to get observables setting its stage values.

//  The intermediate stages could be observables.
//   Would help some types of observations.

// returns a function.
//  mfp could help annotate this.

// mfp warnings on the wrong return type will help.
//  console.warn as the wrong return type.

// this could be a relatively simple function?

// this will help to compose functions out of other functions
//  eg same decompression function within a download or load from disk function.

// fn_stages???
// declarative mfp?
// mfp with object and function....

//  stages could have improved pipe stages.
//   a syntax for data piping?
//   readable and writable streams?
//  stream into the next function, not using an observable?

//  a function accepting a readable_stream?
//   we could make a writable stream from the buffer results too.

//  integrating the methods and syntax with pipe would make sense.
//   downloading and decompressing without buffering in between would be useful.
//    will be optional too.

// A stage could itself be defined as a transform stream.
//  want nicer syntax to decare a Transform_Stream.

// works with obs, incorporates monitoring.
//  want to be able to inspect the data rate of specific stages of a function.

//  now need to work on inspecting the data rates of stages that involve / process R readable_stream.

// when the input type of a stage is a readable stream
// output type is readable stream

// fn.io?

// a .io property would be good for providing rates.
//  input b/s, output b/s   i/o ratio
//   some fairly simple measurements, code needs to be a little complex to do it.

// could have monitoring elsewhere, and brought in here?
//  for the moment put it here and in obs stages.
//  maybe refer to / use monitoring code lower in the platform if it's suitable there.

// the rate monitoring is currently a feature of observable.
//  however, in some cases it appears as though we are moving away from observables to the node native streams.

// observe_stream?

// observables monitoring themselves?
//  observables monitoring internal stages.
//  that makes most sense for how monitoring will be used at the moment.

//  want to calculate the rates of various operations within the function.
//   and latencies too of course.

//  want a dl etc function which has got built in advanced monitoring, compression handling etc.

// this will help to tell in many cases what the performance is like.

// monitor_stream
//  could be a useful encapsulation for this.

// raise stage event / events.

// mid_stage_event?

// try listening to stream events.

// stage input stream event
// stage output stream event

// log info about both of them.

//  want to measure log ram usage sizes too
//   keep it under control where necessary.
//    log size limits.

const arg_transformation = require('./default-arg-transformations');

const transform_stage_input = {
    'R': arg_transformation.R
}



// turns out to be a considerably large amount of code.

// returns a 'staged function'.

// 16/06/2019 - about 2000 lines including comments.


// 18/06/2019 - want to remake stages, so that makes use of fn-io-transform and fn-monitor.


// 19/06/2019 - OK, stages is not so long or complex with the IO transformations and monitoring stripped from it.
//  Having those encapsulated in their own functions will improve the code.


// Calculate the overall 'rate'.
//  Function output rate.

// input rate is not so relevant to this function.
// hard to calculate in fact. maybe irrelevant.


// create stages object of the result.


// .stages object
//  .main true
//  
// .main object?
//  could be the main stage object.

// .input object
// .output object

// .output.rate

const stages = mfp({
    name: 'stages',
    return_type: 'function'   // function that returns an observable.
}, function() {
    // arrow function instead?
    //  can we keep the same this in some places? or it doesn't matter when we use arrow fns elsewhere?
    const a = arguments, l = a.length;
    const sig = get_a_sig(a);
    //const arr_stages = [];
    //log('stages sig', sig);
    let arr_stages;
    let num_stages;

    // simpler way to raise a stage event?

    // its within the function that gets called.
    //  want access to the observable result?

    let fn_inner;
    //let _raise_stage_event;

    // Not so sure that preparing these functions works so well....
    //  Or does it...?


    // Not so sure that stage preparation actually works (here).
    //  Possibly should use functions that have already been prepared if possible.
    //   Or make a non-functional (ie does not wrap a function) system of io transformations.


    // Possibility of calling the prepared functions within the right closure?

    const prepare_arr_fns = (ofns) => {

        const input_ofns = ofns => {
            const map_stage_reserved_names = {
                _raise_stage_event: true
            }
            const res = [];
            //arr_stages = [];
            // a 'pre' stage?
            //  or do without that?
            //   implement it separately / differently?
            //log('ofns', ofns);
            // filter it so it's not the reserved words...

            const o_filtered_stage_fns = {};
            let num_stages = 0;
            let last_stage_name;

            each(ofns, (fn_stage, stage_name) => {
                // want to know if it's the last too.
                //  won't have output transformation of promise.
                // io transformed stage...
                //  with transformation event callback?
                //   then could give that to monitoring function.
                // doing input and output on the stage function makes sense.
                //  definitly makes sense to wait for promises to resolve.

                //const io_transformed_stage = fn_io_transform(fn_stage)
                //  then monitored stage...

                // evented_fn, like evented_class?
                //  events given in a callback
                //   or observable if the callback is not provided?
                //   or relatively basic Evented_Class, with the right API?

                // leaving stage events out of here for the moment.

                // an events callback function makes a lot of sense in some cases.
                //  it's quite simple and performant, direct, and could then be wrapped in some kinds of objects.

                if (!map_stage_reserved_names[stage_name]) {
                    o_filtered_stage_fns[stage_name] = fn_stage;
                    num_stages++;
                    last_stage_name = stage_name;
                }
            });

            each(o_filtered_stage_fns, (fn_stage, stage_name) => {
                // want to know if it's the last too.
                //  won't have output transformation of promise.
                // define the transforms based on what the function accepts?
                //  so if the fn is known to only accept some params, we can give it transforms to that parameter / those parameter arrangements.
                // see what the stage accepts, if that's defined.
                //log('stage_name', stage_name);
                //log('fn_stage', fn_stage);
                //log('Object.keys(fn_stage)', Object.keys(fn_stage));
                const is_last_stage = stage_name === last_stage_name;
                //log('is_last_stage', is_last_stage);
                const map_sigs = fn_stage.map_sigs;

                if (Object.keys(fn_stage).length === 0) {
                    // still should io wrap it for arguments and promise resolution.
                    const io_transform = {

                    }
                    // all stages apart from last should have output promise resolution.
                    if (!is_last_stage) {
                        io_transform.o = {
                            p: arg_transformation.p
                        }
                    }
                    // io transformed, with the io transformation monitoring?
                    //  monitor the output of the input transform only?
                    //  then monitor the function call too?
                    //  monitor the input to the output processing stage?

                    // monitoring integrated here?

                    const io_transformed_stage = fn_io_transform(fn_stage, io_transform);
                    io_transformed_stage.name = stage_name;
                    res.push([stage_name, io_transformed_stage]);
                    //fn_stage.name = stage_name;
                    //arr_stages.push([stage_name, fn_stage]);
                } else {
                    // if we have the map of signatures...
                    //  we can tell 

                    if (map_sigs) {
                        const io_transform = {
                            i: transform_stage_input
                        }
                        io_transform.o = {
                            'p': arg_transformation.p,
                            'O': arg_transformation.O
                        }
                        const io_transformed_stage = fn_io_transform(fn_stage, io_transform);
                        io_transformed_stage.name = stage_name;
                        res.push([stage_name, io_transformed_stage]);
                    } else {
                        const io_transform = {

                        }
                        //if (!is_last_stage) {
                            //io_transform.p = arg_transformation.p;
                        io_transform.o = {
                            'p': arg_transformation.p,
                            'O': arg_transformation.O
                        }
                        //}
                        const io_transformed_stage = fn_io_transform(fn_stage, io_transform);
                        io_transformed_stage.name = stage_name;
                        res.push([stage_name, io_transformed_stage]);
                    }
                }
            });
            //num_stages = res.length;
            //log('input_ofns num_stages', num_stages);
            //console.trace();
            return res;
        }
        return input_ofns(ofns);
    }

    const prepare = () => {
        // but really its best to execute a function inside stages.
        //  giving that function the capability of?:
        //   Raising events on the result object
        //   Raising stage events that go through the exising stages and observable system?
        // Raising the 'have-result' or 'have-result-stream' would help to determine the latency
        // 'have-result-stream' or 'result-stream' or 'response-stream' event.
        //  knowing when a stram starts to be recieved is useful when calculating latency.

        // Preparing the functions for execution.
        //  Seems tricky now if we want to choose which closure the functions run in.
        
        if (sig === '[a]') {
            valid = true;
            each(a[0], stage => {
                // and the stage should be an array
                //log('stage', stage);
                //log('get_a_sig(stage)', get_a_sig(stage));
                if (get_a_sig(stage) === '[s,f]') {
                    const [stage_name, fn_stage] = stage;
                    if (!fn_stage.name) fn_stage.name = stage_name;
                } else {
                    valid = false;
                    console.trace();
                    throw 'expected stage to be specified as an array [s,f]'
                }
            });
            if (valid) {
                //arr_stages = a[0];
                arr_stages = prepare_arr_fns(a[0]);
                num_stages = arr_stages.length;
            }
        } else if (sig === '[o]') {
            input_ofns(a[0]);
        } else if (sig === '[f]') {

            // Giving the function a single function.
            //  That function event working independently with all function calls.

            // But we are given a single function here.
            //  Not sure how it will apply to the particular function call and particular result obs object.

            // maybe this does work....

            // Want to be able to raise stage events through the running of the stages.
            //  possibly we should use an evented_fn wrapper.
            //   has a .events as part of the result.
            //    maybe it would be more flexible and less constrained than observable.


            // Wrong use of closures here so far.
            //  Not sure...

            // sending the function raise_stage_event into the function call.
            //  likely would be better to do this through access to the result observable.
            //   not as sure about doing it through the closure here.

            // Don't think we can define this function during the stages prep.

            /*
            const raise_stage_event = (name, evt) => {

                // Within the definition part?
                //  Not sure how to get this to apply to the result.

                // This part is within the definition rather than the part that produces the result.
                //  Making a new instance of that function for each call?

                // Want to get events back to the 'stages' part.
                //  Should be OK....
                //   Because of closures.
                //  ?????

                // no, can't set _raise_stage_event for every function call.
                //  however, an events property on each function call would make sense.



                //if (_raise_stage_event) _raise_stage_event(name, evt);

                console.trace();
                throw 'stop';


            }
            */

            // yes, can pass the function in here...
            //  however, that would probably only work with singletons.
            //  need to get it so that a new function is made before the function call?
            //  but then a whole execution of the prepare function each time the function is run?
            //   maybe, as it may need a new closure each time.

            // want this raise_stage_event to be used on specific function calls.
            //  its calls are relevant to specific executions of the function.

            // Need to way the function input and calling? Seems we are close...

            // Not so sure how to wrap the whole thing in a closure....
            //  Need a different function call with the raise_stage_event for every time the stages fn is called.

            //console.trace();
            //throw 'Broken';

            // Maybe this sets up the stage functions within the wrong closure when this is called at the beginning.
            // first call of it... but it's possibly in the wrong closure.
            //  for the moment, lets call it within the right closure.

            // call the prepared functions?
            //  but they are prepared to operate within the wrong closure?
            
            // Think that the functions that are prepared need to be called within local closure.
            //  This could be done with a callback on the setup closure.
            //   ???

            // Preparing the functions on each call...?

            //const res_fns_stages = a[0]();

            // Not so wure we eant to call this now...?

            // really not so sure about calling the inner function on setup.
            //  maybe a different api that works with prepared functions will work better.
            arr_stages = prepare_arr_fns(a[0]());
            num_stages = arr_stages.length;
            //input_ofns(res_fns_stages);
            //return stages(res_fns_stages);
            //console.trace();
            //throw 'stages expected an array (may become more flexible in the future)';
        } else {
            // an object...
            //  will put that into the arr_stages.
            //arr_stages = [];
            //each()
            console.trace();
            throw 'stages expected an array or object (may become more flexible in the future)';
        }
    }
    const ms_pre_prepare = Date.now();
    // maybe best not to (try to) prepare the functions all at once.
    let res_prepare = prepare();
    const ms_prep_time = Date.now() - ms_pre_prepare;

    if (res_prepare) {
        //log('pre prepare');
        log('ms_prep_time', ms_prep_time);
        return res_prepare;
    }
    //log('post prepare');
    // can call the prepared functions, with the unique function / functions / objects from the wanted closure?

    // set up the empty stage result info here?
    //  then can clone it for every function call.

    const arr_stages_info = new Array(arr_stages.length);
    each(arr_stages, (arr_stage, i) => {
        //log('fn_stage.name', fn_stage.name);
        //log('fn_stage', fn_stage);
        const stage_name = arr_stage[0];
        //log('stage_name', stage_name);
        // ms_input_start
        // ms_input_complete
        arr_stages_info[i] = {
            name: stage_name
        }
    });
    //throw 'stop';
    // or the stages event function will be fine applying to the function def?
    // Ability to respond to stage events here?
    // Some kind of function execution closure...?
    // Takes an event callback function?

    // Main part of the fn, after prepare.
    //  Not the execution closure.


    // 06/07/2019 - Want to make it so that completion and io completion are better handled and dealt with.
    //  would be nice if we didnt need to use io complete in many circumstances
    //   and tell easily when we do need to use it.
    //   be able to easily tell if the io is ongoing
    //    that would be nice by default

    //  see what the result is when it's complete.
    //   if it's an R (or others not yet specced / done) then there is ongoing io.
    //  normally complete event will mean totally complete
    //   ongoing io will be considered a bit more of a special case.
    //    could return an ongoing_io flag in the complete event.

    //  yes. an ongoing io flag makes most sense.
    //   boolean value for easiest checking.
    //    other bits of functionality can bring this into a 'status' system.
    

    





    const process = () => {
        //log('3) process() num_stages', num_stages);
        // I think the current system is broken, but I'm not sure.
        //  Need to get various events back.

        // Even have the stages function return the event?
        //  Not got the event passing all sorted out yet.

        // Likely to need different event function callbacks here.

        // 1. a stage event function here perhaps?
        //  How to get the stages function to provide the stage event function?

        // think I have it....
        const res = function() {
            const a2 = arguments, l2 = a2.length;
            const sig2 = get_a_sig(a2);
            // 2. a stage event function here perhaps?
            // raise it on the obs_res?
            // The stages event function?
            // Can monitor the input args here.
            // input.status
            //  waiting?
            //  processing / on / started / running?
            //   'on' is simplest
            //  complete?
            // input.bytes
            // res.input.events
            //  an evented_class
            // res.output.events
            let next_apply_args = a2.length === 0 ? undefined : a2;
            //log('pre return stages obs');
            // Could raise a stage event here...?
            //  But really want stage timings to be nicely integrated.
            // // is it just io?
            // or info? metadata? md?
            // .info?
            // obs.io?
            //  .io seems like a decent name.
            // or 'other' event types in the observable?
            // .stages would make sense too.
            //  where data is provided about the various stages.
            // .stage_events?
            // maybe don't want to necessarily observe events (again), but want the data provided through observing / listening to their events.

            // Events seem easier to raise here.
            // This would be the place to call the closure for the stages to run in.
            //  Call the given function each time the function executes.
            //  Also call it for preparing the stages?
            //   Should be fine, so long as it executes within the correct scope.
            // Call the given function here....
            // Define the stage callback function?
            // or later on when it's got access to the callback function.
            //  latencies for 

            // need to know the last stage that wasnt skipped.

            // will raise 'stage' events on obs_res

            //console.log('');
            //console.log('pre create obs_res');
            //console.trace();

            const obs_res = observable((next, complete, error, status, log, stage) => {
                // create the stage event callback function
                // timings for make-request
                // have-response

                //console.log('');
                //console.log('wrapped stages function being processed!!!');
                //console.log('');
                //console.trace();

                const log_stage_events = [];
                obs_res.log_stage_events = log_stage_events;
                // map of stage events by name.
                //  will help with latency calculations.

                const map_stage_events_by_name = {};
                // want to record the timings for the stage events.
                //  and the times between subsequent stage events will be useful too... such as for providing a latency measurement.
                // a log / list of stage event timings.
                //  and just stage event info?
                // and the time since the previous event too...
                //  will be useful for finding things like latencies.

                let ms_last_stage_event;
                // just with a name, no properties here???
                // Specific stage events...?
                // And have the general ones, such as stage exec start etc?
                // Want to be able to raise stage events.
                // It should definitely know which stage it applies to!
                //  And should not need to be told in the idiomatic code.
                // Knowing what stage is running would be very useful for the stage_event function.
                //  have we got / can we set a single running stage variable?

                let c = 0;

                // the c variable does not follow asyncronous execution.?

                const cb_stage_event = (name, evt) => {
                    // the evt name?
                    // the event name being included in the event object?
                    evt = evt || {
                        name: name
                    }
                    //console.log('cb_stage_event name:', name);
                    //console.log('evt', evt);
                    //console.log('c', c);

                    // c is the current stage index?
                    //  not so sure it will be reliable. may need more testing.
                    //console.trace();
                    const now = Date.now();
                    // want the stage name here as well.
                    evt.ms = now;
                    evt.i_stage = c;

                    // Seems it does do OK waiting for promise resolution.
                    //console.log('arr_stages[c]', arr_stages[c]);
                    evt.stage_name = arr_stages[c][0];
                    
                    if (ms_last_stage_event) {
                        evt.ms_since_last = now - ms_last_stage_event;
                    }
                    ms_last_stage_event = now;
                    log_stage_events.push(evt);
                    map_stage_events_by_name[name] = evt;

                    if (name === 'have-response') {
                        // can set the result latency.
                        obs_res.ms_latency = now - map_stage_events_by_name['make-request'].ms;
                    }

                    obs_res.raise('stage', evt);
                    /*
                    log('cb_stage_event');
                    log('name', name);
                    log('evt', evt);
                    console.trace();
                    throw 'stop';
                    */
                    // It works with function reprep.
                    //  Maybe a single closure will be fine so long as no local variables are needed.
                    //  Though we could pass in a local {} to store local (in purpose) variables.
                };
                // call the main inner function (it returns the functions, but hopefully we can use the ones that are already prepared.)
                //  but those prepared ones could be within the wrong closure :( )

                const t1 = Date.now();
                const new_obj_fns = a[0](cb_stage_event);
                // and prepare them again?
                // and newly prepared stages....

                //log('new_obj_fns', new_obj_fns);
                // Maybe function reprep won't take so long....? Especially if function prep gets called a lot, it will get compiled to run faster.

                const newly_prepared_stages = prepare_arr_fns(new_obj_fns);
                const arr_stages = newly_prepared_stages; // overrides in this scope.
                const reprep_time = Date.now() - t1;
                log('reprep_time', reprep_time);

                // Repreparation of functions could be very inefficient :(
                //  Maybe necessery for easiest use of the wanted closure.
                //   Likely not though.
                //   Or direct reference to the obs res would be another route - could use some syntactic sugar.
                //console.trace();
                //throw 'stop';

                
                //let _last_stage_res;
                const res_input = obs_res.input = {};
                // and a stages object?
                const res_output = obs_res.output = {};
                // res.events
                //  would be simple enough to watch for events on that.
                //   could send them all through that.
                // Likely won't use res_events.???
                //const res_events = obs_res.events = new Evented_Class();
                //  And another route for transmitting events.
                //log('arr_stages_info', arr_stages_info);
                //console.trace();
                const res_stages = obs_res.stages = clone(arr_stages_info);

                //log('res_stages', res_stages);
                //throw 'stop';
                //const res_stages = res.stages = 

                // Raising stage events?

                // Monitor what goes into the function.

                //console.log('a2', a2);
                //console.trace();

                monitor_item(a2, (evt_input_args) => {
                    //log('evt_input_args', evt_input_args);
                    const event_name = evt_input_args.name;
                    //log('event_name', event_name);
                    //res_events.raise('input', evt_input_args);

                    //console.trace();
                    //throw 'stop';
                    // input started..
                });
                // Need to do some further work in order to get latency.
                //  It will have more to do with relative timings.
                // since_start           start of the whole observable system
                // since_stage_start
                // need more relative timings to work out the latency.
                //  or latency is the time the main function has its result available / output starting?
                // ms until the main output?
                //  the main stream starting.
                
                // seems like we need that in order to measure the latency.
                //  or an event that gives the latency point?
                //  and better to measure the latency without the fn setup etc.
                // need more / better relative timings.
                // time from the request being made until we have the response object.
                // need a clear way of measuring the latency?
                //  not something where it looks into the response of the 'main' stage?
                //  status change, from waiting to has-response?
                // sent-request first.
                // raising a has-response event?
                // keep track of the last stage that was run.
                //  then if the execution is complete, ie with missed stages, 
                let i_last_unskipped_stage = -1;
                let exec_is_complete = false;
                // last unskipped stage index may be better.
                //  not sure we need the name
                const process_next = () => {
                    // post processing promise resolution?
                    //  better if it's set up ahead of time.
                    //log('next_apply_args', next_apply_args);
                    //log('num_stages', num_stages);
                    // need promise resolution post-processing.
                    //  the io processing will already be put in place.
                    // monitor the input ags to the first stage.
                    // Will (at first) monitor the objects before, after, and in between the different stages.
                    const have_next_stage = !!arr_stages[c];
                    const i_stage = c;
                    //const ec_stage_api = new Evented_Class();
                    //log('process_next c:', c);
                    log('have_next_stage', have_next_stage);
                    //log('Object.keys(arr_stages)', Object.keys(arr_stages));

                    if (have_next_stage) {
                        const stage_name = arr_stages[c][0];
                        const fn_stage = arr_stages[c][1];
                        // crate the stage info object in the result.
                        const is_main_stage = fn_stage.main === true;
                        const is_last_stage = c === arr_stages.length -1;
                        //log('');
                        //log('stage_name', stage_name);
                        //console.trace();
                        //log('is_main_stage', is_main_stage);
                        //log('');
                        const res_stage = res_stages[c];
                        const res_prev_stage = res_stages[c - 1];
                        const res_next_stage = res_stages[c + 1];
                        res_stage.ms_start = Date.now();
                        /*
                        if (res_prev_stage && res_prev_stage.bytes_out) {
                            // only when the previous stage's io is complete.
                            res_stage.bytes_in = res_prev_stage.bytes_out;
                        }
                        */
                        // bytes in being the bytes out of the prev stage.
                        if (is_main_stage) {
                            res_stage.main = true;
                            // monitor the output?
                            //  get the output rate from it.
                        }
                        // 

                        // and raise a main stage result when necessary.
                        //throw 'stop';
                        //_raise_stage_event = raise_stage_event;
                        // Could work this way :)
                        //  sending it to the closure works...
                        //stage(stage_name, ec_stage_api);
                        //let stage_res;
                        //let dsargs = deep_sig(next_apply_args);
                        // when it's the main stage, will set the .main object as well as the stage object in the array.

                        let fn_ready_args;
                        const exec_fn = () => {
                            const i_stage = c;
                            //log();
                            console.log('calling exec_fn ' + stage_name);
                            console.trace();
                            //log();
                            //const given_args_sig = deep_sig(fn_ready_args);
                            // ms_exec_start?
                            // need the output-start and output-complete events.
                            //  maybe only output-start if its async output.
                            //log('pre fn_stage.call');
                            //log('fn_stage', fn_stage);
                            //log('!!fn_ready_args', !!fn_ready_args);
                            // Does the function get skipped?
                            //  Need to know which is the last executed function.
                            const stage_res = fn_stage.call(this, fn_ready_args, transform_call_event => {
                                //log('Object.keys(transform_call_event)', Object.keys(transform_call_event));
                                const {name, sig, value} = transform_call_event;
                                // likely not to need an output sig.
                                //log('name, sig', name, sig);
                                // at the start?
                                if (name === 'complete') {
                                    // the stage could have been skipped.
                                    //  no need to monitor output in that case.
                                    //console.log('transform_call_event', transform_call_event);
                                    //console.log('Object.keys(transform_call_event)', Object.keys(transform_call_event));
                                    if (transform_call_event.skipped === true) {
                                        res_stage.skipped = true;
                                    } else {
                                        // The last unskipped stage...?
                                        if (i_stage > i_last_unskipped_stage) i_last_unskipped_stage = i_stage;
                                        // Raising monitoring events may work best.
                                        // monitor the output when the function call is complete?
                                        // could send the input and output transforms / transformed parameters here.
                                        let content_length;
                                        // Not so sure we know what the last unskipped stage is at this point?
                                        //  Telling when the io is complete would work better at the very end of the call chain?
                                        // skipped function calls have output too?
                                        //  same as the input.
                                        // so the output from the last stage still happens....
                                        // be able to get access to the monitoring later as well?
                                        monitor_item(value, (evt_stage_res) => {
                                            // will maybe have 'start'?
                                            //  'available'?
                                            const cl_evt = clone(evt_stage_res);
                                            //log('cl_evt', cl_evt);
                                            //console.trace();
                                            //log('');
                                            const event_name = evt_stage_res.name;
                                            // io complete.
                                            // these are output events.
                                            // 'available' event.
                                            // used to say the result start.
                                            // possible event names...
                                            // 'data'
                                            // but also want to know the bytes into a function.
                                            //  could be previous stage .bytes_out.
                                            // Calculate its rate before its complete.
                                            if (event_name === 'complete') {
                                                console.log('c', c);
                                                console.log('stage item complete');


                                                // Or the complete event could contain a separate callback too for the io-complete?


                                                // output_complete_ms
                                                const ms_output_complete = Date.now();
                                                const ms_taken = ms_output_complete - res_stage.ms_start;
                                                res_stage.ms_output_complete = ms_output_complete;
                                                // But what if we have not recorded bytes being output?
                                                if (res_stage.ms_output_start) {
                                                    const ms_output_taken = res_stage.ms_output_taken = ms_output_complete - res_stage.ms_output_start;
                                                    if (ms_output_taken > 0) {
                                                        //console.log('res_stage.bytes_out', res_stage.bytes_out);
                                                        if (res_stage.bytes_out) {
                                                            const output_rate = res_stage.bytes_out / (ms_output_taken / 1000);
                                                            res_stage.output_rate = output_rate;
                                                            // and if it's the main stage:
                                                            if (is_main_stage) {
                                                                obs_res.main_rate = output_rate;
                                                            }
                                                        }
                                                    }
                                                    // can also calculate the output rate.
                                                }
                                                res_stage.ms_taken = ms_taken;
                                                // main stage complete?

                                                // last unskipped stage complete?
                                                

                                                //console.log('i_last_unskipped_stage', i_last_unskipped_stage);
                                                //console.log('i_stage', i_stage);
                                                
                                                // May have got into race consdition?
                                                //  Only want to raise 'complete' after the last stage has executed at least.

                                                console.log('c', c);
                                                console.log('i_stage', i_stage);
                                                console.log('is_last_stage', is_last_stage);

                                                // only when execution is complete as well.

                                                // Working on the monitored item right now.

                                                // Maybe don't use .io object by default?
                                                //  So it not being there means there is no ongoing io?


                                                // Worth having a more serious and signigicant look into this.
                                                //  It was a bit tricky before.
                                                //  Want clarity and ease of use.



                                                // Now this is (so far untested) done within obs, when it returns an R.

                                                /*
                                                if (exec_is_complete && i_stage === i_last_unskipped_stage) {
                                                    obs_res.io.raise('complete');
                                                }
                                                */
                                                // this stage number?


                                                // at the end, c would be the length of the stages array....

                                                /*
                                                if (is_last_stage) {
                                                    obs_res.io.raise('complete');
                                                }
                                                */

                                                /*
                                                if (c === arr_stages.length) {
                                                    obs_res.io.raise('complete');
                                                }
                                                */

                                                /*

                                                // would work with a timeout?
                                                //  probably best on the end of the whole thing.
                                                //  last stage.

                                                if (i_last_unskipped_stage === i_stage) {
                                                    obs_res.io.raise('complete');

                                                    // OK, looks like this is working now.
                                                    // Make use of this within ofp.

                                                }
                                                */


                                                // can calculate the output rate of the stage here.
                                                ///log('monitor_item event:');
                                                //log('-------------------')
                                                //log('stage_name', stage_name);
                                                //log('evt_stage_res', evt_stage_res);
                                                // and the next stage's bytes in...
                                                //if (res_next_stage && res_stage.bytes_out) {
                                                    //res_next_stage.bytes_in = res_stage.bytes_out;
                                                //}
                                            } else if (event_name === 'available') {
                                                // look at the content_length
                                                //console.log('R available evt_stage_res', evt_stage_res);
                                                //console.trace();
                                                if (evt_stage_res.content_length) {
                                                    res_stage.content_length = evt_stage_res.content_length;
                                                    // also want to check to see if its the main stage.
                                                    // main_content_length?
                                                    if (is_main_stage) {
                                                        content_length = obs_res.content_length = evt_stage_res.content_length;
                                                    }
                                                }
                                                res_stage.ms_output_start = Date.now();
                                            } else if (event_name === 'data') {
                                                // evt_stage_res
                                                // Can get the estimated time remaining here.
                                                /*
                                                    Don't need to calculate as much here - it's already been calculated in the monitoring function.
                                                    {
                                                        name: 'data',
                                                        t: 'B',
                                                        bytes: data.length,
                                                        bytes_total: bytes,
                                                        byte_rate: byte_rate,
                                                        content_length: content_length,
                                                        bytes_remaining: bytes_remaining,
                                                        ms_est_remaining: est_remaining,
                                                        ms_taken: ms_taken,
                                                        proportion: proportion
                                                    }
                                                */
                                                // bytes_total
                                                const {bytes, bytes_total, byte_rate, content_length, bytes_remaining, ms_est_remaining, ms_est_complete, ms_taken, proportion} = evt_stage_res;
                                                //res_stage.ms_output_start = Date.now();
                                                // though we could add to the bytes_out.
                                                //res_stage.bytes_out = res_stage.bytes_out || 0;
                                                //res_stage.bytes_out += cl_evt.bytes;
                                                // and can measure / record the bytes out rate.
                                                //const ms_outputting = Date.now() - res_stage.ms_output_start;
                                                const ms_processing_output = ms_taken; // subtract paused time too?
                                                const out_rate = byte_rate;
                                                // Some of this may be better encapsulated elsewhere.
                                                //console.log('stage_name', stage_name);
                                                //console.log('byte_rate', byte_rate);
                                                res_stage.bytes_out = bytes_total;
                                                // the bytes io gets stored in the stages info anyway.
                                                // also will skip decompression stage if we don't get gzipped or whatever web compression.
                                                if (res_stage.bytes_in) {
                                                    // out / in
                                                    //  oi ratio seems like the one we want most.
                                                    // just bytes_ratio?
                                                    res_stage.bytes_oi_ratio = res_stage.bytes_out / res_stage.bytes_in;
                                                }
                                                // the main rate makes sense to use.
                                                //  not say its the overall fn output rate.
                                                if (is_main_stage) {
                                                    // main_bytes_out
                                                    // main_byte_rate?
                                                    // main_rate
                                                    // obs_res.main_bytes_out = obs_res.main_bytes_out || 0;
                                                    obs_res.main_bytes_out = bytes_total;
                                                    // and main_rate
                                                    // the main rate.
                                                    obs_res.main_output_rate = out_rate;
                                                    // estimated completion time?
                                                }

                                                if (i_last_unskipped_stage === i_stage) {
                                                    // this will be the output for all the stages as a whole.
                                                    // do want to be able to calculate the sizes of arrays etc.
                                                    //  be able to switch it off, but it will be useful for consistency in measurements.
                                                    //   will be useful in knowing and using actual data rates.
                                                    obs_res.bytes_out = bytes_total;
                                                    //obs_res.bytes_out += cl_evt.bytes;
                                                    obs_res.output_rate = out_rate;
                                                    // and the out / output rate.
                                                    // estimated completion time?
                                                    //console.log('cl_evt', cl_evt);
                                                    // 
                                                    if (def(proportion)) obs_res.proportion = proportion;
                                                    if (def(bytes_remaining)) obs_res.bytes_remaining = bytes_remaining;
                                                    if (def(ms_est_remaining)) obs_res.ms_est_remaining = ms_est_remaining;
                                                    if (def(ms_est_complete)) obs_res.ms_est_complete = ms_est_complete;
                                                    // and estimate when it will be complete too.
                                                }

                                                if (res_next_stage) {
                                                    res_next_stage.bytes_in = res_next_stage.bytes_in || 0;
                                                    res_next_stage.bytes_in += cl_evt.bytes;
                                                }
                                            } else {
                                                // ignore data events for the moment
                                                log('event_name', event_name);
                                                console.trace();
                                                throw 'stop';
                                            }
                                            // output complete separate to stage exec complete.
                                            // send this through to further monitoring?
                                        });
                                    }
                                    // can go to the next
                                    // we have the value it was completed with :)
                                    // don't need last_stage_res?
                                    //_last_stage_res = value;
                                    next_apply_args = value;
                                    c++;
                                    // output complete?
                                    log('pre process next stage');
                                    process_next();
                                } else {
                                    log('transform_call_event', transform_call_event);
                                    //console.trace();
                                    // send it through as a stages event?
                                    /// want to 
                                    // determining rate and latency with a few different operations...?
                                    // and output-transform-complete too?
                                    if (name === 'input-transform-complete') {
                                        // record the stage as having an input transformation.
                                        //o_dl.stages?
                                        // .stages could work better than .io and .io.stages.
                                        // .rate and .latency seem the most important.
                                        
                                        //  definitely the most important for eos-live.
                                        // set the time of io transform complete...
                                        const ms_input_transform_complete = Date.now();
                                        res_stage.ms_input_transform_complete = ms_input_transform_complete;
                                        res_stage.ms_input_transform_taken = ms_input_transform_complete - res_stage.ms_input_transform_start;
                                    } else if (name === 'input-transform-start') {
                                        // record the stage as having an input transformation.
                                        //o_dl.stages?
                                        // .stages could work better than .io and .io.stages.
                                        // .rate and .latency seem the most important.
                                        
                                        //  definitely the most important for eos-live.
                                        // set the time of io transform complete...
                                        res_stage.ms_input_transform_start = Date.now();
                                    } else if (name === 'exec-start') {
                                        // record the stage as having an input transformation.
                                        //o_dl.stages?
                                        // .stages could work better than .io and .io.stages.
                                        // .rate and .latency seem the most important.
                                        
                                        //  definitely the most important for eos-live.
                                        // set the time of io transform complete...
                                        res_stage.ms_exec_start = Date.now();
                                    } else if (name === 'exec-complete') {
                                        // record the stage as having an input transformation.
                                        //o_dl.stages?
                                        // .stages could work better than .io and .io.stages.
                                        // .rate and .latency seem the most important.
                                        
                                        //  definitely the most important for eos-live.
                                        // set the time of io transform complete...
                                        const ms_exec_complete = Date.now();
                                        res_stage.ms_exec_complete = ms_exec_complete;
                                        res_stage.ms_exec_taken = ms_exec_complete - res_stage.ms_exec_start;
                                    } else {
                                        log('name', name);
                                        log('transform_call_event', transform_call_event);
                                        console.trace();
                                        throw 'stop';
                                    }
                                    // input-transform-complete
                                    // input transfom data events...?
                                    //  will want to know what the data was changed to.
                                    // stage input transformation event...?
                                }
                            });
                        }
                        fn_ready_args = next_apply_args;
                        log('pre exec_fn');
                        exec_fn();
                    } else {
                        //log('process_next reached completion. may still need to do some output transformation.');
                        //console.log('i_last_unskipped_stage', i_last_unskipped_stage);
                        // then the output from the last unskipped stage is the main function output
                        // connect to that stage's output monitoring / events?
                        const tsr = tf(next_apply_args);
                        c++;
                        log('tsr', tsr);
                        //log('pre raise complete');
                        // can complete the download function with a readable stream.
                        //  or a parsed object.
                        // and the io complete?
                        //  wait for the whole of the io to be complete?
                        // wait for the last unskipped stage?
                        console.log('the stages exec is complete');
                        console.log('i_last_unskipped_stage', i_last_unskipped_stage);
                        // then we want to wait for the completion of that stage to say that the whole function is complete?
                        // or monitor the next_apply_args specially here, this will be the output monitoring of the function.
                        //  But these args are already monitoried?
                        exec_is_complete = true;
                        complete(next_apply_args);
                        //log('post raise complete');
                    }
                }
                process_next();
            });
            return obs_res;
        }
        res.is_staged = true;
        // or it returns a function?
        res.return_type = 'observable'; //???should already be.
        return res;
    }
    return process();
})

// output_complete - final output for the stage.
//  either main part or post-processing.

//  main-output-complete
//  post-output-complete
//  output-complete - whichever of the above two is later.
//   always gets called.


// need to finish off single function staged call:
//  finish measurements of all parts
//   calculate rate
//   and io ratio

// measuring the overall rate is important
//  still need to do more work on getting the data sizes for the stages.

// Stages
//  will return an observable
//   so yes, use mfp to include the return type at least.
//   only accept an array or an object?
//    only accept array for the moment.
//    must be an array of functions.
//     more type checking / grammar work needed?

// An observable that gives info about the various stages inside it....

module.exports = {
    'observable': observable,
    'nce': nce,
    'obs': observable,
    'obsalias': obsalias,
    'obscollect': obscollect,
    'obsfilter': obsfilter,
    'obspool': obspool,
    'obsmap': obsmap,
    'seq': seq,
    'sequence': seq,
    'sig_obs_or_cb': sig_obs_or_cb,
    'cb_to_prom_or_cb': cb_to_prom_or_cb,
    'prom_or_cb': prom_or_cb,
    'prom': prom,
    'obs_or_cb': obs_or_cb,
    'unpage': unpage,
    'is_obs': is_obs,
    'is_prom': is_prom,
    'obs_prom_arr_item': obs_prom_arr_item,
    'stages': stages
}

if (require.main === module) {

    console.log('running fnl as main');
    // Could return its stop function.
    //  Use its next, complete, error functions in one closure
    //  Get back its stop, pause, resume functions as the result in an array

    /*
    // Keeping this longer form -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-

    let data_source_interval_mult = (next, complete, error) => {
        ...
        return [stop, pause, resume];
    }
    // -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~

    // Other code with a data_source functionality?
    // Seems like a fairly good standad for making an observable.

    let obs = observable(data_source_interval_mult);

    */
    // observables / data sources that apply to something else?
    //  anyway, can use this observable for the moment to improve some server code.

    // Data source - gets functions to call, returns functions.
    //  The observable manages that.

    // Maybe return a data_source itself? or the data source is simply a function being executed.
    // This looks like it could tidy up some server code.

    const make_timer_obs = () => observable((next, complete, error) => {
        let c = 2;
        let paused = false;

        let cease = () => {
            clearInterval(ivl);
        }

        let stop = () => {
            clearInterval(ivl);
            complete();
        }

        let ivl = setInterval(() => {
            if (!paused) {
                let v = c * 2;
                //log('v', v);
                next({
                    'v': v
                });
                c++;

                if (c > 6) {
                    error(new Error('A problem'));
                    cease();
                    // After error, should not allow 'next' or 'complete'.

                }

                if (c > 8) {
                    stop();
                }
            }

        }, 1000);

        return [stop, () => {
            paused = true;
        }, () => {
            paused = false;
        }];
    });

    let obs = make_timer_obs();



    /* .filter(data => {
        return data.v !== 8;
    }).filter(data => {
        return data.v % 3 !== 0;
    }); */

    // ok, this event listener works too.

    let test_obs = () => {
        obs.on('paused', () => log('* paused'));
        obs.on('resumed', () => log('* resumed'));
        obs.on('error', (err) => log('* error', err));
        obs.next(data => {
            log('data', data);
        });
    }
    test_obs();

    let test_then = () => {
        (async () => {
            let res = await obs;
            log('awaited res', res);
        })();
    }
    //test_then();

    log('stages', stages);

    let test_split = () => {
        obs.on('paused', () => log('* paused'));
        obs.on('resumed', () => log('* resumed'));

        let [obs1, obs2] = obs.split(data => data.v % 3 === 0)

        obs1.on('next', data => log('obs1 data', data));
        obs2.on('next', data => log('obs2 data', data));
    }

    //test_split();

    let test_filter = () => {
        obs.filter(data => {
            return data.v !== 8;
        }).filter(data => {
            return data.v % 3 !== 0;
        });

        obs.next(data => {
            //log('data', data);
            if (data === 8) {
                obs.delay(5000);

                // works nicely here.
                // want listeners for the pause and resume events.
                // That would be convenient syntax

                obs.pause();
                log('paused');
                setTimeout(() => {
                    log('wait over');
                    obs.resume();
                }, 2000);

            }
        }).end(() => {
            log('end');
        })
    }
} else {

}

},{"./default-arg-transformations":4,"./fn-io-transform":5,"./monitor-item":7,"lang-mini":379}],7:[function(require,module,exports){
const {tf, deep_sig, each, def} = require('lang-mini');


// Could use callbacks

// Will be used to monitor arguments and values between stages().

// Complete?
//  Monitoring complete makes sense.

// Various parts now measure their byte rates.

// 




const monitor_item = (item, cb_evt_monitoring) => {

    // The type of item...

    const ti = tf(item);

    // promise
    // stream

    // 

    // some objects... can just get the size.

    // readable stream....

    // monitoring arguments - monitor every object there.
    //  subitems too?
    //  a subitems tree?

    // array?

    // 
    //console.log('monitor_item ti', ti);

    if (ti === 'A') {
        const l = item.length;
        // no different with just one argyment.
        // begin args?
        //  then args complete?
        for (let c = 0; c < l; c++) {
            const arg = item[c];



            // carry out monitoring on that arg.
            ((arg, c) => {
                monitor_item(arg, (evt_arg_monitor) => {
                    //console.log('evt_arg_monitor', evt_arg_monitor);
                    // need to callback for cb_evt_monitoring
                    //  say the arg_index
                    // say it's a subitem?
                    // type and subtype?
                    evt_arg_monitor.arg_index = c;
                    cb_evt_monitoring(evt_arg_monitor);
                    //console.trace();
                    //throw 'stop';
                })
            })(arg, c);
        }
        // monitor each of the items in the arguments.
    } else if (ti === 's') {
        // the length of the string = length * 2

        // say what type it is.
        //  bytes_length

        cb_evt_monitoring({
            name: 'complete',
            t: 's',
            bytes: item.length * 2
        });


        // object... probably don't get its size.
        //  get its keys?


    } else if (ti === 'o') {
        // the length of the string = length * 2

        // say what type it is.
        //  bytes_length
        // get the object sig?

        // need to wait for that observable to complete?
        //  could wait for the io complete event.

        // Do need to wait for observables to complete?
        //  Or wait for the io complete event?

        // Only want to say that the item is complete when its io is complete?

        




        cb_evt_monitoring({
            name: 'complete',
            t: 'o'//,
            //bytes: item.length * 2
        });

        // object... probably don't get its size.
        //  get its keys?


    } else if (ti === 'R') {
        // could be output monitoring.

        //console.trace();

        // the length of the string = length * 2

        // say what type it is.
        //  bytes_length

        // get the object sig?

        // monitor the rs data.
        const rs = item;
        // stream identified / available
        // stream data started (first data event)???
        // stream data event
        // stream data complete

        // the time?

        let bytes = 0;

        // ms_started ....

        const ms_start = Date.now();

        // and a start?
        //  instead of available?

        // available?
        //  start?

        let content_length, bytes_remaining;

        const {headers} = item;
        //console.log('headers', headers);
        //console.log('item', item);

        if (headers && headers['content-length']) {
            content_length = parseInt(headers['content-length'], 10);
            bytes_remaining = content_length;
        }

        //console.log('**** headers', headers);
        //console.log('content_length', content_length);
        //console.trace();

        // Be able to look into the headers, get numbers such as content-length.

        // and send the headers.
        //  the content length will be useful in particular.

        const o_evt = {
            name: 'available',
            t: 'R',
            ms: ms_start,
            headers: headers
            //,
            //bytes: item.length * 2
        }

        if (def(content_length)) {
            o_evt.content_length = content_length;
        }
        cb_evt_monitoring(o_evt);
        // Providing the rate and estimated time complete and remaining will be useful.
        //  Want that encapsulated here. Maybe make it optional?

        rs.on('data', data => {
            bytes += data.length;
            bytes_remaining -= data.length;
            // bytes remaining
            // be able to calculate / estimate time remaining?
            //  and estimated completion time?

            // calculating the rate within this part would make a lot of sense.
            //  and not in observable stages?

            // Rate calculation here would definitely be useful.

            // could include the time for each piece of data that arrives.
            //  

            // how long it has taken
            //  the bytes output total so far?

            // ms into? ms so far? ms_total? ms_processing?


            const ms = Date.now();
            const ms_taken = ms - ms_start;
            // Should be able to calculate how long it will take to do the bytes_remaining based on the rate.
            const byte_rate = bytes / (ms_taken / 1000);
            const est_remaining = bytes_remaining / byte_rate * 1000;
            const proportion = bytes / content_length;

            const ms_est_complete = ms + est_remaining;

            // bytes_total?
            cb_evt_monitoring({
                name: 'data',
                t: 'B',
                bytes: data.length,
                bytes_total: bytes,
                byte_rate: byte_rate,
                content_length: content_length,
                bytes_remaining: bytes_remaining,
                ms_est_remaining: est_remaining,
                ms_est_complete: ms_est_complete,
                ms_taken: ms_taken,
                proportion: proportion
            });
            // and readable stream output data too.
            // input_data function?
            //  makes sense.
            //  for monitoring a readable stream.

            //console.log('pre post-data-out raise_stage_event ' + stage_name);
            //raise_stage_event('post-data-out', {
            //    data: data
            //});
            //chunks.push(data);
        });
        rs.on('end', () => {
            // raise the stage complete at a different time. ???
            // monitoring / length recording / events?
            //exec_fn();
            // ms_taken would be of use here.
            const ms_complete = Date.now();
            const ms_taken = ms_complete - ms_start;

            // and byte_rate...
            const byte_rate = bytes / (ms_taken / 1000);

            cb_evt_monitoring({
                name: 'complete',
                ms: ms_complete,
                ms_taken: ms_taken,
                t: 'R',
                'bytes': bytes,
                byte_rate: byte_rate//,
                //bytes: item.length * 2
            });
        });
        rs.on('error', err => {
            //console.log('error reading stream for param transformation in stages()');
            //error(err);
            cb_evt_monitoring({
                name: 'error',
                value: err,
                t: 'R'//,
                //bytes: item.length * 2
            });
        });

        /*
        cb_evt_monitoring({
            name: 'complete',
            t: 'o'//,
            //bytes: item.length * 2
        });
        */

        // object... probably don't get its size.
        //  get its keys?


    } else if (ti === 'B') {
        // the length of the string = length * 2
        // say what type it is.
        //  bytes_length
        cb_evt_monitoring({
            name: 'complete',
            t: 'B',
            bytes: item.length
        });
        // object... probably don't get its size.
        //  get its keys?

    } else if (ti === 'a') {
        // the length of the string = length * 2
        // say what type it is.
        //  bytes_length

        // recursive function to calculate the size of a js object in bytes.
        //  should be in lang-mini.


        cb_evt_monitoring({
            name: 'complete',
            t: 'a'
        });
        // object... probably don't get its size.
        //  get its keys?
    } else {
        console.log('ti', ti);
        console.trace();
        throw 'stop';
    }
}

module.exports = monitor_item;
},{"lang-mini":379}],8:[function(require,module,exports){
(function (__filename,__dirname){(function (){
/***********************************************
Copyright 2010, 2011, Chris Winberry <chris@winberry.net>. All rights reserved.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
***********************************************/
/* v1.7.6 */

(function () {

function runningInNode () {
	return(
		(typeof require) == "function"
		&&
		(typeof exports) == "object"
		&&
		(typeof module) == "object"
		&&
		(typeof __filename) == "string"
		&&
		(typeof __dirname) == "string"
		);
}

if (!runningInNode()) {
	if (!this.Tautologistics)
		this.Tautologistics = {};
	else if (this.Tautologistics.NodeHtmlParser)
		return; //NodeHtmlParser already defined!
	this.Tautologistics.NodeHtmlParser = {};
	exports = this.Tautologistics.NodeHtmlParser;
}

//Types of elements found in the DOM
var ElementType = {
	  Text: "text" //Plain text
	, Directive: "directive" //Special tag <!...>
	, Comment: "comment" //Special tag <!--...-->
	, Script: "script" //Special tag <script>...</script>
	, Style: "style" //Special tag <style>...</style>
	, Tag: "tag" //Any tag that isn't special
}

function Parser (handler, options) {
	this._options = options ? options : { };
	if (this._options.includeLocation == undefined) {
		this._options.includeLocation = false; //Do not track element position in document by default
	}

	this.validateHandler(handler);
	this._handler = handler;
	this.reset();
}

	//**"Static"**//
	//Regular expressions used for cleaning up and parsing (stateless)
	Parser._reTrim = /(^\s+|\s+$)/g; //Trim leading/trailing whitespace
	Parser._reTrimComment = /(^\!--|--$)/g; //Remove comment tag markup from comment contents
	Parser._reWhitespace = /\s/g; //Used to find any whitespace to split on
	Parser._reTagName = /^\s*(\/?)\s*([^\s\/]+)/; //Used to find the tag name for an element

	//Regular expressions used for parsing (stateful)
	Parser._reAttrib = //Find attributes in a tag
		/([^=<>\"\'\s]+)\s*=\s*"([^"]*)"|([^=<>\"\'\s]+)\s*=\s*'([^']*)'|([^=<>\"\'\s]+)\s*=\s*([^'"\s]+)|([^=<>\"\'\s\/]+)/g;
	Parser._reTags = /[\<\>]/g; //Find tag markers

	//**Public**//
	//Methods//
	//Parses a complete HTML and pushes it to the handler
	Parser.prototype.parseComplete = function Parser$parseComplete (data) {
		this.reset();
		this.parseChunk(data);
		this.done();
	}

	//Parses a piece of an HTML document
	Parser.prototype.parseChunk = function Parser$parseChunk (data) {
		if (this._done)
			this.handleError(new Error("Attempted to parse chunk after parsing already done"));
		this._buffer += data; //FIXME: this can be a bottleneck
		this.parseTags();
	}

	//Tells the parser that the HTML being parsed is complete
	Parser.prototype.done = function Parser$done () {
		if (this._done)
			return;
		this._done = true;
	
		//Push any unparsed text into a final element in the element list
		if (this._buffer.length) {
			var rawData = this._buffer;
			this._buffer = "";
			var element = {
				  raw: rawData
				, data: (this._parseState == ElementType.Text) ? rawData : rawData.replace(Parser._reTrim, "")
				, type: this._parseState
				};
			if (this._parseState == ElementType.Tag || this._parseState == ElementType.Script || this._parseState == ElementType.Style)
				element.name = this.parseTagName(element.data);
			this.parseAttribs(element);
			this._elements.push(element);
		}
	
		this.writeHandler();
		this._handler.done();
	}

	//Resets the parser to a blank state, ready to parse a new HTML document
	Parser.prototype.reset = function Parser$reset () {
		this._buffer = "";
		this._done = false;
		this._elements = [];
		this._elementsCurrent = 0;
		this._current = 0;
		this._next = 0;
		this._location = {
			  row: 0
			, col: 0
			, charOffset: 0
			, inBuffer: 0
		};
		this._parseState = ElementType.Text;
		this._prevTagSep = '';
		this._tagStack = [];
		this._handler.reset();
	}
	
	//**Private**//
	//Properties//
	Parser.prototype._options = null; //Parser options for how to behave
	Parser.prototype._handler = null; //Handler for parsed elements
	Parser.prototype._buffer = null; //Buffer of unparsed data
	Parser.prototype._done = false; //Flag indicating whether parsing is done
	Parser.prototype._elements =  null; //Array of parsed elements
	Parser.prototype._elementsCurrent = 0; //Pointer to last element in _elements that has been processed
	Parser.prototype._current = 0; //Position in data that has already been parsed
	Parser.prototype._next = 0; //Position in data of the next tag marker (<>)
	Parser.prototype._location = null; //Position tracking for elements in a stream
	Parser.prototype._parseState = ElementType.Text; //Current type of element being parsed
	Parser.prototype._prevTagSep = ''; //Previous tag marker found
	//Stack of element types previously encountered; keeps track of when
	//parsing occurs inside a script/comment/style tag
	Parser.prototype._tagStack = null;

	//Methods//
	//Takes an array of elements and parses any found attributes
	Parser.prototype.parseTagAttribs = function Parser$parseTagAttribs (elements) {
		var idxEnd = elements.length;
		var idx = 0;
	
		while (idx < idxEnd) {
			var element = elements[idx++];
			if (element.type == ElementType.Tag || element.type == ElementType.Script || element.type == ElementType.style)
				this.parseAttribs(element);
		}
	
		return(elements);
	}

	//Takes an element and adds an "attribs" property for any element attributes found 
	Parser.prototype.parseAttribs = function Parser$parseAttribs (element) {
		//Only parse attributes for tags
		if (element.type != ElementType.Script && element.type != ElementType.Style && element.type != ElementType.Tag)
			return;
	
		var tagName = element.data.split(Parser._reWhitespace, 1)[0];
		var attribRaw = element.data.substring(tagName.length);
		if (attribRaw.length < 1)
			return;
	
		var match;
		Parser._reAttrib.lastIndex = 0;
		while (match = Parser._reAttrib.exec(attribRaw)) {
			if (element.attribs == undefined)
				element.attribs = {};
	
			if (typeof match[1] == "string" && match[1].length) {
				element.attribs[match[1]] = match[2];
			} else if (typeof match[3] == "string" && match[3].length) {
				element.attribs[match[3].toString()] = match[4].toString();
			} else if (typeof match[5] == "string" && match[5].length) {
				element.attribs[match[5]] = match[6];
			} else if (typeof match[7] == "string" && match[7].length) {
				element.attribs[match[7]] = match[7];
			}
		}
	}

	//Extracts the base tag name from the data value of an element
	Parser.prototype.parseTagName = function Parser$parseTagName (data) {
		if (data == null || data == "")
			return("");
		var match = Parser._reTagName.exec(data);
		if (!match)
			return("");
		return((match[1] ? "/" : "") + match[2]);
	}

	//Parses through HTML text and returns an array of found elements
	//I admit, this function is rather large but splitting up had an noticeable impact on speed
	Parser.prototype.parseTags = function Parser$parseTags () {
		var bufferEnd = this._buffer.length - 1;
		while (Parser._reTags.test(this._buffer)) {
			this._next = Parser._reTags.lastIndex - 1;
			var tagSep = this._buffer.charAt(this._next); //The currently found tag marker
			var rawData = this._buffer.substring(this._current, this._next); //The next chunk of data to parse
	
			//A new element to eventually be appended to the element list
			var element = {
				  raw: rawData
				, data: (this._parseState == ElementType.Text) ? rawData : rawData.replace(Parser._reTrim, "")
				, type: this._parseState
			};
	
			var elementName = this.parseTagName(element.data);
	
			//This section inspects the current tag stack and modifies the current
			//element if we're actually parsing a special area (script/comment/style tag)
			if (this._tagStack.length) { //We're parsing inside a script/comment/style tag
				if (this._tagStack[this._tagStack.length - 1] == ElementType.Script) { //We're currently in a script tag
					if (elementName.toLowerCase() == "/script") //Actually, we're no longer in a script tag, so pop it off the stack
						this._tagStack.pop();
					else { //Not a closing script tag
						if (element.raw.indexOf("!--") != 0) { //Make sure we're not in a comment
							//All data from here to script close is now a text element
							element.type = ElementType.Text;
							//If the previous element is text, append the current text to it
							if (this._elements.length && this._elements[this._elements.length - 1].type == ElementType.Text) {
								var prevElement = this._elements[this._elements.length - 1];
								prevElement.raw = prevElement.data = prevElement.raw + this._prevTagSep + element.raw;
								element.raw = element.data = ""; //This causes the current element to not be added to the element list
							}
						}
					}
				}
				else if (this._tagStack[this._tagStack.length - 1] == ElementType.Style) { //We're currently in a style tag
					if (elementName.toLowerCase() == "/style") //Actually, we're no longer in a style tag, so pop it off the stack
						this._tagStack.pop();
					else {
						if (element.raw.indexOf("!--") != 0) { //Make sure we're not in a comment
							//All data from here to style close is now a text element
							element.type = ElementType.Text;
							//If the previous element is text, append the current text to it
							if (this._elements.length && this._elements[this._elements.length - 1].type == ElementType.Text) {
								var prevElement = this._elements[this._elements.length - 1];
								if (element.raw != "") {
									prevElement.raw = prevElement.data = prevElement.raw + this._prevTagSep + element.raw;
									element.raw = element.data = ""; //This causes the current element to not be added to the element list
								} else { //Element is empty, so just append the last tag marker found
									prevElement.raw = prevElement.data = prevElement.raw + this._prevTagSep;
								}
							} else { //The previous element was not text
								if (element.raw != "") {
									element.raw = element.data = element.raw;
								}
							}
						}
					}
				}
				else if (this._tagStack[this._tagStack.length - 1] == ElementType.Comment) { //We're currently in a comment tag
					var rawLen = element.raw.length;
					if (element.raw.charAt(rawLen - 2) == "-" && element.raw.charAt(rawLen - 1) == "-" && tagSep == ">") {
						//Actually, we're no longer in a style tag, so pop it off the stack
						this._tagStack.pop();
						//If the previous element is a comment, append the current text to it
						if (this._elements.length && this._elements[this._elements.length - 1].type == ElementType.Comment) {
							var prevElement = this._elements[this._elements.length - 1];
							prevElement.raw = prevElement.data = (prevElement.raw + element.raw).replace(Parser._reTrimComment, "");
							element.raw = element.data = ""; //This causes the current element to not be added to the element list
							element.type = ElementType.Text;
						}
						else //Previous element not a comment
							element.type = ElementType.Comment; //Change the current element's type to a comment
					}
					else { //Still in a comment tag
						element.type = ElementType.Comment;
						//If the previous element is a comment, append the current text to it
						if (this._elements.length && this._elements[this._elements.length - 1].type == ElementType.Comment) {
							var prevElement = this._elements[this._elements.length - 1];
							prevElement.raw = prevElement.data = prevElement.raw + element.raw + tagSep;
							element.raw = element.data = ""; //This causes the current element to not be added to the element list
							element.type = ElementType.Text;
						}
						else
							element.raw = element.data = element.raw + tagSep;
					}
				}
			}
	
			//Processing of non-special tags
			if (element.type == ElementType.Tag) {
				element.name = elementName;
				var elementNameCI = elementName.toLowerCase();
				
				if (element.raw.indexOf("!--") == 0) { //This tag is really comment
					element.type = ElementType.Comment;
					delete element["name"];
					var rawLen = element.raw.length;
					//Check if the comment is terminated in the current element
					if (element.raw.charAt(rawLen - 1) == "-" && element.raw.charAt(rawLen - 2) == "-" && tagSep == ">")
						element.raw = element.data = element.raw.replace(Parser._reTrimComment, "");
					else { //It's not so push the comment onto the tag stack
						element.raw += tagSep;
						this._tagStack.push(ElementType.Comment);
					}
				}
				else if (element.raw.indexOf("!") == 0 || element.raw.indexOf("?") == 0) {
					element.type = ElementType.Directive;
					//TODO: what about CDATA?
				}
				else if (elementNameCI == "script") {
					element.type = ElementType.Script;
					//Special tag, push onto the tag stack if not terminated
					if (element.data.charAt(element.data.length - 1) != "/")
						this._tagStack.push(ElementType.Script);
				}
				else if (elementNameCI == "/script")
					element.type = ElementType.Script;
				else if (elementNameCI == "style") {
					element.type = ElementType.Style;
					//Special tag, push onto the tag stack if not terminated
					if (element.data.charAt(element.data.length - 1) != "/")
						this._tagStack.push(ElementType.Style);
				}
				else if (elementNameCI == "/style")
					element.type = ElementType.Style;
				if (element.name && element.name.charAt(0) == "/")
					element.data = element.name;
			}
	
			//Add all tags and non-empty text elements to the element list
			if (element.raw != "" || element.type != ElementType.Text) {
				if (this._options.includeLocation && !element.location) {
					element.location = this.getLocation(element.type == ElementType.Tag);
				}
				this.parseAttribs(element);
				this._elements.push(element);
				//If tag self-terminates, add an explicit, separate closing tag
				if (
					element.type != ElementType.Text
					&&
					element.type != ElementType.Comment
					&&
					element.type != ElementType.Directive
					&&
					element.data.charAt(element.data.length - 1) == "/"
					)
					this._elements.push({
						  raw: "/" + element.name
						, data: "/" + element.name
						, name: "/" + element.name
						, type: element.type
					});
			}
			this._parseState = (tagSep == "<") ? ElementType.Tag : ElementType.Text;
			this._current = this._next + 1;
			this._prevTagSep = tagSep;
		}

		if (this._options.includeLocation) {
			this.getLocation();
			this._location.row += this._location.inBuffer;
			this._location.inBuffer = 0;
			this._location.charOffset = 0;
		}
		this._buffer = (this._current <= bufferEnd) ? this._buffer.substring(this._current) : "";
		this._current = 0;
	
		this.writeHandler();
	}

	Parser.prototype.getLocation = function Parser$getLocation (startTag) {
		var c,
			l = this._location,
			end = this._current - (startTag ? 1 : 0),
			chunk = startTag && l.charOffset == 0 && this._current == 0;
		
		for (; l.charOffset < end; l.charOffset++) {
			c = this._buffer.charAt(l.charOffset);
			if (c == '\n') {
				l.inBuffer++;
				l.col = 0;
			} else if (c != '\r') {
				l.col++;
			}
		}
		return {
			  line: l.row + l.inBuffer + 1
			, col: l.col + (chunk ? 0: 1)
		};
	}

	//Checks the handler to make it is an object with the right "interface"
	Parser.prototype.validateHandler = function Parser$validateHandler (handler) {
		if ((typeof handler) != "object")
			throw new Error("Handler is not an object");
		if ((typeof handler.reset) != "function")
			throw new Error("Handler method 'reset' is invalid");
		if ((typeof handler.done) != "function")
			throw new Error("Handler method 'done' is invalid");
		if ((typeof handler.writeTag) != "function")
			throw new Error("Handler method 'writeTag' is invalid");
		if ((typeof handler.writeText) != "function")
			throw new Error("Handler method 'writeText' is invalid");
		if ((typeof handler.writeComment) != "function")
			throw new Error("Handler method 'writeComment' is invalid");
		if ((typeof handler.writeDirective) != "function")
			throw new Error("Handler method 'writeDirective' is invalid");
	}

	//Writes parsed elements out to the handler
	Parser.prototype.writeHandler = function Parser$writeHandler (forceFlush) {
		forceFlush = !!forceFlush;
		if (this._tagStack.length && !forceFlush)
			return;
		while (this._elements.length) {
			var element = this._elements.shift();
			switch (element.type) {
				case ElementType.Comment:
					this._handler.writeComment(element);
					break;
				case ElementType.Directive:
					this._handler.writeDirective(element);
					break;
				case ElementType.Text:
					this._handler.writeText(element);
					break;
				default:
					this._handler.writeTag(element);
					break;
			}
		}
	}

	Parser.prototype.handleError = function Parser$handleError (error) {
		if ((typeof this._handler.error) == "function")
			this._handler.error(error);
		else
			throw error;
	}

//TODO: make this a trully streamable handler
function RssHandler (callback) {
	RssHandler.super_.call(this, callback, { ignoreWhitespace: true, verbose: false, enforceEmptyTags: false });
}
inherits(RssHandler, DefaultHandler);

	RssHandler.prototype.done = function RssHandler$done () {
		var feed = { };
		var feedRoot;

		var found = DomUtils.getElementsByTagName(function (value) { return(value == "rss" || value == "feed"); }, this.dom, false);
		if (found.length) {
			feedRoot = found[0];
		}
		if (feedRoot) {
			if (feedRoot.name == "rss") {
				feed.type = "rss";
				feedRoot = feedRoot.children[0]; //<channel/>
				feed.id = "";
				try {
					feed.title = DomUtils.getElementsByTagName("title", feedRoot.children, false)[0].children[0].data;
				} catch (ex) { }
				try {
					feed.link = DomUtils.getElementsByTagName("link", feedRoot.children, false)[0].children[0].data;
				} catch (ex) { }
				try {
					feed.description = DomUtils.getElementsByTagName("description", feedRoot.children, false)[0].children[0].data;
				} catch (ex) { }
				try {
					feed.updated = new Date(DomUtils.getElementsByTagName("lastBuildDate", feedRoot.children, false)[0].children[0].data);
				} catch (ex) { }
				try {
					feed.author = DomUtils.getElementsByTagName("managingEditor", feedRoot.children, false)[0].children[0].data;
				} catch (ex) { }
				feed.items = [];
				DomUtils.getElementsByTagName("item", feedRoot.children).forEach(function (item, index, list) {
					var entry = {};
					try {
						entry.id = DomUtils.getElementsByTagName("guid", item.children, false)[0].children[0].data;
					} catch (ex) { }
					try {
						entry.title = DomUtils.getElementsByTagName("title", item.children, false)[0].children[0].data;
					} catch (ex) { }
					try {
						entry.link = DomUtils.getElementsByTagName("link", item.children, false)[0].children[0].data;
					} catch (ex) { }
					try {
						entry.description = DomUtils.getElementsByTagName("description", item.children, false)[0].children[0].data;
					} catch (ex) { }
					try {
						entry.pubDate = new Date(DomUtils.getElementsByTagName("pubDate", item.children, false)[0].children[0].data);
					} catch (ex) { }
					feed.items.push(entry);
				});
			} else {
				feed.type = "atom";
				try {
					feed.id = DomUtils.getElementsByTagName("id", feedRoot.children, false)[0].children[0].data;
				} catch (ex) { }
				try {
					feed.title = DomUtils.getElementsByTagName("title", feedRoot.children, false)[0].children[0].data;
				} catch (ex) { }
				try {
					feed.link = DomUtils.getElementsByTagName("link", feedRoot.children, false)[0].attribs.href;
				} catch (ex) { }
				try {
					feed.description = DomUtils.getElementsByTagName("subtitle", feedRoot.children, false)[0].children[0].data;
				} catch (ex) { }
				try {
					feed.updated = new Date(DomUtils.getElementsByTagName("updated", feedRoot.children, false)[0].children[0].data);
				} catch (ex) { }
				try {
					feed.author = DomUtils.getElementsByTagName("email", feedRoot.children, true)[0].children[0].data;
				} catch (ex) { }
				feed.items = [];
				DomUtils.getElementsByTagName("entry", feedRoot.children).forEach(function (item, index, list) {
					var entry = {};
					try {
						entry.id = DomUtils.getElementsByTagName("id", item.children, false)[0].children[0].data;
					} catch (ex) { }
					try {
						entry.title = DomUtils.getElementsByTagName("title", item.children, false)[0].children[0].data;
					} catch (ex) { }
					try {
						entry.link = DomUtils.getElementsByTagName("link", item.children, false)[0].attribs.href;
					} catch (ex) { }
					try {
						entry.description = DomUtils.getElementsByTagName("summary", item.children, false)[0].children[0].data;
					} catch (ex) { }
					try {
						entry.pubDate = new Date(DomUtils.getElementsByTagName("updated", item.children, false)[0].children[0].data);
					} catch (ex) { }
					feed.items.push(entry);
				});
			}

			this.dom = feed;
		}
		RssHandler.super_.prototype.done.call(this);
	}

///////////////////////////////////////////////////

function DefaultHandler (callback, options) {
	this.reset();
	this._options = options ? options : { };
	if (this._options.ignoreWhitespace == undefined)
		this._options.ignoreWhitespace = false; //Keep whitespace-only text nodes
	if (this._options.verbose == undefined)
		this._options.verbose = true; //Keep data property for tags and raw property for all
	if (this._options.enforceEmptyTags == undefined)
		this._options.enforceEmptyTags = true; //Don't allow children for HTML tags defined as empty in spec
	if ((typeof callback) == "function")
		this._callback = callback;
}

	//**"Static"**//
	//HTML Tags that shouldn't contain child nodes
	DefaultHandler._emptyTags = {
		  area: 1
		, base: 1
		, basefont: 1
		, br: 1
		, col: 1
		, frame: 1
		, hr: 1
		, img: 1
		, input: 1
		, isindex: 1
		, link: 1
		, meta: 1
		, param: 1
		, embed: 1
	}
	//Regex to detect whitespace only text nodes
	DefaultHandler.reWhitespace = /^\s*$/;

	//**Public**//
	//Properties//
	DefaultHandler.prototype.dom = null; //The hierarchical object containing the parsed HTML
	//Methods//
	//Resets the handler back to starting state
	DefaultHandler.prototype.reset = function DefaultHandler$reset() {
		this.dom = [];
		this._done = false;
		this._tagStack = [];
		this._tagStack.last = function DefaultHandler$_tagStack$last () {
			return(this.length ? this[this.length - 1] : null);
		}
	}
	//Signals the handler that parsing is done
	DefaultHandler.prototype.done = function DefaultHandler$done () {
		this._done = true;
		this.handleCallback(null);
	}
	DefaultHandler.prototype.writeTag = function DefaultHandler$writeTag (element) {
		this.handleElement(element);
	} 
	DefaultHandler.prototype.writeText = function DefaultHandler$writeText (element) {
		if (this._options.ignoreWhitespace)
			if (DefaultHandler.reWhitespace.test(element.data))
				return;
		this.handleElement(element);
	} 
	DefaultHandler.prototype.writeComment = function DefaultHandler$writeComment (element) {
		this.handleElement(element);
	} 
	DefaultHandler.prototype.writeDirective = function DefaultHandler$writeDirective (element) {
		this.handleElement(element);
	}
	DefaultHandler.prototype.error = function DefaultHandler$error (error) {
		this.handleCallback(error);
	}

	//**Private**//
	//Properties//
	DefaultHandler.prototype._options = null; //Handler options for how to behave
	DefaultHandler.prototype._callback = null; //Callback to respond to when parsing done
	DefaultHandler.prototype._done = false; //Flag indicating whether handler has been notified of parsing completed
	DefaultHandler.prototype._tagStack = null; //List of parents to the currently element being processed
	//Methods//
	DefaultHandler.prototype.handleCallback = function DefaultHandler$handleCallback (error) {
			if ((typeof this._callback) != "function")
				if (error)
					throw error;
				else
					return;
			this._callback(error, this.dom);
	}
	
	DefaultHandler.prototype.isEmptyTag = function(element) {
		var name = element.name.toLowerCase();
		if (name.charAt(0) == '/') {
			name = name.substring(1);
		}
		return this._options.enforceEmptyTags && !!DefaultHandler._emptyTags[name];
	};
	
	DefaultHandler.prototype.handleElement = function DefaultHandler$handleElement (element) {
		if (this._done)
			this.handleCallback(new Error("Writing to the handler after done() called is not allowed without a reset()"));
		if (!this._options.verbose) {
//			element.raw = null; //FIXME: Not clean
			//FIXME: Serious performance problem using delete
			delete element.raw;
			if (element.type == "tag" || element.type == "script" || element.type == "style")
				delete element.data;
		}
		if (!this._tagStack.last()) { //There are no parent elements
			//If the element can be a container, add it to the tag stack and the top level list
			if (element.type != ElementType.Text && element.type != ElementType.Comment && element.type != ElementType.Directive) {
				if (element.name.charAt(0) != "/") { //Ignore closing tags that obviously don't have an opening tag
					this.dom.push(element);
					if (!this.isEmptyTag(element)) { //Don't add tags to the tag stack that can't have children
						this._tagStack.push(element);
					}
				}
			}
			else //Otherwise just add to the top level list
				this.dom.push(element);
		}
		else { //There are parent elements
			//If the element can be a container, add it as a child of the element
			//on top of the tag stack and then add it to the tag stack
			if (element.type != ElementType.Text && element.type != ElementType.Comment && element.type != ElementType.Directive) {
				if (element.name.charAt(0) == "/") {
					//This is a closing tag, scan the tagStack to find the matching opening tag
					//and pop the stack up to the opening tag's parent
					var baseName = element.name.substring(1);
					if (!this.isEmptyTag(element)) {
						var pos = this._tagStack.length - 1;
						while (pos > -1 && this._tagStack[pos--].name != baseName) { }
						if (pos > -1 || this._tagStack[0].name == baseName)
							while (pos < this._tagStack.length - 1)
								this._tagStack.pop();
					}
				}
				else { //This is not a closing tag
					if (!this._tagStack.last().children)
						this._tagStack.last().children = [];
					this._tagStack.last().children.push(element);
					if (!this.isEmptyTag(element)) //Don't add tags to the tag stack that can't have children
						this._tagStack.push(element);
				}
			}
			else { //This is not a container element
				if (!this._tagStack.last().children)
					this._tagStack.last().children = [];
				this._tagStack.last().children.push(element);
			}
		}
	}

	var DomUtils = {
		  testElement: function DomUtils$testElement (options, element) {
			if (!element) {
				return false;
			}
	
			for (var key in options) {
				if (key == "tag_name") {
					if (element.type != "tag" && element.type != "script" && element.type != "style") {
						return false;
					}
					if (!options["tag_name"](element.name)) {
						return false;
					}
				} else if (key == "tag_type") {
					if (!options["tag_type"](element.type)) {
						return false;
					}
				} else if (key == "tag_contains") {
					if (element.type != "text" && element.type != "comment" && element.type != "directive") {
						return false;
					}
					if (!options["tag_contains"](element.data)) {
						return false;
					}
				} else {
					if (!element.attribs || !options[key](element.attribs[key])) {
						return false;
					}
				}
			}
		
			return true;
		}
	
		, getElements: function DomUtils$getElements (options, currentElement, recurse, limit) {
			recurse = (recurse === undefined || recurse === null) || !!recurse;
			limit = isNaN(parseInt(limit)) ? -1 : parseInt(limit);

			if (!currentElement) {
				return([]);
			}
	
			var found = [];
			var elementList;

			function getTest (checkVal) {
				return(function (value) { return(value == checkVal); });
			}
			for (var key in options) {
				if ((typeof options[key]) != "function") {
					options[key] = getTest(options[key]);
				}
			}
	
			if (DomUtils.testElement(options, currentElement)) {
				found.push(currentElement);
			}

			if (limit >= 0 && found.length >= limit) {
				return(found);
			}

			if (recurse && currentElement.children) {
				elementList = currentElement.children;
			} else if (currentElement instanceof Array) {
				elementList = currentElement;
			} else {
				return(found);
			}
	
			for (var i = 0; i < elementList.length; i++) {
				found = found.concat(DomUtils.getElements(options, elementList[i], recurse, limit));
				if (limit >= 0 && found.length >= limit) {
					break;
				}
			}
	
			return(found);
		}
		
		, getElementById: function DomUtils$getElementById (id, currentElement, recurse) {
			var result = DomUtils.getElements({ id: id }, currentElement, recurse, 1);
			return(result.length ? result[0] : null);
		}
		
		, getElementsByTagName: function DomUtils$getElementsByTagName (name, currentElement, recurse, limit) {
			return(DomUtils.getElements({ tag_name: name }, currentElement, recurse, limit));
		}
		
		, getElementsByTagType: function DomUtils$getElementsByTagType (type, currentElement, recurse, limit) {
			return(DomUtils.getElements({ tag_type: type }, currentElement, recurse, limit));
		}
	}

	function inherits (ctor, superCtor) {
		var tempCtor = function(){};
		tempCtor.prototype = superCtor.prototype;
		ctor.super_ = superCtor;
		ctor.prototype = new tempCtor();
		ctor.prototype.constructor = ctor;
	}

exports.Parser = Parser;

exports.DefaultHandler = DefaultHandler;

exports.RssHandler = RssHandler;

exports.ElementType = ElementType;

exports.DomUtils = DomUtils;

})();

}).call(this)}).call(this,"/node_modules/htmlparser/lib/htmlparser.js","/node_modules/htmlparser/lib")
},{}],9:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],10:[function(require,module,exports){
/*
 define(['../../web/jsgui-html', './client-resource', './pool'],

 function(jsgui, Resource, Resource_Pool) {
 */

 // Got a lot of this code to delete / refresh / make more concise once things are more fully working.
 //  Especially regarding parse_mount and controls.
 //   Want to shrink down the package size a lot.

 // Once the API is stable, could create a build that uses many local variables.
 //  Could make a build process that does that.
 //   Would be nice to make a core / small jsgui build that fits in 5KB compressed. 15 would be nice too etc.
 //    Much will be possible with abstractions over the patterns.


var jsgui = require('jsgui3-html');
//var Resource = require('./client-resource');
var Resource_Pool = jsgui.Resource_Pool;

const fnl = require('fnl');
const prom_or_cb = fnl.prom_or_cb;

// Client_Resource?
//  I think that makes sense, so that we have something specific which has the URL attached.
//   It is able to make HTTP requests to the server resource.

//const Data_Resource = require('./data-resource');

/*
var stringify = jsgui.stringify,
	each = jsgui.each,
	arrayify = jsgui.arrayify,
	tof = jsgui.tof;
var filter_map_by_regex = jsgui.filter_map_by_regex;
var Class = jsgui.Class,
	Data_Object = jsgui.Data_Object;
var fp = jsgui.fp,
	is_defined = jsgui.is_defined;
var Collection = jsgui.Collection;
*/

//var exec = require('child_process').exec;

// Perhaps this will have HTTP endpoints as well?
//  Maybe we can access it through url/resources/

// Perhaps a resource publisher, or a few of them could be useful.
//  HTTP_Resource_Publisher?
//  Generally publishes a resource over HTTP.
//   Will have some authorization and authentication properties, hooked up with the proper providers.

// This may be the place in which remote access to the resources is given.
//  It would make sense.
//  Perhaps it is worth using a resource publisher? Then is that a resource?
//  I think the resource pool may be the sensible point of access.


// Possibly all websocket communications for all client-side resources will go through the pool.
//  May need to specify which server in particular we connect to over websocket.
//   However, having front-end back-end servers could work well, that redirect to other servers, thereby providing one endpoint, and balance the load.

/*
var fields = {
	'url': String
};
*/
class Client_Resource_Pool extends Resource_Pool {
	//'fields': ,
	constructor(spec) {
		//this._super(spec);
		super(spec);


		// No need to start it in particular?
		//  Sometimes the data resource will operate over websockets

		//  Sometimes SSE would be better.

		//let data_resource = new Data_Resource({
		//	'name': 'Data Resource'
		//});
		//console.log('pre add data_resource', data_resource);
		//this.add(data_resource);


	}
	'start'(callback) {

		return prom_or_cb((resolve, reject) => {
			//callback(null, true);
			resolve(true);
		}, callback);


	}

}
module.exports = Client_Resource_Pool;
},{"fnl":6,"jsgui3-html":154}],11:[function(require,module,exports){
// Making it a global variable.
jsgui = require('jsgui3-html');

jsgui.Resource_Pool = require('./client-resource-pool');
jsgui.Client_Page_Context = require('./page-context');
//console.log('jsgui.Client_Page_Context', jsgui.Client_Page_Context);
//jsgui.Selection_Scope = require('./selection-scope');
// And then can automatically activate?
//

jsgui.Client_Resource = require('./resource');
const fnl = require('fnl');
const prom_or_cb = fnl.prom_or_cb;

const {each, tf} = jsgui;

// Should move some / all html that is client-side to here.

// Leave the line below
/* -- REQUIREMENTS -- */
// Leave the line above

if (typeof window !== 'undefined') {
    // Maybe use the vhl dl function? Or similar observable?

    // need to use https really

    // timeout...
    let context;

    jsgui.http = (url, callback) => {
        return prom_or_cb((resolve, reject) => {
            let timeout = 2500;
            //if (jsgui.timeout) timeout = jsgui.timeout;
            //console.log('timeout', timeout);
            var oReq = new XMLHttpRequest();
            oReq.timeout = timeout;
            oReq.onreadystatechange = function () {
                //console.log('this.readyState', this.readyState);
                //console.log('this.status', this.status);
                if (this.readyState === 4) {
                    //console.log('this.status', this.status);
                    if (this.status === 200) {
                        var o = JSON.parse(this.responseText);
                        //myFunction(myArr);
                        resolve(o);
                    } else {
                        reject(this.status);
                    }
                }
            };
            oReq.open("GET", url, true);
            oReq.send();
        }, callback);
    }

    jsgui.http_post = (url, value, callback) => {
        return prom_or_cb((resolve, reject) => {

            var oReq = new XMLHttpRequest();
            oReq.onreadystatechange = function () {
                if (this.readyState === 4) {
                    //console.log('this.status', this.status);
                    if (this.status === 200) {
                        var o = JSON.parse(this.responseText);
                        //myFunction(myArr);
                        resolve(o);
                    } else {
                        //console.log('this.status', this.status);
                        reject({
                            status: this.status,
                            responseText: this.responseText
                        });
                    }
                }
            };
            
            oReq.open("POST", url, true);
            // set any headers here, such as content-type

            //let s_value;
            // always send a buffer?
            
            let o_to_send;
            let tval = tf(value)

            //console.log('***** tval', tval);
            //console.log('value', value);
            //console.log('value.length', value.length);

            if (tval === 's') {
                // text string
                o_to_send = value;
            } else if (tval === 'B') {
                o_to_send = value;
            } else if (tval === 'a' || tval === 'o') {
                const json = JSON.stringify(value);
                o_to_send = json;
                oReq.setRequestHeader('content-type', 'application/json');
            }

            //console.log('o_to_send', o_to_send);
            //console.trace();

            oReq.send(o_to_send);
        }, callback);
    }

    jsgui.http_delete = (url, callback) => {
        return prom_or_cb((resolve, reject) => {
            var oReq = new XMLHttpRequest();
            oReq.onreadystatechange = function () {
                if (this.readyState === 4) {
                    //console.log('this.status', this.status);
                    if (this.status === 200) {
                        var o = JSON.parse(this.responseText);
                        //myFunction(myArr);
                        resolve(o);
                    } else {
                        reject(this.status);
                    }
                }
            };
            oReq.open("DELETE", url, true);
            oReq.send();
        }, callback);
    }

    
    jsgui.update_standard_Controls = page_context => {
        each(jsgui.controls, (Control_Subclass, name) => {
            page_context.update_Controls(name, Control_Subclass);
        });
    }
    // Can this be given the context as well?
    //  Could set up the data adapter functions that way too.



    let context_data;


    jsgui.register_server_resources = (o_server_resources) => {
        //console.log('jsgui.register_server_resources o_server_resources', o_server_resources);

        //console.log('!!!!! this log should appear');
        //console.trace();

        // Setting up the Data_Resource makes sense.

        // Creating automatic function calls that communicate with the server.
        //  So it's very easy to call from the app in a normal way. Will be v. simple to use. More concise code too.

        // Do we have access to the context?
        //  The resource registration call is in a separate block of js code. Need to be careful.

        //console.log('** Object.keys(jsgui)', Object.keys(jsgui));

        jsgui.def_server_resources = o_server_resources;
        // then will consult this upon activation, when the context is available.
    }

    jsgui.register_context_data = o_context_data => {
        context_data = o_context_data;
    }


    

    //console.log('Client-side app ready for activation');
    //console.log('next line');

    // Standard controls update
    // Standard controls import?

    // jsgui.update_page_context_default_controls()

    // Maybe activation within the client js would be most reliable and normal.

    // Automatic creation of page_context is best
    
    // Or generate the context, then activate.
    //  Or activation itself ensures and returns the page context.

    // Better id page_context is created here.

    let activate = () => {
        //console.log('client.js activate');
        const {def_server_resources} = jsgui;
        //console.log('def_server_resources', def_server_resources);
        page_context = new jsgui.Client_Page_Context({
            'document': document
        });
        context = page_context;
        jsgui.context = page_context;

        if (context_data) {
            Object.assign(page_context, context_data);

            // So would be able to read mime types from the context, if they are provided.
            //  Other useful pieces of data too.
        }

        jsgui.update_standard_Controls(page_context);

        
        /*
        jsgui.raise('pre-activate', {
            context: context
        });
        */
        
        jsgui.pre_activate(page_context);

        jsgui.activate(page_context);

        

        // Could set up the data_resource function calls here.
        //  Seems like a sensible place to do it, but maybe call a function that is elsewhere.
        //   These function calls will need to talk to the server.

        // context resources data resource.
        //  will create the function call here.

        //console.log('Object.keys(context)', Object.keys(context));
        //console.log('Object.keys(context.resource_pool)', Object.keys(context.resource_pool));
        //console.log('Object.keys(context.resource_pool.resources)', Object.keys(context.resource_pool.resources));

        const arr_resources = context.resource_pool.resources._arr;
        const data_resource = arr_resources[0];

        //console.log('data_resource', data_resource);

        const activate_server_resource_fn = (obj_def) => {
            //console.log('obj_def', obj_def);

            const {name, type} = obj_def;
            if (type === 'function') {
                const fn_remote_call = async (single_param) => {
                    // do jsgui put.
                    // Fn call should be done with put.
                    //const json_single_param = JSON.stringify(single_param);
                    // Then do jsgui post.
                    //jsgui.http_post = (url, value, callback) => {
                    //  optional callback

                    const res_dl = await jsgui.http_post('/' + name, single_param);
                    console.log('res_dl', res_dl);
                    return res_dl;
                }
                //return fn_remote_call;

                data_resource[name] = fn_remote_call;
            }
            // Create a function that does the remote call.
        }

        const activate_server_resource_fns = () => {
            // will use http post for these function calls.
            each(def_server_resources, (server_resource_def, name) => {
                //console.log('name', name);
                //console.log('server_resource_def', server_resource_def);

                // activte server resource function.

                // with no schema defined.

                // with schema / grammar, may set up mfp / ofp / whatever for calling this function.
                activate_server_resource_fn(server_resource_def);
            })
        }

        activate_server_resource_fns();
        // jsgui.def_server_resources

        jsgui.raise('activate', {
            context: context
        });
        page_context.raise('activate', {
            context: context
        });

        // Set up a variety of UI controls here.
        // May be worth looking at some registry of controls.
    }
    // Multiple onload items being added.
    //  Seems like the 

    window.addEventListener('load', () => {
        console.log('client.js window onload');
        activate();
    });

}

module.exports = jsgui;
},{"./client-resource-pool":10,"./page-context":191,"./resource":192,"fnl":6,"jsgui3-html":154}],12:[function(require,module,exports){

class Typed_Array_Binary_Read_Write {

    constructor(ta) {
        this.ta = ta;
        this.dv = new DataView(ta.buffer, ta.byteOffset, ta.byteLength);
        this.byl = ta.byteLength;
        this.bil = this.byl << 3;
    }

    get_bit(idx_bit) {
        const idx_byte_bit = idx_bit & 7;
        return (this.dv.getUint8(idx_bit >>> 3) & (1 << idx_byte_bit)) >> idx_byte_bit;
    }

    set_bit(idx_bit, value) {
        // Ensure value is constrained to either 0 or 1
        value = value ? 1 : 0;

        const { dv } = this;
        const idx_byte = idx_bit >>> 3;
        const idx_byte_bit = idx_bit & 7;
        const byte_mask = 1 << idx_byte_bit;
        const read_byte = dv.getUint8(idx_byte);
        const updated_byte = (read_byte & ~byte_mask) | (value << idx_byte_bit);
        
        dv.setUint8(idx_byte, updated_byte);
    }
}

module.exports = Typed_Array_Binary_Read_Write;
},{}],13:[function(require,module,exports){
//generateGaussianKernel = require('gaussian-convolution-kernel');


/*
 * Generates a kernel used for the gaussian blur effect.
 *
 * @param dimension is an odd integer
 * @param sigma is the standard deviation used for our gaussian function.
 *
 * @returns an array with dimension^2 number of numbers, all less than or equal
 *   to 1. Represents our gaussian blur kernel.
 */
function generateGaussianKernel(dimension, sigma) {

    /*

    Copyright (c) 2016, Andrey Sidorov

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted, provided that the above
    copyright notice and this permission notice appear in all copies.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

    */

    function hypotenuse(x1, y1, x2, y2) {
      var xSquare = Math.pow(x1 - x2, 2);
      var ySquare = Math.pow(y1 - y2, 2);
      return Math.sqrt(xSquare + ySquare);
    }

    if (!(dimension % 2) || Math.floor(dimension) !== dimension || dimension<3) {
      throw new Error(
        'The dimension must be an odd integer greater than or equal to 3'
      );
    }
    var kernel = [];
  
    var twoSigmaSquare = 2 * sigma * sigma;
    var centre = (dimension - 1) / 2;
  
    for (var i = 0; i < dimension; i++) {
      for (var j = 0; j < dimension; j++) {
        var distance = hypotenuse(i, j, centre, centre);
  
        // The following is an algorithm that came from the gaussian blur
        // wikipedia page [1].
        //
        // http://en.wikipedia.org/w/index.php?title=Gaussian_blur&oldid=608793634#Mechanics
        var gaussian = (1 / Math.sqrt(
          Math.PI * twoSigmaSquare
        )) * Math.exp((-1) * (Math.pow(distance, 2) / twoSigmaSquare));
  
        kernel.push(gaussian);
      }
    }
  
    // Returns the unit vector of the kernel array.
    var sum = kernel.reduce(function (c, p) { return c + p; });
    return kernel.map(function (e) { return e / sum; });
  }

module.exports = {
    'edge': new Float32Array(
        [
            -1, -1, -1,
            -1, 8, -1,
            -1, -1, -1
        ]
    ),
    'gauss_blur_5_2': generateGaussianKernel(5, 2),
    'gauss_blur_5_5': generateGaussianKernel(5, 5),
    'get_gauss': (d, sigma) => new Float32Array(generateGaussianKernel(d, sigma)),
    'lap_gauss_5': new Int8Array([
        0, 0, -1, 0, 0,
        0, -1, -2, -1, 0,
        -1, -2, 16, -2, -1,
        0, -1, -2, -1, 0,
        0, 0, -1, 0, 0
    ]),
    'sobel_x': new Int8Array([
        -1, 0, 1,
        -2, 0, 2,
        -1, 0, 1
    ]),
    'sobel_y': new Int8Array([
        1, 2, 1,
        0, 0, 0,
        -1, -2, -1
    ]),
    'sobel_diag_1': new Int8Array([
        0, 1, 2,
        -1, 0, 1,
        -2, -1, 0
    ]),
    'sobel_diag_2': new Int8Array([
        -2, -1, 0,
        -1, 0, 1,
        0, 1, 2
    ])
}
},{}],14:[function(require,module,exports){

// Later may separate into jsgui3-geometry and have gfx require that???
//.  jsgui3-shapes ???

// 



//const gm = require('gm');
// That would mean server side only
// gfx is both for client and server.

// 2023 - Considering making jsgui3-html depend on this.
//.  It could be of use for some collision-detection like features, and with canvas.

// Want some more graphics primitives as classes. Would help with expressing some geometric operations.
//.  Such as check a box that extends to the left of a control (80 pixels) to detect whether and where it intersects any of a control's siblings.

// A geometry core looks like it would be useful.
//.  Maybe call it 'shapes' for the moment???

// Shape_Group ????

// Object_Group???
// Class_Group???
// Instance_Group???

// Collective ???
//.  Address it collectively, ie it acts as a proxy for calling all of them.
//.  Seems like a lang-mini or lang-tools feature.

// Typed_Collective ??? Where each item in there must be an instanceOf the type_class

// Would be useful for addressing a bunch of shapes at once.








//.  Shape
//     Rectangle
//.      .extend('left', 80) for example.

// shape.render_to_pixel_buffer(pixel_buffer, pos) ???
//.  generate pixel buffers (such as a 1/0 mask, or an opacity mask) to represent a shape.

// Being able to express how to detect intersections between shapes.
//.  Being able to get the shapes including sizes and positions of rectangular divs, and then use geometry operations to do things like
//.    detect distances between them.
//.  Get the geometry processing lower level functions working well and efficiently, with convenient syntax, and 




// pixel_buffer.paint_shape ???



// jsgui3-html control.bcr could be changed to return a graphics shape class.




const Rectangle = require('./shapes/Rectangle');



const gfx_core = {
    Pixel_Pos_List: require('./pixel-pos-list'),
    Pixel_Buffer: require('./pixel-buffer'),
    Pixel_Buffer_Painter: require('./pixel-buffer-painter'),
    convolution_kernels: require('./convolution-kernels/kernels'),
    ta_math: require('./ta-math'),
    Rectangle,
    Rect: Rectangle
}

module.exports = gfx_core;
},{"./convolution-kernels/kernels":13,"./pixel-buffer":28,"./pixel-buffer-painter":27,"./pixel-pos-list":29,"./shapes/Rectangle":33,"./ta-math":38}],15:[function(require,module,exports){
(function (Buffer){(function (){

const lang = require('lang-mini');
const {
    each,
    fp,
    tof,
    get_a_sig,
    are_equal,
    tf
} = lang;
const maxui64 = ~0n;
const Pixel_Pos_List = require('./pixel-pos-list');
const oext = require('obext');
const {ro, prop} = oext;
const Typed_Array_Binary_Read_Write = require('./Typed_Array_Binary_Read_Write');
let ta_math = require('./ta-math')
let {resize_ta_colorspace, copy_rect_to_same_size_8bipp, copy_rect_to_same_size_24bipp, dest_aligned_copy_rect_1to4bypp} = ta_math;

// Core structures first?

// inner core



class Pixel_Buffer_Core_Inner_Structures {
    constructor(spec) {
        if (spec instanceof Pixel_Buffer_Core_Inner_Structures) {
            spec = {
                bits_per_pixel: spec.bits_per_pixel,
                size: spec.size,
                ta: spec.ta
            }
        }
        if (spec.window_to) {
            spec.bits_per_pixel = spec.window_to.bits_per_pixel;
        }
        const pos = new Int16Array(2);
        const size = new Int16Array(2);
        let ta; // flexible, can be redefined? Can still make read-only in userland.
        ro(this, 'ta', () => {
            return ta;
        });
        ro(this, 'buffer', () => {
            return ta;
        });
        const ta_bpp = new Uint8Array(2);
        ta_bpp[1] = 8; // byte to bit multiplier. will stay as 8.
        const _24bipp_to_8bipp = () => {
            const old_ta = ta;
            const new_ta = ta = new Uint8Array(this.num_px);
            const l_read = old_ta.length;
            let iby_read = 0, iby_write = 0;
            while (iby_read < l_read) {
                new_ta[iby_write++] = Math.round((old_ta[iby_read++] + old_ta[iby_read++] + old_ta[iby_read++]) / 3);
            }
        }
        const _change_bipp_inner_update = (old_bipp, new_bipp) => {
            if (old_bipp === 24) {
                if (new_bipp === 8) {
                    _24bipp_to_8bipp();
                } else {
                    console.trace();
                    throw 'NYI';
                }
            } else {
                console.trace();
                throw 'NYI';
            }
        }
        const def_bipp = {
            get() { return ta_bpp[0]; },
            set(value) { 
                console.log('value', value);
                const old_bipp = ta_bpp[0];
                ta_bpp[0] = value;
                _change_bipp_inner_update(old_bipp, ta_bpp[0]);
            },
            enumerable: true,
            configurable: false
        }
        Object.defineProperty(this, 'bits_per_pixel', def_bipp);
        Object.defineProperty(this, 'bipp', def_bipp);
        const def_bypp = {
            get() { return ta_bpp[0] / 8; },
            set(value) { 
                const old_bipp = ta_bpp[0];
                ta_bpp[0] = value * 8;
                _change_bipp_inner_update(old_bipp, ta_bpp[0]);
            },
            enumerable: true,
            configurable: false
        }
        Object.defineProperty(this, 'bytes_per_pixel', def_bypp);
        Object.defineProperty(this, 'bypp', def_bypp);
        const def_bypr = {
            get() {
                return size[0] * ta_bpp[0] / 8;
            }
        }
        Object.defineProperty(this, 'bytes_per_row', def_bypr);
        Object.defineProperty(this, 'bypr', def_bypr);
        Object.defineProperty(this, 'pos', {
            get() { return pos; },
            set(value) {
                if (value instanceof Int16Array) {
                    if (value.length === 2) {
                        pos[0] = value[0];
                        pos[1] = value[1];
                    }
                }
            },
            enumerable: true,
            configurable: false
        });
        const pos_bounds = new Int16Array(4);
        const pos_center = new Int16Array(2);
        const edge_offsets_from_center = new Int16Array(4);
        ro(this, 'pos_center', () => pos_center);
        ro(this, 'edge_offsets_from_center', () => edge_offsets_from_center);
        Object.defineProperty(this, 'pos_bounds', {
            get() {
                return pos_bounds; 
            },
            set(value) {
                const tv = tf(value);
                if (tv === 'a') {
                    if (value.length === 4) {
                        pos_bounds.set(value);
                    } else {
                        throw 'Expected Array with .length 4, value.length: ' + value.length;
                    }
                } else {
                    console.trace();
                    console.log('pos_bounds set tv', tv);
                    throw 'Expected Array';
                }
            },
            enumerable: true,
            configurable: false
        });
        const minus_pos = new Int16Array(2);
        Object.defineProperty(this, 'minus_pos', {
            get() {
                if (pos) {
                    minus_pos[0] = pos[0] * -1;
                    minus_pos[1] = pos[1] * -1;
                    return minus_pos;
                }
            },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'size', {
            get() { return size; },
            set(value) {
                if (value instanceof Int16Array) {
                    if (value.length === 2) {
                        size[0] = value[0];
                        size[1] = value[1];
                    }
                } else {
                    console.trace();
                    throw 'NYI';
                }
            },
            enumerable: true,
            configurable: false
        });
        if (spec instanceof Pixel_Pos_List) {
            throw 'NYI - change to 1bipp';
            const ppl = spec;
            const bounds = ppl.bounds;
            const ppl_size = new Uint16Array(2);
            ppl_size[0] = bounds[2] - bounds[0];
            ppl_size[1] = bounds[3] - bounds[1];
            this.bits_per_pixel = 8;
            const bpp = this.bytes_per_pixel = 1;
            this.size = new Uint16Array([ppl_size[0] + 4, ppl_size[1] + 4]);
            this.pos = new Int16Array([bounds[0], bounds[1]]);
            const bpr = this.bytes_per_row = bpp * this.size[0];
            const buf = this.ta = this.buffer = new Uint8ClampedArray(this.size[0] * this.size[1]);
            const l = buf.length;
            for (var c = 0; c < l; c++) buf[c] = 255;
            ppl.each_pixel(pixel_pos => {
                buf[(bpr * (pixel_pos[1] - bounds[1])) + (pixel_pos[0] - bounds[0])] = 0;
            });
        } else {
            if (spec.buffer) {
                if (spec.buffer instanceof Buffer) {
                    ta = new Uint8ClampedArray(spec.buffer.buffer);
                } else {
                    ta = spec.buffer;
                }
            }
            if (spec.ta) {
                ta = spec.ta;
            }
            if (spec.size) {
                size[0] = spec.size[0];
                size[1] = spec.size[1];
            } else {
                throw 'Expected: size [x, y] property in the Pixel_Buffer_Core specification';
            }
            if (spec.bytes_per_pixel && !spec.bits_per_pixel) spec.bits_per_pixel = spec.bytes_per_pixel * 8;
            spec.bits_per_pixel = spec.bits_per_pixel || 32;
            if (spec.bits_per_pixel) {
                if (spec.bits_per_pixel != 1 && spec.bits_per_pixel != 8 && spec.bits_per_pixel != 24 && spec.bits_per_pixel != 32) {
                    console.log('spec.bits_per_pixel', spec.bits_per_pixel);
                    console.trace();
                    throw 'Invalid bits_per_pixel value of ' + spec.bits_per_pixel + ', must be 8, 24 or 32, default is 32.';
                } else {
                    // bits per row...


                    //   but there could be some kind of round to 64 bit row alignment for 1bipp.

                    


                    ta_bpp[0] = spec.bits_per_pixel;
                }
            }
            /*
            const bytes_per_pixel = this.bytes_per_pixel = this.bits_per_pixel / 8;
            this.bytes_per_row = bytes_per_pixel * this.size[0];
            */

            let auto_adjust_ta_length_to_multiple_of_8 = true;
            //    if it would be tiny anyway, don't.



            if (size && !this.buffer) {
                //ta = new Uint8ClampedArray(Math.ceil((ta_bpp[0] / 8) * this.size[0] * this.size[1]));

                this.bits_per_row = size[0] * this.bits_per_pixel;

                let proposed_ta_length = Math.ceil((ta_bpp[0] / 8) * (size[0] * size[1]));

                if (auto_adjust_ta_length_to_multiple_of_8) {
                    const r8 = proposed_ta_length % 8;
                    if (r8 > 0) {
                        proposed_ta_length += (8 - r8);
                    }
                }
                
                ta = new Uint8Array(proposed_ta_length);
            }
            if (spec.color) {
                this.color_whole(spec.color);
            }
        }
        ro(this, 'meta', () => {
            return {
                size: this.size,
                bits_per_pixel: this.bits_per_pixel,
                bytes_per_pixel: this.bytes_per_pixel,
                bytes_per_row: this.bytes_per_row
            }
        });
        if (spec.window_to || spec.source || spec.window_to_source) {
            pb_source = spec.window_to || spec.source || spec.window_to_source;
            const log_info = () => {
                console.log('Pixel_Buffer_Core (or subclass) needs to act as a window to another Pixel Buffer.')
                console.log('pb_source', pb_source);
                console.log('pb_source.size', pb_source.size);
                console.log('spec.pos', spec.pos);
                console.log('spec.pos_center', spec.pos_center);
                console.log('this.pos', this.pos);
                console.log('this.pos_my_center_within_source', this.pos_my_center_within_source);
                console.log('spec', spec);
            }
        }
        if (spec.pos_bounds) {
            this.pos_bounds = spec.pos_bounds;
        }
        this.move = ta_2d_vector => {
            pos[0] += ta_2d_vector[0];
            pos[1] += ta_2d_vector[1];
            if (this.source) {
                this.copy_from_source();
            }
        }
        this.each_pos_within_bounds = (callback) => {
            const has_source = !!this.source;
            for (pos[1] = pos_bounds[1]; pos[1] < pos_bounds[3]; pos[1] ++) {
                for (pos[0] = pos_bounds[0]; pos[0] < pos_bounds[2]; pos[0] ++) {
                    if (has_source) this.copy_from_source();
                    callback();
                }
            }
        }
        this.move_next_px = () => {
            const source_size = this.source.size;
            if (pos[0] + size[0] < source_size[0]) {
                pos[0]++;
            } else {
                if (pos[1] + size[1] < source_size[1]) {
                    pos[0] = 0;
                    pos[1]++;
                } else {
                    return false;
                }
            }
            if (this.source) {
                this.copy_from_source();
            }
            return pos;
        }
        
        /*
        ro(this, 'bytes_per_row', () => {
            return this.size[0] * this.bytes_per_pixel;
        });
        */
        this.tabrw = new Typed_Array_Binary_Read_Write(ta);
        this.dv = this.tabrw.dv;
    }
    
    toString() {
        /*
        size: Uint32Array [ 1024, 576 ],
        bits_per_pixel: 32,
        bytes_per_pixel: 4,
        bytes_per_row: 4096 }
        */
        return JSON.stringify({
            buffer: 'Uint8ClampedArray length ' + this.buffer.length,
            size: this.size,
            bits_per_pixel: this.bits_per_pixel,
            bytes_per_pixel: this.bytes_per_pixel,
            bytes_per_row: this.bytes_per_row
        });
    }
    /*
    [inspect]() {
        return 'Pixel_Buffer_Core ' + this.toString();
    }
    */
    
    each_pixel_byte_index(cb) {
        const {bipp} = this;
        let ctu = true;
        const stop = () => ctu = false;

        // .num_pixels????

        const [w, h] = this.size;
        const num_pixels = w * h;

        let bit_idx = 0, byte_idx = bit_idx >> 3;

        for (let c = 0; c < num_pixels; c++) {

            byte_idx = bit_idx >> 3;
            bc(byte_idx);



        }
    }
    each_px(callback) {


        const ta_pos = new Int32Array(2);


        const [w, h] = this.size;
        //let x, y;

        // (pos, color, index) would be good callback format.
        let index = 0;

        for (ta_pos[1] = 0; ta_pos[1] < h; ta_pos[1]++) {
            for (ta_pos[0] = 0; ta_pos[0] < w; ta_pos[0]++) {
                const color = this.get_pixel(ta_pos);
                //ta_px_value[0] = px;
                callback(ta_pos, color, index++);
            }
        }
    }
    paint_pixel_list(pixel_pos_list, color) {
        pixel_pos_list.each_pixel(pos => {
            this.set_pixel_ta(pos, color);
        });
    }

    // Maybe a class level that has get and set pixel logic for the different bipps at this level.

    


    get num_px() {
        return this.size[0] * this.size[1];
    }
    get split_rgb_channels() {
        const [bipp, bypp] = [this.bits_per_pixel, this.bytes_per_pixel];
        if (bipp === 24 || bipp === 32) {
            const res = [new this.constructor({
                bits_per_pixel: 8,
                size: this.size
            }), new this.constructor({
                bits_per_pixel: 8,
                size: this.size
            }), new this.constructor({
                bits_per_pixel: 8,
                size: this.size
            })]
            const [r, g, b] = res;
            let i_px = 0;
            const num_px = this.num_px;
            let i_byte = 0;
            const [ta_r, ta_g, ta_b] = [r.ta, g.ta, b.ta];
            const ta = this.ta;
            while (i_px < num_px) {
                ta_r[i_px] = ta[i_byte];
                ta_g[i_px] = ta[i_byte + 1];
                ta_b[i_px] = ta[i_byte + 2];
                i_px++;
                i_byte += bypp;
            }
            return res;
        } else {
            console.trace();
            throw 'NYI';
        }
    }
    process(fn) {
        let res = this.clone();
        return fn(this, res);
    }
    /*
    function typedArraysAreEqual(a, b) {
if (a.byteLength !== b.byteLength) return false;
return a.every((val, i) => val === b[i]);
}
    */
    equals(other_pixel_buffer) {
        let buf1 = this.ta;
        let buf2 = other_pixel_buffer.ta;
        const other_colorspace = other_pixel_buffer.ta_colorspace;
        const my_colorspace = other_pixel_buffer.ta_colorspace;
        if (my_colorspace.length === other_colorspace.length) {
            if(my_colorspace.every((val, i) => val === other_colorspace[i])) {
                if (buf1.length === buf2.length) {
                    return buf1.every((val, i) => val === buf2[i]);
                } else {
                }
            } else {
            }
        }
        return false;
    }
    copy_pixel_pos_list_region(pixel_pos_list, bg_color) {
        let bounds = pixel_pos_list.bounds;
        let size = new Uint16Array([bounds[2] - bounds[0] + 1, bounds[3] - bounds[1] + 1]);
        const res = new this.constructor({
            size: size,
            bytes_per_pixel: this.bytes_per_pixel
        });
        if (this.pos) res.pos = this.pos;
        if (bg_color) {
            res.color_whole(bg_color);
        }
        res.pos = new Int16Array([bounds[0], bounds[1]]);
        pixel_pos_list.each_pixel((pos) => {
            let color = this.get_pixel_ta(pos);
            const target_pos = new Int16Array([(pos[0] - bounds[0]), (pos[1] - bounds[1])]);
            res.set_pixel_ta(target_pos, color);
        });
        return res;
    }
    'blank_copy'() {
        var res = new this.constructor({
            'size': this.size,
            'bits_per_pixel': this.bits_per_pixel
        });
        res.buffer.fill(0);
        if (this.pos) res.pos = this.pos;
        return res;
    }
    'clone'() {
        var res = new this.constructor({
            'size': this.size,
            'bits_per_pixel': this.bits_per_pixel,
            'buffer': new this.buffer.constructor(this.buffer)
        });
        if (this.pos) res.pos = this.pos;
        return res;
    }
    'add_alpha_channel'() {
        console.log('add_alpha_channel this.bytes_per_pixel', this.bytes_per_pixel);
        if (this.bytes_per_pixel === 3) {
            var res = new this.constructor({
                'size': this.size,
                'bytes_per_pixel': 4
            });
            if (this.pos) res.pos = this.pos;
            /*
            this.each_pixel((x, y, r, g, b) => {
                res.set_pixel(x, y, r, g, b, 255);
            });
            */
            const buf = this.buffer,
                res_buf = res.buffer;
            const px_count = this.size[0] * this.size[1];
            let i = 0,
                ir = 0;
            for (let p = 0; p < px_count; p++) {
                res_buf[ir++] = buf[i++];
                res_buf[ir++] = buf[i++];
                res_buf[ir++] = buf[i++];
                res_buf[ir++] = 255;
            }
            return res;
        }
        if (this.bytes_per_pixel === 4) {
            return this;
        }
    }
}
module.exports = Pixel_Buffer_Core_Inner_Structures;
if (require.main === module) {
    const lg = console.log;
    (async() => {
        const run_examples = async() => {
            lg('Begin run examples');
            const examples = [
                async() => {
                    lg('Begin example 0');
                    const pb = new Pixel_Buffer_Core_Reference_Implementations({
                        bits_per_pixel: 1,
                        size: [8, 8]
                    });
                    const ta_pos = new Int16Array(2);
                    ta_pos[0] = 3;
                    ta_pos[1] = 3;
                    pb.set_pixel(ta_pos, 1);
                    lg('End example 0');
                    return pb;
                }
            ]
            const l = examples.length;
            for (var c = 0; c < l; c++) {
                const res_eg = await examples[c]();
                console.log('res_eg ' + c + ':', res_eg);
            };
            lg('End run examples');
        }
        await run_examples();
    })();
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./Typed_Array_Binary_Read_Write":12,"./pixel-pos-list":29,"./ta-math":38,"buffer":3,"lang-mini":47,"obext":382}],16:[function(require,module,exports){

const lang = require('lang-mini');
const {
    each,
    fp,
    tof,
    get_a_sig,
    are_equal,
    tf
} = lang;
const maxui64 = ~0n;
const Pixel_Pos_List = require('./pixel-pos-list');
const oext = require('obext');
const {ro, prop} = oext;
const Typed_Array_Binary_Read_Write = require('./Typed_Array_Binary_Read_Write');
const Pixel_Buffer_Painter = require('./pixel-buffer-painter');
let ta_math = require('./ta-math')
let {resize_ta_colorspace, copy_rect_to_same_size_8bipp, copy_rect_to_same_size_24bipp, dest_aligned_copy_rect_1to4bypp} = ta_math;

// Core structures first?

// inner core
const Pixel_Buffer_Core_Inner_Structures = require('./pixel-buffer-0-core-inner-structures');


class Pixel_Buffer_Core_Get_Set_Pixels extends Pixel_Buffer_Core_Inner_Structures{
    constructor(spec) {
        if (spec instanceof Pixel_Buffer_Core_Get_Set_Pixels) {
            spec = {
                bits_per_pixel: spec.bits_per_pixel,
                size: spec.size,
                ta: spec.ta
            }
        }

        super(spec);
        
    }
    
    'get_pixel_byte_bit_1bipp'(pos) {
        /*
        */
        const idx = pos[1] * this.size[0] + pos[0];
        const byte = idx >> 3;
        const bit = (idx & 0b111);
        return {byte, bit};
    }
    'get_pixel_byte_bit_BE_1bipp'(pos) {
        const idx = pos[1] * this.size[0] + pos[0];
        const byte = idx >> 3;
        const bit = (idx & 0b111);
        return {byte, bit};
    }
    set_pixel_on_1bipp_by_pixel_index(pixel_index) {
        this.ta[pixel_index >> 3] |= (128 >> (pixel_index & 0b111));
    }

    'set_pixel_on_1bipp_xy'(x, y) {
        const pixel_index = y * this.size[0] + x;
        this.ta[pixel_index >> 3] |= (128 >> (pixel_index & 0b111));
    }

    'set_pixel_on_1bipp'(pos) {
        const pixel_index = pos[1] * this.size[0] + pos[0];
        this.ta[pixel_index >> 3] |= (128 >> (pixel_index & 0b111));
    }
    set_pixel_off_1bipp_by_pixel_index(pixel_index) {
        this.ta[pixel_index >> 3] &= (~(128 >> (pixel_index & 0b111))) & 255;
    }
    'set_pixel_off_1bipp'(pos) {
        const pixel_idx = pos[1] * this.size[0] + pos[0];
        this.ta[pixel_idx >> 3] &= (~(128 >> (pixel_idx & 0b111))) & 255;
    }
    'set_pixel_1bipp'(pos, color) {
        const idx_bit = (pos[1] * this.size[0]) + pos[0];
        const byte = idx_bit >> 3;
        const bit = (idx_bit & 0b111);
        if (color === 1) {
            this.ta[byte] |= (128 >> bit);
        } else {
            this.ta[byte] &= (~(128 >> bit)) & 255;
        }
    }
    'set_pixel_8bipp'(pos, color) {
        const idx = pos[1] * this.size[0] + pos[0];
        this.ta[idx] = color;
    }
    'set_pixel_24bipp'(pos, color) {
        const idx = pos[1] * this.size[0] + pos[0];
        let byte = idx * 3;
        this.ta[byte++] = color[0];
        this.ta[byte++] = color[1];
        this.ta[byte] = color[2];
    }
    'set_pixel_32bipp'(pos, color) {
        const idx = pos[1] * this.size[0] + pos[0];
        let byte = idx * 4;
        this.ta[byte++] = color[0];
        this.ta[byte++] = color[1];
        this.ta[byte++] = color[2];
        this.ta[byte] = color[3];
    }
    'set_pixel_by_idx_8bipp'(idx, color) {
        const byte = idx;
        this.ta[byte] = color;
    }
    'set_pixel_by_idx_24bipp'(idx, color) {
        const byte = idx * 3;
        this.ta[byte] = color[0];
        this.ta[byte + 1] = color[1];
        this.ta[byte + 2] = color[2];
    }
    'set_pixel_by_idx_32bipp'(idx, color) {
        const byte = idx * 4;
        this.ta[byte] = color[0];
        this.ta[byte + 1] = color[1];
        this.ta[byte + 2] = color[2];
        this.ta[byte + 3] = color[3];
    }
    'set_pixel_by_idx'(idx, color) {
        const a = arguments;
        const l = a.length;
        const bipp = this.bipp;
        if (bipp === 1) {
            return this.set_pixel_by_idx_1bipp(a[0], a[1]);
        } else if (bipp === 8) {
            if (l === 2) {
                return(this.set_pixel_by_idx_8bipp(a[0], a[1]));
            }
        } else if (bipp === 24) {
            if (l === 2) {
                return(this.set_pixel_by_idx_24bipp(a[0], a[1]));
            }
        } else if (bipp === 32) {
            if (l === 2) {
                return(this.set_pixel_by_idx_32bipp(a[0], a[1]));
            }
        }
    }
    'set_pixel'(pos, color) {
        const a = arguments;
        const l = a.length;
        const bipp = this.bipp;
        if (bipp === 1) {
            return(this.set_pixel_1bipp(a[0], a[1]));
        } else if (bipp === 8) {
            if (l === 2) {
                return(this.set_pixel_8bipp(a[0], a[1]));
            }
        } else if (bipp === 24) {
            if (l === 2) {
                return(this.set_pixel_24bipp(a[0], a[1]));
            }
        } else if (bipp === 32) {
            if (l === 2) {
                return(this.set_pixel_32bipp(a[0], a[1]));
            }
        } else {
            console.trace();
            throw 'unsupported bipp: ' + bipp;
        }
    }
    'get_pixel_by_idx_1bipp'(idx) {
        /*
        const idx = pos[1] * this.size[0] + pos[0];
        const byte = idx >> 3;
        const bit = (idx & 0b111);
        */
        const byte = idx >> 3;
        const bit = (idx & 0b111);
        const pow = 128 >> bit;
        return ((this.ta[byte] & pow) === pow) ? 1 : 0;
    }
    'get_pixel_by_idx_8bipp'(idx) {
        const byte = idx;
        return this.ta[byte];
    }
    'get_pixel_by_idx_24bipp'(idx) {
        const byte = idx * 3;
        return this.ta.slice(byte, byte + 3);
    }
    'get_pixel_by_idx_32bipp'(idx) {
        const byte = idx * 4;
        return this.ta.slice(byte, byte + 4);
    }
    'get_pixel_by_idx'(idx) {
        const bipp = this.bits_per_pixel;
        if (bipp === 1) {
            return this.get_pixel_by_idx_1bipp(idx);
        } else if (bipp === 8) {
            return this.get_pixel_by_idx_8bipp(idx);
        } else if (bipp === 24) {
            return this.get_pixel_by_idx_24bipp(idx);
        } else if (bipp === 32) {
            return this.get_pixel_by_idx_32bipp(idx);
        } else {
            throw 'Unsupported bipp'
        }
    }
    'get_pixel_1bipp'(pos) {
        const idx = (pos[1] * this.size[0]) + pos[0];
        const byte = idx >> 3;
        return ((this.ta[byte] & 128 >> (idx & 0b111)) !== 0) ? 1 : 0;
    }
    'get_pixel_8bipp'(pos) {
        const idx = pos[1] * this.size[0] + pos[0];
        const byte = idx;
        return this.ta[byte];
    }
    'get_pixel_24bipp'(pos) {
        const idx = pos[1] * this.size[0] + pos[0];
        const byte = idx * 3;
        return this.ta.slice(byte, byte + 3);
    }
    'get_pixel_32bipp'(pos) {
        const idx = pos[1] * this.size[0] + pos[0];
        const byte = idx * 4;
        return this.ta.slice(byte, byte + 4);
    }
    'get_pixel'(pos) {
        const bipp = this.bits_per_pixel;
        if (bipp === 1) {
            return this.get_pixel_1bipp(pos);
        } else if (bipp === 8) {
            return this.get_pixel_8bipp(pos);
        } else if (bipp === 24) {
            return this.get_pixel_24bipp(pos);
        } else if (bipp === 32) {
            return this.get_pixel_32bipp(pos);
        } else {
            console.trace();
            throw 'bits per pixels error';
        }
    }

    // Maybe a class level that has get and set pixel logic for the different bipps at this level.

    
    
}
module.exports = Pixel_Buffer_Core_Get_Set_Pixels;
},{"./Typed_Array_Binary_Read_Write":12,"./pixel-buffer-0-core-inner-structures":15,"./pixel-buffer-painter":27,"./pixel-pos-list":29,"./ta-math":38,"lang-mini":47,"obext":382}],17:[function(require,module,exports){
/*
    Maybe want an Image class that internally uses both Pixel_Buffer as well as X_Spans.
    Being able to handle multiple modes could be useful.
    Some modes will be more optimal for some operations.
    Drawing X_Spans will be sometimes a lot faster than drawing pixels.
    Then could get the output as a pixel buffer.
    Could keep one specific data structure up-to-date, and then when another representation is needed it renders the image into that
    data structure.
    May want to move some higher level algorithms upwards - ones that could work on top of either image type so long as there are
    lower level functions that do things like set_pixel.
    Could have optimised implementations for some things what work on those data structures.
    Static_X_Spans - Would be a good format to represent a shape. Maybe good format for saving to disk.
    Dynamic_X_Spans - Would be a good format for drawing a shape. Probably good for flood fills and other operations that modify the image.
        Dynamic_X_Spans seems more useful for the moment.
    Pixel_Buffer_Core could possibly use Dynamic_X_Spans when it does a draw_pollygon filled operation.
        The X_Spans idea came about as a way to do faster flood fills.
        A highly optimised Dynamic_X_Spans should be particularly useful for this.
            Flood fills will remove / join together some X Spans.
    Maybe Pixel_Buffer_Enh will use these Dynamic_X_Spans in order to do some things quicker (too)
    Polygon shape drawing seems core in terms of API, but somewhat higher level compared to some other features and algorithms.
    Possibly a Polygon that could draw itself to image data structures would work well.
*/
/*
    1 Small / trivial change
       2 mins going on 10 mins
    2  Small change
       5 mins going on 30 mins
    3  Medium-Small task
       15 mins going on 1.5h
       could be an easier version of a 4 - needs an optimized algorithm to be written and tested, it doesnt require further R&D.
    4
       45 mins going on 4.5(+)h
        as in could be an underestimated 5?
        may require thinking about maths & optimization
    5 Moderate - a few hours
        2 hours if it turns out to be relatively easy
        going on a day
    6
        0.5 days to 3 days
    7   (some level of overhaul or new API design involved)
        1.5 days to 1 week
    8  
        1 week to 3 weeks
    9 Programming / API overhaul
        3 weeks to 6 weeks
    10 Huge overhaul / major rewrite / a medium-large project of its own
        1 month to 3 months
*/
/*
const _roadmap = {
    '0.0.22': [
        ['pb.bypp = 1 convert to greyscale', 'done', 3, 'Medium small task requiring writing of optimized algorithm']
    ],
    '0.0.23': [
        'Convolutions', 
        `
        Task Size and Complexity Measure: 5 changed to 6.5
            Going into a larger properties overhaul - new size 6 or 7
        Rethinking and implementing pos_bounds
            pos_within_source_bounds
        Rename pos
            pos_within_source
            In this case, can't assume all positions are relative to the self pb, so need to be extra explicit in the variable names regarding what they relate to.
        Consider other pos type variables. Explicit names for what they do.
            pos_iteration_within_self
            pos_cursor_within_self
        Better to have more API-based centering, and adjust the central position?
            Possibly not best for convolution, for perf reasons.
            Don't want more calculations done during iteration...?
            Maybe don't need to deal with centering as directly right now?
                Seems useful for convolutions, centering the window of the px is a core part of the convolution logic. Worth having the platform support it as easily as possible.
        new_window
            implemented
        new_centered_window() ???
            NOT doing this for the moment. done new_window
            centered on 0,0.
            center of that window corresponds to a pixel in this window.
            bounds determined...
                does make sense for the moment.
                implement this fn, makes sense for convs right now.
            get_conv_window?
        new_convolved(convolution) - using this.
        `
        ['window view into specific channel?'],
        ['run convolution on 8bipp image?', 'maybe', 'not yet'],
        ['Convolution Class', ],
        ['Bug fix move_next_px, need to use boundary ranges for proper movement of the window within a source', 4, [
            ['cancelled - doing pb.pos_bounds', 'pb.window_movement_bounds', `
                Need to make / finish function
                Considering different types of bounds
            `],
            ['pos_bounds', `
                consider iterate_pos_within_bounds
                just each_pos_px?
                As well as positions, need to properly calculate iteration values and indexes.
                Put these into a typed array, access them through use of a function
            `]
        ]]
    ],
    '0.0.24': [
        'Moving of mathematical code to ta_math where possible and suitable.',
        'Current size: >6000 lines. Can it be brought down to 1000? Still kept v performant?',
        ['new_resized', 'clearly creates a new pb']
    ],
    '0.0.25': [
        'Improvements / optimization to resize',
        'Facilitate usage of C++ acceleration.'
    ]
}
*/
const lang = require('lang-mini');
const {
    each,
    fp,
    tof,
    get_a_sig,
    are_equal,
    tf
} = lang;
const maxui64 = ~0n;
const Pixel_Pos_List = require('./pixel-pos-list');
const oext = require('obext');
const {ro, prop} = oext;
const Typed_Array_Binary_Read_Write = require('./Typed_Array_Binary_Read_Write');
const Pixel_Buffer_Painter = require('./pixel-buffer-painter');
let ta_math = require('./ta-math')
let {resize_ta_colorspace, copy_rect_to_same_size_8bipp, copy_rect_to_same_size_24bipp, dest_aligned_copy_rect_1to4bypp} = ta_math;

const Pixel_Buffer_Core_Get_Set_Pixels = require('./pixel-buffer-1-core-get-set-pixel');

class Pixel_Buffer_Core_Draw_Lines extends Pixel_Buffer_Core_Get_Set_Pixels {
    constructor(spec) {
        
        super(spec);

        
        
        
    }

    'draw_line'(pos1, pos2, color) {

        // options would help....
        //  or it could just be color here.

        // And maybe use different bipp options.


        // yes, want to make an optimised 1bipp version. Will use a table of 8 movement offsets.

        // Maybe a 2 pixel coords ta?
        //   or a Pixel_Pair class????
        //    that extends a typed array


        if (this.bits_per_pixel === 1) {

            // This thing with the array probably slows it down?
            //   Though having such an array available could be better still?
            //     Or array itself will be better with improved optimisation???


            let x0 = pos1[0];
            let y0 = pos1[1];
            let x1 = pos2[0];
            let y1 = pos2[1];

            let dx = Math.abs(x1 - x0);
            let dy = Math.abs(y1 - y0);
            let sx = (x0 < x1) ? 1 : -1;
            let sy = (y0 < y1) ? 1 : -1;
            let err = dx - dy;

            while (true) {
                //console.log('[x0, y0]', [x0, y0]);
                this.set_pixel_1bipp([x0, y0], color);

                if (x0 === x1 && y0 === y1) {
                    break;
                }

                let e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x0 += sx;
                }

                if (e2 < dx) {
                    err += dx;
                    y0 += sy;
                }
            }


            //return this.draw_line_1bipp(new Uint32Array([pos1[0], pos1[1], pos2[0], pos2[1]]));
        } else {
            let x0 = pos1[0];
            let y0 = pos1[1];
            let x1 = pos2[0];
            let y1 = pos2[1];

            let dx = Math.abs(x1 - x0);
            let dy = Math.abs(y1 - y0);
            let sx = (x0 < x1) ? 1 : -1;
            let sy = (y0 < y1) ? 1 : -1;
            let err = dx - dy;

            while (true) {
                this.set_pixel([x0, y0], color);

                if (x0 === x1 && y0 === y1) {
                    break;
                }

                let e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x0 += sx;
                }

                if (e2 < dx) {
                    err += dx;
                    y0 += sy;
                }
            }
        }


        
    }

    
    draw_line_1bipp(ta_pixel_pair, color) {
        const { ta } = this;  // Extract the typed array (ta) from the pixel buffer object

        let [x0, y0, x1, y1] = ta_pixel_pair,     // Extract x0, y0, x1, y1 from ta_pixel_pair
            bytes_per_row = this.bytes_per_row,   // Access bytes per row from the object
            dx = Math.abs(x1 - x0),               // Calculate dx
            dy = Math.abs(y1 - y0),               // Calculate dy
            sx = (x0 < x1) ? 1 : -1,              // Set step direction for x
            sy = (y0 < y1) ? 1 : -1,              // Set step direction for y
            err = dx - dy, e2;                    // Initialize error value and temporary variable e2

        while (true) {
            // Calculate the byte index and bit position for (x0, y0)
            const byte_index = (x0 >> 3) + (y0 * bytes_per_row), bit_position = x0 & 7;

            if (color) {
                ta[byte_index] |= (1 << (7 - bit_position)); // Set the pixel in the typed array
            } else {
                ta[byte_index] &= ~(1 << (7 - bit_position)); // Clear the pixel in the typed array
            }

            if (x0 === x1 && y0 === y1) break;  // Stop when we reach the end

            e2 = err << 1;
            if (e2 > -dy) err -= dy, x0 += sx;  // Adjust error and move x
            if (e2 < dx) err += dx, y0 += sy;   // Adjust error and move y
        }
    }

    'draw_horizontal_line_off_1bipp_inclusive'([x1, x2], y) {
        const {size, ta} = this;
        const number_of_pixels_to_draw = (x2 - x1) + 1;
        if (number_of_pixels_to_draw === 1) {
            const pixel_index = (y * size[0]) + x1;
            ta[pixel_index >> 3] &= (~(128 >> (pixel_index & 0b111))) & 255;
        } else if (number_of_pixels_to_draw === 2) {
            let pixel_index = (y * size[0]) + x1;
            ta[pixel_index >> 3] &= (~(128 >> ((pixel_index & 0b111)))) & 255
            pixel_index++;
            ta[pixel_index >> 3] &= (~(128 >> ((pixel_index & 0b111)))) & 255
            pixel_index++;
        } else {
            const [w] = size;
            const starting_pixel_index = ((y * w) + x1) | 0;
            const ending_pixel_index = starting_pixel_index + (number_of_pixels_to_draw - 1);
            const starting_byte_index = starting_pixel_index >> 3;
            const starting_bit_within_byte_index = (starting_pixel_index & 7);
            const ending_byte_index = ending_pixel_index >> 3;
            const ending_bit_within_byte_index = (ending_pixel_index & 7);
            const bits_from_end_of_byte = 7 - ending_bit_within_byte_index;
            const number_of_bytes_with_any_coverage = (ending_byte_index - starting_byte_index) + 1;
            if (starting_byte_index === ending_byte_index) {
                ta[starting_byte_index] &= (~((((((255 << starting_bit_within_byte_index) & 255) >> starting_bit_within_byte_index)) >> bits_from_end_of_byte) << bits_from_end_of_byte))&255;
            }  else if (number_of_bytes_with_any_coverage === 2) {
                ta[starting_byte_index] &= (~(((255 << starting_bit_within_byte_index) & 255) >> starting_bit_within_byte_index))&255;
                ta[ending_byte_index] &= (~((255 >> bits_from_end_of_byte) << bits_from_end_of_byte))&255;
            } else {
                ta[starting_byte_index] &= (~((((255 << starting_bit_within_byte_index) & 255) >> starting_bit_within_byte_index)))&255;
                for (let x = starting_byte_index + 1; x < ending_byte_index; x++) {
                    ta[x] = 0;
                }
                ta[ending_byte_index] &= (~((255 >> bits_from_end_of_byte) << bits_from_end_of_byte))&255;
            }
        }
    }


    draw_x_span_on_1bipp(x, y, l) {
        const x2 = x + l;

        //console.log('[x, y, l]', [x, y, l]);

        for (let ix = x; ix < x2; ix++) {
            this.set_pixel_on_1bipp_xy(ix, y);

        }

    }

    // May do more lower level / general purpose work on line drawing....

    'draw_horizontal_line_on_1bipp_inclusive'([x1, x2], y) {
        const {size, ta} = this;
        const number_of_pixels_to_draw = (x2 - x1) + 1;
        if (number_of_pixels_to_draw === 1) {
            const pixel_index = (y * size[0]) + x1;
            ta[pixel_index >> 3] |= (128 >> (pixel_index & 0b111));
        } else if (number_of_pixels_to_draw === 2) {
            let pixel_index = (y * size[0]) + x1;
            // Seems possibly wrong op....
            //   Maybe this would really be best doing the 16 bit way.
            ta[pixel_index >> 3] |= (128 >> (pixel_index & 0b111));
            pixel_index++;
            ta[pixel_index >> 3] |= (128 >> (pixel_index & 0b111));
            pixel_index++;
        } else {
            const [w, h] = size;
            const starting_pixel_index = ((y * w) + x1) | 0;
            const ending_pixel_index = starting_pixel_index + (number_of_pixels_to_draw - 1);
            //const ending_pixel_index = starting_pixel_index + (number_of_pixels_to_draw - 1);
            const starting_byte_index = starting_pixel_index >> 3;
            const starting_bit_within_byte_index = (starting_pixel_index & 7);
            const ending_byte_index = ending_pixel_index >> 3;
            const ending_bit_within_byte_index = (ending_pixel_index & 7);
            const bits_from_end_of_byte = 7 - ending_bit_within_byte_index;
            if (starting_byte_index === ending_byte_index) {
                ta[starting_byte_index] |= (((((255 << starting_bit_within_byte_index) & 255) >> starting_bit_within_byte_index)) >> bits_from_end_of_byte) << bits_from_end_of_byte;
            } else {
                ta[starting_byte_index] |= ((255 << starting_bit_within_byte_index) & 255) >> starting_bit_within_byte_index;
                for (let x = starting_byte_index + 1; x < ending_byte_index; x++) {
                    ta[x] = 255;
                }
                ta[ending_byte_index] |= (255 >> bits_from_end_of_byte) << bits_from_end_of_byte;
            }
        }
    }
    
    'draw_horizontal_line_8bipp'(xspan, y, color) {
        const [x1, x2] = xspan;
        const {ta} = this;
        const [width] = this.size;
        const start_pixel_idx = width * y + x1;
        //const [r, g, b] = color;
        let w = start_pixel_idx;
        for (let x = x1; x <= x2; x++) {
            ta[w++] = color;
        }
    }
    'draw_horizontal_line_24bipp'(xspan, y, color) {
        const [x1, x2] = xspan;
        const {ta} = this;
        const [width] = this.size;
        const start_pixel_idx = width * y + x1;
        const [r, g, b] = color;
        let w = start_pixel_idx * 3;
        for (let x = x1; x <= x2; x++) {
            ta[w++] = r;
            ta[w++] = g;
            ta[w++] = b;
        }
    }
    'draw_horizontal_line_32bipp'(xspan, y, color) {
        const [x1, x2] = xspan;
        const {ta} = this;
        const [width] = this.size;
        const start_pixel_idx = width * y + x1;
        const [r, g, b, a] = color;
        let w = start_pixel_idx * 4;
        for (let x = x1; x <= x2; x++) {
            ta[w++] = r;
            ta[w++] = g;
            ta[w++] = b;
            ta[w++] = a;
        }
    }
    'draw_horizontal_line'(xspan, y, color) {
        const {bipp} = this;
        if (bipp === 1) {
            if (color === 1) {
                return this.draw_horizontal_line_on_1bipp_inclusive(xspan, y);
            } else {
                return this.draw_horizontal_line_off_1bipp_inclusive(xspan, y);
            }
        } else if (bipp === 8) {
            return this.draw_horizontal_line_8bipp(xspan, y, color);
        } else if (bipp === 24) {
            return this.draw_horizontal_line_24bipp(xspan, y, color);
        } else if (bipp === 32) {
            return this.draw_horizontal_line_32bipp(xspan, y, color);
        } else {
            console.trace();
            throw 'NYI';
        }
    }

    'draw_horizontal_line_y_x1_x2'(y, x1, x2, color, pre_populated_array, populate_array) {
        const {bipp} = this;
        if (bipp === 1) {
            if (color === 1) {
                return this.draw_horizontal_line_on_1bipp_inclusive_y_x1_x2(y, x1, x2);
            } else {
                return this.draw_horizontal_line_off_1bipp_inclusive_y_x1_x2(y, x1, x2);
            }
        } else if (bipp === 8) {
            return this.draw_horizontal_line_8bipp_y_x1_x2(y, x1, x2, color);
        } else if (bipp === 24) {
            return this.draw_horizontal_line_24bipp_y_x1_x2(y, x1, x2, color, pre_populated_array, populate_array);
        } else if (bipp === 32) {
            return this.draw_horizontal_line_32bipp_y_x1_x2(y, x1, x2, color);
        } else {
            console.trace();
            throw 'NYI';
        }
    }

    'draw_horizontal_line_8bipp_y_x1_x2'(y, x1, x2, color) {
        //const [x1, x2] = xspan;
        const {ta} = this;
        const [width] = this.size;
        const start_pixel_idx = width * y + x1;
        //const [r, g, b] = color;
        let w = start_pixel_idx;
        for (let x = x1; x <= x2; x++) {
            ta[w++] = color;
        }
    }

    '_draw_horizontal_line_24bipp_y_x1_x2'(y, x1, x2, color) {
        //const [x1, x2] = xspan;
        const {ta} = this;
        const [width] = this.size;
        const start_pixel_idx = width * y + x1;
        const [r, g, b] = color;
        let w = start_pixel_idx * 3;
        for (let x = x1; x <= x2; x++) {
            ta[w++] = r;
            ta[w++] = g;
            ta[w++] = b;
        }
    }

    'draw_horizontal_line_24bipp_y_x1_x2'(y, x1, x2, color, pre_populated_array = null, populate_array = true) {
        const { ta } = this;
        const [width, height] = this.size;

        // Validate bounds
        if (y < 0 || y >= height || x1 < 0 || x2 >= width || x1 > x2) {
            throw new Error("Coordinates out of bounds");
        }

        const start_pixel_idx = width * y + x1;
        const [r, g, b] = color;
        const pixel_count = x2 - x1 + 1;

        if (pixel_count < 8) {
            // For small spans, use the original per-pixel method
            let w = start_pixel_idx * 3;
            for (let x = x1; x <= x2; x++) {
                ta[w++] = r;
                ta[w++] = g;
                ta[w++] = b;
            }
            return;
        }

        // Create and optionally populate the pre-populated array if needed
        if (!pre_populated_array) {
            pre_populated_array = new Uint8Array(96 * 3); // Default size of 96 pixels, 288 bytes
        }

        if (populate_array) {
            for (let i = 0; i < pre_populated_array.length; i += 3) {
                pre_populated_array[i] = r;
                pre_populated_array[i + 1] = g;
                pre_populated_array[i + 2] = b;
            }
        }

        let w = start_pixel_idx * 3;
        const ppal = pre_populated_array.length;
        const chunk_size = ppal / 3; // Use the provided pre-populated array's actual size
        let remaining_pixels = pixel_count;

        while (remaining_pixels >= chunk_size) {
            //const byte_count = chunk_size * 3;
            ta.set(pre_populated_array, w);
            w += ppal;
            remaining_pixels -= chunk_size;
        }


        /*
        // Use .set for remaining pixels if 16 or more remain
        if (remaining_pixels >= 32) {
            const byte_count = remaining_pixels * 3;
            ta.set(pre_populated_array.subarray(0, byte_count), w);
        } else if (remaining_pixels > 0) {
            // Handle remaining pixels directly for fewer than 16
            for (let i = 0; i < remaining_pixels * 3; i += 3) {
                ta[w++] = r;
                ta[w++] = g;
                ta[w++] = b;
            }
        }

        */

        for (let i = 0; i < remaining_pixels; i ++) {
            ta[w++] = r;
            ta[w++] = g;
            ta[w++] = b;
        }
    }

    'draw_horizontal_line_32bipp_y_x1_x2'(y, x1, x2, color) {
        //const [x1, x2] = xspan;
        const {ta} = this;
        const [width] = this.size;
        const start_pixel_idx = width * y + x1;
        const [r, g, b, a] = color;
        let w = start_pixel_idx * 4;
        for (let x = x1; x <= x2; x++) {
            ta[w++] = r;
            ta[w++] = g;
            ta[w++] = b;
            ta[w++] = a;
        }
    }
    
}
module.exports = Pixel_Buffer_Core_Draw_Lines;
},{"./Typed_Array_Binary_Read_Write":12,"./pixel-buffer-1-core-get-set-pixel":16,"./pixel-buffer-painter":27,"./pixel-pos-list":29,"./ta-math":38,"lang-mini":47,"obext":382}],18:[function(require,module,exports){
const Pixel_Buffer_Core_Draw_Lines = require('./pixel-buffer-1.1-core-draw-line');

const Polygon_Scanline_Edges = require('./shapes/Polygon_Scanline_Edges');

let {resize_ta_colorspace, copy_rect_to_same_size_8bipp, copy_rect_to_same_size_24bipp, dest_aligned_copy_rect_1to4bypp,

    get_ta_bits_that_differ_from_previous_as_1s, right_shift_32bit_with_carry,
    xor_typed_arrays, each_1_index, count_1s,

    draw_polygon_outline_to_ta_1bipp, ensure_polygon_is_ta, calc_polygon_stroke_points_x_y


} = require('./ta-math');


const Polygon = require('./shapes/Polygon');
const ScanlineProcessor = require('./shapes/ScanlineProcessor');
class Pixel_Buffer_Core_Draw_Polygons extends Pixel_Buffer_Core_Draw_Lines {
    constructor(spec) {
        
        super(spec);
        
    }

    gpt_draw_polygon_filling(polygon) {
        const edges = [];
        const num_points = polygon.length / 2;

        const [w, h] = this.size;
    
        // Create edges for the polygon, connecting the last point to the first
        for (let i = 0; i < num_points; i++) {
            const x1 = polygon[i * 2];
            const y1 = polygon[i * 2 + 1];
            const x2 = polygon[((i + 1) % num_points) * 2];
            const y2 = polygon[((i + 1) % num_points) * 2 + 1];
    
            // Skip degenerate edges with the same start and end points
            if (x1 === x2 && y1 === y2) continue;
    
            // Only add non-horizontal edges
            if (y1 !== y2) {
                // Standardize edge creation to ensure consistent ordering
                const is_y1_lower = y1 < y2;
                edges.push({
                    x1: is_y1_lower ? x1 : x2,
                    y1: Math.min(y1, y2),
                    x2: is_y1_lower ? x2 : x1,
                    y2: Math.max(y1, y2),
                    slope: (x2 - x1) / (y2 - y1)
                });
            }
        }
    
        // Sort edges by y1, then by x1 for ties
        edges.sort((a, b) => a.y1 - b.y1 || a.x1 - b.x1);
    
        let active_edges = [];
        let edge_index = 0;
    
        // Process scanlines from top to bottom within the image bounds
        for (let y = 0; y < h; y++) {
            // Add edges that start at this y to the active edge list
            while (edge_index < edges.length && edges[edge_index].y1 === y) {
                active_edges.push(edges[edge_index]);
                edge_index++;
            }
    
            // Remove edges that end before this y
            active_edges = active_edges.filter(e => e.y2 > y);
    
            // Sort active edges by the current x-intercept for the scanline
            active_edges.sort((a, b) => a.x1 - b.x1);

            const aelm1 = active_edges.length - 1;

            //console.log('active_edges', active_edges);
    
            // Fill pixels between pairs of intersections
            for (let i = 0; i < aelm1; i += 2) {
                const x_start = Math.ceil(active_edges[i].x1);
                const x_end = Math.floor(active_edges[i + 1].x1);
    
                for (let x = x_start; x <= x_end; x++) {

                    const pixel_index = y * w + x;
                    this.ta[pixel_index >> 3] |= (128 >> (pixel_index & 0b111));

                    //this.set_pixel_on_1bipp_xy(x, y); // Fill with a color of 1 (binary for bitmask)
                }
            }
    
            // Update x-intercepts for active edges for the next scanline
            for (let edge of active_edges) {
                edge.x1 += edge.slope;
            }
        }
    }

    class_enh_gpt_draw_polygon_filling(polygon) {
        const [w, h] = this.size;
        polygon = Polygon.ensure_is(polygon);
        const polygon_scanline_edges = new Polygon_Scanline_Edges(polygon);
        const processor = new ScanlineProcessor(polygon_scanline_edges, w, h, this.ta);
        processor.process();
    }

    gpt_draw_filled_polygon_1bipp(polygon) {
        polygon = Polygon.ensure_is(ensure_polygon_is_ta(polygon));
        const scanline_processor = new ScanlineProcessor(
            polygon.scanline_edges, 
            this.size[0], 
            this.size[1], 
            this.ta, 
            { draw_edges: true } // Enable edge drawing
        );
        scanline_processor.process_1bipp();
    }

    

    draw_color_1_filled_polygon_1bipp(polygon) {
        return this.gpt_draw_filled_polygon_1bipp(polygon);
    }

    draw_polygon_1bipp(polygon, stroke_color, fill_color = false) {

        polygon = ensure_polygon_is_ta(polygon);
        if (fill_color === undefined || fill_color === false) {
            let x, y;
            let prev_x, prev_y;
            let is_first = true;

            const num_points = polygon.length >>> 1;
            let r = 0;
            //console.log('polygon outline pre draw. num_points: ', num_points);
            //console.log('stroke_color', stroke_color);
            for (let c = 0; c < num_points; c++) {
                x = polygon[r++];
                y = polygon[r++];
                if (!is_first) {
                    this.draw_line([prev_x, prev_y], [x, y], stroke_color);
                }
                [prev_x, prev_y] = [x, y];
                is_first = false;

            }
            //x = polygon[r++];
            //y = polygon[r++];
            this.draw_line([prev_x, prev_y], [polygon[0], polygon[1]], stroke_color);
        } else {
            if (stroke_color === 1) {
                if (fill_color === 1) {
                    // A filled polygon

                    // Get filled polygon x-spans
                    //   Draw those x-spans.
                    return this.draw_color_1_filled_polygon_1bipp(polygon);


                    
                } else if (fill_color === 0) {
                    // Needs to be filled with the color 0.
                    //   So basically need to get the outline and the inner shapes, draw them separately.

                    // Need to get the inner part x-spans.

                    console.trace();
                    throw 'NYI';



                }

            } else {

                if (fill_color === 1) {

                    // Only want the internal part of it.
                    console.trace();
                    throw 'NYI';

                } else if (fill_color === 0) {
                    console.trace();
                    throw 'NYI';
                    
                }

            }
        }
    }


    'draw_polygon'(arr_points, color, fill = false, stroke_color) {

        const {bits_per_pixel} = this;

        if (bits_per_pixel === 1) {

            if (fill === true) {
                if (stroke_color === undefined) {
                    return this.draw_polygon_1bipp(arr_points, color, color);
                } else {

                    console.trace();
                    throw 'NYI';

                    if (stroke_color === 1) {
                        //draw_polygon_outline_to_ta_1bipp(this.ta, this.size[0], polygon);
                    } else {
                        
                    }

                    //
                    
                }
            } else {
                return this.draw_polygon_1bipp(arr_points, color);

            }
        } else {
            if (fill === true) {

                // Let's have a faster way to draw these.
                //   Likely will use ta.set to set some larger number of pixels all at once, with 24bipp would need to do a num both divisible by 4 and by 3, so use a factor of 12.
                //     Like 144 bytes at once, ie 48 pixels at once.







                // Want to try the different 'flood fill inner pixels' for this polygon drawing.
                //  Will before long try on larger images. Maybe much larger too.



                // Iterate scanline spans????

                const iterate_class_polygon_scanline_spans_implementation = () => {

                    /*
                    const draw_stroke = () => {
                        //let x, y;
                        let prev_x, prev_y;
                        let is_first = true;
                        for (const [x, y] of arr_points) {
                            //console.log('[x, y]', [x, y]);
                            if (!is_first) {
                                this.draw_line([prev_x, prev_y], [x, y], color);
                            }
                            [prev_x, prev_y] = [x, y];
                            is_first = false;
                        }
                        this.draw_line([prev_x, prev_y], arr_points[0], color);
                    }
                    */


                    const draw_filling = () => {
                        const polygon = Polygon.ensure_is(ensure_polygon_is_ta(arr_points));
                        //polygon = polygon);
                    
                        // Create a Polygon_Scanline_Edges instance for the polygon
                        const polygon_scanline_edges = new Polygon_Scanline_Edges(polygon);
                    
                        // Get the size of the target bitmap (e.g., width and height)
                        const [w, h] = this.size;
                    
                        // Create a ScanlineProcessor instance to handle the rendering logic
                        const processor = new ScanlineProcessor(polygon_scanline_edges, w, h, this.ta, { draw_edges: true });

                        // Create the pre-populated array???

                        if (bits_per_pixel === 24) {
                            //const ppal = 96 * 3;
                            const ppal = 64 * 3;
                            const pre_populated_array = new Uint8Array(ppal); // 96 pixels, 288 bytes
                
                            for (let i = 0; i < ppal;) {
                                pre_populated_array[i++] = color[0];
                                pre_populated_array[i++] = color[1];
                                pre_populated_array[i++] = color[2];
                            }

                            for (const [y, x1, x2] of processor.iterate_process()) {
                                this.draw_horizontal_line_24bipp_y_x1_x2(y, x1, x2, color, pre_populated_array, false);

                            }
                        } else {
                            for (const [y, x1, x2] of processor.iterate_process()) {
                                //console.log('[y, x1, x2]', [y, x1, x2]);

                                //this.draw_horizontal_line([x1, x2], y, color);
                                this.draw_horizontal_line_y_x1_x2(y, x1, x2, color);

                                // draw_horizontal_line_y_x1_x2

                            }
                        }

                        
                    }
                    //draw_stroke();
                    draw_filling();
                }

                iterate_class_polygon_scanline_spans_implementation();
            } else {

                // Should make a much faster implementation.
                //   Will not use set_pixel, but will track the pixel index, work out the offset for whichever move (could look it up from ta of 8) and adjust the pixel index, then do an inline set pixel on the ta.


                //let x, y;
                let prev_x, prev_y;
                let is_first = true;
                for (const [x, y] of arr_points) {
                    //console.log('[x, y]', [x, y]);
                    if (!is_first) {
                        this.draw_line([prev_x, prev_y], [x, y], color);
                    }
                    [prev_x, prev_y] = [x, y];
                    is_first = false;
                }
                this.draw_line([prev_x, prev_y], arr_points[0], color);
            }
        }
        

        // But a filled polygon is more complex to draw.


        // go through the points doing draw_line.


        // then back to the start.
    }

    
    
}
module.exports = Pixel_Buffer_Core_Draw_Polygons;
},{"./pixel-buffer-1.1-core-draw-line":17,"./shapes/Polygon":30,"./shapes/Polygon_Scanline_Edges":32,"./shapes/ScanlineProcessor":34,"./ta-math":38}],19:[function(require,module,exports){
const Pixel_Buffer_Core_Draw_Polygons = require('./pixel-buffer-1.2-core-draw-polygon');
const Polygon_Scanline_Edges = require('./shapes/Polygon_Scanline_Edges');
const ScanlineProcessor = require('./shapes/ScanlineProcessor');
class Pixel_Buffer_Core_Masks extends Pixel_Buffer_Core_Draw_Polygons {
    constructor(spec) {
        super(spec);
    }
    'draw_1bipp_pixel_buffer_mask_1bipp'(pb_1bipp_mask, dest_pos, color) {
        const arr_on_xspans_implementation = () => {
            const arr_rows_arr_on_xspans = pb_1bipp_mask.calculate_arr_rows_arr_x_on_spans_1bipp();
            const [width, height] = pb_1bipp_mask.size;
            const [dest_x, dest_y] = dest_pos;
            if (color === 1) {
                for (let y = 0; y < height; y++) {
                    const target_y = y + dest_y;
                    for (const xonspan of arr_rows_arr_on_xspans[y]) {
                        xonspan[0] += dest_x;
                        xonspan[1] += dest_x;
                        this.draw_horizontal_line_on_1bipp_inclusive(xonspan, target_y);
                    }
                }
            } else {
                for (let y = 0; y < height; y++) {
                    const target_y = y + dest_y;
                    for (const xonspan of arr_rows_arr_on_xspans[y]) {
                        xonspan[0] += dest_x;
                        xonspan[1] += dest_x;
                        this.draw_horizontal_line_off_1bipp_inclusive(xonspan, target_y);
                    }
                }
            }
        }
        const bit_realigned_64_bit_implementation = () => {
            const pb_source = pb_1bipp_mask;
            const pb_dest = this;
            const size_source = pb_source.size;
            const w_source = size_source[0];
            const h_source = size_source[1];
            const size_dest = pb_dest.size;
            const w_dest = size_dest[0];
            const iterate_dest_shift_reads = () => {
                const dest_start_pxi = (dest_pos[1] * pb_dest.size[0]) + dest_pos[0];
                const dest_start_row_end_pxi = dest_start_pxi + pb_source.size[0];
                const num_px_from_dest_row_start_to_draw_box_start = dest_pos[0];
                const num_px_from_draw_box_end_to_dest_row_end = pb_dest.size[0] - pb_source.size[0] - num_px_from_dest_row_start_to_draw_box_start;
                const num_px_line_jump = num_px_from_draw_box_end_to_dest_row_end + dest_pos[0];
                const num_ui64_line_jump = (num_px_line_jump >>> 6) - 1; 
                const dest_start_i64 = dest_start_pxi >>> 6;
                const dest_start_i64_rb = dest_start_pxi % 64;
                const dest_start_row_end_i64 = dest_start_row_end_pxi >>> 6;
                const num_64_bit_at_least_partial_parts_per_row = (dest_start_row_end_i64 - dest_start_i64) + 1;
                let i64_dest = dest_start_i64;
                let i64_source = 0;
                const y_top = dest_pos[1], y_bottom = y_top + h_source;
                const sta64 = new BigUint64Array(pb_source.ta.buffer, pb_source.ta.byteOffset, pb_source.ta.byteLength / 8);
                const dta64 = new BigUint64Array(pb_dest.ta.buffer, pb_dest.ta.byteOffset, pb_dest.ta.byteLength / 8); 
                const bi_dest_start_i64_rb = BigInt(dest_start_i64_rb);
                const bi_right_right_shift_bits = 64n - bi_dest_start_i64_rb;
                const dest_row_middle_ui64_count = num_64_bit_at_least_partial_parts_per_row - 2;
                for (let y = y_top; y < y_bottom; y++) {
                    const process_0th_64bit_part = () => {
                        dta64[i64_dest] = ((dta64[i64_dest] << bi_right_right_shift_bits) >> bi_right_right_shift_bits) | (sta64[i64_source] << bi_dest_start_i64_rb);
                        i64_dest++;
                    }
                    const process_middle_64bit_parts = () => {
                        for (let i_mid = 0; i_mid < dest_row_middle_ui64_count; i_mid++) {
                            dta64[i64_dest++] = (sta64[i64_source] >> bi_right_right_shift_bits) | (sta64[i64_source + 1] << bi_dest_start_i64_rb);
                            i64_source++;
                        }
                    }
                    const process_last_64bit_part = () => {
                        dta64[i64_dest] = (dta64[i64_dest]) | (sta64[i64_source] >> bi_right_right_shift_bits);
                        i64_dest++;
                        i64_source++;
                    }
                    process_0th_64bit_part();
                    process_middle_64bit_parts();
                    process_last_64bit_part();
                    i64_dest += num_ui64_line_jump;
                }
            }
            iterate_dest_shift_reads();
        }
        const test_can_do_aligned_64_bit = () => (this.bits_per_row % 64 === 0 && this.bits_per_row >= 64) && 
            (dest_pos[1] * pb_1bipp_mask.size[0] + dest_pos[0]) % 64 === 0 &&
            pb_1bipp_mask.bits_per_row % 64 === 0 && pb_1bipp_mask.bits_per_row >= 64;
        const test_can_do_bit_realigned_64_bit = () => (this.bits_per_row % 64 === 0 && this.bits_per_row >= 64) && 
        pb_1bipp_mask.bits_per_row % 64 === 0 && pb_1bipp_mask.bits_per_row >= 64;
        const approach_selecting = () => {
            {
                const can_do_bit_realigned_64_bit = test_can_do_bit_realigned_64_bit();
                if (can_do_bit_realigned_64_bit) {
                    return arr_on_xspans_implementation();
                } else {
                    return arr_on_xspans_implementation();
                }
            }
        }
        return approach_selecting();
    }
    'draw_1bipp_pixel_buffer_mask'(pb_1bipp_mask, dest_pos, color) {
        const {bipp} = this;
        if (bipp === 1) {
            return this.draw_1bipp_pixel_buffer_mask_1bipp(pb_1bipp_mask, dest_pos, color);
        } else {
            const arr_on_xspans_implementation = () => {
                //let arr_rows_arr_on_xspans;
                /*
                if (pb_1bipp_mask.arr_rows_arr_on_xspans) {

                } else {
                    pb_1bipp_mask.arr_rows_arr_on_xspans = pb_1bipp_mask.calculate_arr_rows_arr_x_on_spans_1bipp();
                }

                const arr_rows_arr_on_xspans = pb_1bipp_mask.arr_rows_arr_on_xspans;
                */

                const arr_rows_arr_on_xspans = pb_1bipp_mask.calculate_arr_rows_arr_x_on_spans_1bipp();
                const [width, height] = pb_1bipp_mask.size;
                let y = 0;
                let [dest_x, dest_y] = dest_pos;
                for (y = 0; y < height; y++) {
                    const arr_row_xspans_on = arr_rows_arr_on_xspans[y];
                    if (arr_row_xspans_on.length > 0) {
                        for (const xonspan of arr_row_xspans_on) {
                            xonspan[0] += dest_x;
                            xonspan[1] += dest_x;
                            this.draw_horizontal_line(xonspan, y + dest_y, color);
                        }
                    }
                }
                //pb_1bipp_mask.arr_rows_arr_on_xspans = undefined;
            }
            return arr_on_xspans_implementation();
        }
    }
    mask_each_pixel(cb_pixel) {
        const bipp = this.bits_per_pixel;
        let i_byte = 0;
        let i_px = 0;
        const bypp = this.bytes_per_pixel;
        const ta = this.ta;
        const l = ta.length;
        const res_mask = new this.constructor({
            size: this.size,
            bits_per_pixel: 1
        });
        if (bipp === 1) {
            console.trace();
            throw 'NYI';
        } else if (bipp === 8) {
            console.trace();
            throw 'NYI';
        } else if (bipp === 24 || bipp === 32) {
            while (i_byte < l) {
                const ta_sub = ta.slice(i_byte, i_byte + bypp);
                const px_on = cb_pixel(ta_sub) ? 1 : 0;
                res_mask.set_pixel_by_idx(i_px, px_on);
                i_byte += bypp;
                i_px++;
            }
        }
        return res_mask;
    }
    apply_mask(pb_mask, mr, mg, mb, ma) {
        let res = this.blank_copy();
        res.flood_fill(0, 0, 255, 255, 255, 255);
        let px;
        pb_mask.each_pixel((x, y, r, g, b, a) => {
            if (r === mr && g === mg && b === mb && a === ma) {
                px = this.get_pixel(x, y);
                res.set_pixel(x, y, px[0], px[1], px[2], px[3])
            }
        })
        return res;
    }
    'get_mask_each_px'(fn_mask) {
        const bipp = this.bipp;
        console.log('get_mask_each_px bipp', bipp);
        const res_mask = new this.constructor({
            size: this.size,
            bits_per_pixel: 1
        })
        if (bipp === 1) {
            let byte = 0,
                bit = 0; 
            console.trace();
            throw 'NYI'
            const ta = this.ta,
                l = ta.length;
            while (byte < l) {
            }
        } else if (bipp === 8) {
            console.trace();
            throw 'NYI';
        } else if (bipp === 24) {
            let byte_pos = 0,
                i_px = 0;
            const l = this.ta.length;
            while (byte_pos < l) {
                const ta_px = this.ta.slice(byte_pos, byte_pos + 3);
                const mask_res = fn_mask(ta_px);
                byte_pos += 3;
            }
        } else if (bipp === 32) {
            console.trace();
            throw 'NYI';
        }
        return res_mask;
    }
}
module.exports = Pixel_Buffer_Core_Masks;
},{"./pixel-buffer-1.2-core-draw-polygon":18,"./shapes/Polygon_Scanline_Edges":32,"./shapes/ScanlineProcessor":34}],20:[function(require,module,exports){
/*
    Maybe want an Image class that internally uses both Pixel_Buffer as well as X_Spans.
    Being able to handle multiple modes could be useful.
    Some modes will be more optimal for some operations.
    Drawing X_Spans will be sometimes a lot faster than drawing pixels.
    Then could get the output as a pixel buffer.
    Could keep one specific data structure up-to-date, and then when another representation is needed it renders the image into that
    data structure.
    May want to move some higher level algorithms upwards - ones that could work on top of either image type so long as there are
    lower level functions that do things like set_pixel.
    Could have optimised implementations for some things what work on those data structures.
    Static_X_Spans - Would be a good format to represent a shape. Maybe good format for saving to disk.
    Dynamic_X_Spans - Would be a good format for drawing a shape. Probably good for flood fills and other operations that modify the image.
        Dynamic_X_Spans seems more useful for the moment.
    Pixel_Buffer_Core could possibly use Dynamic_X_Spans when it does a draw_pollygon filled operation.
        The X_Spans idea came about as a way to do faster flood fills.
        A highly optimised Dynamic_X_Spans should be particularly useful for this.
            Flood fills will remove / join together some X Spans.
    Maybe Pixel_Buffer_Enh will use these Dynamic_X_Spans in order to do some things quicker (too)
    Polygon shape drawing seems core in terms of API, but somewhat higher level compared to some other features and algorithms.
    Possibly a Polygon that could draw itself to image data structures would work well.
*/
/*
    1 Small / trivial change
       2 mins going on 10 mins
    2  Small change
       5 mins going on 30 mins
    3  Medium-Small task
       15 mins going on 1.5h
       could be an easier version of a 4 - needs an optimized algorithm to be written and tested, it doesnt require further R&D.
    4
       45 mins going on 4.5(+)h
        as in could be an underestimated 5?
        may require thinking about maths & optimization
    5 Moderate - a few hours
        2 hours if it turns out to be relatively easy
        going on a day
    6
        0.5 days to 3 days
    7   (some level of overhaul or new API design involved)
        1.5 days to 1 week
    8  
        1 week to 3 weeks
    9 Programming / API overhaul
        3 weeks to 6 weeks
    10 Huge overhaul / major rewrite / a medium-large project of its own
        1 month to 3 months
*/
/*
const _roadmap = {
    '0.0.22': [
        ['pb.bypp = 1 convert to greyscale', 'done', 3, 'Medium small task requiring writing of optimized algorithm']
    ],
    '0.0.23': [
        'Convolutions', 
        `
        Task Size and Complexity Measure: 5 changed to 6.5
            Going into a larger properties overhaul - new size 6 or 7
        Rethinking and implementing pos_bounds
            pos_within_source_bounds
        Rename pos
            pos_within_source
            In this case, can't assume all positions are relative to the self pb, so need to be extra explicit in the variable names regarding what they relate to.
        Consider other pos type variables. Explicit names for what they do.
            pos_iteration_within_self
            pos_cursor_within_self
        Better to have more API-based centering, and adjust the central position?
            Possibly not best for convolution, for perf reasons.
            Don't want more calculations done during iteration...?
            Maybe don't need to deal with centering as directly right now?
                Seems useful for convolutions, centering the window of the px is a core part of the convolution logic. Worth having the platform support it as easily as possible.
        new_window
            implemented
        new_centered_window() ???
            NOT doing this for the moment. done new_window
            centered on 0,0.
            center of that window corresponds to a pixel in this window.
            bounds determined...
                does make sense for the moment.
                implement this fn, makes sense for convs right now.
            get_conv_window?
        new_convolved(convolution) - using this.
        `
        ['window view into specific channel?'],
        ['run convolution on 8bipp image?', 'maybe', 'not yet'],
        ['Convolution Class', ],
        ['Bug fix move_next_px, need to use boundary ranges for proper movement of the window within a source', 4, [
            ['cancelled - doing pb.pos_bounds', 'pb.window_movement_bounds', `
                Need to make / finish function
                Considering different types of bounds
            `],
            ['pos_bounds', `
                consider iterate_pos_within_bounds
                just each_pos_px?
                As well as positions, need to properly calculate iteration values and indexes.
                Put these into a typed array, access them through use of a function
            `]
        ]]
    ],
    '0.0.24': [
        'Moving of mathematical code to ta_math where possible and suitable.',
        'Current size: >6000 lines. Can it be brought down to 1000? Still kept v performant?',
        ['new_resized', 'clearly creates a new pb']
    ],
    '0.0.25': [
        'Improvements / optimization to resize',
        'Facilitate usage of C++ acceleration.'
    ]
}
*/
const lang = require('lang-mini');
const {
    each,
    fp,
    tof,
    get_a_sig,
    are_equal,
    tf
} = lang;
const maxui64 = ~0n;
const Pixel_Pos_List = require('./pixel-pos-list');
const oext = require('obext');
const {ro, prop} = oext;
const Typed_Array_Binary_Read_Write = require('./Typed_Array_Binary_Read_Write');
const Pixel_Buffer_Painter = require('./pixel-buffer-painter');
let ta_math = require('./ta-math')
let {resize_ta_colorspace, copy_rect_to_same_size_8bipp, copy_rect_to_same_size_24bipp, dest_aligned_copy_rect_1to4bypp} = ta_math;

const Pixel_Buffer_Core_Masks = require('./pixel-buffer-1.5-core-mask');

class Pixel_Buffer_Core_Reference_Implementations extends Pixel_Buffer_Core_Masks {
    constructor(spec) {
        if (spec instanceof Pixel_Buffer_Core_Reference_Implementations) {
            spec = {
                bits_per_pixel: spec.bits_per_pixel,
                size: spec.size,
                ta: spec.ta
            }
        }
        let silent_update_bits_per_pixel;
        let silent_update_bytes_per_pixel;
        if (spec.window_to) {
            spec.bits_per_pixel = spec.window_to.bits_per_pixel;
        }
        const pos = new Int16Array(2);
        const size = new Int16Array(2);
        let ta; // flexible, can be redefined? Can still make read-only in userland.

        super(spec);

        
        
        this.move = ta_2d_vector => {
            pos[0] += ta_2d_vector[0];
            pos[1] += ta_2d_vector[1];
            if (this.source) {
                this.copy_from_source();
            }
        }
        this.each_pos_within_bounds = (callback) => {
            const has_source = !!this.source;
            for (pos[1] = pos_bounds[1]; pos[1] < pos_bounds[3]; pos[1] ++) {
                for (pos[0] = pos_bounds[0]; pos[0] < pos_bounds[2]; pos[0] ++) {
                    if (has_source) this.copy_from_source();
                    callback();
                }
            }
        }
        this.move_next_px = () => {
            const source_size = this.source.size;
            if (pos[0] + size[0] < source_size[0]) {
                pos[0]++;
            } else {
                if (pos[1] + size[1] < source_size[1]) {
                    pos[0] = 0;
                    pos[1]++;
                } else {
                    return false;
                }
            }
            if (this.source) {
                this.copy_from_source();
            }
            return pos;
        }
        this.paint = new Pixel_Buffer_Painter({
            pb: this
        });
    }

    // Some will need to be a bit more optimised for perf rather than readability. Do want clear code though.

    // Not quite sure why this is failing on 1 bipp right now....

    each_pixel(callback) {
        // Want optimised but still idiomatic
        const {ta_pos_scratch, bipp, bypp, size, ta} = this;

        // And a ta_color_scratch perhaps?
        //   ta_24bipp_color_scratch maybe...
        //   ta_rgb or ta_rgba?
        //    number of bits makes more sense. more flexible.

        // Could call each_pixel_pos, and increment a byte index.

        // read_bit_from_byte

        //const bfb = (byte, bit_index) => (byte >> bit_index) & 1;

        if (bipp === 1) {

            // Should not be too hard to implement....

            //let i_pixel = 0;
            // and the number of pixels....
            const [w, h] = size;

            let i_byte = 0, i_bit = 0;
            //let input_byte = ta[0];

            const ta_cb_pos = new Uint32Array(2);

            for (let y = 0; y < h; y++) {
                ta_cb_pos[1] = y;
                for (let x = 0; x < w; x++) {
                    ta_cb_pos[0] = x;
                    //const px_color = (input_byte >> i_bit) & 1;
                    // not sure why this is not working right.

                    const got_px_color = this.get_pixel_1bipp(ta_cb_pos);

                    
                    callback(ta_cb_pos, got_px_color);

                    //i_bit++;
                    if (i_bit === 8) {
                        //i_byte++;
                        //i_bit = 0;
                        //input_byte = ta[i_byte];
                    }
                    //i_pixel++;
                }

            }


            



            //console.trace();
            //throw 'NYI';
        } else if (bipp === 8) {
            // Function to iterate through positions could work.
            // Nested for loops seems a bit simpler...
            //ta_pos_scratch[0] = 0;
            //ta_pos_scratch[1] = 0;
            let pixel_idx = 0;
            this.each_pixel_pos((pos, stop) => {
                callback(pos, ta[pixel_idx++], stop);
            });
            //


        } else if (bipp === 24) {
            // Provide direct access with a subarray?
            //  Could be better for idiomatic writing.
            //  Though setting values would maybe / likely be quicker and mean less allocations.

            const {ta_24bit_color} = this;
            let byte_idx = 0;
            this.each_pixel_pos((pos, stop) => {
                ta_24bit_color[0] = ta[byte_idx++];
                ta_24bit_color[1] = ta[byte_idx++];
                ta_24bit_color[2] = ta[byte_idx++];
                callback(pos, ta_24bit_color, stop);
            });

        } else if (bipp === 32) {
            const {ta_32bit_color} = this;
            let byte_idx = 0;
            this.each_pixel_pos((pos, stop) => {
                ta_32bit_color[0] = ta[byte_idx++];
                ta_32bit_color[1] = ta[byte_idx++];
                ta_32bit_color[2] = ta[byte_idx++];
                ta_32bit_color[3] = ta[byte_idx++];
                callback(pos, ta_32bit_color, stop);
            });
        }

        // Could advance through the positions?
        // Advancing through bit indexes.

    }

    'to_8bit_greyscale'() {
        if (this.bytes_per_pixel === 1) {
            return this;
        } else if (this.bytes_per_pixel === 3) {
            const res = new this.constructor({
                'size': this.size,
                'bits_per_pixel': 8
            });
            if (this.pos) res.pos = this.pos;
            const bres = res.buffer;
            let i = 0;
            this.each_pixel((pos, color) => {
                bres[i++] = Math.round((color[0] + color[1] + color[2]) / 3);
            });
            return res;
        } else if (this.bytes_per_pixel === 4) {
            const res = new this.constructor({
                'size': this.size,
                'bits_per_pixel': 8
            });
            if (this.pos) res.pos = this.pos;
            const bres = res.buffer;
            let i = 0;
            this.each_pixel((pos, color) => {
                bres[i++] = Math.round((color[0] + color[1] + color[2]) / 3);
            });
            return res;
        }
    }
    'to_32bit_rgba'() {
        var res = new this.constructor({
            'size': this.size,
            'bits_per_pixel': 32
        });
        if (this.pos) res.pos = this.pos;
        const bres = res.buffer;
        if (this.bytes_per_pixel === 1) {
            let i = 0, new_v;
            this.each_pixel((pos, v) => {
                bres[i++] = v;
                bres[i++] = v;
                bres[i++] = v;
                bres[i++] = 255;
            });
        } else {
            console.trace();
            throw 'NYI';
        }
        return res;
    }
    '__invert_greyscale_self'() {
        const bres = this.buffer;
        let i = 0;
        this.each_pixel((x, y, v) => {
            bres[i++] = 255 - v;
        });
        return this;
    }
    '__invert_greyscale'() {
        let res = new this.constructor({
            'size': this.size,
            'bits_per_pixel': 8
        });
        if (this.pos) res.pos = this.pos;
        const bres = res.buffer;
        let i = 0;
        this.each_pixel((x, y, v) => {
            bres[i++] = 255 - v;
        });
        return res;
    }

    // Could have a 'paint' file / module.
    'paint_solid_border'(thickness, color) {

        // separate methods for different bipps, this fn chooses one?

        return this.process((me, res) => {
            let x, y;
            const [w, h] = this.size;
            if (this.bytes_per_pixel === 4) {
                // top two rows
                for (y = 0; y < thickness; y++) {
                    for (x = 0; x < w; x++) {
                        res.set_pixel(x, y, color[0], color[1], color[2], color[3]);
                    }
                }
                for (y = h - thickness; y < h; y++) {
                    for (x = 0; x < w; x++) {
                        res.set_pixel(x, y, color[0], color[1], color[2], color[3]);
                    }
                }
                for (y = 0; y < h; y++) {
                    for (x = 0; x < thickness; x++) {
                        res.set_pixel(x, y, color[0], color[1], color[2], color[3]);
                    }
                }
                for (y = 0; y < h; y++) {
                    for (x = w - thickness; x < w; x++) {
                        res.set_pixel(x, y, color[0], color[1], color[2], color[3]);
                    }
                }
            } else if (this.bytes_per_pixel === 3) {
                // top two rows
                for (y = 0; y < thickness; y++) {
                    for (x = 0; x < w; x++) {
                        res.set_pixel(x, y, color[0], color[1], color[2]);
                    }
                }
                for (y = h - thickness; y < h; y++) {
                    for (x = 0; x < w; x++) {
                        res.set_pixel(x, y, color[0], color[1], color[2]);
                    }
                }
                for (y = 0; y < h; y++) {
                    for (x = 0; x < thickness; x++) {
                        res.set_pixel(x, y, color[0], color[1], color[2]);
                    }
                }
                for (y = 0; y < h; y++) {
                    for (x = w - thickness; x < w; x++) {
                        res.set_pixel(x, y, color[0], color[1], color[2]);
                    }
                }
            } else {
                console.trace();
                throw 'NYI';
            }
            return res;
        })
    }

    new_convolved(convolution) {
        const res = this.blank_copy();
        const xy_conv_center = convolution.xy_center;
        const edge_distances_from_center_px_edge = new Int16Array(4);
        edge_distances_from_center_px_edge[0] = xy_conv_center[0] * -1;
        edge_distances_from_center_px_edge[1] = xy_conv_center[1] * -1;
        edge_distances_from_center_px_edge[2] = edge_distances_from_center_px_edge[0] + convolution.size[0] - 1;
        edge_distances_from_center_px_edge[3] = edge_distances_from_center_px_edge[1] + convolution.size[1] - 1;
        const pb_window = this.new_window({
            size: convolution.size,
            pos_bounds: [edge_distances_from_center_px_edge[0], edge_distances_from_center_px_edge[1], this.size[0] - edge_distances_from_center_px_edge[2], this.size[1] - edge_distances_from_center_px_edge[3]],
            pos: [edge_distances_from_center_px_edge[0], edge_distances_from_center_px_edge[1]]
        });
        const pos_window = pb_window.pos;
        const ta_window = pb_window.ta;
        /*
        const pb_conv_res = new Pixel_Buffer({
            size: pb_8bipp_patch.size,
            bits_per_pixel: 24
        });
        */
        let i_write = 0;
        const ta_conv_res = res.ta;
        pb_window.each_pos_within_bounds(() => {
            const rgb = convolution.calc_from_24bipp_ta(ta_window);
            ta_conv_res[i_write++] = rgb[0];
            ta_conv_res[i_write++] = rgb[1];
            ta_conv_res[i_write++] = rgb[2];
        });
        return res;
    }
    new_resized(size) {
        const dest = new this.constructor({
            size: size,
            bits_per_pixel: this.bipp
        });
        resize_ta_colorspace(this.ta, this.ta_colorspace, dest.size, dest.ta);
        return dest;
    }
    copy_rect_by_bounds_to(ta_bounds, pb_target) {
        console.log('pb.copy_rect_by_bounds_to');
        const bipp = this.bipp;
        if (bipp === 24) {
            return this.copy_rect_by_bounds_to_24bipp(ta_bounds, pb_target)
        } else {
            console.trace();
            throw 'NYI';
        }
    }
    each_px_convolution(ta_size, pb_conv_window, ta_pos, callback) {
        console.trace();
        throw 'NYI';
        ta_pos[0] = 0;
        ta_pos[1] = 0;
        if (are_equal(pb_conv_window.size, ta_size)) {
        } else {
        }
    }
    
    toString() {
        /*
        size: Uint32Array [ 1024, 576 ],
        bits_per_pixel: 32,
        bytes_per_pixel: 4,
        bytes_per_row: 4096 }
        */
        return JSON.stringify({
            buffer: 'Uint8ClampedArray length ' + this.buffer.length,
            size: this.size,
            bits_per_pixel: this.bits_per_pixel,
            bytes_per_pixel: this.bytes_per_pixel,
            bytes_per_row: this.bytes_per_row
        });
    }
    /*
    [inspect]() {
        return 'Pixel_Buffer_Core ' + this.toString();
    }
    */
    color_whole(color) {
        this.each_px(pos => {
            this.set_pixel(pos, color);
        })
        return this;
    }
    crop(size) {
        let new_size = new Uint16Array([this.size[0] - size * 2, this.size[1] - size * 2]);
        let res = new this.constructor({
            bytes_per_pixel: this.bytes_per_pixel,
            size: new_size
        });
        if (this.pos) {
            res.pos = new Int16Array([this.pos[0] - size, this.pos[1] - size])
        }
        this.each_pixel_ta((pos, color) => {
            const new_pos = new Int16Array([pos[0] - size, pos[1] - size]);
            if (new_pos[0] >= 0 && new_pos[0] < new_size[0] && new_pos[1] >= 0 && new_pos[1] < new_size[1]) {
                res.set_pixel_ta(new_pos, color);
            }
        });
        return res;
    }
    uncrop(size, color) {
        let res = new this.constructor({
            bytes_per_pixel: this.bytes_per_pixel,
            size: new Uint16Array([this.size[0] + size * 2, this.size[1] + size * 2])
        })
        if (this.pos) res.pos = this.pos;
        if (this.pos) {
        }
        res.color_whole(color);
        console.log('size', size);
        this.each_pixel_ta((pos, color) => {
            res.set_pixel_ta(new Uint16Array([pos[0] + size, pos[1] + size]), color);
        })
        return res;
    }
    color_rect(bounds, color) {
        console.trace();
        throw 'NYI';
    }
    each_pixel_byte_index(cb) {
        const {bipp} = this;
        let ctu = true;
        const stop = () => ctu = false;

        // .num_pixels????

        const [w, h] = this.size;
        const num_pixels = w * h;

        let bit_idx = 0, byte_idx = bit_idx >> 3;

        for (let c = 0; c < num_pixels; c++) {

            byte_idx = bit_idx >> 3;
            cb(byte_idx);



        }
    }
    each_px(callback) {


        const ta_pos = new Int32Array(2);


        const [w, h] = this.size;
        //let x, y;

        // (pos, color, index) would be good callback format.
        let index = 0;

        for (ta_pos[1] = 0; ta_pos[1] < h; ta_pos[1]++) {
            for (ta_pos[0] = 0; ta_pos[0] < w; ta_pos[0]++) {
                const color = this.get_pixel(ta_pos);
                //ta_px_value[0] = px;
                callback(ta_pos, color, index++);
            }
        }
    }
    paint_pixel_list(pixel_pos_list, color) {
        pixel_pos_list.each_pixel(pos => {
            this.set_pixel_ta(pos, color);
        });
    }
    

    // Maybe a class level that has get and set pixel logic for the different bipps at this level.




    get num_px() {
        return this.size[0] * this.size[1];
    }
    get split_rgb_channels() {
        const [bipp, bypp] = [this.bits_per_pixel, this.bytes_per_pixel];
        if (bipp === 24 || bipp === 32) {
            const res = [new this.constructor({
                bits_per_pixel: 8,
                size: this.size
            }), new this.constructor({
                bits_per_pixel: 8,
                size: this.size
            }), new this.constructor({
                bits_per_pixel: 8,
                size: this.size
            })]
            const [r, g, b] = res;
            let i_px = 0;
            const num_px = this.num_px;
            let i_byte = 0;
            const [ta_r, ta_g, ta_b] = [r.ta, g.ta, b.ta];
            const ta = this.ta;
            while (i_px < num_px) {
                ta_r[i_px] = ta[i_byte];
                ta_g[i_px] = ta[i_byte + 1];
                ta_b[i_px] = ta[i_byte + 2];
                i_px++;
                i_byte += bypp;
            }
            return res;
        } else {
            console.trace();
            throw 'NYI';
        }
    }
    process(fn) {
        let res = this.clone();
        return fn(this, res);
    }
    /*
    function typedArraysAreEqual(a, b) {
if (a.byteLength !== b.byteLength) return false;
return a.every((val, i) => val === b[i]);
}
    */
    equals(other_pixel_buffer) {
        let buf1 = this.ta;
        let buf2 = other_pixel_buffer.ta;
        const other_colorspace = other_pixel_buffer.ta_colorspace;
        const my_colorspace = other_pixel_buffer.ta_colorspace;
        if (my_colorspace.length === other_colorspace.length) {
            if(my_colorspace.every((val, i) => val === other_colorspace[i])) {
                if (buf1.length === buf2.length) {
                    return buf1.every((val, i) => val === buf2[i]);
                } else {
                }
            } else {
            }
        }
        return false;
    }
    copy_pixel_pos_list_region(pixel_pos_list, bg_color) {
        let bounds = pixel_pos_list.bounds;
        let size = new Uint16Array([bounds[2] - bounds[0] + 1, bounds[3] - bounds[1] + 1]);
        const res = new this.constructor({
            size: size,
            bytes_per_pixel: this.bytes_per_pixel
        });
        if (this.pos) res.pos = this.pos;
        if (bg_color) {
            res.color_whole(bg_color);
        }
        res.pos = new Int16Array([bounds[0], bounds[1]]);
        pixel_pos_list.each_pixel((pos) => {
            let color = this.get_pixel_ta(pos);
            const target_pos = new Int16Array([(pos[0] - bounds[0]), (pos[1] - bounds[1])]);
            res.set_pixel_ta(target_pos, color);
        });
        return res;
    }


    // Pixel_Buffer_Pair_Complex_Operation class possibly?
    //   Or just Operation.



    // get_pre_operation_alignment_info ....


    
    // And could define such a class which has got requirements / invarients to do with 



    // This is used when drawing filled polygons.

    
    'blank_copy'() {
        var res = new this.constructor({
            'size': this.size,
            'bits_per_pixel': this.bits_per_pixel
        });
        res.buffer.fill(0);
        if (this.pos) res.pos = this.pos;
        return res;
    }
    'clone'() {
        var res = new this.constructor({
            'size': this.size,
            'bits_per_pixel': this.bits_per_pixel,
            'buffer': new this.buffer.constructor(this.buffer)
        });
        if (this.pos) res.pos = this.pos;
        return res;
    }
    'add_alpha_channel'() {
        //console.log('add_alpha_channel this.bytes_per_pixel', this.bytes_per_pixel);
        if (this.bytes_per_pixel === 3) {
            var res = new this.constructor({
                'size': this.size,
                'bytes_per_pixel': 4
            });
            if (this.pos) res.pos = this.pos;
            /*
            this.each_pixel((x, y, r, g, b) => {
                res.set_pixel(x, y, r, g, b, 255);
            });
            */
            const buf = this.buffer,
                res_buf = res.buffer;
            const px_count = this.size[0] * this.size[1];
            let i = 0,
                ir = 0;
            for (let p = 0; p < px_count; p++) {
                res_buf[ir++] = buf[i++];
                res_buf[ir++] = buf[i++];
                res_buf[ir++] = buf[i++];
                res_buf[ir++] = 255;
            }
            return res;
        }
        if (this.bytes_per_pixel === 4) {
            return this;
        }
    }
    
    draw_rect(pos_corner, pos_other_corner, color) {
        /*
        const paint_bounds = new Int16Array([20, 300, 180, 320]);
        const paint_color = new Uint8ClampedArray([255, 0, 0]);
        ta_math.fill_solid_rect_by_bounds(pb_dest.ta, pb_dest.bytes_per_row, paint_bounds, 24, paint_color);
        */
        const l = Math.min(pos_corner[0], pos_other_corner[0]);
        const t = Math.min(pos_corner[1], pos_other_corner[1]);
        const r = Math.max(pos_corner[0], pos_other_corner[0]);
        const b = Math.max(pos_corner[1], pos_other_corner[1]);
        //const paint_bounds = new Int16Array([20, 300, 180, 320]);
        //const paint_color = new Uint8ClampedArray([255, 0, 0]);
        const xspan = [l, r];
        for (let y = t; y <= b; y++) {
            this.draw_horizontal_line(xspan, y, color);
        }
    }
    * 'iterate_arr_row_x_on_spans_1bipp'(y) {
    }
    get xspans() {
    }
}
module.exports = Pixel_Buffer_Core_Reference_Implementations;
if (require.main === module) {
    const lg = console.log;
    (async() => {
        const run_examples = async() => {
            lg('Begin run examples');
            const examples = [
                async() => {
                    lg('Begin example 0');
                    const pb = new Pixel_Buffer_Core_Reference_Implementations({
                        bits_per_pixel: 1,
                        size: [8, 8]
                    });
                    const ta_pos = new Int16Array(2);
                    ta_pos[0] = 3;
                    ta_pos[1] = 3;
                    pb.set_pixel(ta_pos, 1);
                    lg('End example 0');
                    return pb;
                }
            ]
            const l = examples.length;
            for (var c = 0; c < l; c++) {
                const res_eg = await examples[c]();
                console.log('res_eg ' + c + ':', res_eg);
            };
            lg('End run examples');
        }
        await run_examples();
    })();
}

},{"./Typed_Array_Binary_Read_Write":12,"./pixel-buffer-1.5-core-mask":19,"./pixel-buffer-painter":27,"./pixel-pos-list":29,"./ta-math":38,"lang-mini":47,"obext":382}],21:[function(require,module,exports){
/*
    Maybe want an Image class that internally uses both Pixel_Buffer as well as X_Spans.
    Being able to handle multiple modes could be useful.
    Some modes will be more optimal for some operations.
    Drawing X_Spans will be sometimes a lot faster than drawing pixels.
    Then could get the output as a pixel buffer.
    Could keep one specific data structure up-to-date, and then when another representation is needed it renders the image into that
    data structure.
    May want to move some higher level algorithms upwards - ones that could work on top of either image type so long as there are
    lower level functions that do things like set_pixel.
    Could have optimised implementations for some things what work on those data structures.
    Static_X_Spans - Would be a good format to represent a shape. Maybe good format for saving to disk.
    Dynamic_X_Spans - Would be a good format for drawing a shape. Probably good for flood fills and other operations that modify the image.
        Dynamic_X_Spans seems more useful for the moment.
    Pixel_Buffer_Core could possibly use Dynamic_X_Spans when it does a draw_pollygon filled operation.
        The X_Spans idea came about as a way to do faster flood fills.
        A highly optimised Dynamic_X_Spans should be particularly useful for this.
            Flood fills will remove / join together some X Spans.
    Maybe Pixel_Buffer_Enh will use these Dynamic_X_Spans in order to do some things quicker (too)
    Polygon shape drawing seems core in terms of API, but somewhat higher level compared to some other features and algorithms.
    Possibly a Polygon that could draw itself to image data structures would work well.
*/
/*
    1 Small / trivial change
       2 mins going on 10 mins
    2  Small change
       5 mins going on 30 mins
    3  Medium-Small task
       15 mins going on 1.5h
       could be an easier version of a 4 - needs an optimized algorithm to be written and tested, it doesnt require further R&D.
    4
       45 mins going on 4.5(+)h
        as in could be an underestimated 5?
        may require thinking about maths & optimization
    5 Moderate - a few hours
        2 hours if it turns out to be relatively easy
        going on a day
    6
        0.5 days to 3 days
    7   (some level of overhaul or new API design involved)
        1.5 days to 1 week
    8  
        1 week to 3 weeks
    9 Programming / API overhaul
        3 weeks to 6 weeks
    10 Huge overhaul / major rewrite / a medium-large project of its own
        1 month to 3 months
*/
/*
const _roadmap = {
    '0.0.22': [
        ['pb.bypp = 1 convert to greyscale', 'done', 3, 'Medium small task requiring writing of optimized algorithm']
    ],
    '0.0.23': [
        'Convolutions', 
        `
        Task Size and Complexity Measure: 5 changed to 6.5
            Going into a larger properties overhaul - new size 6 or 7
        Rethinking and implementing pos_bounds
            pos_within_source_bounds
        Rename pos
            pos_within_source
            In this case, can't assume all positions are relative to the self pb, so need to be extra explicit in the variable names regarding what they relate to.
        Consider other pos type variables. Explicit names for what they do.
            pos_iteration_within_self
            pos_cursor_within_self
        Better to have more API-based centering, and adjust the central position?
            Possibly not best for convolution, for perf reasons.
            Don't want more calculations done during iteration...?
            Maybe don't need to deal with centering as directly right now?
                Seems useful for convolutions, centering the window of the px is a core part of the convolution logic. Worth having the platform support it as easily as possible.
        new_window
            implemented
        new_centered_window() ???
            NOT doing this for the moment. done new_window
            centered on 0,0.
            center of that window corresponds to a pixel in this window.
            bounds determined...
                does make sense for the moment.
                implement this fn, makes sense for convs right now.
            get_conv_window?
        new_convolved(convolution) - using this.
        `
        ['window view into specific channel?'],
        ['run convolution on 8bipp image?', 'maybe', 'not yet'],
        ['Convolution Class', ],
        ['Bug fix move_next_px, need to use boundary ranges for proper movement of the window within a source', 4, [
            ['cancelled - doing pb.pos_bounds', 'pb.window_movement_bounds', `
                Need to make / finish function
                Considering different types of bounds
            `],
            ['pos_bounds', `
                consider iterate_pos_within_bounds
                just each_pos_px?
                As well as positions, need to properly calculate iteration values and indexes.
                Put these into a typed array, access them through use of a function
            `]
        ]]
    ],
    '0.0.24': [
        'Moving of mathematical code to ta_math where possible and suitable.',
        'Current size: >6000 lines. Can it be brought down to 1000? Still kept v performant?',
        ['new_resized', 'clearly creates a new pb']
    ],
    '0.0.25': [
        'Improvements / optimization to resize',
        'Facilitate usage of C++ acceleration.'
    ]
}
*/
const lang = require('lang-mini');
const {
    each,
    fp,
    tof,
    get_a_sig,
    are_equal,
    tf
} = lang;
const maxui64 = ~0n;
const Pixel_Pos_List = require('./pixel-pos-list');
const oext = require('obext');
const {ro, prop} = oext;
const Typed_Array_Binary_Read_Write = require('./Typed_Array_Binary_Read_Write');
const Pixel_Buffer_Painter = require('./pixel-buffer-painter');
let ta_math = require('./ta-math')
let {resize_ta_colorspace, copy_rect_to_same_size_8bipp, copy_rect_to_same_size_24bipp, dest_aligned_copy_rect_1to4bypp} = ta_math;

const Pixel_Buffer_Core_Reference_Implementations = require('./pixel-buffer-2-core-reference-implementations');

class Pixel_Buffer_Core extends Pixel_Buffer_Core_Reference_Implementations {
    constructor(spec) {
        super(spec);
        const pos = new Int16Array(2);
        const size = new Int16Array(2);
        
        const ta_bpp = new Uint8Array(2);
        ta_bpp[1] = 8; // byte to bit multiplier. will stay as 8.
        const _24bipp_to_8bipp = () => {
            const old_ta = ta;
            const new_ta = ta = new Uint8Array(this.num_px);
            const l_read = old_ta.length;
            let iby_read = 0, iby_write = 0;
            while (iby_read < l_read) {
                new_ta[iby_write++] = Math.round((old_ta[iby_read++] + old_ta[iby_read++] + old_ta[iby_read++]) / 3);
            }
        }
        const _change_bipp_inner_update = (old_bipp, new_bipp) => {
            if (old_bipp === 24) {
                if (new_bipp === 8) {
                    _24bipp_to_8bipp();
                } else {
                    console.trace();
                    throw 'NYI';
                }
            } else {
                console.trace();
                throw 'NYI';
            }
        }
        
        if (spec instanceof Pixel_Pos_List) {
            throw 'NYI - change to 1bipp';
            const ppl = spec;
            const bounds = ppl.bounds;
            const ppl_size = new Uint16Array(2);
            ppl_size[0] = bounds[2] - bounds[0];
            ppl_size[1] = bounds[3] - bounds[1];
            this.bits_per_pixel = 8;
            const bpp = this.bytes_per_pixel = 1;
            this.size = new Uint16Array([ppl_size[0] + 4, ppl_size[1] + 4]);
            this.pos = new Int16Array([bounds[0], bounds[1]]);
            const bpr = this.bytes_per_row = bpp * this.size[0];
            const buf = this.ta = this.buffer = new Uint8ClampedArray(this.size[0] * this.size[1]);
            const l = buf.length;
            for (var c = 0; c < l; c++) buf[c] = 255;
            ppl.each_pixel(pixel_pos => {
                buf[(bpr * (pixel_pos[1] - bounds[1])) + (pixel_pos[0] - bounds[0])] = 0;
            });
        } else {
            
        }
        
    }
    new_convolved(convolution) {
        const res = this.blank_copy();
        const xy_conv_center = convolution.xy_center;
        const edge_distances_from_center_px_edge = new Int16Array(4);
        edge_distances_from_center_px_edge[0] = xy_conv_center[0] * -1;
        edge_distances_from_center_px_edge[1] = xy_conv_center[1] * -1;
        edge_distances_from_center_px_edge[2] = edge_distances_from_center_px_edge[0] + convolution.size[0] - 1;
        edge_distances_from_center_px_edge[3] = edge_distances_from_center_px_edge[1] + convolution.size[1] - 1;
        const pb_window = this.new_window({
            size: convolution.size,
            pos_bounds: [edge_distances_from_center_px_edge[0], edge_distances_from_center_px_edge[1], this.size[0] - edge_distances_from_center_px_edge[2], this.size[1] - edge_distances_from_center_px_edge[3]],
            pos: [edge_distances_from_center_px_edge[0], edge_distances_from_center_px_edge[1]]
        });
        const pos_window = pb_window.pos;
        const ta_window = pb_window.ta;
        /*
        const pb_conv_res = new Pixel_Buffer({
            size: pb_8bipp_patch.size,
            bits_per_pixel: 24
        });
        */
        let i_write = 0;
        const ta_conv_res = res.ta;
        pb_window.each_pos_within_bounds(() => {
            const rgb = convolution.calc_from_24bipp_ta(ta_window);
            ta_conv_res[i_write++] = rgb[0];
            ta_conv_res[i_write++] = rgb[1];
            ta_conv_res[i_write++] = rgb[2];
        });
        return res;
    }
    new_resized(size) {
        const dest = new this.constructor({
            size: size,
            bits_per_pixel: this.bipp
        });
        resize_ta_colorspace(this.ta, this.ta_colorspace, dest.size, dest.ta);
        return dest;
    }
    copy_rect_by_bounds_to(ta_bounds, pb_target) {
        console.log('pb.copy_rect_by_bounds_to');
        const bipp = this.bipp;
        if (bipp === 24) {
            return this.copy_rect_by_bounds_to_24bipp(ta_bounds, pb_target)
        } else {
            console.trace();
            throw 'NYI';
        }
    }
    each_px_convolution(ta_size, pb_conv_window, ta_pos, callback) {
        console.trace();
        throw 'NYI';
        ta_pos[0] = 0;
        ta_pos[1] = 0;
        if (are_equal(pb_conv_window.size, ta_size)) {
        } else {
        }
    }
    get_1bipp_threshold_8bipp(ui8_threshold) {
        const bipp = this.bits_per_pixel;
        if (bipp === 8) {
            const res = new this.constructor({
                bits_per_pixel: 1,
                size: this.size
            });
            const rta = res.ta;
            const ta = this.ta;
            const cpx = this.num_px;
            let i_px = 0;
            let i_dest_byte = 0, i_dest_bit = 7;
            let meets_threshold = false;
            let out_byte = 0;
            while (i_px < cpx) {
                meets_threshold = ta[i_px] >= ui8_threshold;
                if (meets_threshold) {
                    out_byte = out_byte | Math.pow(2, i_dest_bit)
                } else {
                }
                i_px++;
                i_dest_bit--;
                if (i_dest_bit === -1) {
                    rta[i_dest_byte] = out_byte;
                    i_dest_bit = 7;
                    i_dest_byte++;
                    out_byte = 0;
                }
            }
            return res;
        } else {
            console.trace();
            throw 'get_1bipp_threshold_8bipp: Unsupported bits_per_pixel ' + bipp;
        }
    }
    to_8bipp() {
        const bipp = this.bits_per_pixel;
        if (bipp === 1) {
            const res = new this.constructor({
                size: this.size,
                bits_per_pixel: 8
            })
            let i_px = 0;
            let i_byte = 0;
            const num_bytes = this.ta.length;
            while (i_byte < num_bytes) {
                for (var b = 0; b < 8; b++) {
                    const color = this.get_pixel_by_idx_1bipp(i_px) === 1 ? 255 : 0;
                    res.set_pixel_by_idx_8bipp(i_px++, color);
                }
                i_byte++;
            }
            return res;
        } else if (bipp === 8) {
            return this.clone();
        } else if (bipp === 24) {
            console.trace();
            throw 'NYI';
        } else if (bipp === 32) {
            console.trace();
            throw 'NYI';
        }
    }
    to_24bipp() {
        const bipp = this.bits_per_pixel;
        const bypp = this.bytes_per_pixel;
        let i_px = 0;
        const num_px = this.size[0] * this.size[1];
        if (bipp === 1) {
            const res = new this.constructor({
                size: this.size,
                bits_per_pixel: 24
            })
            let i_byte = 0;
            const num_bytes = this.ta.length;
            while (i_byte < num_bytes) {
                for (var b = 0; b < 8; b++) {
                    const color = this.get_pixel_by_idx_1bipp(i_px) === 1 ? new Uint8ClampedArray([255, 255, 255]) : new Uint8ClampedArray([0, 0, 0]);
                    res.set_pixel_by_idx_24bipp(i_px++, color);
                }
                i_byte++;
            }
            return res;
        } else if (bipp === 8) {
            const res = new this.constructor({
                size: this.size,
                bits_per_pixel: 24
            });
            const ta_res = res.ta;
            const ta = this.ta, l = ta.length;
            let pos_w = 0, c = 0;
            for (c = 0; c < l; c++) {
                ta_res[pos_w++] = ta[c];
                ta_res[pos_w++] = ta[c];
                ta_res[pos_w++] = ta[c];
            }
            return res;
        } else if (bipp === 24) {
            return this.clone();
        } else if (bipp === 32) {
            const res = new this.constructor({
                size: this.size,
                bits_per_pixel: 24
            })
            console.trace();
            throw 'NYI';
            while (i_px < num_px) {
                const col_32 = this.get_pixel_by_idx_32bipp(i_px)
                i_px += bypp;
            }
            return res;
        }
    }
    toString() {
        /*
        size: Uint32Array [ 1024, 576 ],
        bits_per_pixel: 32,
        bytes_per_pixel: 4,
        bytes_per_row: 4096 }
        */
        return JSON.stringify({
            buffer: 'Uint8ClampedArray length ' + this.buffer.length,
            size: this.size,
            bits_per_pixel: this.bits_per_pixel,
            bytes_per_pixel: this.bytes_per_pixel,
            bytes_per_row: this.bytes_per_row
        });
    }
    /*
    [inspect]() {
        return 'Pixel_Buffer_Core ' + this.toString();
    }
    */
    color_whole(color) {
        if (this.bytes_per_pixel === 1) {
            const ta_32_scratch = new Uint32Array(12);
            ta_32_scratch[0] = this.size[0] * this.size[1];
            const buf = this.buffer;
            let i;
            for (i = 0; i < ta_32_scratch[0]; i++) {
                buf[i] = color;
            }
        } else if (this.bytes_per_pixel === 3) {
            const ta_32_scratch = new Uint32Array(12);
            ta_32_scratch[0] = this.size[0] * this.size[1] * 3;
            const buf = this.buffer;
            let i, c = 0;
            for (i = 0; i < ta_32_scratch[0]; i++) {
                buf[c++] = color[0];
                buf[c++] = color[1];
                buf[c++] = color[2];
            }
        } else if (this.bytes_per_pixel === 4) {
            const ta_32_scratch = new Uint32Array(12);
            ta_32_scratch[0] = this.size[0] * this.size[1] * 4;
            const buf = this.buffer;
            let i, c = 0;
            for (i = 0; i < ta_32_scratch[0]; i++) {
                buf[c++] = color[0];
                buf[c++] = color[1];
                buf[c++] = color[2];
                buf[c++] = color[3];
            }
        } else {
            throw 'Unsupported this.bytes_per_pixel: ' + this.bytes_per_pixel;
        }
        return this;
    }
    crop(size) {
        let new_size = new Uint16Array([this.size[0] - size * 2, this.size[1] - size * 2]);
        let res = new this.constructor({
            bytes_per_pixel: this.bytes_per_pixel,
            size: new_size
        });
        if (this.pos) {
            res.pos = new Int16Array([this.pos[0] - size, this.pos[1] - size])
        }
        this.each_pixel_ta((pos, color) => {
            const new_pos = new Int16Array([pos[0] - size, pos[1] - size]);
            if (new_pos[0] >= 0 && new_pos[0] < new_size[0] && new_pos[1] >= 0 && new_pos[1] < new_size[1]) {
                res.set_pixel_ta(new_pos, color);
            }
        });
        return res;
    }
    uncrop(size, color) {
        let res = new this.constructor({
            bytes_per_pixel: this.bytes_per_pixel,
            size: new Uint16Array([this.size[0] + size * 2, this.size[1] + size * 2])
        })
        if (this.pos) res.pos = this.pos;
        if (this.pos) {
        }
        res.color_whole(color);
        console.log('size', size);
        this.each_pixel_ta((pos, color) => {
            res.set_pixel_ta(new Uint16Array([pos[0] + size, pos[1] + size]), color);
        })
        return res;
    }
    color_rect(bounds, color) {
        console.trace();
        throw 'NYI';
    }
    each_pixel_byte_index(cb) {
        const {bipp} = this;
        let ctu = true;
        const stop = () => ctu = false;
        if (bipp === 8) {
            const buf = this.buffer, l = buf.length, bpp = this.bytes_per_pixel;
            for (let c = 0; ctu && c < l; c += bpp) {
                cb(c, stop);
            }
        } else if (bipp === 24) {
            const buf = this.buffer, l = buf.length, bpp = this.bytes_per_pixel;
            for (let c = 0; ctu && c < l; c += bpp) {
                cb(c, stop);
            }
        } else if (bipp === 32) {
            const buf = this.buffer, l = buf.length, bpp = this.bytes_per_pixel;
            for (let c = 0; ctu && c < l; c += bpp) {
                cb(c, stop);
            }
        } else {
            console.trace();
            throw 'NYI';
        }
    }
    /*
    each_pixel_pos(cb) {
        const b = this.size;
        const pos = new Int16Array(2);
        for (pos[1] = 0; pos[1] < b[1]; pos[1]++) {
            for (pos[0] = 0; pos[0] < b[0]; pos[0]++) {
                cb(pos);
            }
        }
    }
    */
    each_ta_24bipp(ta_pos, ta_px_value, ta_info, callback) {
        const bipp = this.bipp;
        if (bipp === 24) {
            if (ta_pos instanceof Int16Array || ta_pos instanceof Int32Array && ta_pos.length >= 2) {
                if (ta_px_value instanceof Uint8ClampedArray && ta_px_value.length >= 3) {
                    if (ta_info instanceof Uint32Array && ta_info.length >= 4) {
                        const ta = this.ta;
                        ta_info[0] = this.size[0];
                        ta_info[1] = this.size[1];
                        ta_info[2] = 0;
                        ta_info[3] = 24; // bipp;
                        const update = () => {
                            ta[ta_info[2] * 3] = ta_px_value[0];
                            ta[ta_info[2] * 3 + 1] = ta_px_value[1];
                            ta[ta_info[2] * 3 + 2] = ta_px_value[2];
                        }
                        for (ta_pos[1] = 0; ta_pos[1] < ta_info[1]; ta_pos[1]++) {
                            for (ta_pos[0] = 0; ta_pos[0] < ta_info[0]; ta_pos[0]++) {
                                ta_px_value[0] = ta[ta_info[2] * 3];
                                ta_px_value[1] = ta[ta_info[2] * 3 + 1];
                                ta_px_value[2] = ta[ta_info[2] * 3 + 2];
                                callback(update);
                                ta_info[2]++;
                            }
                        }
                    }
                }
            }
        } else {
            throw 'each_ta_24bipp error: bipp must be 24, bipp: ' + bipp;
        }
    }
    each_ta_1bipp(ta_pos, ta_px_value, ta_info, callback) {
        const bipp = this.bipp;
        if (bipp === 1) {
            const [w, h] = this.size;
            for (ta_pos[1] = 0; ta_pos[1] < h; ta_pos[1]++) {
                for (ta_pos[0] = 0; ta_pos[0] < w; ta_pos[0]++) {
                    const px = this.get_pixel_1bipp(ta_pos);
                    ta_px_value[0] = px;
                    callback(px, ta_pos);
                }
            }
        } else {
            throw 'each_ta_1bipp error: bipp must be 1, bipp: ' + bipp;
        }
    }
    each_px_on_1bipp(ta_pos, ta_px_value, ta_info, callback) {
        const bipp = this.bipp;
        if (bipp === 1) {
            const [w, h] = this.size;
            for (ta_pos[1] = 0; ta_pos[1] < h; ta_pos[1]++) {
                for (ta_pos[0] = 0; ta_pos[0] < w; ta_pos[0]++) {
                    if (this.get_pixel_1bipp(ta_pos) === 1 | 0) {
                        callback(1 | 0, ta_pos);
                    }
                }
            }
        } else {
            throw 'each_ta_1bipp error: bipp must be 1, bipp: ' + bipp;
        }
    }
    each_px(ta_pos, ta_px_value, ta_info, callback) {
        const bipp = this.bipp;
        if (bipp === 1) {
            return this.each_ta_1bipp(ta_pos, ta_px_value, ta_info, callback);
        } else if (bipp === 8) {
            return this.each_ta_8bipp(ta_pos, ta_px_value, ta_info, callback);
        } else if (bipp === 24) {
            return this.each_ta_24bipp(ta_pos, ta_px_value, ta_info, callback);
        } else if (bipp === 32) {
            return this.each_ta_32bipp(ta_pos, ta_px_value, ta_info, callback);
        } else {
            console.trace();
            throw 'Unsupported bipp: ' + bipp;
        }
    }
    paint_pixel_list(pixel_pos_list, color) {
        pixel_pos_list.each_pixel(pos => {
            this.set_pixel_ta(pos, color);
        });
    }
    'get_pixel_byte_bit_1bipp'(pos) {
        /*
        */
        const idx = pos[1] * this.size[0] + pos[0];
        const byte = idx >> 3;
        const bit = (idx & 0b111);
        return {byte, bit};
    }
    'get_pixel_byte_bit_BE_1bipp'(pos) {
        const idx = pos[1] * this.size[0] + pos[0];
        const byte = idx >> 3;
        const bit = (idx & 0b111);
        return {byte, bit};
    }
    set_pixel_on_1bipp_by_pixel_index(pixel_index) {
        this.ta[pixel_index >> 3] |= (128 >> (pixel_index & 0b111));
    }

    'set_pixel_on_1bipp_xy'(x, y) {
        const pixel_index = y * this.size[0] + x;
        this.ta[pixel_index >> 3] |= (128 >> (pixel_index & 0b111));
    }

    'set_pixel_on_1bipp'(pos) {
        const pixel_index = pos[1] * this.size[0] + pos[0];
        this.ta[pixel_index >> 3] |= (128 >> (pixel_index & 0b111));
    }
    set_pixel_off_1bipp_by_pixel_index(pixel_index) {
        this.ta[pixel_index >> 3] &= (~(128 >> (pixel_index & 0b111))) & 255;
    }
    'set_pixel_off_1bipp'(pos) {
        const pixel_idx = pos[1] * this.size[0] + pos[0];
        this.ta[pixel_idx >> 3] &= (~(128 >> (pixel_idx & 0b111))) & 255;
    }
    'set_pixel_1bipp'(pos, color) {
        const idx_bit = (pos[1] * this.size[0]) + pos[0];
        const byte = idx_bit >> 3;
        const bit = (idx_bit & 0b111);
        if (color === 1) {
            this.ta[byte] |= (128 >> bit);
        } else {
            this.ta[byte] &= (~(128 >> bit)) & 255;
        }
    }
    'set_pixel_8bipp'(pos, color) {
        const idx = pos[1] * this.size[0] + pos[0];
        this.ta[idx] = color;
    }
    'set_pixel_24bipp'(pos, color) {
        const idx = pos[1] * this.size[0] + pos[0];
        let byte = idx * 3;
        this.ta[byte++] = color[0];
        this.ta[byte++] = color[1];
        this.ta[byte] = color[2];
    }
    'set_pixel_32bipp'(pos, color) {
        const idx = pos[1] * this.size[0] + pos[0];
        let byte = idx * 4;
        this.ta[byte++] = color[0];
        this.ta[byte++] = color[1];
        this.ta[byte++] = color[2];
        this.ta[byte] = color[3];
    }
    'set_pixel_by_idx_8bipp'(idx, color) {
        const byte = idx;
        this.ta[byte] = color;
    }
    'set_pixel_by_idx_24bipp'(idx, color) {
        const byte = idx * 3;
        this.ta[byte] = color[0];
        this.ta[byte + 1] = color[1];
        this.ta[byte + 2] = color[2];
    }
    'set_pixel_by_idx_32bipp'(idx, color) {
        const byte = idx * 4;
        this.ta[byte] = color[0];
        this.ta[byte + 1] = color[1];
        this.ta[byte + 2] = color[2];
        this.ta[byte + 3] = color[3];
    }
    'set_pixel_by_idx'(idx, color) {
        const a = arguments;
        const l = a.length;
        const bipp = this.bipp;
        if (bipp === 1) {
            return this.set_pixel_by_idx_1bipp(a[0], a[1]);
        } else if (bipp === 8) {
            if (l === 2) {
                return(this.set_pixel_by_idx_8bipp(a[0], a[1]));
            }
        } else if (bipp === 24) {
            if (l === 2) {
                return(this.set_pixel_by_idx_24bipp(a[0], a[1]));
            }
        } else if (bipp === 32) {
            if (l === 2) {
                return(this.set_pixel_by_idx_32bipp(a[0], a[1]));
            }
        }
    }
    'set_pixel'(pos, color) {
        const a = arguments;
        const l = a.length;
        const bipp = this.bipp;
        if (bipp === 1) {
            return(this.set_pixel_1bipp(a[0], a[1]));
        } else if (bipp === 8) {
            if (l === 2) {
                return(this.set_pixel_8bipp(a[0], a[1]));
            }
        } else if (bipp === 24) {
            if (l === 2) {
                return(this.set_pixel_24bipp(a[0], a[1]));
            }
        } else if (bipp === 32) {
            if (l === 2) {
                return(this.set_pixel_32bipp(a[0], a[1]));
            }
        } else {
            console.trace();
            throw 'unsupported bipp: ' + bipp;
        }
    }
    'get_pixel_by_idx_1bipp'(idx) {
        /*
        const idx = pos[1] * this.size[0] + pos[0];
        const byte = idx >> 3;
        const bit = (idx & 0b111);
        */
        const byte = idx >> 3;
        const bit = (idx & 0b111);
        const pow = 128 >> bit;
        return ((this.ta[byte] & pow) === pow) ? 1 : 0;
    }
    'get_pixel_by_idx_8bipp'(idx) {
        const byte = idx;
        return this.ta[byte];
    }
    'get_pixel_by_idx_24bipp'(idx) {
        const byte = idx * 3;
        return this.ta.slice(byte, byte + 3);
    }
    'get_pixel_by_idx_32bipp'(idx) {
        const byte = idx * 4;
        return this.ta.slice(byte, byte + 4);
    }
    'get_pixel_by_idx'(idx) {
        const bipp = this.bits_per_pixel;
        if (bipp === 1) {
            return this.get_pixel_by_idx_1bipp(idx);
        } else if (bipp === 8) {
            return this.get_pixel_by_idx_8bipp(idx);
        } else if (bipp === 24) {
            return this.get_pixel_by_idx_24bipp(idx);
        } else if (bipp === 32) {
            return this.get_pixel_by_idx_32bipp(idx);
        } else {
            throw 'Unsupported bipp'
        }
    }
    'get_pixel_1bipp'(pos) {
        const idx = (pos[1] * this.size[0]) + pos[0];
        const byte = idx >> 3;
        return ((this.ta[byte] & 128 >> (idx & 0b111)) !== 0) ? 1 : 0;
    }
    'get_pixel_8bipp'(pos) {
        const idx = pos[1] * this.size[0] + pos[0];
        const byte = idx;
        return this.ta[byte];
    }
    'get_pixel_24bipp'(pos) {
        const idx = pos[1] * this.size[0] + pos[0];
        const byte = idx * 3;
        return this.ta.slice(byte, byte + 3);
    }
    'get_pixel_32bipp'(pos) {
        const idx = pos[1] * this.size[0] + pos[0];
        const byte = idx * 4;
        return this.ta.slice(byte, byte + 4);
    }
    'get_pixel'(pos) {
        const bipp = this.bits_per_pixel;
        if (bipp === 1) {
            return this.get_pixel_1bipp(pos);
        } else if (bipp === 8) {
            return this.get_pixel_8bipp(pos);
        } else if (bipp === 24) {
            return this.get_pixel_24bipp(pos);
        } else if (bipp === 32) {
            return this.get_pixel_32bipp(pos);
        } else {
            console.trace();
            throw 'bits per pixels error';
        }
    }
    get num_px() {
        return this.size[0] * this.size[1];
    }
    get split_rgb_channels() {
        const [bipp, bypp] = [this.bits_per_pixel, this.bytes_per_pixel];
        if (bipp === 24 || bipp === 32) {
            const res = [new this.constructor({
                bits_per_pixel: 8,
                size: this.size
            }), new this.constructor({
                bits_per_pixel: 8,
                size: this.size
            }), new this.constructor({
                bits_per_pixel: 8,
                size: this.size
            })]
            const [r, g, b] = res;
            let i_px = 0;
            const num_px = this.num_px;
            let i_byte = 0;
            const [ta_r, ta_g, ta_b] = [r.ta, g.ta, b.ta];
            const ta = this.ta;
            while (i_px < num_px) {
                ta_r[i_px] = ta[i_byte];
                ta_g[i_px] = ta[i_byte + 1];
                ta_b[i_px] = ta[i_byte + 2];
                i_px++;
                i_byte += bypp;
            }
            return res;
        } else {
            console.trace();
            throw 'NYI';
        }
    }
    process(fn) {
        let res = this.clone();
        return fn(this, res);
    }
    /*
    function typedArraysAreEqual(a, b) {
if (a.byteLength !== b.byteLength) return false;
return a.every((val, i) => val === b[i]);
}
    */
    equals(other_pixel_buffer) {
        let buf1 = this.ta;
        let buf2 = other_pixel_buffer.ta;
        const other_colorspace = other_pixel_buffer.ta_colorspace;
        const my_colorspace = other_pixel_buffer.ta_colorspace;
        if (my_colorspace.length === other_colorspace.length) {
            if(my_colorspace.every((val, i) => val === other_colorspace[i])) {
                if (buf1.length === buf2.length) {
                    return buf1.every((val, i) => val === buf2[i]);
                } else {
                }
            } else {
            }
        }
        return false;
    }
    copy_pixel_pos_list_region(pixel_pos_list, bg_color) {
        let bounds = pixel_pos_list.bounds;
        let size = new Uint16Array([bounds[2] - bounds[0] + 1, bounds[3] - bounds[1] + 1]);
        const res = new this.constructor({
            size: size,
            bytes_per_pixel: this.bytes_per_pixel
        });
        if (this.pos) res.pos = this.pos;
        if (bg_color) {
            res.color_whole(bg_color);
        }
        res.pos = new Int16Array([bounds[0], bounds[1]]);
        pixel_pos_list.each_pixel((pos) => {
            let color = this.get_pixel_ta(pos);
            const target_pos = new Int16Array([(pos[0] - bounds[0]), (pos[1] - bounds[1])]);
            res.set_pixel_ta(target_pos, color);
        });
        return res;
    }


    // Pixel_Buffer_Pair_Complex_Operation class possibly?
    //   Or just Operation.



    // get_pre_operation_alignment_info ....


    
    // And could define such a class which has got requirements / invarients to do with 



    // This is used when drawing filled polygons.

    'draw_1bipp_pixel_buffer_mask_1bipp'(pb_1bipp_mask, dest_pos, color) {




        // A direct iteration approach could work better.
        // Though (shifting and?) applying the correct boolean operations could work best.



        function draw_bitmap(target, target_width, source, source_width, source_height, target_x, target_y) {
            // Compute bytes per row using bitwise math
            const target_bytes_per_row = (target_width + 7) >> 3;
            const source_bytes_per_row = (source_width + 7) >> 3;
        
            // Iterate over each row of the source bitmap
            for (let row = 0; row < source_height; row++) {
                // Source row offset in bytes
                const source_row_start = row * source_bytes_per_row;
        
                // Target row offset in bytes
                const target_row_start = (target_y + row) * target_bytes_per_row;
        
                // Bit offset within the target byte
                const bit_offset = target_x & 7; // Faster alternative to target_x % 8
        
                // Start byte in the target where source will be drawn
                let target_byte_index = target_row_start + (target_x >> 3); // Divide target_x by 8 using bitwise shift
        
                // Iterate over source bytes for this row
                for (let col = 0; col < source_bytes_per_row; col++) {
                    const source_byte = source[source_row_start + col];
        
                    if (bit_offset === 0) {
                        // Direct copy if aligned with byte boundary
                        target[target_byte_index] |= source_byte;
                    } else {
                        // Handle unaligned case
                        const next_byte_index = target_byte_index + 1;
        
                        // Shift source byte into position
                        const shifted_byte = source_byte << bit_offset;
                        const carry_over = source_byte >> (8 - bit_offset);
        
                        // Merge with target
                        target[target_byte_index] |= shifted_byte;
                        if (next_byte_index < target.length) {
                            target[next_byte_index] |= carry_over;
                        }
                    }
        
                    target_byte_index++;
                }
            }
        }
        

        const chatgpto1_draw_bitmap_implementation = () => {
            draw_bitmap(this.ta, this.size[0], pb_1bipp_mask.ta, pb_1bipp_mask.size[0], pb_1bipp_mask.size[1], dest_pos[0], dest_pos[1]);
        }
        

        const arr_on_xspans_implementation = () => {

            // Getting it as an arr_rows_arr_x_on_spans representation using a class could help.
            //   Or the 'other representaion' type class.

            // May be able to have a faster internal algorithm for that.
            //   Maybe a typed array backed class? Maybe a typed array.

            const arr_rows_arr_on_xspans = pb_1bipp_mask.calculate_arr_rows_arr_x_on_spans_1bipp();
            const [width, height] = pb_1bipp_mask.size;

            const [dest_x, dest_y] = dest_pos;

            /*
            for (const row of arr_rows_arr_on_xspans) {

                for (const xonspan of row) {
                    xonspan[0] += dest_x;
                    xonspan[1] += dest_x;
                }
                
                //this.draw_horizontal_line_on_1bipp_inclusive(xonspan, y + dest_y);
            }
                */
            
            // Not sure the spans are inclusive...

            if (color === 1) {
                //let y = 0;
                //let [dest_x, dest_y] = dest_pos;
                for (let y = 0; y < height; y++) {
                    //const arr_row_xspans_on = arr_rows_arr_on_xspans[y];
                    const target_y = y + dest_y;
                    //if (arr_row_xspans_on.length > 0) {
                    for (const xonspan of arr_rows_arr_on_xspans[y]) {
                        xonspan[0] += dest_x;
                        xonspan[1] += dest_x;
                        this.draw_horizontal_line_on_1bipp_inclusive(xonspan, target_y);
                    }
                    //}
                }
            } else {
                //let y = 0;
                
                for (let y = 0; y < height; y++) {
                    //const arr_row_xspans_on = arr_rows_arr_on_xspans[y];
                    const target_y = y + dest_y;
                    //if (arr_row_xspans_on.length > 0) {
                    for (const xonspan of arr_rows_arr_on_xspans[y]) {
                        xonspan[0] += dest_x;
                        xonspan[1] += dest_x;
                        this.draw_horizontal_line_off_1bipp_inclusive(xonspan, target_y);
                    }
                    //}
                }
            }

            // Get it as an other representation of a 1 bipp image
            
        }

        

        // approach_selecting

        const approach_selecting = () => {

            //let can_do_aligned_64_bit = test_can_do_aligned_64_bit();

            //let can_do_aligned_64_bit = false;

            // And the realigned version...
            //   row width does have to be divisible by 64 on both source and dest
            //   can realign left?right? however many pixels.

            // Maybe create some kind of shifted / realigned pattern first?





            /*

            const res_64_bit_alignment_test = test_aligned_64bit();
            //console.log('res_64_bit_alignment_test', res_64_bit_alignment_test);
            if (res_64_bit_alignment_test.pass === true) {
                can_do_aligned_64_bit = true;
            }
                */

            // A test to see what is possible....


            //if (can_do_aligned_64_bit) {

                //console.log('doing aligned 64 bit assignement');
            //    return aligned_64_bit_implementation();

            //} else 
            {

                // But it will only work in some cases.
                //   May need to increase row lengths to make it possible.
                //     Both for the source and the dest.





                const can_do_bit_realigned_64_bit = test_can_do_bit_realigned_64_bit();
                if (can_do_bit_realigned_64_bit) {

                    // So do that realigned 64 bit operation...
                    //   Need to work out how many bytes and in which direction things will need to shift.
                    //     What is the pixel index?
                    //     What is the byte index?
                    //       What is the remainder?

                    return arr_on_xspans_implementation();

                    //return bit_realigned_64_bit_implementation();
                    //console.log('should do byte realigned 64 bit assignment');
                } else {
                    return arr_on_xspans_implementation();
                }
                
            }

            // 


        }
        //return approach_selecting();

        //return arr_on_xspans_implementation();

        return chatgpto1_draw_bitmap_implementation();
    }

    'draw_1bipp_pixel_buffer_mask'(pb_1bipp_mask, dest_pos, color) {

        const {bipp} = this;

        if (bipp === 1) {
            return this.draw_1bipp_pixel_buffer_mask_1bipp(pb_1bipp_mask, dest_pos, color);
        } else {
            const arr_on_xspans_implementation = () => {

                // Getting it as an arr_rows_arr_x_on_spans representation using a class could help.
                //   Or the 'other representaion' type class.
    
    
                const arr_rows_arr_on_xspans = pb_1bipp_mask.calculate_arr_rows_arr_x_on_spans_1bipp();
                const [width, height] = pb_1bipp_mask.size;
    
                let y = 0;
                let [dest_x, dest_y] = dest_pos;
                for (y = 0; y < height; y++) {
                    const arr_row_xspans_on = arr_rows_arr_on_xspans[y];
                    if (arr_row_xspans_on.length > 0) {
                        for (const xonspan of arr_row_xspans_on) {
                            xonspan[0] += dest_x;
                            xonspan[1] += dest_x;
                            this.draw_horizontal_line(xonspan, y + dest_y, color);
                        }
                    }
                }
    
                
                
            }
            return arr_on_xspans_implementation();
        }
        
    }
    'blank_copy'() {
        var res = new this.constructor({
            'size': this.size,
            'bits_per_pixel': this.bits_per_pixel
        });
        res.buffer.fill(0);
        if (this.pos) res.pos = this.pos;
        return res;
    }
    'clone'() {
        var res = new this.constructor({
            'size': this.size,
            'bits_per_pixel': this.bits_per_pixel,
            'buffer': new this.buffer.constructor(this.buffer)
        });
        if (this.pos) res.pos = this.pos;
        return res;
    }
    'add_alpha_channel'() {
        console.log('add_alpha_channel this.bytes_per_pixel', this.bytes_per_pixel);
        if (this.bytes_per_pixel === 3) {
            var res = new this.constructor({
                'size': this.size,
                'bytes_per_pixel': 4
            });
            if (this.pos) res.pos = this.pos;
            /*
            this.each_pixel((x, y, r, g, b) => {
                res.set_pixel(x, y, r, g, b, 255);
            });
            */
            const buf = this.buffer,
                res_buf = res.buffer;
            const px_count = this.size[0] * this.size[1];
            let i = 0,
                ir = 0;
            for (let p = 0; p < px_count; p++) {
                res_buf[ir++] = buf[i++];
                res_buf[ir++] = buf[i++];
                res_buf[ir++] = buf[i++];
                res_buf[ir++] = 255;
            }
            return res;
        }
        if (this.bytes_per_pixel === 4) {
            return this;
        }
    }
    'to_8bit_greyscale'() {
        if (this.bytes_per_pixel === 1) {
            return this;
        } else if (this.bytes_per_pixel === 3) {
            const res = new this.constructor({
                'size': this.size,
                'bits_per_pixel': 8
            });
            if (this.pos) res.pos = this.pos;
            const bres = res.buffer;
            let i = 0;
            this.each_pixel((pos, color) => {
                bres[i++] = Math.round((color[0] + color[1] + color[2]) / 3);
            });
            return res;
        } else if (this.bytes_per_pixel === 4) {
            const res = new this.constructor({
                'size': this.size,
                'bits_per_pixel': 8
            });
            if (this.pos) res.pos = this.pos;
            const bres = res.buffer;
            let i = 0;
            this.each_pixel((pos, color) => {
                bres[i++] = Math.round((color[0] + color[1] + color[2]) / 3);
            });
            return res;
        }
    }
    'to_32bit_rgba'() {
        var res = new this.constructor({
            'size': this.size,
            'bits_per_pixel': 32
        });
        if (this.pos) res.pos = this.pos;
        const bres = res.buffer;
        if (this.bytes_per_pixel === 1) {
            let i = 0, new_v;
            this.each_pixel((pos, v) => {
                bres[i++] = v;
                bres[i++] = v;
                bres[i++] = v;
                bres[i++] = 255;
            });
        } else {
            console.trace();
            throw 'NYI';
        }
        return res;
    }
    '__invert_greyscale_self'() {
        const bres = this.buffer;
        let i = 0;
        this.each_pixel((x, y, v) => {
            bres[i++] = 255 - v;
        });
        return this;
    }
    '__invert_greyscale'() {
        let res = new this.constructor({
            'size': this.size,
            'bits_per_pixel': 8
        });
        if (this.pos) res.pos = this.pos;
        const bres = res.buffer;
        let i = 0;
        this.each_pixel((x, y, v) => {
            bres[i++] = 255 - v;
        });
        return res;
    }
    
    draw_rect(pos_corner, pos_other_corner, color) {
        /*
        const paint_bounds = new Int16Array([20, 300, 180, 320]);
        const paint_color = new Uint8ClampedArray([255, 0, 0]);
        ta_math.fill_solid_rect_by_bounds(pb_dest.ta, pb_dest.bytes_per_row, paint_bounds, 24, paint_color);
        */
        const l = Math.min(pos_corner[0], pos_other_corner[0]);
        const t = Math.min(pos_corner[1], pos_other_corner[1]);
        const r = Math.max(pos_corner[0], pos_other_corner[0]);
        const b = Math.max(pos_corner[1], pos_other_corner[1]);
        //const paint_bounds = new Int16Array([20, 300, 180, 320]);
        //const paint_color = new Uint8ClampedArray([255, 0, 0]);
        const xspan = [l, r];
        for (let y = t; y <= b; y++) {
            this.draw_horizontal_line(xspan, y, color);
        }
    }
    * 'iterate_arr_row_x_on_spans_1bipp'(y) {
    }
    get xspans() {
    }
}
module.exports = Pixel_Buffer_Core;
if (require.main === module) {
    const lg = console.log;
    (async() => {
        const run_examples = async() => {
            lg('Begin run examples');
            const examples = [
                async() => {
                    lg('Begin example 0');
                    const pb = new Pixel_Buffer_Core({
                        bits_per_pixel: 1,
                        size: [8, 8]
                    });
                    const ta_pos = new Int16Array(2);
                    ta_pos[0] = 3;
                    ta_pos[1] = 3;
                    pb.set_pixel(ta_pos, 1);
                    lg('End example 0');
                    return pb;
                }
            ]
            const l = examples.length;
            for (var c = 0; c < l; c++) {
                const res_eg = await examples[c]();
                console.log('res_eg ' + c + ':', res_eg);
            };
            lg('End run examples');
        }
        await run_examples();
    })();
}

},{"./Typed_Array_Binary_Read_Write":12,"./pixel-buffer-2-core-reference-implementations":20,"./pixel-buffer-painter":27,"./pixel-pos-list":29,"./ta-math":38,"lang-mini":47,"obext":382}],22:[function(require,module,exports){


const lang = require('lang-mini');

const {
    each,
    fp,
    tof,
    get_a_sig,
    are_equal,
    tf
} = lang;

//const Pixel_Pos_List = require('./pixel-pos-list');

const oext = require('obext');

const {ro, prop} = oext;

const Pixel_Buffer_Core = require('./pixel-buffer-3-core');

class Pixel_Buffer_Advanced_TypedArray_Properties extends Pixel_Buffer_Core {

    constructor(...a) {
        super(...a);


        let ta_scratch;
        let ta_pos_scratch;        // Int16Array(2)
        let ta_pos_iterator;        // Int16Array(2)
        let ta_move_vector;
        let ta_bounds;
        let ta_24bit_color;
        let ta_32bit_color;
        //let ta_rgba;
        let ta_row_scratch;

        let ta_bounds_scratch;     // Int16Array(4);
        let ta_bounds2_scratch;    // Int16Array(4);
        let ta_bounds3_scratch;    // Int16Array(4);
        let ta_bounds4_scratch;    // Int16Array(4);
        let ta_size_scratch;       // Uint16Array(2);
        let ta_size2_scratch;       // Uint16Array(2);
        let ta_pointers_scratch;
        let ta_pointers2_scratch;
        let ta_pointerpair_scratch;
        let ta_offsets_scratch;
        let ta_offsets_info_scratch; 


        const setup_ta_ro_props = () => {


            // See about using 'scratch' and other temporary tas.



            ro(this, 'ta_scratch', () => {
                if (!ta_scratch) {
                    ta_scratch = new this.ta.constructor(this.ta);
                } else {
    
                    // If it's not already an instance of the constructor of this.ta?
    
    
    
                    // check the size...? the types as well?
                    if (ta_scratch.length !== this.ta.length) {
                        ta_scratch = new this.ta.constructor(this.ta);
                    } else {
                        const l = this.ta.length;
                        // Could use faster copy?
                        //  Is typed array copy that fast compared to assignment operators?
                        for (c = 0; c < l; c++) {
                            ta_scratch[c] = this.ta[c];
                        }
                    }
                }
            });
    
    
            // ta_row_scratch
            //  a typed array sized to hold pixel data for a single row.
    
            // (this.bypr)
    
            ro(this, 'ta_row_scratch', () => {
                if (!ta_row_scratch) {
                    ta_row_scratch = new Uint8ClampedArray(this.bypr);
                } else {
                    if (ta_row_scratch.length !== this.bypr) {
                        ta_row_scratch = new Uint8ClampedArray(this.bypr);
                    }
                    return ta_row_scratch;
                }
            });
            
            ro(this, 'ta_pos_scratch', () => {
                if (!ta_pos_scratch) {
                    ta_pos_scratch = new Int16Array(2);
                }
                return ta_pos_scratch;
            });

            // and a 2nd pos scratch ta?
    
            ro(this, 'ta_pos_iterator', () => {
                if (!ta_pos_iterator) {
                    ta_pos_iterator = new Int16Array(2);
                }
                return ta_pos_iterator;
            });
    
    
            // ta_source_to_self_translate_vector ???
            //  more properties could be stored and accessed in this form. tas particularly good for simple vectors.
    
            // maybe make some kind of optimized string indexed ta.
            //  look up values to consts, use them...?
            //  or have const declarations of the numbers, use them? May compile best. Macros for consts???
    
    
    
            // ta_move_vector

            // Maybe all this is advanced/enhanced rather than core.
            // Pixel_Buffer_Advanced_Typed_Array_Properties
            //  So the code does not need to be in the core.


            ro(this, 'ta_move_vector', () => {
                if (!ta_move_vector) {
                    ta_move_vector = new Int16Array(2);
                }
                return ta_move_vector;
            });
            ro(this, 'ta_bounds', () => {
                if (!ta_bounds) {
                    ta_bounds = new Int16Array(4);
                }
                return ta_bounds;
            });

            ro(this, 'ta_24bit_color', () => {
                if (!ta_24bit_color) {
                    ta_24bit_color = new Uint8ClampedArray(3);
                }
                return ta_24bit_color;
            });


            ro(this, 'ta_32bit_color', () => {
                if (!ta_32bit_color) {
                    ta_32bit_color = new Uint8ClampedArray(4);
                }
                return ta_32bit_color;
            });
    



            /*

            ro(this, 'ta_rgb', () => {
                if (!ta_rgb) {
                    ta_rgb = new Uint8ClampedArray(3);
                }
                return ta_rgb;
            });
            ro(this, 'ta_rgb2', () => {
                if (!ta_rgb2) {
                    ta_rgb2 = new Uint8ClampedArray(3);
                }
                return ta_rgb2;
            });
            */


            ro(this, 'ta_bounds_scratch', () => {
                if (!ta_bounds_scratch) {
                    ta_bounds_scratch = new Int16Array(4);
                }
                return ta_bounds_scratch;
            });
            ro(this, 'ta_bounds2_scratch', () => {
                if (!ta_bounds2_scratch) {
                    ta_bounds2_scratch = new Int16Array(4);
                }
                return ta_bounds2_scratch;
            });
            ro(this, 'ta_bounds3_scratch', () => {
                if (!ta_bounds3_scratch) {
                    ta_bounds3_scratch = new Int16Array(4);
                }
                return ta_bounds3_scratch;
            });
            ro(this, 'ta_bounds4_scratch', () => {
                if (!ta_bounds4_scratch) {
                    ta_bounds4_scratch = new Int16Array(4);
                }
                return ta_bounds4_scratch;
            });
            ro(this, 'ta_size_scratch', () => {
                if (!ta_size_scratch) {
                    ta_size_scratch = new Uint16Array(2);
                }
                return ta_size_scratch;
            });
            ro(this, 'ta_size2_scratch', () => {
                if (!ta_size2_scratch) {
                    ta_size2_scratch = new Uint16Array(2);
                }
                return ta_size2_scratch;
            });
            ro(this, 'ta_pointers_scratch', () => {
                if (!ta_pointers_scratch) {
                    // Only allow 2 pointers? by default?
                    ta_pointers_scratch = new Uint32Array(4);
                }
                return ta_pointers_scratch;
            });
            ro(this, 'ta_pointers2_scratch', () => {
                if (!ta_pointers2_scratch) {
                    // Only allow 2 pointers? by default?
                    ta_pointers2_scratch = new Uint32Array(4);
                }
                return ta_pointers2_scratch;
            });
            ro(this, 'ta_pointerpair_scratch', () => {
                if (!ta_pointerpair_scratch) {
                    // Only allow 2 pointers? by default?
                    ta_pointerpair_scratch = new Uint32Array(2);
                }
                return ta_pointerpair_scratch;
            });
            ro(this, 'ta_offsets_scratch', () => {
                if (!ta_offsets_scratch) {
                    // Only allow 2 pointers? by default?
                    ta_offsets_scratch = new Int32Array(4);
                }
                return ta_offsets_scratch;
            });
            ro(this, 'ta_offsets_info_scratch', () => {
                if (!ta_offsets_info_scratch) {
                    // Only allow 2 pointers? by default?
                    ta_offsets_info_scratch = new Int32Array(8);
                }
                return ta_offsets_info_scratch;
            });


        }
        setup_ta_ro_props();


        const ta_colorspace = new Int16Array(6);

        // Seems more like an advanced typed array property.
        

        Object.defineProperty(this, 'ta_colorspace', {
            // Using shorthand method names (ES2015 feature).
            // This is equivalent to:
            // get: function() { return bValue; },
            // set: function(newValue) { bValue = newValue; },
            get() {
                // Defensive: handle undefined ta_bpp, fallback to bits_per_pixel or bytes_per_pixel
                ta_colorspace[0] = this.size[0];
                ta_colorspace[1] = this.size[1];
                let bpp = 0;
                if (this.ta_bpp && typeof this.ta_bpp[0] === 'number') {
                    bpp = this.ta_bpp[0];
                } else if (typeof this.bits_per_pixel === 'number') {
                    bpp = this.bits_per_pixel;
                } else if (typeof this.bytes_per_pixel === 'number') {
                    bpp = this.bytes_per_pixel * 8;
                }
                ta_colorspace[2] = bpp % 8 === 0 ? bpp / 8 : 0;
                ta_colorspace[3] = ta_colorspace[2] * ta_colorspace[0];
                ta_colorspace[4] = bpp;
                ta_colorspace[5] = ta_colorspace[4] * ta_colorspace[0];
                return ta_colorspace;
            },
            enumerable: true,
            configurable: false
        });

    }

}


module.exports = Pixel_Buffer_Advanced_TypedArray_Properties;
},{"./pixel-buffer-3-core":21,"lang-mini":47,"obext":382}],23:[function(require,module,exports){
//const Pixel_Buffer_Core = require('./pixel-buffer-core');

const Pixel_Buffer_Advanced_TypedArray_Properties = require('./pixel-buffer-4-advanced-typedarray-properties');
const kernels = require('./convolution-kernels/kernels');

class Pixel_Buffer_Idiomatic_Enh extends Pixel_Buffer_Advanced_TypedArray_Properties {
    constructor(...a) {
        super(...a);
    }

    each_pixel_pos(callback) {
        const {ta_pos_scratch, size} = this;
        let ctu = true;
        const stop = () => {
            ctu = false;
        }

        for (ta_pos_scratch[1] = 0; ctu === true && ta_pos_scratch[1] < size[1]; ta_pos_scratch[1]++) {
            for (ta_pos_scratch[0] = 0; ctu === true && ta_pos_scratch[0] < size[0]; ta_pos_scratch[0]++) {
                callback(ta_pos_scratch, stop);
            }
        }


    }

    count_colors() {
        const map_colors = {};
        let res = 0;
        this.each_pixel_ta((pos, color) => {
            const colstr = color.toString();
            if (!map_colors[colstr]) {
                map_colors[colstr] = true;
                res++;
            }
        });
        return res;
    }

    

    blur(size = 3, sigma = 2) {
        let kernel = kernels.get_gauss(size, sigma);
        return this.apply_square_convolution(kernel);
    }



    count_pixels_with_color(color) {
        let res = 0;
        // could find out here what format the color is...

        console.log('idiomatic count_pixels_with_color');

        const {bipp} = this;


        if (bipp <= 8) {
            this.each_pixel((pos, pixel_color) => {
                //console.log('pixel_color', pixel_color);
                //console.log('color', color);

                if (pixel_color === color) res++;
                //console.trace();
                //throw 'NYI';
            });
        } else if (bipp === 24) {
            this.each_pixel((pos, pixel_color) => {
                //console.log('pixel_color', pixel_color);
                //console.log('color', color);

                if (pixel_color[0] === color[0] && pixel_color[1] === color[1] && pixel_color[2] === color[2]) {
                    res++;
                }
    
    
    
                //console.trace();
                //throw 'NYI';
            });
        } else if (bipp === 32) {
            this.each_pixel((pos, pixel_color) => {
                //console.log('pixel_color', pixel_color);
                //console.log('color', color);

                if (pixel_color[0] === color[0] && pixel_color[1] === color[1] && pixel_color[2] === color[2] && pixel_color[3] === color[3]) {
                    res++;
                }
    
    
    
                //console.trace();
                //throw 'NYI';
            });
        } else {
            console.trace();
            throw 'NYI';
        }

        //console.log('res', res);

        return res;

        
    }
}

module.exports = Pixel_Buffer_Idiomatic_Enh;
},{"./convolution-kernels/kernels":13,"./pixel-buffer-4-advanced-typedarray-properties":22}],24:[function(require,module,exports){
const Pixel_Buffer_Idiomatic_Enh = require('./pixel-buffer-5-idiomatic-enh');

const Pixel_Pos_List = require('./pixel-pos-list');
const get_idx_movement_vectors = (f32a_convolution, bpp, bpr) => {
    const c_length = f32a_convolution.length;
    const dimension_size = Math.sqrt(c_length);
    const padding = (dimension_size - 1) / 2;
    const movement_vectors = new Int8Array(c_length * 2);
    let x, y, pos = 0;
    const idx_movement_vectors = new Int16Array(c_length);
    for (y = -1 * padding; y <= padding; y++) {
        for (x = -1 * padding; x <= padding; x++) {
            movement_vectors[pos++] = x;
            movement_vectors[pos++] = y;
        }
    }
    pos = 0;
    let ii, i;
    for (i = 0; i < c_length; i++) {
        x = movement_vectors[pos++];
        y = movement_vectors[pos++];
        idx_movement_vectors[i] = x * bpp + y * bpr;
    }
    return idx_movement_vectors;
}
const get_points_bounding_box = (points) => {
    let min_x = Number.POSITIVE_INFINITY;
    let min_y = Number.POSITIVE_INFINITY;
    let max_x = Number.NEGATIVE_INFINITY;
    let max_y = Number.NEGATIVE_INFINITY;
    for (const [x, y] of points) {
        if (x < min_x) min_x = x;
        if (x > max_x) max_x = x;
        if (y < min_y) min_y = y;
        if (y > max_y) max_y = y;
    }
    return [
        [min_x, min_y],
        [max_x, max_y]
    ];
}
class Pixel_Buffer_Perf_Focus_Enh extends Pixel_Buffer_Idiomatic_Enh {
    constructor(spec) {
        super(spec);
    }
    get ta_is_64bit_divisible() {
        return (this.ta.length & 63) === 0;
    }
    get ta_is_32bit_divisible() {
        return (this.ta.length & 31) === 0;
    }
    get ta64() {
        if (this._ta64) {
            return this._ta64;
        } else {
        }
        if (this.ta_is_64bit_divisible) {
            if (this.ta.byteOffset % 8 === 0) {
                this._ta64 = new BigUint64Array(this.ta.buffer, this.ta.byteOffset, this.ta.byteLength / 8);
                return this._ta64;
            } else {
                console.error("The byte offset is not aligned to 8 bytes.");
            }
        } else  {
            return false;
        }
    }
    get is_32bit_divisible_image() {
        return (this.ta.length & 31) === 0;
    }
    get is_32_divisible_bits_per_row() {
        return (this.bits_per_row & 31) === 0;
    }
    get number_of_32bit_segments_per_32bit_divisible_row() {
        return this.bits_per_row >> 5;
    }
    get is_64bit_divisible_image() {
        return (this.ta.length & 63) === 0;
    }
    get is_64_divisible_bits_per_row() {
        return (this.bits_per_row & 63) === 0;
    }
    get number_of_64bit_segments_per_64bit_divisible_row() {
        return this.bits_per_row >> 6;
    }
    get bits_per_image_1bipp() {
        return this.size[0] * this.size[1];
    }
    get number_of_64bit_segments_per_64bit_divisible_image() {
        return this.bits_per_image_1bipp >> 6;
    }
    iterate_all_ui32_locations_1bipp(cb) {
        const ui32a_px_range = new Uint32Array(4);
        if (this.ta_is_32bit_divisible) {
            if (this.is_32_divisible_bits_per_row) {
                const number_of_32bit_segments_per_32bit_divisible_row = this.number_of_32bit_segments_per_32bit_divisible_row;
                if (number_of_32bit_segments_per_32bit_divisible_row === 1) {
                    const height = this.size[1];
                    const first_x = 0, last_x = 31;
                    ui32a_px_range[0] = first_x;
                    ui32a_px_range[2] = last_x;
                    let y = 0;
                    for (let i = 0; i < height; i++) {
                        ui32a_px_range[1] = y;
                        ui32a_px_range[3] = y;
                        cb(ui32a_px_range);
                        y++;
                    }
                } else if (number_of_32bit_segments_per_32bit_divisible_row === 2) {
                    const height = this.size[1];
                    const number_of_32bit_segments = height * number_of_32bit_segments_per_32bit_divisible_row;
                    let even = true;
                    let y = 0;
                    let first_x = 0, last_x = 63;
                    for (let i = 0; i < number_of_32bit_segments; i++) {
                        ui32a_px_range[0] = first_x;
                        ui32a_px_range[1] = y;
                        ui32a_px_range[2] = last_x;
                        ui32a_px_range[3] = y;
                        cb(ui32a_px_range);
                        if (!even) {
                            y++;
                            first_x = 0; last_x = 31;
                        } else {
                            first_x = 32; last_x = 63;
                        }
                        even = !even;
                    }
                } else {
                    const height = this.size[1];
                    const number_of_32bit_segments = height * number_of_32bit_segments_per_32bit_divisible_row;
                    let y = 0;
                    let first_x = 0, last_x = 31;
                    let i_row_segment = 0;
                    for (let i = 0; i < number_of_32bit_segments; i++) {
                        ui32a_px_range[0] = first_x;
                        ui32a_px_range[1] = y;
                        ui32a_px_range[2] = last_x;
                        ui32a_px_range[3] = y;
                        cb(ui32a_px_range);
                        i_row_segment++;
                        if (i_row_segment < number_of_32bit_segments_per_32bit_divisible_row) {
                            first_x += 32;
                            last_x += 32;
                        } else {
                            i_row_segment = 0;
                            y++;
                            first_x = 0; last_x = 31;
                        }
                    }
                }
            } else {
            }
        } else {
        }
    }
    iterate_all_ui32_locations_values_prev_values_prev_shifted_values_toggle_locations_1bipp(cb) {
        const ui32a_res = new Uint32Array(12);
        if (this.ta_is_32bit_divisible) {
            const {ta} = this;
            const dv = new DataView(ta.buffer, ta.byteOffset, ta.byteLength);
            if (this.is_32_divisible_bits_per_row) {
                const number_of_32bit_segments_per_32bit_divisible_row = this.number_of_32bit_segments_per_32bit_divisible_row;
                if (number_of_32bit_segments_per_32bit_divisible_row === 1) {
                    const height = this.size[1];
                    const first_x = 0, last_x = 31;
                    ui32a_res[0] = first_x;
                    ui32a_res[2] = last_x;
                    let y = 0;
                    let b = 0;
                    for (let i = 0; i < height; i++) {
                        ui32a_res[1] = y;
                        ui32a_res[3] = y;
                        const ui32_value = dv.getUint32(b);
                        ui32a_res[5] = ui32_value;
                        cb(ui32a_res);
                        y++;
                        b+=4;
                    }
                } else if (number_of_32bit_segments_per_32bit_divisible_row === 2) {
                    const height = this.size[1];
                    const number_of_32bit_segments = height * number_of_32bit_segments_per_32bit_divisible_row;
                    let even = true;
                    let y = 0;
                    let b = 0;
                    let first_x = 0, last_x = 63;
                    let ui32_prev_value = 0;
                    for (let i = 0; i < number_of_32bit_segments; i++) {
                        ui32a_res[0] = first_x;
                        ui32a_res[1] = y;
                        ui32a_res[2] = last_x;
                        ui32a_res[3] = y;
                        const ui32_value = dv.getUint32(b);
                        ui32a_res[4] = ui32_prev_value;
                        ui32a_res[5] = ui32_value;
                        cb(ui32a_res);
                        if (!even) {
                            y++;
                            first_x = 0; last_x = 31;
                        } else {
                            first_x = 32; last_x = 63;
                        }
                        even = !even;
                        b+=4;
                        ui32_prev_value = ui32_value;
                    }
                } else {
                    const height = this.size[1];
                    const number_of_32bit_segments = height * number_of_32bit_segments_per_32bit_divisible_row;
                    let y = 0;
                    let first_x = 0, last_x = 31;
                    let i_row_segment = 0;
                    let b = 0;
                    let ui32_prev_value = 0;
                    for (let i = 0; i < number_of_32bit_segments; i++) {
                        ui32a_res[0] = first_x;
                        ui32a_res[1] = y;
                        ui32a_res[2] = last_x;
                        ui32a_res[3] = y;
                        const ui32_value = dv.getUint32(b);
                        ui32a_res[4] = ui32_prev_value;
                        ui32a_res[5] = ui32_value;
                        if (first_x === 0) {
                            ui32a_res[6] = 0;
                        } else {
                            ui32a_res[6] = ui32_prev_value << 31;
                        }
                        ui32a_res[7] = ui32_value >>> 1;
                        ui32a_res[8] = ui32a_res[6] | ui32a_res[7];
                        ui32a_res[9] = ui32_value ^ ui32a_res[8];
                        cb(ui32a_res);
                        i_row_segment++;
                        if (i_row_segment < number_of_32bit_segments_per_32bit_divisible_row) {
                            first_x += 32;
                            last_x += 32;
                        } else {
                            i_row_segment = 0;
                            y++;
                            first_x = 0; last_x = 31;
                        }
                        b+=4;
                        ui32_prev_value = ui32_value;
                    }
                }
            } else {
            }
        } else {
        }
    }
    iterate_all_ui64_locations_1bipp(cb) {
        const ui32a_px_range = new Uint32Array(4);
        if (this.ta_is_64bit_divisible) {
            if (this.is_64_divisible_bits_per_row) {
                const number_of_64bit_segments_per_64bit_divisible_row = this.number_of_64bit_segments_per_64bit_divisible_row;
                if (number_of_64bit_segments_per_64bit_divisible_row === 1) {
                    const height = this.size[1];
                    const first_x = 0, last_x = 63;
                    ui32a_px_range[0] = first_x;
                    ui32a_px_range[2] = last_x;
                    let y = 0;
                    for (let i = 0; i < height; i++) {
                        ui32a_px_range[1] = y;
                        ui32a_px_range[3] = y;
                        cb(ui32a_px_range);
                        y++;
                    }
                } else if (number_of_64bit_segments_per_64bit_divisible_row === 2) {
                    const height = this.size[1];
                    const number_of_64bit_segments = height * number_of_64bit_segments_per_64bit_divisible_row;
                    let even = true;
                    let y = 0;
                    let first_x = 0, last_x = 63;
                    for (let i = 0; i < number_of_64bit_segments; i++) {
                        ui32a_px_range[0] = first_x;
                        ui32a_px_range[1] = y;
                        ui32a_px_range[2] = last_x;
                        ui32a_px_range[3] = y;
                        cb(ui32a_px_range);
                        if (!even) {
                            y++;
                            first_x = 0; last_x = 63;
                        } else {
                            first_x = 64; last_x = 127;
                        }
                        even = !even;
                    }
                } else {
                    const height = this.size[1];
                    const number_of_64bit_segments = height * number_of_64bit_segments_per_64bit_divisible_row;
                    let y = 0;
                    let first_x = 0, last_x = 63;
                    let i_row_segment = 0;
                    for (let i = 0; i < number_of_64bit_segments; i++) {
                        ui32a_px_range[0] = first_x;
                        ui32a_px_range[1] = y;
                        ui32a_px_range[2] = last_x;
                        ui32a_px_range[3] = y;
                        cb(ui32a_px_range);
                        i_row_segment++;
                        if (i_row_segment < number_of_64bit_segments_per_64bit_divisible_row) {
                            first_x += 64;
                            last_x += 64;
                        } else {
                            i_row_segment = 0;
                            y++;
                            first_x = 0; last_x = 63;
                        }
                    }
                }
            } else {
            }
        } else {
        }
    }
    iterate_all_ui64_values_1bipp() {
    }
    iterate_1bipp_wrapping_x_span_color_toggles(cb) {
        const {ta} = this;
        const r1shifted_ta = right_shift_32bit_with_carry(ta);
        const xored_against_orig = xor_typed_arrays(ta, r1shifted_ta);
        each_1_index(xored_against_orig, cb);
    }
    count_1bipp_wrapping_x_span_color_toggles() {
        const {ta} = this;
        const r1shifted_ta = right_shift_32bit_with_carry(ta);
        const xored_against_orig = xor_typed_arrays(ta, r1shifted_ta);
        return count_1s(xored_against_orig);
    }
    'place_image_from_pixel_buffer'(pixel_buffer, dest_pos, options = {}) {
        const {bipp} = this;
        const dest_buffer = this.buffer;
        const source_buffer = pixel_buffer.buffer;
        if (bipp === 32 && pixel_buffer.bits_per_pixel === 32) {
            const dest_w = this.size[0];
            const dest_h = this.size[1];
            const dest_buffer_line_length = dest_w * 4;
            const source_w = pixel_buffer.size[0];
            const source_h = pixel_buffer.size[1];
            const source_buffer_line_length = source_w * 4;
            let source_buffer_line_start_pos, source_buffer_line_end_pos, dest_buffer_subline_start_pos, dest_buffer_start_offset;
            dest_buffer_start_offset = dest_pos[0] * 4;
            for (var y = 0; y < source_h; y++) {
                source_buffer_line_start_pos = y * source_buffer_line_length;
                source_buffer_line_end_pos = source_buffer_line_start_pos + source_buffer_line_length;
                dest_buffer_subline_start_pos = (y + dest_pos[1]) * dest_buffer_line_length;
                source_buffer.copy(dest_buffer, dest_buffer_subline_start_pos + dest_buffer_start_offset, source_buffer_line_start_pos, source_buffer_line_end_pos);
            }
        } else if (bipp === 1) {
            if (pixel_buffer.bipp === 1) {
                if (options.or === true) {
                    return this.draw_1bipp_pixel_buffer_mask_1bipp(pixel_buffer, dest_pos);
                } else {
                    const pb_source = pixel_buffer;
                    const ta_pos = new Int16Array(2);
                    const ta_px_value = new Uint8ClampedArray(3);
                    const ta_info = new Uint32Array(4);
                    const px_dest_pos = new Uint16Array(2);
                    pb_source.each_ta_1bipp(ta_pos, ta_px_value, ta_info, (color, pos) => {
                        px_dest_pos[0] = pos[0] + dest_pos[0];
                        px_dest_pos[1] = pos[1] + dest_pos[1];
                        this.set_pixel(px_dest_pos, color);
                    })
                }
            } else {
                console.trace();
                throw 'must have matching bipp values (expected: 1)';
            }
        } else {
            console.trace();
            console.log('[pixel_buffer, dest_pos, options]', [pixel_buffer, dest_pos, options]);
            throw 'not currently supported';
        }
    }
    draw_filled_polygon_to_1bipp_pixel_buffer_mask(arr_points) {
        if (arr_points.length >= 2) {
            const bb_points = get_points_bounding_box(arr_points);
            const offset = bb_points[0];
            const polygon_size = [
                [bb_points[1][0] - bb_points[0][0] + 1],
                [bb_points[1][1] - bb_points[0][1] + 1]
            ];
            if (polygon_size[0] === 1 && polygon_size[1] === 1 ) {
                const pb_polygon = new this.constructor({
                    'bits_per_pixel': 1,
                    'size': polygon_size
                });
                pb_polygon.ta[0] = 128;
                pb_polygon.__offset = offset;
                return pb_polygon;
            } else if (polygon_size[0] === 2 && polygon_size[1] === 1 || polygon_size[0] === 1 && polygon_size[1] === 2) {
                const pb_polygon = new this.constructor({
                    'bits_per_pixel': 1,
                    'size': polygon_size
                });
                pb_polygon.ta[0] = 192;
                pb_polygon.__offset = offset;
                return pb_polygon;
            } else {
                const pb_polygon = new this.constructor({
                    'bits_per_pixel': 1,
                    'size': polygon_size
                });
                const down_offsetted_points = arr_points.map(point => [point[0] - offset[0], point[1] - offset[1]]);
                pb_polygon.draw_polygon(down_offsetted_points, 1, false);
                pb_polygon.flood_fill_inner_pixels_off_to_on_1bipp();
                pb_polygon.__offset = offset;
                return pb_polygon;
            }
        } else if (arr_points.length === 1) {
            const pb_polygon = new this.constructor({
                'bits_per_pixel': 1,
                'size': polygon_size
            });
            pb_polygon.ta[0] = 128;
            pb_polygon.__offset = offset;
            return pb_polygon;
        }
    }
    get ta2() {
        if (!this._ta2) {
            this._ta2 = new Uint8Array(this.ta.length);
        }
        return this._ta2;
    }
    apply_square_convolution(f32a_convolution) {
        return this.process((orig, res) => {
            const c_length = f32a_convolution.length;
            const dimension_size = Math.sqrt(c_length);
            const padding = (dimension_size - 1) / 2;
            let x, y, pos = 0,
                ii, i;
            const bpp = this.bytes_per_pixel;
            const bpr = this.bytes_per_row;
            const idx_movement_vectors = get_idx_movement_vectors(f32a_convolution, bpp, bpr);
            let cr, cg, cb, ca;
            const buf = this.buffer;
            const buf_res = res.buffer;
            if (bpp === 3) {
                this.padded_each_pixel_index(padding, (px_idx) => {
                    cr = 0;
                    cg = 0;
                    cb = 0;
                    for (ii = 0; ii < c_length; ii++) {
                        i = px_idx + idx_movement_vectors[ii];
                        cr += f32a_convolution[ii] * buf[i++];
                        cg += f32a_convolution[ii] * buf[i++];
                        cb += f32a_convolution[ii] * buf[i++];
                    }
                    if (cr < 0) cr = 0;
                    if (cg < 0) cg = 0;
                    if (cb < 0) cb = 0;
                    if (cr > 255) cr = 255;
                    if (cg > 255) cg = 255;
                    if (cb > 255) cb = 255;
                    buf_res[px_idx++] = Math.round(cr);
                    buf_res[px_idx++] = Math.round(cg);
                    buf_res[px_idx++] = Math.round(cb);
                });
            } else if (bpp === 4) {
                this.padded_each_pixel_index(padding, (px_idx) => {
                    cr = 0;
                    cg = 0;
                    cb = 0;
                    for (ii = 0; ii < c_length; ii++) {
                        i = px_idx + idx_movement_vectors[ii];
                        cr += f32a_convolution[ii] * buf[i++];
                        cg += f32a_convolution[ii] * buf[i++];
                        cb += f32a_convolution[ii] * buf[i++];
                    }
                    ca = 255;
                    if (cr < 0) cr = 0;
                    if (cg < 0) cg = 0;
                    if (cb < 0) cb = 0;
                    if (cr > 255) cr = 255;
                    if (cg > 255) cg = 255;
                    if (cb > 255) cb = 255;
                    buf_res[px_idx++] = Math.round(cr);
                    buf_res[px_idx++] = Math.round(cg);
                    buf_res[px_idx++] = Math.round(cb);
                    buf_res[px_idx++] = Math.round(ca);
                });
            } else {
                throw 'NYI';
            }
            return res;
        })
    }
    extract_channel(i_channel) {
        const bypp = this.bytes_per_pixel;
        const ta = this.ta;
        let i_byte = i_channel;
        let i_px = 0;
        const l = ta.length;
        if (bypp === 3 || bypp === 4) {
            const res_channel_ta = new this.constructor({
                size: this.size,
                bits_per_pixel: 8
            })
            while (i_byte < l) {
                res_channel_ta.set_pixel_by_idx(i_px, ta[i_byte]);
                i_byte += bypp;
                i_px++;
            }
            return res_channel_ta;
        } else {
            console.trace();
            throw 'NYI';
        }
    }
    _custom_convolve(dimension_size, cb) {
        if (dimension_size % 2 !== 1) {
            throw 'dimension_size must be an odd integer';
        }
        const px = new Uint16Array(2);
        const ta16 = new Int16Array(12);
        [ta16[2], ta16[3]] = this.size;
        ta16[4] = this.bytes_per_pixel;
        ta16[5] = ta16[2] * ta16[4] 
        ta16[8] = dimension_size;
        ta16[9] = (ta16[8] - 1) / 2 
        ta16[10] = 0; 
        ta16[11] = ta16[8] * ta16[4];
        let ta32 = new Uint32Array(4);
        ta32[0] = 0; 
        ta32[1] = 0; 
        ta32[2] = ta16[2] * ta16[3] * ta16[4] 
        let conv_pixels = new Uint8Array(ta16[8] * ta16[8] * ta16[8]);
        const buffer = this.buffer;
        for (px[1] = 0; px[1] < ta16[3]; px[1]++) {
            for (px[0] = 0; px[0] < ta16[2]; px[0]++) {
                ta16[6] = px[0] - ta16[8];
                if (ta16[6] > 0 && ta16[6] < ta16[2] - ta16[8]) {
                    ta16[7] = px[1] - ta16[8];
                    if (ta16[7] > 0 && ta16[7] < ta16[3] - ta16[8]) {
                        ta32[1] = ta32[0] -  ta16[9] * ta16[4] -  ta16[9] * ta16[5];
                        ta16[10] = 0;
                        for (ta16[7] = ta16[1]; ta16[7] < ta16[1] + ta16[8]; ta16[7]++) {
                            let sl = buffer.slice(ta32[1], ta32[1] + ta16[11]);
                            for (let c = 0; c < ta16[11]; c++) {
                                conv_pixels[ta16[10] + c] = sl.readUInt8(c);
                            }
                            ta16[10] += ta16[11];
                            ta32[1] += ta16[5];
                        }
                        cb(px, conv_pixels);
                    }
                }
                ta32[0] += ta16[4];
            }
        }
    }
    get_first_pixel_matching_color(r, g, b, a) {
        let px = 0,
            py = 0;
        let [w, h] = this.size;
        let found = false;
        let buf = this.buffer;
        let pos_buf = 0;
        for (py = 0; !found && py < h; py++) {
            for (px = 0; !found && px < w; px++) {
                if (buf[pos_buf] === r && buf[pos_buf + 1] === g && buf[pos_buf + 2] === b && buf[pos_buf + 3] === a) {
                    found = true;
                }
                pos_buf += 4;
            }
        }
        if (found) {
            return [px, py];
        }
    }
    'flood_fill_small_color_blocks'(max_size, r, g, b, a) {
        this.each_pixel((x, y, pr, pg, pb, pa) => {
            if ((r !== pr || g !== pg || b !== pb || a !== pa)) {
                let s = this.measure_color_region_size(x, y, max_size);
                if (s < max_size) {
                    this.flood_fill(x, y, r, g, b, a);
                }
            }
        })
    }
    self_replace_color(target_color, replacement_color) {
        const bpp = this.bytes_per_pixel;
        const buf = this.buffer;
        const l = buf.length;
        if (bpp === 1) {
            for (let c = 0; c < l; c++) {
                if (buf[c] === target_color) buf[c] = replacement_color;
            }
        } else {
            throw 'NYI';
        }
        return this;
    }
    '_replace_color'(r, g, b, a, tr, tg, tb, ta) {
        const buf_read = this.buffer;
        let ta_u8 = new Uint8Array(8);
        ta_u8[0] = r;
        ta_u8[1] = g;
        ta_u8[2] = b;
        ta_u8[3] = a;
        ta_u8[4] = tr;
        ta_u8[5] = tg;
        ta_u8[6] = tb;
        ta_u8[7] = ta;
        const ta_16_scratch = new Uint32Array(8);
        ta_16_scratch[0] = 0; 
        ta_16_scratch[2] = buf_read.length;
        while (ta_16_scratch[0] < ta_16_scratch[2]) {
            if (buf_read[ta_16_scratch[0]] === ta_u8[0] && buf_read[ta_16_scratch[0] + 1] === ta_u8[1] && buf_read[ta_16_scratch[0] + 2] === ta_u8[2] && buf_read[ta_16_scratch[0] + 3] === ta_u8[3]) {
                buf_read[ta_16_scratch[0]] = ta_u8[4];
                buf_read[ta_16_scratch[0] + 1] = ta_u8[5];
                buf_read[ta_16_scratch[0] + 2] = ta_u8[6];
                buf_read[ta_16_scratch[0] + 3] = ta_u8[7];
            } else {
            }
            ta_16_scratch[0] += 4;
        }
    }
    '__get_single_color_mask_32'(r, g, b, a) {
        var res = new this.constructor({
            'size': this.size,
            'bits_per_pixel': 32
        });
        res.buffer.fill(0);
        const buf_read = this.buffer;
        const buf_write = res.buffer;
        const ta_16_scratch = new Uint32Array(8);
        ta_16_scratch[0] = 0; 
        ta_16_scratch[1] = 0; 
        ta_16_scratch[2] = buf_read.length;
        ta_16_scratch[3] = buf_write.length;
        let ta_u8 = new Uint8Array(4);
        ta_u8[0] = r;
        ta_u8[1] = g;
        ta_u8[2] = b;
        ta_u8[3] = a;
        while (ta_16_scratch[0] < ta_16_scratch[2]) {
            if (buf_read[ta_16_scratch[0]] === ta_u8[0] && buf_read[ta_16_scratch[0] + 1] === ta_u8[1] && buf_read[ta_16_scratch[0] + 2] === ta_u8[2] && buf_read[ta_16_scratch[0] + 3] === ta_u8[3]) {
                buf_write[ta_16_scratch[1]++] = 0;
                buf_write[ta_16_scratch[1]++] = 0;
                buf_write[ta_16_scratch[1]++] = 0;
                buf_write[ta_16_scratch[1]++] = 255;
            } else {
                buf_write[ta_16_scratch[1]++] = 255;
                buf_write[ta_16_scratch[1]++] = 255;
                buf_write[ta_16_scratch[1]++] = 255;
                buf_write[ta_16_scratch[1]++] = 255;
            }
            ta_16_scratch[0] += 4;
        }
        return res;
    }
    count_pixels_with_color(...args) {
        const {bipp} = this;
        if (bipp === 32) {
            const [r, g, b, a] = args;
            const buf_read = this.buffer;
            const scratch_32 = new Uint32Array(5);
            scratch_32[0] = 0; 
            scratch_32[2] = buf_read.length;
            scratch_32[4] = 0;
            const ta_16_scratch = new Uint16Array(8);
            let ta_u8 = new Uint8Array(4);
            ta_u8[0] = r;
            ta_u8[1] = g;
            ta_u8[2] = b;
            ta_u8[3] = a;
            while (scratch_32[0] < scratch_32[2]) {
                if (buf_read[scratch_32[0]++] === ta_u8[0] && buf_read[scratch_32[0]++] === ta_u8[1] && buf_read[scratch_32[0]++] === ta_u8[2] && buf_read[scratch_32[0]++] === ta_u8[3]) {
                    scratch_32[4]++;
                }
            }
            return scratch_32[4];
        } else {
            return super.count_pixels_with_color(...args);
        }
    }
    '__get_single_color_mask'(r, g, b, a) {
        var res = new this.constructor({
            'size': this.size,
            'bits_per_pixel': 8
        });
        res.buffer.fill(0);
        const buf_read = this.buffer;
        const buf_write = res.buffer;
        const ta_16_scratch = new Uint16Array(8);
        ta_16_scratch[0] = 0; 
        ta_16_scratch[1] = 0; 
        ta_16_scratch[2] = buf_read.length;
        ta_16_scratch[3] = buf_write.length;
        let ta_u8 = new Uint8Array(4);
        ta_u8[0] = r;
        ta_u8[1] = g;
        ta_u8[2] = b;
        ta_u8[3] = a;
        while (ta_16_scratch[0] < ta_16_scratch[2]) {
            if (buf_read[ta_16_scratch[0]++] === ta_u8[0] && buf_read[ta_16_scratch[0]++] === ta_u8[1] && buf_read[ta_16_scratch[0]++] === ta_u8[2] && buf_read[ta_16_scratch[0]++] === ta_u8[3]) {
                buf_write[ta_16_scratch[1]] = 255;
            }
            ta_16_scratch[1]++;
        }
        return res;
    }
    'measure_color_region_size'(x, y, max) {
        const buffer = this.buffer;
        if (this.bytes_per_pixel === 4) {
            const scratch_32 = new Uint32Array(16);
            scratch_32[0] = this.size[0]; 
            scratch_32[1] = this.size[1]; 
            scratch_32[2] = scratch_32[0] * scratch_32[1];
            scratch_32[3] = this.bytes_per_pixel;
            scratch_32[6] = 0 
            scratch_32[7] = 0 
            scratch_32[8] = 0 
            scratch_32[9] = max;
            const ta8_pixels = new Uint8Array(12);
            scratch_32[10] = 0 
            const ta16_pixels = new Uint8Array(4);
            const ta_pixels_visited = new Uint8Array(scratch_32[2]);
            const ta_visiting_pixels = new Uint16Array(scratch_32[2] * 2);
            scratch_32[8] = scratch_32[3] * (x + (y * scratch_32[0]));
            ta8_pixels[0] = buffer[scratch_32[8]++];
            ta8_pixels[1] = buffer[scratch_32[8]++];
            ta8_pixels[2] = buffer[scratch_32[8]++];
            ta8_pixels[3] = buffer[scratch_32[8]++];
            ta_visiting_pixels[0] = x;
            ta_visiting_pixels[1] = y;
            scratch_32[7] = 2;
            while (scratch_32[6] < scratch_32[7] && scratch_32[10] < scratch_32[9]) {
                scratch_32[4] = ta_visiting_pixels[scratch_32[6]++]; 
                scratch_32[5] = ta_visiting_pixels[scratch_32[6]++]; 
                scratch_32[8] = scratch_32[3] * (scratch_32[4] + (scratch_32[5] * scratch_32[0]));
                ta8_pixels[4] = buffer[scratch_32[8]++];
                ta8_pixels[5] = buffer[scratch_32[8]++];
                ta8_pixels[6] = buffer[scratch_32[8]++];
                ta8_pixels[7] = buffer[scratch_32[8]++];
                ta16_pixels[0] = ta8_pixels[4] - ta8_pixels[0];
                ta16_pixels[1] = ta8_pixels[5] - ta8_pixels[1];
                ta16_pixels[2] = ta8_pixels[6] - ta8_pixels[2];
                ta16_pixels[3] = ta8_pixels[7] - ta8_pixels[3];
                if (ta16_pixels[0] === 0 && ta16_pixels[1] === 0 && ta16_pixels[2] === 0 && ta16_pixels[3] === 0) {
                    if (scratch_32[4] - 1 >= 0 && scratch_32[4] - 1 < scratch_32[0] && ta_pixels_visited[scratch_32[4] - 1 + (scratch_32[0] * scratch_32[5])] === 0) {
                        ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] - 1;
                        ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                        ta_pixels_visited[scratch_32[4] - 1 + (scratch_32[0] * scratch_32[5])] = 255;
                    }
                    if (scratch_32[5] - 1 >= 0 && scratch_32[5] - 1 < scratch_32[1] && ta_pixels_visited[scratch_32[4] + (scratch_32[0] * (scratch_32[5] - 1))] === 0) {
                        ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                        ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] - 1;
                        ta_pixels_visited[scratch_32[4] + (scratch_32[0] * (scratch_32[5] - 1))] = 255;
                    }
                    if (scratch_32[4] + 1 >= 0 && scratch_32[4] + 1 < scratch_32[0] && ta_pixels_visited[scratch_32[4] + 1 + (scratch_32[0] * scratch_32[5])] === 0) {
                        ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] + 1;
                        ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                        ta_pixels_visited[scratch_32[4] + 1 + (scratch_32[0] * scratch_32[5])] = 255
                    }
                    if (scratch_32[5] + 1 >= 0 && scratch_32[5] + 1 < scratch_32[1] && ta_pixels_visited[scratch_32[4] + (scratch_32[0] * (scratch_32[5] + 1))] === 0) {
                        ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                        ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] + 1;
                        ta_pixels_visited[scratch_32[4] + (scratch_32[0] * (scratch_32[5] + 1))] = 255
                    }
                }
                scratch_32[10]++;
            }
            return scratch_32[10];
        } else if (this.bytes_per_pixel === 1) {
            return (() => {
                const scratch_32 = new Uint32Array(16);
                scratch_32[0] = this.size[0]; 
                scratch_32[1] = this.size[1]; 
                scratch_32[2] = scratch_32[0] * scratch_32[1];
                scratch_32[3] = this.bytes_per_pixel;
                scratch_32[6] = 0 
                scratch_32[7] = 0 
                scratch_32[8] = 0 
                scratch_32[9] = max;
                const ta8_pixels = new Uint8Array(12);
                scratch_32[10] = 0 
                const ta16_pixels = new Uint8Array(4);
                const ta_pixels_visited = new Uint8Array(scratch_32[2]);
                const ta_visiting_pixels = new Uint16Array(scratch_32[2] * 2);
                scratch_32[8] = scratch_32[3] * (x + (y * scratch_32[0]));
                ta8_pixels[0] = buffer[scratch_32[8]++];
                ta_visiting_pixels[0] = x;
                ta_visiting_pixels[1] = y;
                scratch_32[7] = 2;
                while (scratch_32[6] < scratch_32[7] && scratch_32[10] < scratch_32[9]) {
                    scratch_32[4] = ta_visiting_pixels[scratch_32[6]++]; 
                    scratch_32[5] = ta_visiting_pixels[scratch_32[6]++]; 
                    scratch_32[8] = scratch_32[3] * (scratch_32[4] + (scratch_32[5] * scratch_32[0]));
                    ta8_pixels[4] = buffer[scratch_32[8]++];
                    ta16_pixels[0] = ta8_pixels[4] - ta8_pixels[0];
                    if (ta16_pixels[0] === 0) {
                        if (scratch_32[4] - 1 >= 0 && scratch_32[4] - 1 < scratch_32[0] && ta_pixels_visited[scratch_32[4] - 1 + (scratch_32[0] * scratch_32[5])] === 0) {
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] - 1;
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                            ta_pixels_visited[scratch_32[4] - 1 + (scratch_32[0] * scratch_32[5])] = 255;
                        }
                        if (scratch_32[5] - 1 >= 0 && scratch_32[5] - 1 < scratch_32[1] && ta_pixels_visited[scratch_32[4] + (scratch_32[0] * (scratch_32[5] - 1))] === 0) {
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] - 1;
                            ta_pixels_visited[scratch_32[4] + (scratch_32[0] * (scratch_32[5] - 1))] = 255;
                        }
                        if (scratch_32[4] + 1 >= 0 && scratch_32[4] + 1 < scratch_32[0] && ta_pixels_visited[scratch_32[4] + 1 + (scratch_32[0] * scratch_32[5])] === 0) {
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] + 1;
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                            ta_pixels_visited[scratch_32[4] + 1 + (scratch_32[0] * scratch_32[5])] = 255
                        }
                        if (scratch_32[5] + 1 >= 0 && scratch_32[5] + 1 < scratch_32[1] && ta_pixels_visited[scratch_32[4] + (scratch_32[0] * (scratch_32[5] + 1))] === 0) {
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] + 1;
                            ta_pixels_visited[scratch_32[4] + (scratch_32[0] * (scratch_32[5] + 1))] = 255
                        }
                    }
                    scratch_32[10]++;
                }
                return scratch_32[10];
            })();
        } else {
            throw 'unsuppored bytes_per_pixel ' + this.bytes_per_pixel
        }
    }
    'get_pixel_pos_list_of_pixels_with_color'(color) {
        let res = new Pixel_Pos_List();
        if (this.pos) {
            console.log('this.pos', this.pos);
            this.each_pixel_ta((pos, px_color) => {
                if (px_color === color) {
                    res.add(new Uint16Array([pos[0] + this.pos[0], pos[1] + this.pos[1]]));
                }
            });
            res.pos = this.pos;
        } else {
            this.each_pixel_ta((pos, px_color) => {
                if (px_color === color) {
                    res.add(pos);
                }
            });
        }
        res.fix();
        return res;
    }
    'get_ppl_color_region'(pos) {
        console.trace();
        throw 'NYI';
    }
    'flood_fill_self_get_pixel_pos_list'(pos, color) {
        const size = this.size;
        if (!(pos instanceof Uint16Array || pos instanceof Uint32Array)) {
            throw 'Wrong pos data type, pos ' + pos;
        }
        if (this.bytes_per_pixel === 4) {
            throw 'NYI'
        } else if (this.bytes_per_pixel === 1) {
            const using_ta_pixels_visited = () => {
                const res = new Pixel_Pos_List();
                const buffer = this.buffer;
                const scratch_32 = new Uint32Array(10);
                scratch_32[0] = this.size[0]; 
                scratch_32[1] = this.size[1]; 
                const size = scratch_32;
                scratch_32[2] = size[0] * size[1];
                scratch_32[3] = this.bytes_per_pixel;
                let cpos = pos.slice();
                scratch_32[6] = 0 
                scratch_32[7] = 0 
                scratch_32[8] = 0 
                scratch_32[9] = 0 
                const obj_pixels_visited = {};
                const ppl_visiting_pixels = new Pixel_Pos_List();
                const ta_visiting_pixels = ppl_visiting_pixels.ta;
                let ccolor;
                scratch_32[8] = scratch_32[3] * (cpos[0] + (cpos[1] * size[0]));
                ccolor = buffer[scratch_32[8]++];
                ppl_visiting_pixels.add(cpos);
                scratch_32[7] = 2;
                while (scratch_32[9] <= scratch_32[2]) {
                    console.log('scratch_32[9]', scratch_32[9]);
                    console.log('scratch_32[2]', scratch_32[2]);
                    cpos[0] = ta_visiting_pixels[scratch_32[6]++];
                    cpos[1] = ta_visiting_pixels[scratch_32[6]++];
                    scratch_32[8] = scratch_32[3] * (cpos[0] + (cpos[1] * size[0]));
                    if (buffer[scratch_32[8]++] - ccolor === 0) {
                        buffer[scratch_32[8] - 1] = color;
                        res.add(cpos);
                        if (cpos[0] - 1 >= 0 && !obj_pixels_visited[cpos[0] - 1 + (size[0] * cpos[1])]) {
                            ppl_visiting_pixels.add(new Uint16Array([cpos[0] - 1, cpos[1]]));
                            scratch_32[7] += 2;
                            obj_pixels_visited[cpos[0] - 1 + (size[0] * cpos[1])] = true;
                        }
                        if (cpos[1] - 1 >= 0 && !obj_pixels_visited[cpos[0] + (size[0] * (cpos[1] - 1))]) {
                            ppl_visiting_pixels.add(new Uint16Array([cpos[0], cpos[1] - 1]));
                            scratch_32[7] += 2;
                            obj_pixels_visited[cpos[0] + (size[0] * (cpos[1] - 1))] = true;
                        }
                        if (cpos[0] + 1 < size[0] && !obj_pixels_visited[cpos[0] + 1 + (size[0] * cpos[1])]) {
                            ppl_visiting_pixels.add(new Uint16Array([cpos[0] + 1, cpos[1]]));
                            scratch_32[7] += 2;
                            obj_pixels_visited[cpos[0] + 1 + (size[0] * cpos[1])] = true;
                        }
                        if (cpos[1] + 1 < size[1] && !obj_pixels_visited[cpos[0] + (size[0] * (cpos[1] + 1))]) {
                            ppl_visiting_pixels.add(new Uint16Array([cpos[0], cpos[1] + 1]));
                            scratch_32[7] += 2;
                            obj_pixels_visited[cpos[0] + (size[0] * (cpos[1] + 1))] = true;
                        }
                    }
                    scratch_32[9]++;
                }
                res.fix();
                return res;
            }
            return using_ta_pixels_visited();
        } else {
            console.trace();
            throw 'NYI';
        }
    }
    'flood_fill_c1_1bipp'(pos) {
        const target_color = this.get_pixel_1bipp(pos);
        let [x, y] = pos;
        if (target_color === 1) {
            return 0;
        } else {
            const ta_stack_fn_calls_inlined_8bipp_visited_matrix_implementation = () => {
                let stack_capacity = 1024 * 1024 * 16; 
                let ta_stack = new Uint16Array(stack_capacity);
                let i_stack_pos = 0;
                let stack_length = 0;
                let px_color;
                let ta_pos = new Uint16Array(2);
                let ta_pos2 = new Uint16Array(2);
                ta_pos[0] = pos[0];
                ta_pos[1] = pos[1];
                if (i_stack_pos < stack_capacity) {
                    ta_stack[i_stack_pos++] = ta_pos[0];
                    ta_stack[i_stack_pos++] = ta_pos[1];
                    stack_length++;
                } else {
                    console.log('stack_length', stack_length);
                    console.log('i_stack_pos', i_stack_pos);
                    console.trace();
                    throw 'NYI - stack exceeded capacity';
                }
                const [width, height] = this.size;
                const ta_already_visited = new Uint8Array(width * height);
                while (stack_length > 0) {
                    ta_pos[0] = ta_stack[i_stack_pos - 2];
                    ta_pos[1] = ta_stack[i_stack_pos - 1];
                    i_stack_pos -= 2;
                    stack_length--;
                    if (i_stack_pos >= stack_capacity - 8) {
                        throw 'Not enough stack for positions yet to visit';
                    }
                    px_color = this.get_pixel_1bipp(ta_pos); 
                    if (px_color === target_color) {
                        this.set_pixel_on_1bipp(ta_pos);
                        if (ta_pos[0] > 0) {
                            ta_pos2[0] = ta_pos[0] - 1;
                            ta_pos2[1] = ta_pos[1];
                            if (ta_already_visited[width * ta_pos2[1] + ta_pos2[0]] === 0) {
                                ta_stack[i_stack_pos++] = ta_pos2[0];
                                ta_stack[i_stack_pos++] = ta_pos2[1];
                                stack_length++;
                            };
                        }
                        if (ta_pos[0] < width - 1) {
                            ta_pos2[0] = ta_pos[0] + 1;
                            ta_pos2[1] = ta_pos[1];
                            if (ta_already_visited[width * ta_pos2[1] + ta_pos2[0]] === 0) {
                                ta_stack[i_stack_pos++] = ta_pos2[0];
                                ta_stack[i_stack_pos++] = ta_pos2[1];
                                stack_length++;
                            };
                        }
                        if (ta_pos[1] > 0) {
                            ta_pos2[0] = ta_pos[0];
                            ta_pos2[1] = ta_pos[1] - 1;
                            if (ta_already_visited[width * ta_pos2[1] + ta_pos2[0]] === 0) {
                                ta_stack[i_stack_pos++] = ta_pos2[0];
                                ta_stack[i_stack_pos++] = ta_pos2[1];
                                stack_length++;
                            };
                        }
                        if (ta_pos[1] < height - 1) {
                            ta_pos2[0] = ta_pos[0];
                            ta_pos2[1] = ta_pos[1] + 1;
                            if (ta_already_visited[width * ta_pos2[1] + ta_pos2[0]] === 0) {
                                ta_stack[i_stack_pos++] = ta_pos2[0];
                                ta_stack[i_stack_pos++] = ta_pos2[1];
                                stack_length++;
                            };
                        }
                        ta_already_visited[width * ta_pos[1] + ta_pos[0]] = 255
                    }
                }
            }
            const horizontal_line_filling_stack_to_visit_store_already_visited_implementation = () => {
                const {ta, size} = this;
                const aa_x_off_spans = this.calculate_arr_rows_arr_x_off_spans_1bipp();
                console.log('aa_x_off_spans', aa_x_off_spans);
                const find_connected_x_off_spans_below = (y, idx_x_off_span) => {
                    const res = [];
                    if (y < aa_x_off_spans.length - 1) {
                        const span1 = aa_x_off_spans[y][idx_x_off_span];
                        console.log('');
                        console.log('span1', span1);
                        const y_below = aa_x_off_spans[y + 1];
                        console.log('y_below', y_below);
                        const l_y_below = y_below.length;
                        for (let i_below = 0; i_below < l_y_below; i_below++) {
                            const range_below = y_below[i_below];
                            const has_overlap = range_below[0] >= span1[0] && range_below[0] <= span1[1] || range_below[1] >= span1[0] && range_below[1] <= span1[1];
                            console.log('range_below', range_below);
                            console.log('has_overlap', has_overlap);
                            if (has_overlap) {
                                res.push(range_below);
                            }
                        }
                    }
                    return res;
                }
                for (let y = 0; y < aa_x_off_spans.length; y++) {
                    const arr_row_x_off_spans = aa_x_off_spans[y];
                    for (let idx_x_off_span = 0; idx_x_off_span < arr_row_x_off_spans.length; idx_x_off_span++) {
                        const x_off_span = arr_row_x_off_spans[idx_x_off_span];
                        const path_xos = [y, idx_x_off_span];
                        console.log('path_xos', path_xos);
                        const spans_connected_below = find_connected_x_off_spans_below(y, idx_x_off_span);
                        console.log('spans_connected_below', spans_connected_below);
                    }
                }
                const old = () => {
                    const calculate_1bipp_row_arr_x_spans_off = y => {
                        const res = [];
                        const width = this.size[0];
                        let last_color = 0;
                        let current_color;
                        let ta_pos = new Uint16Array(2);
                        ta_pos[1] = y;
                        for (let x = 0; x < width; x++) {
                            ta_pos[0] = x;
                            current_color = this.get_pixel_1bipp(ta_pos);
                            if (current_color === last_color) {
                                if (res.length === 0) {
                                    res.push([0, 1]);
                                } else {
                                    res[res.length - 1][1]++;
                                }
                            } else {
                                if (res.length === 0) {
                                    res.push([0, 0]); 
                                    res.push([0, 1]);
                                } else {
                                    res.push([x, x + 1]);
                                }
                            }
                            last_color = current_color;
                        }
                        return res;
                    }
                    const row_x_off_spans = calculate_1bipp_row_arr_x_spans_off(y);
                    console.log('----------------');
                    console.log('row_x_off_spans', row_x_off_spans);
                    if (y > 0) {
                        const row_above_x_off_spans = calculate_1bipp_row_arr_x_spans_off(y - 1);
                        console.log('row_above_x_off_spans', row_above_x_off_spans);
                    }
                    if (y < this.size[1] - 1) {
                        const row_below_x_off_spans = calculate_1bipp_row_arr_x_spans_off(y + 1);
                        console.log('row_below_x_off_spans', row_below_x_off_spans);
                    }
                    console.log('----------------');
                }
            }
            return ta_stack_fn_calls_inlined_8bipp_visited_matrix_implementation();
        }
    }
    'flood_fill_1bipp'(x, y, color) {
        const new_color = color;
        const target_color = this.get_pixel_1bipp([x, y]);
        const [width, height] = this.size;
        if (target_color === new_color) {
            return 0;
        } else {
            const ta_stack_fn_calls_inlined_implementation = () => {
                let stack_capacity = 1024 * 1024 * 8; 
                let ta_stack = new Uint16Array(stack_capacity);
                let i_stack_pos = 0;
                let stack_length = 0;
                let px_color;
                let ta_pos = new Uint16Array(2);
                let ta_pos2 = new Uint16Array(2);
                ta_pos[0] = x;
                ta_pos[1] = y;
                if (i_stack_pos < stack_capacity) {
                    ta_stack[i_stack_pos++] = ta_pos[0];
                    ta_stack[i_stack_pos++] = ta_pos[1];
                    stack_length++;
                } else {
                    console.log('stack_length', stack_length);
                    console.log('i_stack_pos', i_stack_pos);
                    console.trace();
                    throw 'NYI - stack exceeded capacity';
                }
                const pb_already_visited = new Core({
                    size: this.size,
                    bits_per_pixel: 1
                })
                while (stack_length > 0) {
                        ta_pos[0] = ta_stack[i_stack_pos - 2];
                        ta_pos[1] = ta_stack[i_stack_pos - 1];
                        i_stack_pos -= 2;
                        stack_length--;
                    px_color = this.get_pixel_1bipp(ta_pos); 
                    if (px_color === target_color) {
                        this.set_pixel_1bipp(ta_pos, new_color);
                        if (ta_pos[0] > 0) {
                            ta_pos2[0] = ta_pos[0] - 1;
                            ta_pos2[1] = ta_pos[1];
                            if (pb_already_visited.get_pixel_1bipp(ta_pos2) === 0) {
                                if (i_stack_pos < stack_capacity) {
                                    ta_stack[i_stack_pos++] = ta_pos2[0];
                                    ta_stack[i_stack_pos++] = ta_pos2[1];
                                    stack_length++;
                                } else {
                                    console.log('stack_length', stack_length);
                                    console.log('i_stack_pos', i_stack_pos);
                                    console.trace();
                                    throw 'NYI - stack exceeded capacity';
                                }
                            };
                        }
                        if (ta_pos[0] < width - 1) {
                            ta_pos2[0] = ta_pos[0] + 1;
                            ta_pos2[1] = ta_pos[1];
                            if (pb_already_visited.get_pixel_1bipp(ta_pos2) === 0) {
                                if (i_stack_pos < stack_capacity) {
                                    ta_stack[i_stack_pos++] = ta_pos2[0];
                                    ta_stack[i_stack_pos++] = ta_pos2[1];
                                    stack_length++;
                                } else {
                                    console.log('stack_length', stack_length);
                                    console.log('i_stack_pos', i_stack_pos);
                                    console.trace();
                                    throw 'NYI - stack exceeded capacity';
                                }
                            };
                        }
                        if (ta_pos[1] > 0) {
                            ta_pos2[0] = ta_pos[0];
                            ta_pos2[1] = ta_pos[1] - 1;
                            if (pb_already_visited.get_pixel_1bipp(ta_pos2) === 0) {
                                if (i_stack_pos < stack_capacity) {
                                    ta_stack[i_stack_pos++] = ta_pos2[0];
                                    ta_stack[i_stack_pos++] = ta_pos2[1];
                                    stack_length++;
                                } else {
                                    console.log('stack_length', stack_length);
                                    console.log('i_stack_pos', i_stack_pos);
                                    console.trace();
                                    throw 'NYI - stack exceeded capacity';
                                }
                            };
                        }
                        if (ta_pos[1] < height - 1) {
                            ta_pos2[0] = ta_pos[0];
                            ta_pos2[1] = ta_pos[1] + 1;
                            if (pb_already_visited.get_pixel_1bipp(ta_pos2) === 0) {
                                if (i_stack_pos < stack_capacity) {
                                    ta_stack[i_stack_pos++] = ta_pos2[0];
                                    ta_stack[i_stack_pos++] = ta_pos2[1];
                                    stack_length++;
                                } else {
                                    console.log('stack_length', stack_length);
                                    console.log('i_stack_pos', i_stack_pos);
                                    console.trace();
                                    throw 'NYI - stack exceeded capacity';
                                }
                            };
                        }
                        pb_already_visited.set_pixel_1bipp(ta_pos, 1);
                    }
                }
            }
            const ta_stack_fn_calls_inlined_8bipp_visited_matrix_implementation = () => {
                let stack_capacity = 1024 * 1024 * 8; 
                let ta_stack = new Uint16Array(stack_capacity);
                let i_stack_pos = 0;
                let stack_length = 0;
                let px_color;
                let ta_pos = new Uint16Array(2);
                let ta_pos2 = new Uint16Array(2);
                ta_pos[0] = x;
                ta_pos[1] = y;
                if (i_stack_pos < stack_capacity) {
                    ta_stack[i_stack_pos++] = ta_pos[0];
                    ta_stack[i_stack_pos++] = ta_pos[1];
                    stack_length++;
                } else {
                    console.log('stack_length', stack_length);
                    console.log('i_stack_pos', i_stack_pos);
                    console.trace();
                    throw 'NYI - stack exceeded capacity';
                }
                const [width, height] = this.size;
                const ta_already_visited = new Uint8Array(width * height);
                while (stack_length > 0) {
                        ta_pos[0] = ta_stack[i_stack_pos - 2];
                        ta_pos[1] = ta_stack[i_stack_pos - 1];
                        i_stack_pos -= 2;
                        stack_length--;
                    px_color = this.get_pixel_1bipp(ta_pos); 
                    if (px_color === target_color) {
                        this.set_pixel_1bipp(ta_pos, new_color);
                        if (ta_pos[0] > 0) {
                            ta_pos2[0] = ta_pos[0] - 1;
                            ta_pos2[1] = ta_pos[1];
                            if (ta_already_visited[width * ta_pos2[1] + ta_pos2[0]] === 0) {
                                if (i_stack_pos < stack_capacity) {
                                    ta_stack[i_stack_pos++] = ta_pos2[0];
                                    ta_stack[i_stack_pos++] = ta_pos2[1];
                                    stack_length++;
                                } else {
                                    console.log('stack_length', stack_length);
                                    console.log('i_stack_pos', i_stack_pos);
                                    console.trace();
                                    throw 'NYI - stack exceeded capacity';
                                }
                            };
                        }
                        if (ta_pos[0] < width - 1) {
                            ta_pos2[0] = ta_pos[0] + 1;
                            ta_pos2[1] = ta_pos[1];
                            if (ta_already_visited[width * ta_pos2[1] + ta_pos2[0]] === 0) {
                                if (i_stack_pos < stack_capacity) {
                                    ta_stack[i_stack_pos++] = ta_pos2[0];
                                    ta_stack[i_stack_pos++] = ta_pos2[1];
                                    stack_length++;
                                } else {
                                    console.log('stack_length', stack_length);
                                    console.log('i_stack_pos', i_stack_pos);
                                    console.trace();
                                    throw 'NYI - stack exceeded capacity';
                                }
                            };
                        }
                        if (ta_pos[1] > 0) {
                            ta_pos2[0] = ta_pos[0];
                            ta_pos2[1] = ta_pos[1] - 1;
                            if (ta_already_visited[width * ta_pos2[1] + ta_pos2[0]] === 0) {
                                if (i_stack_pos < stack_capacity) {
                                    ta_stack[i_stack_pos++] = ta_pos2[0];
                                    ta_stack[i_stack_pos++] = ta_pos2[1];
                                    stack_length++;
                                } else {
                                    console.log('stack_length', stack_length);
                                    console.log('i_stack_pos', i_stack_pos);
                                    console.trace();
                                    throw 'NYI - stack exceeded capacity';
                                }
                            };
                        }
                        if (ta_pos[1] < height - 1) {
                            ta_pos2[0] = ta_pos[0];
                            ta_pos2[1] = ta_pos[1] + 1;
                            if (ta_already_visited[width * ta_pos2[1] + ta_pos2[0]] === 0) {
                                if (i_stack_pos < stack_capacity) {
                                    ta_stack[i_stack_pos++] = ta_pos2[0];
                                    ta_stack[i_stack_pos++] = ta_pos2[1];
                                    stack_length++;
                                } else {
                                    console.log('stack_length', stack_length);
                                    console.log('i_stack_pos', i_stack_pos);
                                    console.trace();
                                    throw 'NYI - stack exceeded capacity';
                                }
                            };
                        }
                        ta_already_visited[width * ta_pos[1] + ta_pos[0]] = 255
                    }
                }
            }
            return ta_stack_fn_calls_inlined_8bipp_visited_matrix_implementation();
        }
    }
    'flood_fill'(x, y, r, g, b, a) {
        const {
            bipp
        } = this;
        if (bipp === 24) {
            const [w, h] = this.size;
            let fast_stacked_mapped_flood_fill = () => {
                const buffer = this.buffer;
                const scratch_32 = new Uint32Array(16);
                scratch_32[0] = this.size[0]; 
                scratch_32[1] = this.size[1]; 
                scratch_32[2] = scratch_32[0] * scratch_32[1];
                scratch_32[3] = this.bytes_per_pixel;
                scratch_32[6] = 0 
                scratch_32[7] = 0 
                scratch_32[8] = 0 
                scratch_32[9] = 0 
                const ta8_pixels = new Uint8Array(12);
                ta8_pixels[8] = r;
                ta8_pixels[9] = g;
                ta8_pixels[10] = b;
                const ta_pixels_visited = new Uint8Array(scratch_32[2]);
                const ta_visiting_pixels = new Uint16Array(scratch_32[2] * 2);
                scratch_32[8] = scratch_32[3] * (x + (y * scratch_32[0]));
                ta8_pixels[0] = buffer[scratch_32[8]++];
                ta8_pixels[1] = buffer[scratch_32[8]++];
                ta8_pixels[2] = buffer[scratch_32[8]++];
                ta_visiting_pixels[0] = x;
                ta_visiting_pixels[1] = y;
                scratch_32[7] = 2;
                while (scratch_32[9] <= scratch_32[2]) {
                    scratch_32[4] = ta_visiting_pixels[scratch_32[6]++]; 
                    scratch_32[5] = ta_visiting_pixels[scratch_32[6]++]; 
                    scratch_32[8] = scratch_32[3] * (scratch_32[4] + (scratch_32[5] * scratch_32[0]));
                    if (buffer[scratch_32[8]++] - ta8_pixels[0] === 0 && buffer[scratch_32[8]++] - ta8_pixels[1] === 0 && buffer[scratch_32[8]++] - ta8_pixels[2] === 0) {
                        scratch_32[8] -= 3;
                        buffer[scratch_32[8]++] = ta8_pixels[8];
                        buffer[scratch_32[8]++] = ta8_pixels[9];
                        buffer[scratch_32[8]++] = ta8_pixels[10];
                        if (scratch_32[4] - 1 >= 0 && ta_pixels_visited[scratch_32[4] - 1 + (scratch_32[0] * scratch_32[5])] === 0) {
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] - 1;
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                            ta_pixels_visited[scratch_32[4] - 1 + (scratch_32[0] * scratch_32[5])] = 255;
                        }
                        if (scratch_32[5] - 1 >= 0 && ta_pixels_visited[scratch_32[4] + (scratch_32[0] * (scratch_32[5] - 1))] === 0) {
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] - 1;
                            ta_pixels_visited[scratch_32[4] + (scratch_32[0] * (scratch_32[5] - 1))] = 255;
                        }
                        if (scratch_32[4] + 1 < scratch_32[0] && ta_pixels_visited[scratch_32[4] + 1 + (scratch_32[0] * scratch_32[5])] === 0) {
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] + 1;
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                            ta_pixels_visited[scratch_32[4] + 1 + (scratch_32[0] * scratch_32[5])] = 255;
                        }
                        if (scratch_32[5] + 1 < scratch_32[1] && ta_pixels_visited[scratch_32[4] + (scratch_32[0] * (scratch_32[5] + 1))] === 0) {
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] + 1;
                            ta_pixels_visited[scratch_32[4] + (scratch_32[0] * (scratch_32[5] + 1))] = 255;
                        }
                    }
                    scratch_32[9]++;
                }
                return this;
            }
            return fast_stacked_mapped_flood_fill();
        } else if (bipp === 32) {
            const [w, h] = this.size;
            let fast_stacked_mapped_flood_fill = () => {
                const buffer = this.buffer;
                const scratch_32 = new Uint32Array(16);
                scratch_32[0] = this.size[0]; 
                scratch_32[1] = this.size[1]; 
                scratch_32[2] = scratch_32[0] * scratch_32[1];
                scratch_32[3] = this.bytes_per_pixel;
                scratch_32[6] = 0 
                scratch_32[7] = 0 
                scratch_32[8] = 0 
                scratch_32[9] = 0 
                const ta8_pixels = new Uint8Array(12);
                ta8_pixels[8] = r;
                ta8_pixels[9] = g;
                ta8_pixels[10] = b;
                ta8_pixels[11] = a;
                const ta_pixels_visited = new Uint8Array(scratch_32[2]);
                const ta_visiting_pixels = new Uint16Array(scratch_32[2] * 2);
                scratch_32[8] = scratch_32[3] * (x + (y * scratch_32[0]));
                ta8_pixels[0] = buffer[scratch_32[8]++];
                ta8_pixels[1] = buffer[scratch_32[8]++];
                ta8_pixels[2] = buffer[scratch_32[8]++];
                ta8_pixels[3] = buffer[scratch_32[8]++];
                ta_visiting_pixels[0] = x;
                ta_visiting_pixels[1] = y;
                scratch_32[7] = 2;
                while (scratch_32[9] <= scratch_32[2]) {
                    scratch_32[4] = ta_visiting_pixels[scratch_32[6]++]; 
                    scratch_32[5] = ta_visiting_pixels[scratch_32[6]++]; 
                    scratch_32[8] = scratch_32[3] * (scratch_32[4] + (scratch_32[5] * scratch_32[0]));
                    if (buffer[scratch_32[8]++] - ta8_pixels[0] === 0 && buffer[scratch_32[8]++] - ta8_pixels[1] === 0 && buffer[scratch_32[8]++] - ta8_pixels[2] === 0 && buffer[scratch_32[8]++] - ta8_pixels[3] === 0) {
                        scratch_32[8] -= 4;
                        buffer[scratch_32[8]++] = ta8_pixels[8];
                        buffer[scratch_32[8]++] = ta8_pixels[9];
                        buffer[scratch_32[8]++] = ta8_pixels[10];
                        buffer[scratch_32[8]++] = ta8_pixels[11];
                        if (scratch_32[4] - 1 >= 0 && ta_pixels_visited[scratch_32[4] - 1 + (scratch_32[0] * scratch_32[5])] === 0) {
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] - 1;
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                            ta_pixels_visited[scratch_32[4] - 1 + (scratch_32[0] * scratch_32[5])] = 255;
                        }
                        if (scratch_32[5] - 1 >= 0 && ta_pixels_visited[scratch_32[4] + (scratch_32[0] * (scratch_32[5] - 1))] === 0) {
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] - 1;
                            ta_pixels_visited[scratch_32[4] + (scratch_32[0] * (scratch_32[5] - 1))] = 255;
                        }
                        if (scratch_32[4] + 1 < scratch_32[0] && ta_pixels_visited[scratch_32[4] + 1 + (scratch_32[0] * scratch_32[5])] === 0) {
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] + 1;
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                            ta_pixels_visited[scratch_32[4] + 1 + (scratch_32[0] * scratch_32[5])] = 255;
                        }
                        if (scratch_32[5] + 1 < scratch_32[1] && ta_pixels_visited[scratch_32[4] + (scratch_32[0] * (scratch_32[5] + 1))] === 0) {
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] + 1;
                            ta_pixels_visited[scratch_32[4] + (scratch_32[0] * (scratch_32[5] + 1))] = 255;
                        }
                    }
                    scratch_32[9]++;
                }
                return this;
            }
            return fast_stacked_mapped_flood_fill();
        } else if (bipp === 8) {
            const [w, h] = this.size;
            let fast_stacked_mapped_flood_fill = () => {
                const v = r;
                const buffer = this.buffer;
                const scratch_32 = new Uint32Array(16);
                scratch_32[0] = this.size[0]; 
                scratch_32[1] = this.size[1]; 
                scratch_32[2] = scratch_32[0] * scratch_32[1];
                scratch_32[3] = this.bytes_per_pixel;
                scratch_32[6] = 0 
                scratch_32[7] = 0 
                scratch_32[8] = 0 
                scratch_32[9] = 0 
                const ta8_pixels = new Uint8Array(12);
                ta8_pixels[8] = v;
                const ta_pixels_visited = new Uint8Array(scratch_32[2]);
                const ta_visiting_pixels = new Uint16Array(scratch_32[2] * 2);
                scratch_32[8] = scratch_32[3] * (x + (y * scratch_32[0]));
                ta8_pixels[0] = buffer[scratch_32[8]++];
                ta_visiting_pixels[0] = x;
                ta_visiting_pixels[1] = y;
                scratch_32[7] = 2;
                while (scratch_32[9] <= scratch_32[2]) {
                    scratch_32[4] = ta_visiting_pixels[scratch_32[6]++]; 
                    scratch_32[5] = ta_visiting_pixels[scratch_32[6]++]; 
                    scratch_32[8] = scratch_32[3] * (scratch_32[4] + (scratch_32[5] * scratch_32[0]));
                    if (buffer[scratch_32[8]++] - ta8_pixels[0] === 0) {
                        scratch_32[8] -= 1;
                        buffer[scratch_32[8]++] = ta8_pixels[8];
                        if (scratch_32[4] - 1 >= 0 && ta_pixels_visited[scratch_32[4] - 1 + (scratch_32[0] * scratch_32[5])] === 0) {
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] - 1;
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                            ta_pixels_visited[scratch_32[4] - 1 + (scratch_32[0] * scratch_32[5])] = 255;
                        }
                        if (scratch_32[5] - 1 >= 0 && ta_pixels_visited[scratch_32[4] + (scratch_32[0] * (scratch_32[5] - 1))] === 0) {
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] - 1;
                            ta_pixels_visited[scratch_32[4] + (scratch_32[0] * (scratch_32[5] - 1))] = 255;
                        }
                        if (scratch_32[4] + 1 < scratch_32[0] && ta_pixels_visited[scratch_32[4] + 1 + (scratch_32[0] * scratch_32[5])] === 0) {
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[4] + 1;
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[5];
                            ta_pixels_visited[scratch_32[4] + 1 + (scratch_32[0] * scratch_32[5])] = 255;
                        }
                        if (scratch_32[5] + 1 < scratch_32[1] && ta_pixels_visited[scratch_32[4] + (scratch_32[0] * (scratch_32[5] + 1))] === 0) {
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[4];
                            ta_visiting_pixels[scratch_32[7]++] = scratch_32[5] + 1;
                            ta_pixels_visited[scratch_32[4] + (scratch_32[0] * (scratch_32[5] + 1))] = 255;
                        }
                    }
                    scratch_32[9]++;
                }
                return this;
            }
            return fast_stacked_mapped_flood_fill();
        } else if (bipp === 1) {
            return this.flood_fill_1bipp(x, y, r);
        } else {
            console.trace();
            throw 'Unsupported bipp: ' + bipp;
        }
    }
    'invert'() {
        const {
            bipp
        } = this;
        if (bipp === 1) {
            const {
                ta
            } = this;
            const l = ta.length;
            for (let i = 0; i < l; i++) {
                ta[i] = ~ta[i] & 255;
            }
        } else {
            console.trace();
            throw 'NYI (unsupported bipp) ' + bipp;
        }
    }
    'or'(other_pb) {
        const {
            bipp
        } = this;
        if (bipp === 1) {
            const other_bipp = other_pb.bipp;
            if (other_bipp === 1) {
                const {
                    ta
                } = this;
                const l_my_ta = ta.length;
                const other_ta = other_pb.ta;
                const l_other_ta = other_ta.length;
                if (l_other_ta === l_my_ta) {
                    for (let i = 0; i < l_my_ta; i++) {
                        ta[i] = ta[i] | other_ta[i];
                    }
                } else {
                    console.trace();
                    throw 'lengths of pixel buffer typed arrays must match';
                }
            } else {
                console.trace();
                throw 'bipp values must match (other_pb expected to have bipp: 1)'
            }
        } else {
            console.trace();
            throw 'NYI (unsupported bipp) ' + bipp;
        }
    }
    each_outer_boundary_pixel(callback) {
        let ta_pos = new Uint16Array(2);
        const {size} = this;
        const [w, h] = size;
        ta_pos[0] = 0;
        ta_pos[1] = 0;
        for (ta_pos[0] = 0; ta_pos[0] < w; ta_pos[0]++) {
            const px = this.get_pixel(ta_pos);
            callback(px, ta_pos);
        }
        ta_pos[0]--;
        for (ta_pos[1] = 0; ta_pos[1] < h; ta_pos[1]++) {
            const px = this.get_pixel(ta_pos);
            callback(px, ta_pos);
        }
        ta_pos[1]--;
        for (ta_pos[0] = w - 1; ta_pos[0] > 0; ta_pos[0]--) {
            const px = this.get_pixel(ta_pos);
            callback(px, ta_pos);
        }
        let px = this.get_pixel(ta_pos);
        callback(px, ta_pos);
        for (ta_pos[1] = h - 1; ta_pos[1] > 0; ta_pos[1]--) {
            const px = this.get_pixel(ta_pos);
            callback(px, ta_pos);
        }
        px = this.get_pixel(ta_pos);
        callback(px, ta_pos);
    }
    flood_fill_off_pixels_from_outer_boundary_on_1bipp() {
        this.each_outer_boundary_pixel((b_color, pos) => {
            if (b_color === 0) {
                this.flood_fill_c1_1bipp(pos);
            }
        });
    }
    flood_fill_given_color_pixels_from_outer_boundary(given_color, fill_color) {
        const {
            bits_per_pixel
        } = this;
        if (bits_per_pixel === 24) {
            this.each_outer_boundary_pixel((b_color, pos) => {
                const [r, g, b] = b_color;
                if (r === given_color[0] && g === given_color[1] && b === given_color[2]) {
                    this.flood_fill(pos[0], pos[1], fill_color[0], fill_color[1], fill_color[2]);
                }
            });
        } else if (bits_per_pixel === 1) {
            this.each_outer_boundary_pixel((b_color, pos) => {
                if (b_color === given_color) {
                    this.flood_fill(pos[0], pos[1], fill_color);
                }
            });
        } else {
            console.log('not flood filling');
            console.log('bits_per_pixel', bits_per_pixel);
            throw 'NYI';
            console.trace();
        }
    }
    each_x_span(cb) {
        const [w, h] = this.size;
        const ta_x_span_toggle_bits = get_ta_bits_that_differ_from_previous_as_1s(this.ta);
        let prev_x, prev_y;
        let x_delta, y_delta;
        let color_leading_on_from_current_x_toggle_position;
        const found_empty_rows = (y0, y1_inclusive) => {
        }
        const found_x_span = (x0, x1, y, color) => {
            cb(x0, x1, y, color);
        }
        const complete_previous_row_x_span = () => {
        }
        const complete_any_empty_in_between_rows = () => {
        }
        const complete_current_x_span = (x, y) => {
            found_x_span(prev_x, x - 1, y, color_leading_on_from_current_x_toggle_position);
            color_leading_on_from_current_x_toggle_position^=1;
        }
        const found_row_beginning_color_0_x_span = (x_span_end, y) => {
            found_x_span(0, x_span_end, y, 0);
            color_leading_on_from_current_x_toggle_position = 1;
        }
        const found_row_beginning_color_1_x_span_beginning = (y) => {
            color_leading_on_from_current_x_toggle_position = 1;
        }
        const handle_xy_toggle_position = (x, y) => {
            if (prev_x === undefined) {
                if (y > 0) {
                    found_empty_rows(0, y - 1);
                }
                if (x > 0) {
                    found_row_beginning_color_0_x_span(x, y);
                } else {
                    found_row_beginning_color_1_x_span_beginning(y);
                }
            } else {
                if (y > prev_y) {
                    complete_previous_row_x_span();
                    complete_any_empty_in_between_rows();
                    if (x === 0) {
                        found_row_beginning_color_1_x_span_beginning(y);
                    } else {
                        found_row_beginning_color_0_x_span(x - 1, y);
                    }
                } else {
                    complete_current_x_span(x, y);
                }
            }
            prev_x = x; prev_y = y;
        }
        each_1_index(ta_x_span_toggle_bits, i => {
            const y = Math.floor(i / w);
            const x = i % w;
            handle_xy_toggle_position(x, y);
        });
    }
    not_very_fast_flood_fill_inner_pixels_off_to_on_1bipp() {
        const identify_overlaps = (higher_row_x_spans, lower_row_x_spans) => {
            let i = 0, j = 0;
            const m = higher_row_x_spans.length, n = lower_row_x_spans.length;
            while (i < m && j < n) {
                const a = higher_row_x_spans[i], b = lower_row_x_spans[j];
                if (a.x0_span[1] < b.x0_span[0]) {
                    i++;
                } else if (b.x0_span[1] < a.x0_span[0]) {
                    j++;
                } else {
                    a.connected_below.push(b.idx);
                    b.connected_above.push(a.idx);
                    if (a.x0_span[1] <= b.x0_span[1]) {
                        i++;
                    }
                    if (b.x0_span[1] <= a.x0_span[1]) {
                        j++;
                    }
                }
            }
        }
        const rows_x0spans = this.calculate_arr_rows_arr_x_off_spans_1bipp();
        const arr_all_x_spans = [];
        const arr_y_indexed = new Array(this.size[1]);
        let i2;
        let idx = 0;
        for (let i = 0; i < rows_x0spans.length; i++) {
            const single_row_x0spans = rows_x0spans[i];
            arr_y_indexed[i] = [];
            for (i2 = 0; i2 < single_row_x0spans.length; i2++) {
                const x0_span = single_row_x0spans[i2];
                const o_x0span = {
                    idx: idx++,
                    y: i,
                    x0_span: x0_span,
                    connected_above: [],
                    connected_below: [],
                }
                arr_all_x_spans.push(o_x0span);
                arr_y_indexed[i].push(o_x0span);
            }
        }
        let higher_row_y, lower_row_y;
        let span_above, span_below;
        for (higher_row_y = 0; higher_row_y < this.size[1] - 1; higher_row_y++) {
            identify_overlaps(arr_y_indexed[higher_row_y], arr_y_indexed[higher_row_y + 1]);
        }
        const l = arr_all_x_spans.length;
        let arr_stack_yet_to_visit = [];
        let ui8a_visited_already = new Uint8Array(l);
        let i_group = 0;
        let i_current_group;
        const arr_groups = [];
        const arr_o_groups = [];
        let arr_current_group = [];
        let o_current_group;
        let i_xspan_visiting, xspan_visiting;
        const [width, height] = this.size;
        const hm1 = height - 1, wm1 = width - 1;
        const is_xspan_image_boundary_adjacent = xspan => {
            const {x0_span} = xspan;
            if (xspan.y === 0) return true;
            if (x0_span[0] === 0) return true;
            if (xspan.y === hm1) return true;
            if (x0_span[1] === wm1) return true;
            return false;
        }
        let xspan;
        let idx_span_above, idx_span_below;
        for (let c = 0; c < l; c++) {
            if (ui8a_visited_already[c] === 0) {
                ui8a_visited_already = new Uint8Array(l);
                xspan = arr_all_x_spans[c];
                ui8a_visited_already[c] = 255;
                if (xspan.group === undefined) {
                    i_current_group = i_group++;
                    arr_current_group = [];
                    o_current_group = {
                        index: i_current_group,
                        xspan_indexes: arr_current_group
                    }
                    arr_o_groups.push(o_current_group);
                    arr_groups.push(arr_current_group);
                    if (is_xspan_image_boundary_adjacent(xspan)) {
                        o_current_group.is_boundary_adjacent = true;
                    }
                    xspan.group = i_current_group;
                    arr_current_group.push(c);
                    for (idx_span_above of xspan.connected_above) {
                        if (ui8a_visited_already[idx_span_above] === 0) arr_stack_yet_to_visit.push(idx_span_above);
                    }
                    for (idx_span_below of xspan.connected_below) {
                        if (ui8a_visited_already[idx_span_below] === 0) arr_stack_yet_to_visit.push(idx_span_below);
                    }
                    while (arr_stack_yet_to_visit.length > 0) {
                        i_xspan_visiting = arr_stack_yet_to_visit.pop();
                        if (ui8a_visited_already[i_xspan_visiting] === 0) {
                            xspan_visiting = arr_all_x_spans[i_xspan_visiting];
                            if (is_xspan_image_boundary_adjacent(xspan_visiting)) {
                                o_current_group.is_boundary_adjacent = true;
                            }
                            xspan_visiting.group = i_current_group;
                            arr_current_group.push(i_xspan_visiting);
                            ui8a_visited_already[i_xspan_visiting] = 255;
                            for (idx_span_above of xspan_visiting.connected_above) {
                                if (ui8a_visited_already[idx_span_above] === 0) arr_stack_yet_to_visit.push(idx_span_above);
                            }
                            for (idx_span_below of xspan_visiting.connected_below) {
                                if (ui8a_visited_already[idx_span_below] === 0) arr_stack_yet_to_visit.push(idx_span_below);
                            }
                        }
                    }
                }
            }
        }
        const non_boundary_group_indexes = [];
        for (const g of arr_o_groups) {
            if (!g.is_boundary_adjacent) {
                for (const idx of g.xspan_indexes) {
                    non_boundary_group_indexes.push(idx);
                }
            }
        }
        const write_direct = () => {
            let xspan;
            for (const idx of non_boundary_group_indexes) {
                xspan = arr_all_x_spans[idx];
                this.draw_horizontal_line_on_1bipp_inclusive(xspan.x0_span, xspan.y);
            }
        }
        write_direct();
    }
    flood_fill_inner_pixels_off_to_on_1bipp() {
        return this.not_very_fast_flood_fill_inner_pixels_off_to_on_1bipp();
    }
}
module.exports = Pixel_Buffer_Perf_Focus_Enh;

},{"./pixel-buffer-5-idiomatic-enh":23,"./pixel-pos-list":29}],25:[function(require,module,exports){
const Pixel_Buffer_Perf_Focus_Enh = require('./pixel-buffer-6-perf-focus-enh');
let {resize_ta_colorspace, copy_rect_to_same_size_8bipp, copy_rect_to_same_size_24bipp, dest_aligned_copy_rect_1to4bypp,

    get_ta_bits_that_differ_from_previous_as_1s, each_1_index


} = require('./ta-math');
class Pixel_Buffer_Specialised_Enh extends Pixel_Buffer_Perf_Focus_Enh {
    constructor(...a) {
        super(...a);
        const bounds_within_source = new Int16Array(4);
        Object.defineProperty(this, 'bounds_within_source', {
            get() {
                const size = this.size;
                const pos = this.pos;
                bounds_within_source[0] = pos[0];
                bounds_within_source[1] = pos[1];
                bounds_within_source[2] = pos[0] + size[0];
                bounds_within_source[3] = pos[1] + size[1];
                return bounds_within_source;
            },
            /*
            set(value) {
            },*/
            enumerable: true,
            configurable: false
        });
        const size_bounds = new Int16Array(4);
        Object.defineProperty(this, 'size_bounds', {
            get() {
                const size = this.size;
                size_bounds[0] = 0;
                size_bounds[1] = 0;
                size_bounds[2] = size[0];
                size_bounds[3] = size[1];
                return size_bounds;
            },
            enumerable: true,
            configurable: false
        });
        let pb_source;
        Object.defineProperty(this, 'source', {
            get() { return pb_source; },
            set(value) {
                pb_source = value;
            },
            enumerable: true,
            configurable: false
        });
    }
    copy_from_source() {
        const bipp = this.bipp;
        const pb_source = this.source;
        const ta_source = pb_source.ta;
        const ta = this.ta;
        const my_bounds = this.bounds_within_source;
        const source_size_bounds = pb_source.size_bounds;
        if (bipp === 1) {
            console.trace();
            throw 'NYI';
        } else if (bipp === 8 || bipp === 24 || bipp === 32) {
            dest_aligned_copy_rect_1to4bypp(ta_source, ta, pb_source.bytes_per_row, this.bytes_per_pixel, ta_math.overlapping_bounds(my_bounds, source_size_bounds));
        } else {
            console.trace();
            throw 'stop';
        }
    }
    threshold_gs(value) {
        let res = this.clone();
        if (this.bytes_per_pixel === 1) {
            /*
            this.each_pixel((x, y, v, i) => {
                if (v >= value) {
                    res.set_pixel(x, y, 255);
                } else {
                    res.set_pixel(x, y, 0);
                }
            });
            */
            this.each_pixel((pos, color) => {
                if (color >= value) {
                    res.set_pixel(pos[0], pos[1], 255);
                } else {
                    res.set_pixel(pos[0], pos[1], 0);
                }
            });
        }
        return res;
    }
    padded_each_pixel_index(padding, cb) {
        const ta_32_scratch = new Uint32Array(9);
        ta_32_scratch[0] = this.bytes_per_pixel;
        ta_32_scratch[1] = 0; // i
        ta_32_scratch[2] = this.size[0] - padding;
        ta_32_scratch[3] = this.size[1] - padding;
        ta_32_scratch[7] = this.size[0];
        const bpp = this.bits_per_pixel;
        if (bpp === 32) {
            ((cb) => {
                for (ta_32_scratch[5] = padding; ta_32_scratch[5] < ta_32_scratch[3]; ta_32_scratch[5]++) {
                    for (ta_32_scratch[4] = 0; ta_32_scratch[4] < ta_32_scratch[2]; ta_32_scratch[4]++) {
                        cb((ta_32_scratch[5] * ta_32_scratch[7] + ta_32_scratch[4]) * ta_32_scratch[0]);
                    }
                }
            })(cb);
        } else if (bpp === 24) {
            ((cb) => {
                for (ta_32_scratch[5] = padding; ta_32_scratch[5] < ta_32_scratch[3]; ta_32_scratch[5]++) {
                    for (ta_32_scratch[4] = 0; ta_32_scratch[4] < ta_32_scratch[2]; ta_32_scratch[4]++) {
                        cb((ta_32_scratch[5] * ta_32_scratch[7] + ta_32_scratch[4]) * ta_32_scratch[0]);
                    }
                }
            })(cb);
        } else if (bpp === 8) {
            ((cb) => {
                for (ta_32_scratch[5] = padding; ta_32_scratch[5] < ta_32_scratch[3]; ta_32_scratch[5]++) {
                    for (ta_32_scratch[4] = 0; ta_32_scratch[4] < ta_32_scratch[2]; ta_32_scratch[4]++) {
                        cb((ta_32_scratch[5] * ta_32_scratch[7] + ta_32_scratch[4]) * ta_32_scratch[0]);
                    }
                }
            })(cb);
        } else {
            console.trace();
            throw 'NYI';
        }
    }
    new_window(options) {
        options.window_to = this;
        const res = new this.constructor(options);
        res.copy_from_source();
        return res;
    }
    new_centered_window(size_or_options) {
        console.trace();
        throw 'NYI';
        const t1 = tf(size_or_options);
        console.log('t1', t1);
        let size;
        if (t1 === 'a') {
            if (size_or_options.length === 2) {
                size = new Int16Array([size_or_options, size_or_options]);
            } else {
                console.log('size_or_options', size_or_options);
                console.trace();
                throw 'Size array expected length: 2';
            }
        } else if (t1 === 'n') {
            size = new Int16Array([size_or_options, size_or_options]);
        } else {
            console.trace();
            throw 'NYI';
        }
        const res_pb = new this.constructor({
            size: size,
            bits_per_pixel: this.bits_per_pixel,
            window_to: this
        });
    }
    fill_solid_rect_by_bounds() {
        const bounds = this.ta_bounds;
        const bipp = this.bipp;
        if (bipp === 24) {
            const rgb = this.ta_rgb;
            const bytes_per_bounds_row = (bounds[2] - bounds[0]) * this.bypp;
            const solid_row = new Uint8ClampedArray(bytes_per_bounds_row);
            let cc = 0;
            for (let c = 0; c < bytes_per_bounds_row; c++) {
                solid_row[c] = rgb[cc];
                cc++;
                if (cc === 3) cc = 0;
            }
            let write_byte_idx = bounds[0] * this.bypp + bounds[1] * this.bypr;
            for (let i_row = bounds[1]; i_row < bounds[3]; i_row++) {
                this.ta.set(solid_row, write_byte_idx);
                write_byte_idx += this.bypr;
            }
        } else {
            console.trace();
            throw 'NYI';
        }
    }
    calc_source_target_valid_bounds_overlap() {
        const source = this.source;
        const my_bounds = this.bounds_within_source;
        const source_size_bounds = source.size_bounds;
        const res = this.ta_bounds_scratch;
        if (my_bounds[0] < source_size_bounds[0]) {
            res[0] = source_size_bounds[0];
        } else {
            res[0] = my_bounds[0];
        }
        if (my_bounds[1] < source_size_bounds[1]) {
            res[1] = source_size_bounds[1];
        } else {
            res[1] = my_bounds[1];
        }
        if (my_bounds[2] > source_size_bounds[2]) {
            res[2] = source_size_bounds[2];
        } else {
            res[2] = my_bounds[2];
        }
        if (my_bounds[3] > source_size_bounds[3]) {
            res[3] = source_size_bounds[3];
        } else {
            res[3] = my_bounds[3];
        }
        return res;
    }
    copy_rect_by_bounds_to_24bipp(ta_bounds, pb_target) {
        console.trace();
        throw 'NYI';
        const pos = this.ta_pos_scratch;
        const rect_size = this.ta_size_scratch;
        rect_size[0] = ta_bounds[2] - ta_bounds[0];
        rect_size[1] = ta_bounds[3] - ta_bounds[1];
        console.log('rect_size', rect_size);
        const ta_pointers = this.ta_pointers_scratch;
        const ta_target_pointers = pb_target.ta_pointers_scratch;
        console.log('ta_pointers', ta_pointers);
        console.log('ta_target_pointers', ta_target_pointers);
        console.log('pos', pos);
        console.log('ta_bounds', ta_bounds);
        const ta = this.ta;
        const ta_target = pb_target.ta;
        console.log('pb_target.pos', pb_target.pos);
        const ta_safe_bounds_limits = this.ta_bounds_scratch;
        ta_safe_bounds_limits[0] = 0;
        ta_safe_bounds_limits[1] = 0;
        ta_safe_bounds_limits[2] = this.size[0];
        ta_safe_bounds_limits[3] = this.size[1];
        const ta_safe_adjusted_bounds = this.ta_bounds2_scratch;
        const ta_bounds_adjustments = this.ta_bounds3_scratch;
        const ta_bounds_byte_offsets = this.ta_bounds3_scratch;
        if (ta_bounds[0] >= ta_safe_bounds_limits[0]) {
            ta_safe_adjusted_bounds[0] = ta_bounds[0];
            ta_bounds_adjustments[0] = 0;
        } else {
            ta_bounds_adjustments[0] = ta_safe_bounds_limits[0] - ta_bounds[0];
            ta_safe_adjusted_bounds[0] = ta_safe_bounds_limits[0];
        }
        if (ta_bounds[1] >= ta_safe_bounds_limits[1]) {
            ta_safe_adjusted_bounds[1] = ta_bounds[1];
            ta_bounds_adjustments[1] = 0;
        } else {
            ta_bounds_adjustments[1] = ta_safe_bounds_limits[1] - ta_bounds[1];
            ta_safe_adjusted_bounds[1] = ta_safe_bounds_limits[1];
        }
        if (ta_bounds[2] <= ta_safe_bounds_limits[2]) {
            ta_safe_adjusted_bounds[2] = ta_bounds[2];
            ta_bounds_adjustments[2] = 0;
        } else {
            ta_bounds_adjustments[2] = ta_safe_bounds_limits[2] - ta_bounds[2];
            ta_safe_adjusted_bounds[2] = ta_safe_bounds_limits[2];
        }
        if (ta_bounds[3] <= ta_safe_bounds_limits[3]) {
            ta_safe_adjusted_bounds[3] = ta_bounds[3];
            ta_bounds_adjustments[3] = 0;
        } else {
            ta_bounds_adjustments[3] = ta_safe_bounds_limits[3] - ta_bounds[3];
            ta_safe_adjusted_bounds[3] = ta_safe_bounds_limits[3];
        }
        console.log('ta_safe_adjusted_bounds', ta_safe_adjusted_bounds);
        console.log('ta_bounds_adjustments', ta_bounds_adjustments);
        console.log('this.bytes_per_row', this.bytes_per_row);
        const source_bytes_per_row = this.bytes_per_row;
        const bypp = this.bypp;
        const adjusted_safe_bounds_source_read_byte_offsets = this.ta_offsets_scratch;
        adjusted_safe_bounds_source_read_byte_offsets[0] = ta_bounds_adjustments[0] * bypp;
        adjusted_safe_bounds_source_read_byte_offsets[1] = ta_bounds_adjustments[1] * source_bytes_per_row;
        adjusted_safe_bounds_source_read_byte_offsets[2] = ta_bounds_adjustments[2] * bypp;
        adjusted_safe_bounds_source_read_byte_offsets[3] = ta_bounds_adjustments[3] * source_bytes_per_row;
        console.log('adjusted_safe_bounds_source_read_byte_offsets', adjusted_safe_bounds_source_read_byte_offsets);
        const adjusted_safe_bounds_target_write_byte_offsets = pb_target.ta_offsets_scratch;
        const ta_pp_source_read = this.ta_pointerpair_scratch;
        const ta_pp_target_write = pb_target.ta_pointerpair_scratch;
        const bytes_per_row_of_safe_bounds = (ta_safe_adjusted_bounds[2] - ta_safe_adjusted_bounds[0]) * bypp;
        console.log('bytes_per_row_of_safe_bounds', bytes_per_row_of_safe_bounds);
        ta_pp_source_read[0] = adjusted_safe_bounds_source_read_byte_offsets[0] + adjusted_safe_bounds_source_read_byte_offsets[1];
        ta_pp_source_read[1] = ta_pp_source_read[0] + bytes_per_row_of_safe_bounds;
        ta_pp_target_write[0] = 0; // no, it's the left indent of the safe bounds.
        ta_pp_target_write[1] = ta_pp_target_write[0] + bytes_per_row_of_safe_bounds;
        console.log('ta_pp_source_read', ta_pp_source_read);
        console.log('ta_pp_target_write', ta_pp_target_write);
        console.log('pb_target.bytes_per_row', pb_target.bytes_per_row);
        const num_rows_to_copy = ta_safe_adjusted_bounds[3] - ta_safe_adjusted_bounds[1];
        console.log('num_rows_to_copy', num_rows_to_copy);
        for (let c = 0; c < num_rows_to_copy; c++) {
            const sa_source_row = ta.subarray(ta_pp_source_read[0], ta_pp_source_read[1]);
            console.log('sa_source_row', sa_source_row);
        }
        for (pos[1] = ta_bounds[1]; pos[1] < ta_bounds[3]; pos[1]++) {
        }
        if (rect_size[0] === pb_target.size[0] && rect_size[1] === pb_target.size[1]) {
            console.log('rect_size matches target size.')
        }
    }


    // And this could be done in a more optimised bitwise way.

    'get_ta_contiguous_spans_1bipp_toggle'() {
        const get_count = () => {
            const initial_color = 0;
            let color = initial_color;
            let count_color_changes = 0;
            this.each_pixel(([x, y], px_color) => {
                if (px_color !== color) {
                    count_color_changes++;
                }
                color = px_color;
            });
            count_color_changes++;
            return count_color_changes;
        }
        const get_max_span_length = () => {
            const initial_color = 0;
            let color = initial_color;
            let l = 0;
            let max_l = 0;
            this.each_pixel(([x, y], px_color) => {
                if (px_color !== color) {
                    l = 0;
                } else {
                    l++;
                    if (l > max_l) max_l = l;
                }
                color = px_color;
            });
            return max_l + 1;
        }
        const nccs = get_count();
        const max_xpan_l = get_max_span_length();
        if (max_xpan_l <= 255) {
            const res = new Uint8Array(nccs);
            const initial_color = 0;
            let color = initial_color;
            let count_color_changes = 0;
            let l = -1;
            this.each_pixel(([x, y], px_color) => {
                if (px_color !== color) {
                    res[count_color_changes] = l + 1;
                    count_color_changes++;
                    l = 0;
                } else {
                    l++;
                }
                color = px_color;
            });
            res[count_color_changes] = l + 1;
            return res;
        } else {
            console.trace();
            throw 'stop';
        }
    }
    'count_row_on_xspans_1bipp'(y) {
        let res = 0;
        const width = this.size[0];
        let last_color = 1;
        let current_color;
        let ta_pos = new Uint16Array(2);
        ta_pos[1] = y;
        for (let x = 0; x < width; x++) {
            ta_pos[0] = x;
            current_color = this.get_pixel_1bipp(ta_pos);
            if (current_color === 1) {
                if (current_color === last_color) {
                    if (res === 0) {
                        res++;
                    } else {
                    }
                } else {
                    res++;
                }
            }
            last_color = current_color;
        }
        return res;
    }
    'calculate_ta_row_x_off_x2ygbspans_1bipp'(y) {
        const count_xoffspans = this.count_row_off_xspans_1bipp(y);
        const res = new Uint16Array(count_xoffspans * 5);
        let i_w = 0;
        const width = this.size[0];
        let last_color = 0;
        let current_color;
        let ta_pos = new Uint16Array(2);
        ta_pos[1] = y;
        for (let x = 0; x < width; x++) {
            ta_pos[0] = x;
            current_color = this.get_pixel_1bipp(ta_pos);
            if (current_color === 0) {
                if (current_color === last_color) {
                    if (res.length === 0) {
                        res[i_w++] = x;
                        res[i_w++] = x;
                        res[i_w++] = y;
                        res[i_w++] = 0; // 0 for undefined group here....
                        res[i_w++] = 0; // 0 for undefined border status here
                    } else {
                        res[i_w - 4]++;
                    }
                } else {
                    res[i_w++] = x;
                    res[i_w++] = x;
                    res[i_w++] = y;
                    res[i_w++] = 0; // 0 for undefined group here....
                    res[i_w++] = 0; // 0 for undefined border status here
                }
            }
            last_color = current_color;
        }
        return res;
    }
    'calculate_arr_row_x_off_spans_1bipp'(y) {
            const res = [];
            const width = this.size[0];
            const {ta} = this;
            let last_color = 0;
            let current_color;
            const x_start = 0;
            let idx_bit_overall = ((y * this.size[0]) + x_start) | 0, idx_bit_within_byte = 0 | 0;
            let arr_last;
            let num_bits_remaining = width;
            let x = 0; // an x local value is fine - will update it as necessary
            let has_just_done_multi_read = false;
            let byte_val = 0 | 0;
            while (num_bits_remaining > 0) {
                idx_bit_within_byte = idx_bit_overall & 0b111;
                has_just_done_multi_read = false;
                if (idx_bit_within_byte === 0 && num_bits_remaining >= 8) {
                    byte_val = ta[idx_bit_overall >> 3];
                    if (byte_val === 255) {
                        last_color = 1;
                        has_just_done_multi_read = true;
                        idx_bit_overall += 8;
                        x += 8;
                        num_bits_remaining -= 8;
                    } else if (byte_val === 0) {
                        if (last_color === 0) {
                            if (res.length === 0) {
                                if (arr_last) res.push(arr_last);
                                arr_last = [x, x + 7];
                            } else {
                                arr_last[1] += 8;
                            }
                        } else {
                            if (arr_last) res.push(arr_last);
                            arr_last = [x, x + 7];
                        }
                        x += 8;
                        last_color = 0;
                        num_bits_remaining -= 8;
                        idx_bit_overall += 8;
                        has_just_done_multi_read = true;
                    } else {
                    }
                }
                if (!has_just_done_multi_read) {
                    current_color = ((ta[idx_bit_overall >> 3] & 128 >> (idx_bit_within_byte)) !== 0) ? 1 : 0;
                    if (current_color === 0) {
                        if (current_color === last_color) {
                            if (res.length === 0) {
                                if (arr_last) res.push(arr_last);
                                arr_last = [x, x];
                            } else {
                                arr_last[1]++;
                            }
                        } else {
                            if (arr_last) res.push(arr_last);
                            arr_last = [x, x];
                        }
                    }
                    last_color = current_color;
                    idx_bit_overall++;
                    x++;
                    num_bits_remaining--;
                }
            }
            if (arr_last) res.push(arr_last);
            return res;
    }

    // Could see about a more optimised way to do it that does not go row-by-row.


    // Do want a simpler way....

    // Want something with a callback for each y value.....



    // Does seem a bit tricky for the moment.

    // Want to streamline it more!





    'opt_calculate_arr_rows_arr_x_off_spans_1bipp'() {

        // Think we need to redo this.....
        // Have a handle_y_change function.

        


        const ta_x_span_toggle_bits = get_ta_bits_that_differ_from_previous_as_1s(this.ta);

        // Or get a typed array of the 1 indexes.



        // Then an interator of that, by rows....?
        // says which row each of these is?
        // provides an array of x positions for each row?

        // Or other type of iteration, go through the values, track the rows. Got a bit stuck with that way though.







        //const c_all = count_1s(ta_x_span_toggle_bits);

        const [w, h] = this.size;


        const get_arr_arr_toggle_positions = () => {
            let prev_y = -1;
            let prev_x = -1;

            let arr_positions_in_row;
            const res = new Array(h);

            // complete a row...

            // complete it...?
            

            const handle_row_complete = (y, arr_x_toggle_positions) => {
                res[y] = arr_x_toggle_positions;
            }

            // Where it iterates through the rows, and for each row it runs a 'catch up and complete' function?
            //   Or read until we have one that is not in that row?

            // Row by row iteration does seem best.

            // .row_bitindex_ranges????

            // And an algorithm that checks and groups with rows above too?
            







            each_1_index(ta_x_span_toggle_bits, i => {
            
                // Should probably iterate them (better) by rows.

                // And when it's the first in a row?

                //console.log('i', i);



                const y = Math.floor(i / w);
                const x = i % w;

                //current_y = y;

                if (y !== prev_y) {
                    
                    //console.log('y', y);

                    const y_diff = y - prev_y;

                    // complete it...????
                    if (arr_positions_in_row) {
                        arr_positions_in_row.push(prev_x);
                        handle_row_complete(prev_y, arr_positions_in_row);

                    }

                    if (y_diff > 1) {
                        // then the empty rows....

                        //const num_empty_rows = y_diff - 1;
                        for (let y2 = prev_y + 1; y2 < y; y2++) {
                            handle_row_complete(y2, []);
                        }

                    }

                    arr_positions_in_row = [x];

                    // then begin the new row.
                    //  do we have a toggle position already????


                    

                    // then write the previous line????
                    //   Let's just track the values for that row.



                    
                    //handle_y_change_from_new_toggle_position(prev_y, y, x);

                    

                    // then recognise the first span of the row.
                    
                } else {
                    arr_positions_in_row.push(x);
                }

                prev_x = x;
                prev_y = y;

                //current_i++;

            });

            return res;
        }

        const arr_arr_toggle_positions = get_arr_arr_toggle_positions();
        console.log('arr_arr_toggle_positions.length', arr_arr_toggle_positions.length);
        console.log('h', h);

        throw 'stop'


        


        const _second_attempt = () => {

            let prev_y = -1;
            //let current_y = -1;
            let current_i = 0;
            let current_color = 0;
            let arr_current_row_arr_off_spans;
            let current_span_start_x, current_span_end_x;

            let is_first_span_in_row = true;

            // current span end x

            let res = [];
            
            
            const handle_row_complete = (arr_row, prev_y, new_y) => {
                if (arr_row) {
                    res.push(arr_row);
                    
                }
                arr_current_row_arr_off_spans = [];
                
                //current_y
            }

            const handle_span_off_start = (x, y) => {
                current_span_start_x = x;
            }
            const handle_span_off_end = (x, y) => {
                current_span_end_x = x;
                arr_current_row_arr_off_spans.push([current_span_start_x, current_span_end_x]);
            }

            const place_empty_row = () => {
                res.push([0, w - 1]);
            }

            const handle_y_change_from_new_toggle_position = (prev_y, y, x) => {


                // finish current row.
                // write any empty rows in between.
                // start the span in the current row.
                handle_row_complete(arr_current_row_arr_off_spans, prev_y, y);
                prev_y++;

                while (prev_y < y) {
                    // empty row....
                    place_empty_row();
                    prev_y++;
                }

                is_first_span_in_row = true;
                if (x === 0) {
                    current_color = 1;
                } else {

                    if (current_color === 1) {
                        handle_span_off_start(x, y);
                        current_color = 0;
                    } else {
                        handle_span_off_start(0, y);
                        handle_span_off_end(x - 1, y);
                        current_color = 1;
                    }


                    //current_color = 0;
                    
                }

            }

            // Need simpler toggle position logic.
            //   Grouping them by their rows could help.



            

            each_1_index(ta_x_span_toggle_bits, i => {
        
                // Should probably iterate them (better) by rows.

                // And when it's the first in a row?

                //console.log('i', i);



                const y = Math.floor(i / w);
                const x = i % w;

                //current_y = y;

                if (y !== prev_y) {
                    handle_y_change_from_new_toggle_position(prev_y, y, x);

                    

                    // then recognise the first span of the row.
                }


                current_i++;

            });

            return res;

        }

        



        


        // But the size will be offset somehow.....

        //console.log('this._offset', this._offset);

        //console.log('this.size', this.size);

        //console.log('[w, h]', [w, h]);

        //console.log('this.ta[0]', this.ta[0]);

        //console.log('this.ta', this.ta);

        //throw 'stop';

        



        const old_attempt = () => {
                // Iterate those toggle bits....

                let prev_x = 0, prev_y = 0;

                const arr_rows_arr_x_off_spans_1bipp = [];
    
                let current_row = [];
    
                //let prev_i;
    
                // All spans?
    
                // Maybe better by far to operate on the rows explicitly.
    
                let current_color = 0;
    
                // See about upgrading the flood fill function / find x off spans.
    
                // Probably need to redo this.
                //   Have an iterator that provides an array of all the rows.
    
                // each_row_x_span_toggle_bits perhaps.
    
                // or a handle new row inner function?
    
                each_1_index(ta_x_span_toggle_bits, i => {
    
                    // Should probably iterate them (better) by rows.
    
                    // And when it's the first in a row?
    
                    //console.log('i', i);
    
    
    
                    const y = Math.floor(i / w);
                    const x = i % w;
    
                    //console.log('[x, y]', [x, y]);
    
                    //throw 'stop';
    
                    // detect the row starting color being 1????
                    //   so an absence of it means there is an x span.
    
                    // a callback with the points even?
    
    
    
                    if (y > prev_y) {
    
                        // End the row we were on.
    
    
    
                        // it's another row.
                        //   write the prev row.
    
                        // and the previous index...???
                        //   what is the distance????
    
                        // finish the current_row row....
    
                        //const span_length = x - prev_x;
                        //const span_color = current_color;
    
    
                        
    
                        if (current_color === 0) {
                            //const span_pair = [[prev_x, prev_y], [w, prev_y]];
                            //console.log('span_pair', span_pair);
                            //current_row.push([[prev_x, prev_y], [w - 1, prev_y]]);
    
                            current_row.push([prev_x, w - 1]);
                        }
                        // span until the end of the row.
    
    
    
                        //console.log('current_row', current_row);
    
    
    
                        // May differ by more than one.
                        arr_rows_arr_x_off_spans_1bipp.push(current_row);
                        current_row = [];
                        prev_y++;
                        prev_x = 0;
                        
    
                        while (y > prev_y) {
                            // it's another row.
                            //   write the prev row.
            
                            // May differ by more than one.
            
                            // it's an off x span.
                            current_row.push([0, w - 1]);
            
                            arr_rows_arr_x_off_spans_1bipp.push(current_row);
                            current_row = [];
                            prev_y++;
                            prev_x = 0;
                        }
    
                        current_color = 0;
                        current_row = [[0, x]];
                        
                        prev_x = x;
    
                    }
                    
    
                    // Start a span.
    
                    if (x === 0) {  
                        current_color = 1;
                    } else {
                        
                        // and how many since the prev x
    
                        //const span_length = x - prev_x;
                        //const span_color = current_color;
    
    
                        
    
                        if (current_color === 0) {
                            //const span_pair = [[prev_x, y], [x, y]];
                            //console.log('span_pair', span_pair);
                            current_row.push([prev_x + 1, x]);
                        }
    
                        current_color ^= 1;
                        
                        //current_color = current_color === 0 ? 1 : 0;
    
                    }
    
                    //console.log('[x, y]', [x, y]);
                    //console.log('w', w);
                    //console.log('i / w', i / w);
    
                    prev_y = y;
                    //prev_i = i;
                    prev_x = x;
                });
    
                // finish the current row
    
                if (current_color === 0) {
                    //const span_pair = [[prev_x, prev_y], [w, prev_y]];
                    //console.log('span_pair', span_pair);
                    current_row.push([prev_x, w - 1]);
                    arr_rows_arr_x_off_spans_1bipp.push(current_row);
                }
    
    
                const last_row_y = (h - 1);
    
                let y = prev_y;
    
                //console.log('prev_y', prev_y);
                //throw 'stop';
    
                y++;
    
                if (y < h) {
    
                    
                    //current_row.push([[prev_x, prev_y], [w, prev_y]]);
                    
    
                    //for (let y = prev_y + 1; y < h; y++) {
                        //arr_rows_arr_x_off_spans_1bipp.push([[[0, y], [w, y]]]);
                    //}
    
                    while (y < h) {
                        arr_rows_arr_x_off_spans_1bipp.push([[0, w - 1]]);
                        y++;
                    }
                    arr_rows_arr_x_off_spans_1bipp.push([[0, w - 1]]);
                    //arr_rows_arr_x_off_spans_1bipp.push([[[0, y], [w, y]]]);
                }
    
                //console.log(JSON.stringify(arr_rows_arr_x_off_spans_1bipp, null, 4));
    
                //console.log('h', h);
    
                //console.log('arr_rows_arr_x_off_spans_1bipp.length', arr_rows_arr_x_off_spans_1bipp.length);
    
                //throw 'stop';
    
                return arr_rows_arr_x_off_spans_1bipp;
        }

        

    }
    'simpler_calculate_arr_rows_arr_x_off_spans_1bipp'() {
        const [width, height] = this.size;
        const res = new Array(height);
        for (let y = 0; y < height; y++) {
            res[y] = this.calculate_arr_row_x_off_spans_1bipp(y);
        }
        return res;
    }

    'calculate_arr_rows_arr_x_off_spans_1bipp'() {

        // Will have a more optimised way to do this....
        //   Bitwise ops involved.
        return this.simpler_calculate_arr_rows_arr_x_off_spans_1bipp();
        

        const scalc = this.simpler_calculate_arr_rows_arr_x_off_spans_1bipp();

        console.log(JSON.stringify(scalc).slice(0, 2000).replaceAll(',', ', '));

        //return this.opt_calculate_arr_rows_arr_x_off_spans_1bipp();

        const ocalc = this.opt_calculate_arr_rows_arr_x_off_spans_1bipp();


        console.log('\n\n');

        console.log(JSON.stringify(ocalc).slice(0, 2000).replaceAll(',', ', '));
        

        return ocalc;
        /*

        

        */
    }


    'calculate_arr_rows_arr_x_on_spans_1bipp'() {
        const [width, height] = this.size;
        const res = new Array(height);
        for (let y = 0; y < height; y++) {
            res[y] = this.calculate_arr_row_x_on_spans_1bipp(y);
        }
        return res;
    }
    'count_row_off_xspans_1bipp'(y) {
        let res = 0;
        const width = this.size[0];
        let last_color = 0;
        let current_color;
        let ta_pos = new Uint16Array(2);
        ta_pos[1] = y;
        for (let x = 0; x < width; x++) {
            ta_pos[0] = x;
            current_color = this.get_pixel_1bipp(ta_pos);
            if (current_color === 0) {
                if (current_color === last_color) {
                    if (res.length === 0) {
                        res++;
                    } else {
                    }
                } else {
                    res++;
                    if (res.length === 0) {
                    } else {
                    }
                }
            }
            last_color = current_color;
        }
        return res;
    }
    'calculate_ta_row_x_on_x2ygbspans_1bipp'(y) {
        const count_xonspans = this.count_row_on_xspans_1bipp(y);
        const res = new Uint16Array(count_xonspans * 5);
        console.log('y, count_xonspans', y, count_xonspans);
        let i_w = 0;
        const width = this.size[0];
        let last_color = 1;
        let current_color;
        let ta_pos = new Uint16Array(2);
        ta_pos[1] = y;
        for (let x = 0; x < width; x++) {
            ta_pos[0] = x;
            current_color = this.get_pixel_1bipp(ta_pos);
            if (current_color === 1) {
                if (current_color === last_color) {
                    if (res.length === 0) {
                        res[i_w++] = x;
                        res[i_w++] = x;
                        res[i_w++] = y;
                        res[i_w++] = 0; // 0 for undefined group here....
                        res[i_w++] = 0; // 0 for undefined border status here
                    } else {
                        res[i_w - 4]++;
                    }
                } else {
                    res[i_w++] = x;
                    res[i_w++] = x;
                    res[i_w++] = y;
                    res[i_w++] = 0; // 0 for undefined group here....
                    res[i_w++] = 0; // 0 for undefined border status here
                }
            }
            last_color = current_color;
        }
        return res;
    }
    'calculate_arr_rows_ta_x_off_x2ygbspans_1bipp'() {
        const [width, height] = this.size;
        const res = new Array(height);
        for (let y = 0; y < height; y++) {
            res[y] = this.calculate_ta_row_x_off_x2ygbspans_1bipp(y);
        }
        return res;
    }
    'calculate_arr_rows_ta_x_on_x2ygbspans_1bipp'() {
        const [width, height] = this.size;
        const res = new Array(height);
        for (let y = 0; y < height; y++) {
            res[y] = this.calculate_ta_row_x_on_x2ygbspans_1bipp(y);
        }
        console.log('* this.ta', this.ta);
        console.log('this.size', this.size);
        return res;
    }
    'calculate_arr_row_x_on_spans_1bipp'(y) {
        const initial_implementation = () => {
                const res = [];
            const width = this.size[0];
            let last_color = 1;
            let current_color;
            let ta_pos = new Uint16Array(2);
            ta_pos[1] = y;
            for (let x = 0; x < width; x++) {
                ta_pos[0] = x;
                current_color = this.get_pixel_1bipp(ta_pos);
                if (current_color === 1) {
                    if (current_color === last_color) {
                        if (res.length === 0) {
                            res.push([x, x]);
                        } else {
                            res[res.length - 1][1]++;
                        }
                    } else {
                        res.push([x, x]);
                    }
                }
                last_color = current_color;
            }
            return res;
        }
        const _64x0 = BigInt(0);
        const _64x1 = ~_64x0;
        const broken_64bit_optimisation_attempt_inlined_consecutive_value_checking_no_x_loop_implementation = () => {
            const COLOR_LOOKING_FOR = 1;
            const COLOR_NOT_LOOKING_FOR = 0;
            const res = [];
            const width = this.size[0];
            const {ta} = this;
            const ab = ta.buffer;
            const dv = new DataView(ab);
            let last_color = 1; // Try keeping it for the moment.
            let current_color;
            const x_start = 0;
            let idx_bit_overall = ((y * this.size[0]) + x_start) | 0, idx_bit_within_byte = 0 | 0;
            let arr_last;
            let num_bits_remaining = width;
            let x = 0; // an x local value is fine - will update it as necessary
            let has_just_done_multi_read = false;
            let byte_val = 0 | 0;
            let _8_byte_val = BigInt(0);
            while (num_bits_remaining > 0) {
                idx_bit_within_byte = idx_bit_overall & 0b111;
                has_just_done_multi_read = false;
                if (idx_bit_within_byte === 0 && num_bits_remaining >= 8) {
                    if (num_bits_remaining >= 64) {
                        _8_byte_val = dv.getBigInt64(idx_bit_overall >> 3);
                        if (_8_byte_val === _64x0) {
                            last_color = 0;
                            has_just_done_multi_read = true;
                            idx_bit_overall += 64;
                            x += 64;
                            num_bits_remaining -= 64;
                        } else if (_8_byte_val === _64x1) {
                            if (last_color === 1) {
                                if (res.length === 0) {
                                    arr_last = [x, x + 63];
                                    res.push(arr_last);
                                } else {
                                    arr_last[1] += 64;
                                }
                            } else {
                                arr_last = [x, x + 63];
                                res.push(arr_last);
                            }
                            x += 8;
                            last_color = 1;
                            num_bits_remaining -= 64;
                            idx_bit_overall += 64;
                            has_just_done_multi_read = true;
                        }
                    } else {
                    }
                    if (!has_just_done_multi_read) {
                        byte_val = ta[idx_bit_overall >> 3];
                        if (byte_val === 255) {
                            if (last_color === 1) {
                                if (res.length === 0) {
                                    arr_last = [x, x + 7];
                                    res.push(arr_last);
                                } else {
                                    arr_last[1] += 8;
                                }
                            } else {
                                arr_last = [x, x + 7];
                                res.push(arr_last);
                            }
                            x += 8;
                            last_color = 1;
                            num_bits_remaining -= 8;
                            idx_bit_overall += 8;
                            has_just_done_multi_read = true;
                        } else if (byte_val === 0) {
                            last_color = 0;
                            has_just_done_multi_read = true;
                            idx_bit_overall += 8;
                            x += 8;
                            num_bits_remaining -= 8;
                        } else {
                        }
                    }
                }
                if (!has_just_done_multi_read) {
                    current_color = ((ta[idx_bit_overall >> 3] & 128 >> (idx_bit_within_byte)) !== 0) ? 1 : 0;
                    if (current_color === 1) {
                        if (current_color === last_color) {
                            if (res.length === 0) {
                                arr_last = [x, x];
                                res.push(arr_last);
                            } else {
                                arr_last[1]++;
                            }
                        } else {
                            arr_last = [x, x];
                            res.push(arr_last);
                        }
                    }
                    last_color = current_color;
                    idx_bit_overall++;
                    x++;
                    num_bits_remaining--;
                }
            }
            return res;
        }
        const inlined_consecutive_value_checking_no_x_loop_implementation = () => {
            const COLOR_LOOKING_FOR = 1;
            const COLOR_NOT_LOOKING_FOR = 0;
            const res = [];
            const width = this.size[0];
            const {ta} = this;
            const ab = ta.buffer;
            const dv = new DataView(ab);
            let last_color = 1; // Try keeping it for the moment.
            let current_color;
            const x_start = 0;
            let idx_bit_overall = ((y * this.size[0]) + x_start) | 0, idx_bit_within_byte = 0 | 0;
            let arr_last;
            let num_bits_remaining = width;
            let x = 0; // an x local value is fine - will update it as necessary
            let has_just_done_multi_read = false;
            let byte_val = 0 | 0;
            while (num_bits_remaining > 0) {
                idx_bit_within_byte = idx_bit_overall & 0b111;
                has_just_done_multi_read = false;
                if (idx_bit_within_byte === 0 && num_bits_remaining >= 8) {
                    /*
                    if (num_bits_remaining >= 64) {
                    } else {
                    }
                    */
                    byte_val = ta[idx_bit_overall >> 3];
                    if (byte_val === 255) {
                        if (last_color === 1) {
                            if (res.length === 0) {
                                arr_last = [x, x + 7];
                                res.push(arr_last);
                            } else {
                                arr_last[1] += 8;
                            }
                        } else {
                            arr_last = [x, x + 7];
                            res.push(arr_last);
                        }
                        x += 8;
                        last_color = 1;
                        num_bits_remaining -= 8;
                        idx_bit_overall += 8;
                        has_just_done_multi_read = true;
                    } else if (byte_val === 0) {
                        last_color = 0;
                        has_just_done_multi_read = true;
                        idx_bit_overall += 8;
                        x += 8;
                        num_bits_remaining -= 8;
                    } else {
                    }
                }
                if (!has_just_done_multi_read) {
                    current_color = ((ta[idx_bit_overall >> 3] & 128 >> (idx_bit_within_byte)) !== 0) ? 1 : 0;
                    if (current_color === 1) {
                        if (current_color === last_color) {
                            if (res.length === 0) {
                                arr_last = [x, x];
                                res.push(arr_last);
                            } else {
                                arr_last[1]++;
                            }
                        } else {
                            arr_last = [x, x];
                            res.push(arr_last);
                        }
                    }
                    last_color = current_color;
                    idx_bit_overall++;
                    x++;
                    num_bits_remaining--;
                }
            }
            return res;
        }
        const inlined_consecutive_value_checking_no_x_loop_delayed_push_implementation = () => {
            const COLOR_LOOKING_FOR = 1;
            const COLOR_NOT_LOOKING_FOR = 0;
            const res = [];
            const width = this.size[0];
            const {ta} = this;
            const ab = ta.buffer;
            const dv = new DataView(ab);
            let last_color = 1; // Try keeping it for the moment.
            let current_color;
            const x_start = 0;
            let idx_bit_overall = ((y * this.size[0]) + x_start) | 0, idx_bit_within_byte = 0 | 0;
            let arr_last;
            let num_bits_remaining = width;
            let x = 0; // an x local value is fine - will update it as necessary
            let has_just_done_multi_read = false;
            let byte_val = 0 | 0;
            while (num_bits_remaining > 0) {
                idx_bit_within_byte = idx_bit_overall & 0b111;
                has_just_done_multi_read = false;
                if (idx_bit_within_byte === 0 && num_bits_remaining >= 8) {
                    /*
                    if (num_bits_remaining >= 64) {
                    } else {
                    }
                    */
                    byte_val = ta[idx_bit_overall >> 3];
                    if (byte_val === 255) {
                        if (last_color === 1) {
                            if (res.length === 0) {
                                if (arr_last) {
                                    res.push(arr_last);
                                }
                                arr_last = [x, x + 7];
                            } else {
                                arr_last[1] += 8;
                            }
                        } else {
                            if (arr_last) {
                                res.push(arr_last);
                            }
                            arr_last = [x, x + 7];
                        }
                        x += 8;
                        last_color = 1;
                        num_bits_remaining -= 8;
                        idx_bit_overall += 8;
                        has_just_done_multi_read = true;
                    } else if (byte_val === 0) {
                        last_color = 0;
                        has_just_done_multi_read = true;
                        idx_bit_overall += 8;
                        x += 8;
                        num_bits_remaining -= 8;
                    } else {
                    }
                }
                if (!has_just_done_multi_read) {
                    current_color = ((ta[idx_bit_overall >> 3] & 128 >> (idx_bit_within_byte)) !== 0) ? 1 : 0;
                    if (current_color === 1) {
                        if (current_color === last_color) {
                            if (res.length === 0) {
                                if (arr_last) {
                                    res.push(arr_last);
                                }
                                arr_last = [x, x];
                            } else {
                                arr_last[1]++;
                            }
                        } else {
                            if (arr_last) {
                                res.push(arr_last);
                            }
                            arr_last = [x, x];
                        }
                    }
                    last_color = current_color;
                    idx_bit_overall++;
                    x++;
                    num_bits_remaining--;
                }
            }
            if (arr_last) {
                res.push(arr_last);
            }
            return res;
        }
        return inlined_consecutive_value_checking_no_x_loop_delayed_push_implementation();
    }
}
const get_contig_x_spans_AND = (ta_contig_x_spans_1, ta_contig_x_spans_2) => {
    if (true || ta_contig_x_spans_1.length === ta_contig_x_spans_2.length) {
        const parallel_iterate_inputs = () => {
            const starting_color = 0;
            const l1 = ta_contig_x_spans_1.length, l2 = ta_contig_x_spans_2.length;
            let r_pos_in_1 = 0, r_pos_in_2 = 0;
            let px_idx_in_1 = 0, px_idx_in_2 = 0;
            let color_in_1 = starting_color, color_in_2 = starting_color;
            let color_in_output = starting_color;
            let pos_idx_in_output = 0;
            let are_in_sync = true;
            let i_read_step = 0;
            const arr_res = [];
            const read_step = () => {
                const span_length_from_1 = ta_contig_x_spans_1[r_pos_in_1], span_length_from_2 = ta_contig_x_spans_2[r_pos_in_2];
                console.log('');
                console.log('i_read_step', i_read_step);
                console.log('are_in_sync', are_in_sync);
                console.log('span_length_from_1', span_length_from_1);
                console.log('span_length_from_2', span_length_from_2);
                if (are_in_sync) {
                    if (px_idx_in_1 === px_idx_in_2) {
                        if (span_length_from_1 === span_length_from_2) {
                            if (are_in_sync) {
                                const same_length_in_sync = span_length_from_1;
                                console.log('same_length_in_sync', same_length_in_sync);
                                px_idx_in_1 += same_length_in_sync;
                                px_idx_in_2 += same_length_in_sync;
                                pos_idx_in_output += same_length_in_sync;
                                r_pos_in_1++;
                                r_pos_in_2++;
                                arr_res.push(same_length_in_sync);
                                color_in_1 = color_in_1 === 1 ? 0 : 1;
                                color_in_2 = color_in_2 === 1 ? 0 : 1;
                                color_in_output = color_in_output === 1 ? 0 : 1;
                            } else {
                                console.trace();
                                throw 'NYI';
                            }
                        } else if (span_length_from_1 > span_length_from_2) {
                            if (are_in_sync) {
                                const num_remaining_in_sync = span_length_from_2;
                                arr_res.push(num_remaining_in_sync);
                                console.trace();
                                throw 'NYI';
                            } else {
                                console.trace();
                                throw 'NYI';
                            }
                        } else {
                            console.trace();
                            throw 'NYI';
                        }
                    } else {
                        console.trace();
                        throw 'NYI';
                    }
                } else {
                    console.trace();
                    throw 'NYI';
                }
                i_read_step++;
            }
            read_step();
            console.log('arr_res', arr_res);
            read_step();
        }
        parallel_iterate_inputs();
    } else {
        console.trace();
        throw 'Length Mismatch';
    }
}
Pixel_Buffer_Specialised_Enh.get_contig_x_spans_AND = get_contig_x_spans_AND;
module.exports = Pixel_Buffer_Specialised_Enh;
},{"./pixel-buffer-6-perf-focus-enh":24,"./ta-math":38}],26:[function(require,module,exports){
const Pixel_Buffer_Enh = require('./pixel-buffer-7-specialised-enh');

module.exports = Pixel_Buffer_Enh;
},{"./pixel-buffer-7-specialised-enh":25}],27:[function(require,module,exports){

const ta_math = require('./ta-math');


const {fill_solid_rect_by_bounds} = ta_math;


// May want a simpler / more general method of composing polygons / shapes on a 1bipp pixelbuffer - and then writing that 1bipp image to the
// destination in the correct color.

// 3bipp and 4bipp would definitely be useful for a variety of uses.
// 8 color, 16 color.

// Painting polygons and the logic for polygons could help.
//  As in, which pixels are inside or outside a polygon.
//   Rendering the edges and doing flood fill could work well.

//   Flood fill within 1 bipp should be powerful in many situations.


// Polygon drawing:
//  Filled polygon composition:
//  Need to render the edges, and flood fill the inside.

// Maybe 2bipp would be more convenient in some ways?

// Render the edges.
//  Copy that image
//  Flood fill from the outside
//   Invert that image
//  Copy the edges image onto that inverted image (showing the inner area?)

// Or better to geometrically get points inside the image?
//  Flood fill is fast though.

// Fast 1bipp polygon ops should be useful overall.
//  Like equation masks.

// Maybe better to do ops more focused on countries to start with?
//  Though generalised polygon algorithms will help too.

//  And could specify them with pixel deltas too.



// core.draw_polygon(points, options)
//  Drawing a filled polygon could mean compositing it in its own new pixelbuffer

























class Pixel_Buffer_Painter {
    constructor(spec) {
        const pb = this.pb = spec.pb || spec.pixel_buffer



        /*
        // Draw line
        // pos1, pos2, color

        // And weight???
        this.line = (pos1, pos2, color) => {

        }
        */

        this.rect = (pos, size, color) => {
            // call the lower level ta_math function.

            // bounds_from_pos_and_size?
            //  calc_bounds(pos, size);

            //console.log('paint rect [pos, size, color]', [pos, size, color]);
            

            const ta_bounds = new Int16Array(4);
            ta_bounds[0] = pos[0];
            ta_bounds[1] = pos[1];
            ta_bounds[2] = pos[0] + size[0];
            ta_bounds[3] = pos[1] + size[1];

            // const fill_solid_rect_by_bounds = (ta_dest, bypr_dest, ta_bounds, bipp, color)

            fill_solid_rect_by_bounds(pb.ta, pb.bypr, ta_bounds, pb.bipp, color);



            return this;  // return the painter.   paint.rect(...).rect(...) etc.



        }
    }
    //rect()
}


module.exports = Pixel_Buffer_Painter;
},{"./ta-math":38}],28:[function(require,module,exports){
module.exports = require('./pixel-buffer-8-enh');
},{"./pixel-buffer-8-enh":26}],29:[function(require,module,exports){
// Simple enough... can add pixels, can iterate through the pixels.
//  Would be good to .to_pixel_buffer?

// Getting lists of pixel positions when extracting regions would be a nice optimization over bit masks that use 8 bpp.
//  Will support 1 bipp properly. 0.125bypp.
//  While this is 32bpp, it's only specific pixels.

const inspect = Symbol.for('nodejs.util.inspect.custom');

const Ui16toUi32 = (ui16) => {
    let res = new Uint32Array(ui16.length / 2);
    let dv = new DataView(ui16.buffer);
    let l = ui16.length;
    let hl = l / 2;
    let resw = 0;
    for (let c = 0; c < hl; c++) {
        res[resw++] = dv.getUint32(c * 4);
    }
    return res;
}

const Ui32toUi16 = (ui32) => {
    let res = new Uint16Array(ui32.length * 2);
    let dv = new DataView(ui32.buffer);
    let l = ui32.length;
    let resw = 0;
    for (let c = 0; c < l; c++) {
        res[resw++] = dv.getUint16(c * 4 + 2);
        res[resw++] = dv.getUint16(c * 4);
    }
    return res;
}

/**
 * A class for efficiently managing a list of pixel positions.
 * Provides methods for adding, removing, sorting, and iterating over pixel positions.
 */
class Pixel_Pos_List {
    [Symbol.iterator]() {
        let index = 0;
        const pixels = [];
        
        this.each_pixel(pos => {
            pixels.push([pos[0], pos[1]]);
        });
        
        return {
            next: () => {
                if (index < pixels.length) {
                    return { value: pixels[index++], done: false };
                } else {
                    return { done: true };
                }
            }
        };
    }

    [inspect]() {
        return this.toString();
    }

    toString() {
        const res = 'PPL ' + JSON.stringify({
            length: this.length,
            pixels: this.str_pixels
        });
        return res;
    }

    /**
     * Creates a new Pixel_Pos_List instance.
     * @param {Object} [spec] - Optional specification object.
     */
    constructor(spec) {
        // current capacity * 10 when expanding.
        const capacities = new Uint32Array([16, 1024, 1024 * 1024 / 8, 1024 * 1024 / 2, 1024 * 1024 * 2, 1024 * 1024 * 8]);
        let i_capacity = 0;
        let capacity = capacities[i_capacity];
        let max_index = capacity * 2 - 1;
        // Could start with much lower capacity and increase it if necessary.
        let i = 0;
        let ta_pixels = new Uint16Array(capacity * 2);
        let read_pos = 0;

        // Array methods
        /**
         * Sorts the pixel positions.
         * Compacts the array first if needed.
         * @returns {Pixel_Pos_List} this instance for chaining
         */
        this.sort = () => {
            // If there are elements that have been shifted out, compact the array first
            if (read_pos > 0) {
                // Copy remaining elements to the beginning of the array
                const length = i - read_pos;
                for (let idx = 0; idx < length; idx++) {
                    ta_pixels[idx] = ta_pixels[idx + read_pos];
                }
                i = length;
                read_pos = 0;
            }
            
            // Only sort the actually used part of the array
            const activeSlice = ta_pixels.slice(0, i);
            let ui32 = Ui16toUi32(activeSlice);
            ui32.sort();
            
            // Copy the sorted values back
            const sortedUi16 = Ui32toUi16(ui32);
            for (let idx = 0; idx < i; idx++) {
                ta_pixels[idx] = sortedUi16[idx];
            }
            
            return this;
        }

        /**
         * Removes and returns the first pixel position in the list.
         * @returns {Uint16Array|undefined} The pixel position or undefined if empty
         */
        this.shift = () => {
            if (read_pos < i) {
                const res = new Uint16Array(2);
                res[0] = ta_pixels[read_pos];
                res[1] = ta_pixels[read_pos + 1];
                read_pos += 2;
                
                // If we've removed a significant number of elements, compact the array
                if (read_pos >= 1024 && read_pos > i / 2) {
                    // Create a new array with just the remaining elements
                    const newArray = new Uint16Array(i - read_pos);
                    for (let idx = 0; idx < i - read_pos; idx++) {
                        newArray[idx] = ta_pixels[idx + read_pos];
                    }
                    
                    // Update internal arrays and indices
                    ta_pixels = this.ta = newArray;
                    i = i - read_pos;
                    read_pos = 0;
                    max_index = ta_pixels.length - 1;
                }
                
                return res;
            }
            
            // Return undefined if there are no more pixels to shift
            return undefined;
        }

        /**
         * Removes and returns the last pixel position in the list.
         * @returns {Uint16Array|undefined} The pixel position or undefined if empty
         */
        this.pop = () => {
            // If index pointer is at least 2 (meaning there's at least one pixel)
            if (i > read_pos) {
                // Create a new array for the result
                const res = new Uint16Array(2);
                // Decrease the index by 2 (one full pixel)
                i -= 2;
                // Copy the values
                res[0] = ta_pixels[i];
                res[1] = ta_pixels[i+1];
                return res;
            }
            // Return undefined if there are no pixels to pop
            return undefined;
        }

        // Could start out with a smaller ta_pixels.
        this.ta = ta_pixels;

        /**
         * Adds a pixel position to the list.
         * @param {Array|Uint16Array} pos - The [x, y] position to add
         * @returns {Pixel_Pos_List} this instance for chaining
         * @throws {Error} If the position is invalid
         */
        this.add = (pos) => {
            // Validate input
            if (!pos || pos.length < 2) {
                throw new Error('Invalid pixel position. Expected [x, y] array with at least 2 elements.');
            }
            
            // Ensure position values are integers
            const x = Math.floor(pos[0]);
            const y = Math.floor(pos[1]);
            
            // Check if we need to resize the array
            if (i > max_index) {
                // Could check to see if the array can be shortened.
                // Same capacity, but move it forward.
                if (read_pos >= 1024) {
                    const new_ta = new Uint16Array(capacity * 2);
                    const l = ta_pixels.length - read_pos;
                    for (let c = 0; c < l; c++) {
                        new_ta[c] = ta_pixels[c + read_pos];
                    }
                    ta_pixels = new_ta;
                    i -= read_pos;
                    read_pos = 0;
                } else {
                    // Need to increase the capacity
                    if (i_capacity < capacities.length - 1) {
                        capacity = capacities[++i_capacity];
                    } else {
                        // If we've reached the maximum predefined capacity, double the current capacity
                        capacity *= 2;
                    }
                    
                    max_index = capacity * 2 - 1;
                    const new_ta = new Uint16Array(capacity * 2);
                    const l = ta_pixels.length;
                    for (let c = 0; c < l; c++) {
                        new_ta[c] = ta_pixels[c];
                    }
                    ta_pixels = this.ta = new_ta;
                }
            }
            
            ta_pixels[i++] = x;
            ta_pixels[i++] = y;
            
            return this;
        }

        /**
         * Iterates over each pixel in the list.
         * @param {Function} cb - Callback function receiving (pixel, index)
         */
        this.each_pixel = (cb) => {
            // Start from the read pos
            let count = 0;
            for (let i2 = read_pos; i2 < i; i2 += 2) {
                // Create a fresh copy of the pixel data for the callback
                const pixelPos = new Uint16Array(2);
                pixelPos[0] = ta_pixels[i2];
                pixelPos[1] = ta_pixels[i2 + 1];
                cb(pixelPos, count++);
            }
        }

        /**
         * Trims the internal array to the actual size of the data.
         * @returns {Pixel_Pos_List} this instance for chaining
         */
        this.fix = () => {
            // Slice the array to only include the actual pixels
            const adjusted = ta_pixels.slice(0, i);
            // Update both the instance property and the local variable
            this.ta = ta_pixels = adjusted;
            // Reset the max_index since we've resized
            max_index = this.ta.length - 1;
            return this;
        }

        /**
         * Compares this list with another pixel position list.
         * @param {Pixel_Pos_List} pixel_pos_list - The list to compare with
         * @returns {boolean} True if the lists contain the same pixels
         */
        this.equals = (pixel_pos_list) => {
            // Check if both instances have the same number of pixels
            if (this.length !== pixel_pos_list.length) {
                return false;
            }
            
            // Extract all pixels from both lists for comparison
            const thisList = [];
            const otherList = [];
            
            this.each_pixel(pos => {
                thisList.push([pos[0], pos[1]]);
            });
            
            pixel_pos_list.each_pixel(pos => {
                otherList.push([pos[0], pos[1]]);
            });
            
            // Sort both lists for consistent comparison
            thisList.sort((a, b) => {
                if (a[0] === b[0]) return a[1] - b[1];
                return a[0] - b[0];
            });
            
            otherList.sort((a, b) => {
                if (a[0] === b[0]) return a[1] - b[1];
                return a[0] - b[0];
            });
            
            // Compare each pixel
            for (let i = 0; i < thisList.length; i++) {
                if (thisList[i][0] !== otherList[i][0] || thisList[i][1] !== otherList[i][1]) {
                    return false;
                }
            }
            
            return true;
        }

        /**
         * Maps each pixel position to a new value using the callback function.
         * @param {Function} mapFn - Function that receives (pixel, index) and returns a new value
         * @returns {Array} Array of mapped values
         */
        this.map = (mapFn) => {
            const result = [];
            this.each_pixel((pos, idx) => {
                result.push(mapFn(pos, idx));
            });
            return result;
        }

        /**
         * Filters pixel positions based on the predicate function.
         * @param {Function} predicate - Function that receives (pixel, index) and returns boolean
         * @returns {Pixel_Pos_List} A new Pixel_Pos_List with the filtered pixels
         */
        this.filter = (predicate) => {
            const result = new Pixel_Pos_List();
            this.each_pixel((pos, idx) => {
                if (predicate(pos, idx)) {
                    result.add([pos[0], pos[1]]);
                }
            });
            return result;
        }

        /**
         * Executes a function for each pixel position.
         * @param {Function} callback - Function that receives (pixel, index)
         */
        this.forEach = (callback) => {
            this.each_pixel(callback);
        }

        /**
         * Creates a string representation of all pixels.
         * @private
         */
        const str_pixels = () => {
            let res = '';
            let first = true;
            this.each_pixel(pos => {
                if (first) {
                    first = false;
                } else {
                    res = res + ', ';
                }
                res = res + '[' + pos[0] + ', ' + pos[1] + ']';
            });
            return res;
        }

        /**
         * Property to get a string representation of all pixels.
         */
        Object.defineProperty(this, 'str_pixels', {
            get: () => str_pixels(),
            enumerable: true,
            configurable: false
        });

        /**
         * Property to get the number of pixels in the list.
         */
        Object.defineProperty(this, 'length', {
            get: () => ((i - read_pos) / 2),
            enumerable: true,
            configurable: false
        });

        /**
         * Property to get the bounding box of all pixels.
         * @returns {Uint16Array} [minX, minY, maxX, maxY]
         */
        let _bounds;
        Object.defineProperty(this, 'bounds', {
            get: () => {
                // Always recalculate bounds when accessed
                _bounds = new Uint16Array(4);
                
                // Initialize bounds with values that will be replaced
                if (this.length > 0) {
                    // Default to extreme values
                    _bounds[0] = Number.MAX_SAFE_INTEGER; // Minimum x
                    _bounds[1] = Number.MAX_SAFE_INTEGER; // Minimum y
                    _bounds[2] = 0; // Maximum x
                    _bounds[3] = 0; // Maximum y
                    
                    // Iterate through all pixels to find min/max values
                    this.each_pixel(pos => {
                        if (pos[0] < _bounds[0]) _bounds[0] = pos[0];
                        if (pos[0] > _bounds[2]) _bounds[2] = pos[0];
                        if (pos[1] < _bounds[1]) _bounds[1] = pos[1];
                        if (pos[1] > _bounds[3]) _bounds[3] = pos[1];
                    });
                } else {
                    // If no pixels, use default bounds of 0,0,0,0
                    _bounds[0] = 0;
                    _bounds[1] = 0;
                    _bounds[2] = 0;
                    _bounds[3] = 0;
                }
                
                return _bounds;
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Property to get the top-left position of all pixels.
         * @returns {Uint16Array} [minX, minY]
         */
        let _pos;
        Object.defineProperty(this, 'pos', {
            get: () => {
                // Always recalculate position when accessed
                _pos = new Uint16Array(2);
                
                if (this.length > 0) {
                    _pos[0] = Number.MAX_SAFE_INTEGER;
                    _pos[1] = Number.MAX_SAFE_INTEGER;
                    
                    this.each_pixel(pos => {
                        if (pos[0] < _pos[0]) _pos[0] = pos[0];
                        if (pos[1] < _pos[1]) _pos[1] = pos[1];
                    });
                } else {
                    _pos[0] = 0;
                    _pos[1] = 0;
                }
                
                return _pos;
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Clears all pixels from the list.
         * @returns {Pixel_Pos_List} this instance for chaining
         */
        this.clear = () => {
            i = 0;
            read_pos = 0;
            return this;
        }

        /**
         * Checks if the list contains the given pixel position.
         * @param {Array|Uint16Array} pos - The [x, y] position to check
         * @returns {boolean} True if the position is in the list
         */
        this.contains = (pos) => {
            if (!pos || pos.length < 2) return false;
            
            // For non-integer values, check if they need to be floored
            // We only match exact integer values or floored non-integers
            const isXInteger = Number.isInteger(pos[0]);
            const isYInteger = Number.isInteger(pos[1]);
            
            // If both values are non-integers, we won't find a match
            if (!isXInteger && !isYInteger) {
                return false;
            }
            
            const x = Math.floor(pos[0]);
            const y = Math.floor(pos[1]);
            
            let found = false;
            this.each_pixel(pixel => {
                if (pixel[0] === x && pixel[1] === y) {
                    // For non-integer inputs, only match if the input values floor to the same values
                    if ((!isXInteger && Math.floor(pos[0]) !== pos[0]) || 
                        (!isYInteger && Math.floor(pos[1]) !== pos[1])) {
                        return; // Skip this match for non-integers
                    }
                    found = true;
                }
            });
            
            return found;
        }

        /**
         * Converts the list to a plain array of [x,y] positions.
         * @returns {Array} Array of [x,y] positions
         */
        this.toArray = () => {
            const result = [];
            this.each_pixel(pos => {
                result.push([pos[0], pos[1]]);
            });
            return result;
        }
    }

    /**
     * Creates a Pixel_Pos_List from an array of positions.
     * @param {Array} positions - Array of [x,y] positions
     * @returns {Pixel_Pos_List} A new Pixel_Pos_List
     * @static
     */
    static fromArray(positions) {
        const ppl = new Pixel_Pos_List();
        if (Array.isArray(positions)) {
            positions.forEach(pos => {
                if (Array.isArray(pos) && pos.length >= 2) {
                    ppl.add(pos);
                }
            });
        }
        return ppl;
    }
}

// Example usage when run as a script
if (require.main === module) {
    const test1 = () => {
        let ppl = new Pixel_Pos_List();
        ppl.add([2, 2]);
        ppl.add([2, 3]);
        ppl.add([8, 4]);
        ppl.add([8, 3]);
        ppl.add([3, 3]);
        ppl.add([1, 2]);
        ppl.add([1, 3]);
        ppl.add([3, 2]);
        ppl.fix();
        
        // Using iterator protocol
        console.log('Pixels using for...of:');
        for (const pos of ppl) {
            console.log(`  [${pos[0]}, ${pos[1]}]`);
        }
        
        // Using new methods
        console.log('\nFiltered pixels (x > 2):');
        const filtered = ppl.filter(pos => pos[0] > 2);
        filtered.forEach(pos => {
            console.log(`  [${pos[0]}, ${pos[1]}]`);
        });
        
        // Map
        console.log('\nMapped pixels (x+y):');
        const sums = ppl.map(pos => pos[0] + pos[1]);
        console.log(sums);
        
        console.log('\nSorted pixels:');
        ppl = ppl.sort();
        let item;
        while ((item = ppl.shift())) {
            console.log(`  [${item[0]}, ${item[1]}]`);
        }
    }
    test1();
} else {
    // Required as a module
}

module.exports = Pixel_Pos_List;
},{}],30:[function(require,module,exports){
(function (process){(function (){
const Shape = require('./Shape');

// new Rectangle([w, h], [x, y]); seems like the most standard format.
//.  Does seem best when defining the rectangle.
//.    Possibly have some default parameter order property? Or a bit of online explanation?

const {tof, is_array, get_item_sig, is_arr_of_t} = require('lang-mini');

const Rectangle = require('./Rectangle');

//.  what it is, where it is???
//.  or [pos, size]????
// But it can exist without its position (usually / in theory at least).

const {draw_polygon_outline_to_ta_1bipp,
    ensure_polygon_is_ta,

    right_shift_32bit_with_carry,
    xor_typed_arrays,
    each_1_index,
    count_1s,
    fast_find_next_set_ta_bit,
    get_ta_bits_that_differ_from_previous_as_1s,
    get_bit,
    calc_polygon_stroke_points_x_y} = require('../ta-math');


const is_integer_typed_array = (obj) => {
    if (ArrayBuffer.isView(obj)) {
        return (
            obj instanceof Int8Array ||
            obj instanceof Uint8Array ||
            obj instanceof Int16Array ||
            obj instanceof Uint16Array ||
            obj instanceof Int32Array ||
            obj instanceof Uint32Array ||
            obj instanceof BigInt64Array ||
            obj instanceof BigUint64Array
        );
    }
    return false;
};


// Extend a TA_Table perhaps?
//   Or it's just a Matrix?

// TA_Matrix

// A table is more about expressing it as a list of records.


const Polygon_Scanline_Edges = require('./Polygon_Scanline_Edges');




class Polygon extends Shape {
    // Set the points but with an offset too????

    constructor(spec) {
        super(spec);

        // Give it the polygon points

        // Functions to get various data derived from that polygon.
        //   A typed array that expresses the x on spans may be most useful.

        if (is_array(spec)) {
            // Should be an array of pairs.

            const l = spec.length;
            const num_points = l;
            // Determine what data structure to use for the ta points. Could use 16 bit numbers, maybe even 8 bit....
            //   8 bit would be fine (or best) for the smallest polygons. 
            //   Or go strait ahead and use 32 bit??

            // May want to downshift it?
            //   Not to start with.
            const ta_points = new Uint32Array(num_points << 1);
            let i = 0;

            // May as well determine the bounding box here? Maybe not?

            for (const [x, y] of spec) {
                ta_points[i++] = x;
                ta_points[i++] = y;
            }

            this.ta_points = ta_points;
        } else {

            //console.log('spec', spec);

            if (is_integer_typed_array(spec)) {
                this.ta_points = spec;
            } else {
                console.trace();
                throw 'NYI';
            }
        }
    }


    // Or just as a normal array? Maybe that would be faster.

    get ta_bounding_box() {
        if (!this._ta_bounding_box) {
            const {ta_points} = this, l = ta_points.length;
            let min_x = Infinity, min_y = Infinity, max_x = -Infinity, max_y = -Infinity;

            let i = 0;
            let x, y;

            while (i < l) {
                x = ta_points[i++];
                y = ta_points[i++];
                min_x = Math.min(min_x, x);
                min_y = Math.min(min_y, y);
                max_x = Math.max(max_x, x);
                max_y = Math.max(max_y, y);
            }

            return this._ta_bounding_box = new Uint32Array([min_x, min_y, max_x, max_y]);
        } else {
            return this._ta_bounding_box;
        }
    }
    
    get ta_xylc_x_spans() {

        // count x spans?

        // Count them first with its own count algorithm????

        const downshifted = this.downshifted();
        const tabb = downshifted.ta_bounding_box;

        const offset = this.ta_bounding_box;

        const draw_size = [tabb[2], tabb[3]];
        const [w, h] = draw_size;

        const draw_size_num_pixels = draw_size[0] * draw_size[1];

        // Then see about getting it into an 8 bit aligned ta.
        const r_from_8 = draw_size_num_pixels % 8;
        const has_remainder_byte = r_from_8 !== 0;
        const ta_draw_num_bytes = (draw_size_num_pixels >>> 3) + (has_remainder_byte ? 1 : 0);
        const ta_draw = new Uint8Array(ta_draw_num_bytes);

        // Then draw the downshifted polygon to that ta....

        draw_polygon_outline_to_ta_1bipp(ta_draw, draw_size[0], downshifted.ta_points);
        const ta_x_span_toggles = get_ta_bits_that_differ_from_previous_as_1s(ta_draw, draw_size[0]);


        // Count the number of rows that begin with 1s?
        const num_toggle_bits = count_1s(ta_x_span_toggles);
        const iterate_to_count_x_spans = () => {
            //let i_w_res = 0;
            //let res = 0;
            let i_row_start = 0, i_row_end = w + 1;
            let cx = 0;
            const found_x_span = (x, y, l, c) => {
                cx++;
            }

            for (let y = 0; y < h; y++) {
                let i_next_set_bit = fast_find_next_set_ta_bit(ta_x_span_toggles, i_row_start, i_row_end - i_row_start - 1);
                //console.log('y, i_next_set_bit', y, i_next_set_bit);


                if (i_next_set_bit === false) {
                    // Then the row's only span is of the start color.
                    found_x_span(0, y, i_row_end);


                } else {
                    found_x_span(0, y, i_next_set_bit - i_row_start);
                    //color = (~color)&1;
                    let i_last_set_bit = i_next_set_bit;

                    while (i_next_set_bit !== false && i_next_set_bit < i_row_end) {

                        // That fn seems broken for now.
                        i_next_set_bit = fast_find_next_set_ta_bit(ta_x_span_toggles, i_next_set_bit, i_row_end - i_next_set_bit - 1);
                        //console.log('y, i_next_set_bit', y, i_next_set_bit);

                        if (i_next_set_bit === false) {
                            // Then the row's only span is of the start color.
                            found_x_span(i_last_set_bit - i_row_start, y, i_row_end - i_last_set_bit);
                        } else {
                            found_x_span(i_last_set_bit - i_row_start, y, i_next_set_bit - i_last_set_bit);
                            i_last_set_bit = i_next_set_bit;
                        }
                    }
                }
                i_row_start += w;
                i_row_end += w;
            }
            return cx;
        }

        const num_x_spans = iterate_to_count_x_spans();

        const num_fields_per_result_item = 4;
        const l_res = num_x_spans * num_fields_per_result_item;

        const res = new Uint32Array(l_res);
        

        const iterate_to_write_result = () => {
            let i_w_res = 0;
            //let res = 0;
            let i_row_start = 0, i_row_end = w + 1;
            let cx = 0;
            const found_x_span = (x, y, l, c) => {
                res[i_w_res++] = x;
                res[i_w_res++] = y;
                res[i_w_res++] = l;
                res[i_w_res++] = c;
                cx++;
                //console.log('cx', cx);
            }

            for (let y = 0; y < h; y++) {
                const row_x0_value = get_bit(ta_x_span_toggles, i_row_start);
                let color = row_x0_value;

                /*
                if (row_x0_value !== 0) {
                    console.log([y, row_x0_value]);
                }

                */
                // And rather than a limit, have an absolute boundary of the end of that row?

                // And limit it up to the row end?
                let i_next_set_bit = fast_find_next_set_ta_bit(ta_x_span_toggles, i_row_start, i_row_end - i_row_start - 1);
                //console.log('y, i_next_set_bit', y, i_next_set_bit);


                if (i_next_set_bit === false) {
                    // Then the row's only span is of the start color.
                    found_x_span(0, y, i_row_end, color);


                } else {
                    found_x_span(0, y, i_next_set_bit - i_row_start, color);
                    color = (~color)&1;
                    let i_last_set_bit = i_next_set_bit;

                    while (i_next_set_bit !== false && i_next_set_bit < i_row_end) {

                        // That fn seems broken for now.
                        i_next_set_bit = fast_find_next_set_ta_bit(ta_x_span_toggles, i_next_set_bit, i_row_end - i_next_set_bit - 1);
                        //console.log('y, i_next_set_bit', y, i_next_set_bit);

                        if (i_next_set_bit === false) {
                            // Then the row's only span is of the start color.
                            found_x_span(i_last_set_bit - i_row_start, y, i_row_end - i_last_set_bit, color);
                        } else {
                            found_x_span(i_last_set_bit - i_row_start, y, i_next_set_bit - i_last_set_bit, color);
                            i_last_set_bit = i_next_set_bit;
                            //found_x_span(0, y, i_next_set_bit - i_row_start, color);
                            color = (~color)&1;
                        }


                        //console.log('[y, i_next_set_bit]', [y, i_next_set_bit]);

                        //i_last_set_bit = i_next_set_bit;
                    }
                }
                i_row_start += w;
                i_row_end += w;
            }
        }

        iterate_to_write_result();
        return res;


    }





    // x, y, l makes the most sense

    get ta_x_spans_filled() {


        const calling_other_fns_attempt = () => {

            const bb = this.ta_bounding_box;

            const offset_width = bb[2] - bb[0];

            const offset_height = bb[3] - bb[1];
            const ohm1 = offset_height - 1;

            // Maybe need to break this down into OO classes to get it working properly.

            const ta_xylc_x_spans = this.ta_xylc_x_spans;

            //console.log('ta_xylc_x_spans', ta_xylc_x_spans + '');
            //console.trace();
            //throw 'stop';


            const iterate_to_count_x_spans_touching_image_border = () => {
                const ta_l = ta_xylc_x_spans.length;
                const num_x_spans = ta_l / 4;

                //let i_x_span = 0;
                let i_r = 0;
                let c_touching_image_border = 0;

                for (let i_x_span = 0; i_x_span < num_x_spans; i_x_span++) {
                    const x = ta_xylc_x_spans[i_r++], y = ta_xylc_x_spans[i_r++], l = ta_xylc_x_spans[i_r++], c = ta_xylc_x_spans[i_r++];
                    if (x === 0) {
                        c_touching_image_border++
                    } else if (x + l === offset_width) {
                        c_touching_image_border++
                    } else if (y === 0) {
                        c_touching_image_border++
                    } else if (y === ohm1) {
                        c_touching_image_border++
                    }
                }
                return c_touching_image_border;
            }

            const c_touching_image_border = iterate_to_count_x_spans_touching_image_border();

            // Iterate to get the indexes of the x spans touching the border.
            //   Not setting them as a group bitfield for the moment.

            const indexes_of_x_spans_touching_image_border = new Uint32Array(c_touching_image_border);

            const iterate_to_populate_indexes_of_x_spans_touching_image_border = () => {
                let i_r = 0, i_w = 0;

                const ta_l = ta_xylc_x_spans.length;
                const num_x_spans = ta_l / 4;

                //let i_x_span = 0;

                for (let i_x_span = 0; i_x_span < num_x_spans; i_x_span++) {
                    const x = ta_xylc_x_spans[i_r++], y = ta_xylc_x_spans[i_r++], l = ta_xylc_x_spans[i_r++], c = ta_xylc_x_spans[i_r++];
                    if (x === 0) {
                        indexes_of_x_spans_touching_image_border[i_w++] = i_x_span;
                    } else if (x + l === offset_width) {
                        indexes_of_x_spans_touching_image_border[i_w++] = i_x_span;
                    } else if (y === 0) {
                        indexes_of_x_spans_touching_image_border[i_w++] = i_x_span;
                    } else if (y === ohm1) {
                        indexes_of_x_spans_touching_image_border[i_w++] = i_x_span;
                    }
                }
            }
            iterate_to_populate_indexes_of_x_spans_touching_image_border();

            
            const iterate_to_count_color_0_x_spans_touching_image_border = () => {
                const ta_l = ta_xylc_x_spans.length;
                const num_x_spans = ta_l / 4;

                //let i_x_span = 0;
                let i_r = 0;
                let c_touching_image_border = 0;

                for (let i_x_span = 0; i_x_span < num_x_spans; i_x_span++) {
                    const x = ta_xylc_x_spans[i_r++], y = ta_xylc_x_spans[i_r++], l = ta_xylc_x_spans[i_r++], c = ta_xylc_x_spans[i_r++];
                    if (c === 0) {
                        if (x === 0) {
                            c_touching_image_border++;
                        } else if (x + l === offset_width) {
                            c_touching_image_border++;
                        } else if (y === 0) {
                            c_touching_image_border++;
                        } else if (y === ohm1) {
                            c_touching_image_border++;
                        }
                    }
                    
                }
                return c_touching_image_border;
            }

            const c_color_0_touching_image_border = iterate_to_count_color_0_x_spans_touching_image_border();
            //console.log('c_color_0_touching_image_border', c_color_0_touching_image_border);

            const indexes_of_color_0_x_spans_touching_image_border = new Uint32Array(c_color_0_touching_image_border);

            const iterate_to_populate_indexes_of_color_0_x_spans_touching_image_border = () => {
                let i_r = 0, i_w = 0;

                const ta_l = ta_xylc_x_spans.length;
                const num_x_spans = ta_l / 4;

                //let i_x_span = 0;

                for (let i_x_span = 0; i_x_span < num_x_spans; i_x_span++) {
                    const x = ta_xylc_x_spans[i_r++], y = ta_xylc_x_spans[i_r++], l = ta_xylc_x_spans[i_r++], c = ta_xylc_x_spans[i_r++];
                    if (c === 0) {
                        if (x === 0) {
                            indexes_of_color_0_x_spans_touching_image_border[i_w++] = i_x_span;
                        } else if (x + l === offset_width) {
                            indexes_of_color_0_x_spans_touching_image_border[i_w++] = i_x_span;
                        } else if (y === 0) {
                            indexes_of_color_0_x_spans_touching_image_border[i_w++] = i_x_span;
                        } else if (y === ohm1) {
                            indexes_of_color_0_x_spans_touching_image_border[i_w++] = i_x_span;
                        }
                    }
                    
                }
            }
            iterate_to_populate_indexes_of_color_0_x_spans_touching_image_border();


            const invert_indexes = (indexes) => {
                const ta_l = ta_xylc_x_spans.length;
                const num_x_spans = ta_l / 4;
            
                let i_idx = 0; // pointer for indexes array
                let res_idx = 0; // pointer for result array
            
                const res = new Uint32Array(num_x_spans - indexes.length);
            
                // Iterate over each span index
                for (let i_x_span = 0; i_x_span < num_x_spans; i_x_span++) {
                    // Check if the current span index is in the indexes array
                    if (i_idx < indexes.length && indexes[i_idx] === i_x_span) {
                        // If i_x_span matches current index, skip it and move to the next index in indexes
                        i_idx++;
                    } else {
                        // If i_x_span is not in indexes, add it to result array
                        res[res_idx++] = i_x_span;
                    }
                }
            
                return res;
            };
            

            const assemble_res_from_indexes = indexes => {
                //console.log('indexes', indexes);
                const l = indexes.length;
                let i_r = 0, i_w = 0;

                const l_res = l * 3;
                const res = new Uint32Array(l_res);
                //console.log('ta_xylc_x_spans', ta_xylc_x_spans);

                for (let i_index = 0; i_index < l; i_index++) {
                    const i_in_main = indexes[i_index];
                    //console.log('i_index, i_in_main', i_index, i_in_main);
                    const pos_in_main = i_in_main * 4;
                    const x = ta_xylc_x_spans[pos_in_main];
                    const y = ta_xylc_x_spans[pos_in_main + 1];
                    const l = ta_xylc_x_spans[pos_in_main + 2];
                    //console.log('[x, y, l]', [x, y, l]);
                    res[i_w++] = x;
                    res[i_w++] = y;
                    res[i_w++] = l;

                }

                return res;

            }

            const res = assemble_res_from_indexes(invert_indexes(indexes_of_color_0_x_spans_touching_image_border));


            return res;

        }

        return calling_other_fns_attempt();



    }

    set offset(value) {
        if (!this._offset) {
            this._offset = new Uint32Array(2);
        }
        if (is_array(value)) {
            this._offset[0] = value[0];
            this._offset[1] = value[1];
        } else {
            console.trace();
            throw 'NYI';
        }
    }

    get offset() {
        if (!this._offset) {
            this._offset = new Uint32Array(2);
        }
        return this._offset;
    }

    downshifted() {

        // Determine the offset from the bounding box mins.

        const [x, y] = this.ta_bounding_box;
        const dx = -x, dy = -y;

        const {ta_points} = this, l = ta_points.length;

        const ta_downshifted_points = new Uint32Array(l);
        let i = 0;
        while (i < l) {
            ta_downshifted_points[i] = ta_points[i++] + dx;
            ta_downshifted_points[i] = ta_points[i++] + dy;
        }

        const res = new Polygon(ta_downshifted_points);
        res.offset = [x, y];
        return res;


    }

    get scanline_edges() {
        const res = new Polygon_Scanline_Edges(this);
        return res;

    }

}

Polygon.Polygon_Scanline_Edges = Polygon_Scanline_Edges;

Polygon.ensure_is = obj => {
    if (obj instanceof Polygon) {
        return obj;
    } else {
        return new Polygon(obj);
    }
}

module.exports = Polygon;

if (require.main === module) {

    const t0 = process.hrtime();

    //const polygon = new Polygon([[4, 4,], [28, 4], [28, 28], [4, 28]]);


    const polygon = new Polygon([[900, 900,], [200, 200], [1000, 900], [1600, 200], [1000, 1000], [1000, 1100], [1000, 1600], [900, 1600]]);



    const ta_l = polygon.ta_points.length;
    const tabb = polygon.ta_bounding_box;

    const ds_pg = polygon.downshifted();


    // May be able to get that with a fill algorithm that looks into the edges.
    const xsf = polygon.ta_x_spans_filled;

    const l_xsf = xsf.length;
    
    const num_x_spans = l / 3;

    let i = 0;

    for (let c = 0; c < num_x_spans; c++) {
        const x = xsf[i++], y = xsf[i++], l = xsf[i++], x2 = x + l;

    }

    const tt0 = process.hrtime(t0);
    const ms0 = tt0[0] * 1000 + tt0[1] / 1000000

    //console.log('tt0', tt0);
    console.log('ms0', ms0);
    console.log('ta_l', ta_l);
    console.log('tabb', tabb);
    console.log('polygon', polygon);
    console.log('ds_pg', ds_pg);
    console.log('ds_pg.ta_bounding_box', ds_pg.ta_bounding_box);
    console.log('xsf', xsf);



    // Then can this be drawn to a pixel buffer????
    //   Rapid draw of x-span in the [x, y, l] format.





    // Getting the filled polygon x-spans....
    //   Is a somewhat complex procedure, but want to get it running very quick. Some OO will help keep it consistent in terms of usage.

    // Get these x-spans as a typed array?
    //   [x, y, l] ???





    // ta_bounding_box
}
}).call(this)}).call(this,require('_process'))
},{"../ta-math":38,"./Polygon_Scanline_Edges":32,"./Rectangle":33,"./Shape":35,"_process":383,"lang-mini":47}],31:[function(require,module,exports){
const DEBUG = require('./is_debug');
const TA_Table_8_Columns = require('./TA_Table_8_Columns');

class Polygon_Edges extends TA_Table_8_Columns {
    constructor(polygon) {
        const ptap = polygon.ta_points;
        const num_points = ptap.length >> 1; // Divide length by 2 to get number of points

        let num_edges = 0;

        // Loop to determine the number of edges
        for (let i = 0; i < num_points; i++) {
            const y1 = ptap[(i << 1) + 1]; // i * 2 + 1 becomes (i << 1) + 1, efficient bitwise multiply
            const y2 = ptap[(((i + 1) % num_points) << 1) + 1]; // Proper multiplication by 2 for the lookup

            if (y1 !== y2 || y1 === y2) { // Count horizontal edges as well
                num_edges++;
            }
        }

        super(num_edges);
        this.sorted_indices = new Uint32Array(num_edges);

        this.populate_edges(polygon);
        this.sort_by_y1_then_x1();
    }

    populate_edges(polygon) {
        const ptap = polygon.ta_points;
        const num_points = ptap.length >> 1;
        const {sorted_indices} = this;

        let row = 0;
        for (let i = 0; i < num_points; i++) {

            const ix2 = i << 1;

            const indx2 = ((i + 1) % num_points) << 1;

            const x1 = ptap[ix2];
            const y1 = ptap[ix2 + 1];
            const x2 = ptap[indx2];
            const y2 = ptap[indx2 + 1];

            if (y1 !== y2 || y1 === y2) { // Include horizontal edges
                const is_horizontal = (y1 === y2) ? 1 : 0;
                this.set(row, 0, y1 < y2 ? x1 : x2); // x1
                this.set(row, 1, Math.min(y1, y2)); // y1
                this.set(row, 2, y1 < y2 ? x2 : x1); // x2
                this.set(row, 3, Math.max(y1, y2)); // y2
                this.set(row, 4, (y1 !== y2) ? (x2 - x1) / (y2 - y1) : 0); // Slope (0 for horizontal)
                this.set(row, 5, is_horizontal); // is_horizontal (1 for horizontal, 0 otherwise)
                sorted_indices[row] = row;
                row++;
            }
        }

        if (DEBUG) {
            console.log('Edges populated:', Array.from({ length: this.row_count }, (_, i) => ({
                x1: this.get(i, 0),
                y1: this.get(i, 1),
                x2: this.get(i, 2),
                y2: this.get(i, 3),
                slope: this.get(i, 4),
                is_horizontal: this.get(i, 5),
            })));
        }
    }

    sort_by_y1_then_x1() {
        this.sorted_indices.sort((a, b) => {
            const y1A = this.get(a, 1);
            const y1B = this.get(b, 1);
            if (y1A !== y1B) return y1A - y1B;
            const x1A = this.get(a, 0);
            const x1B = this.get(b, 0);
            return x1A - x1B;
        });

        if (DEBUG) {
            console.log(
                'Sorted edges by y1, then x1:',
                this.sorted_indices.map((index) => ({
                    x1: this.get(index, 0),
                    y1: this.get(index, 1),
                    x2: this.get(index, 2),
                    y2: this.get(index, 3),
                    slope: this.get(index, 4),
                    is_horizontal: this.get(index, 5),
                }))
            );
        }
    }
}

module.exports = Polygon_Edges;

},{"./TA_Table_8_Columns":36,"./is_debug":37}],32:[function(require,module,exports){
const DEBUG = require('./is_debug');
const Polygon_Edges = require('./Polygon_Edges');

class Scanline_Polygon_Edges extends Polygon_Edges {
    constructor(polygon, options = {}) {
        super(polygon);
        this.active_edges = new Uint32Array(this.row_count); // Backed by typed array
        this.num_active_edges = 0;
        this.allow_horizontal_edges = options.allow_horizontal_edges || false;
    }

    update_active_edges(scanline_y) {
        let write_index = 0;

        const {active_edges, sorted_indices} = this;

        // Remove inactive edges
        for (let i = 0; i < this.num_active_edges; i++) {
            const edge_index = active_edges[i];
            const y2 = this.get(edge_index, 3); // y2 is the ending y-coordinate

            if (scanline_y < y2 || (this.allow_horizontal_edges && scanline_y === y2)) {
                active_edges[write_index++] = edge_index; // Keep active
            } else if (DEBUG) {
                console.log(`Edge ${edge_index} removed (scanline_y=${scanline_y}, y2=${y2})`);
            }
        }

        this.num_active_edges = write_index;

        const sil = sorted_indices.length;

        // Add new edges that start at this scanline
        for (let i = 0; i < sil; i++) {
            const edge_index = sorted_indices[i];
            const y1 = this.get(edge_index, 1); // y1 is the starting y-coordinate
            const y2 = this.get(edge_index, 3);

            if (y1 === scanline_y && (scanline_y < y2 || (this.allow_horizontal_edges && scanline_y === y2))) {
                active_edges[this.num_active_edges++] = edge_index;
                if (DEBUG) {
                    console.log(
                        `Edge ${edge_index} added (scanline_y=${scanline_y}, y1=${y1}, y2=${y2})`
                    );
                }
            }
        }

        if (DEBUG) {
            console.log(
                `Updated active edges for scanline ${scanline_y}:`,
                active_edges.slice(0, this.num_active_edges)
            );
        }
    }

    sort_active_edges_by_x() {
        this.active_edges.set(
            this.active_edges
                .slice(0, this.num_active_edges)
                .sort((edgeA, edgeB) => this.get(edgeA, 0) - this.get(edgeB, 0))
        );

        if (DEBUG) {
            console.log(
                `Sorted active edges by x:`,
                this.active_edges.slice(0, this.num_active_edges)
            );
        }
    }

    get_active_edges() {
        // Slice to return only the active edges
        return this.active_edges.slice(0, this.num_active_edges);
    }
}

module.exports = Scanline_Polygon_Edges;

},{"./Polygon_Edges":31,"./is_debug":37}],33:[function(require,module,exports){


const Shape = require('./Shape');

// new Rectangle([w, h], [x, y]); seems like the most standard format.
//.  Does seem best when defining the rectangle.
//.    Possibly have some default parameter order property? Or a bit of online explanation?

const {tof, get_item_sig, is_arr_of_t} = require('lang-mini');


//.  what it is, where it is???
//.  or [pos, size]????
// But it can exist without its position (usually / in theory at least).

// 

// May be worth considering some kind of virtual (non-JS-class) rectangles that can be accessed through operations on 
//.  a single class instance that internally uses a ta efficiently?
//.   Could have an API that returns Rectangle class instances but internally keeps all the data in a single (large enough) ta.
//.     That would likely be best regarding performance concerns.



// Rectangular_Geometry_Virtual_Container perhaps....

// That could be a really specific class for 

// Could have some kind of lower level Geometry_Container.
//.Or Rect_Geometry_Container
//.  With capabilities and optimisations specifically for multiple rectangles on a 2d plane.

// Could allow dealing with many rectangles without using the garbage collector for them.

// Does seem worth using 'prop' function for brevity.

const {prop, get_set} = require('obext');

// But want to be able to have this within a coord system where the y coordinates increase downwards.

// rect.box???

// rect.ta may help in some / many cases.

// .rect.box perhaps????
// .rect.coords ? .r.c?

// and have jsgui3-html make use of this Rectangle class.
//.  will support collision detection / avoidance for controls, which will help controls dynamically rearrange themselves.



class Rectangle extends Shape {

    // y_axis_up_direction = -1 for example?

    // up property being -1 or 1?
    //. y_axis_scaling_factor = -1 would make sense here.

    // though up_is_negitive would be simpler and quicker logically, could subtract vectors rater than multiply them by -1 and
    // then add them.





    // Should hold a typed array to keep a few values.
    //.  Or even be able to be part of a larger typed array holding many rects.

    // up_direction...?

    // up = +1?


    // This constructor system is maybe too slow for when many such rectangles get made.

    constructor(...a) {
        super(...a);

        this.up_is_negitive = true;
        

        const al = a.length;

        // Could provide it a single typed array. That could maybe be initialised as a subarray (from the spec).

        let x, y, w, h;

        const sig = get_item_sig(a, 2);
        //console.log('sig', sig);

        // 

        if (sig === '[[n,n],[n,n]]') {
            [[w, h], [x, y]] = a;
        }

        // Maybe defineProperty would be the better way here???

        // const get_set = (obj, prop_name, fn_get, fn_set) => {

        // And get_set could raise change events too....

        get_set(this, 'x', () => x, (value) => x = value);
        get_set(this, 'y', () => y, (value) => y = value);
        get_set(this, ['w', 'width'], () => w, (value) => w = value);
        get_set(this, ['h', 'height'], () => h, (value) => h = value);
        
        get_set(this, 'size', () => [w, h], (value) => [w, h] = value);
        get_set(this, 'pos', () => [x, y], (value) => [x, y] = value);



        get_set(this, 'left', () => x);
        get_set(this, 'top', () => this.up_is_negitive ? y : y + h, value => this.up_is_negitive ? y = value : y = value - height);


        get_set(this, 'right', () => x + w);
        get_set(this, 'bottom', () => this.up_is_negitive ? y + h : y);


        // The bcr interface.

        const using_bcr_interface = true;

        if (using_bcr_interface) {
            get_set(this, '0', () => [x, y]);
            get_set(this, '1', () => [this.right, this.bottom]);
            get_set(this, '2', () => [w, h]);
        }


        
        


        // then the bounds...

        // t, r
        // top and right....





        //prop(this, '')

        //. Though that arrangement with y being top will not always be the case.
        //.   Probably want that as an option in some place, such as when declaring a coord space.



        // properties such as width, height, left (x), top (y)

        //if (al === 2) {
            // [size, pos]




            // And are they both arrays?

        //}
    }

    extend(direction, px) {
        if (direction === 'left' || direction === 'l') {
            const cx = this.x, cw = this.width;
            this.x = cx - px;
            this.width = cw + px;
        } else if (direction === 'right' || direction === 'r') {
            const cx = this.x, cw = this.width;
            //this.x = cx - px;
            this.width = cw + px;
        } else if (direction === 'up' || direction === 'u') {
            //const cx = this.x, cw = this.width;
            //this.x = cx - px;
            //this.width = cw + px;

            if (this.up_is_negitive) {
                this.y = this.y - px;
                this.h = this.h + px;
            } else {
                this.h = this.h + px;
            }
        } else if (direction === 'down' || direction === 'd') {
            //const cx = this.x, cw = this.width;
            //this.x = cx - px;
            //this.width = cw + px;

            if (!this.up_is_negitive) {
                this.y = this.y - px;
                this.h = this.h + px;
            } else {
                this.h = this.h + px;
            }
        } else {
            throw 'Supported directions: left l right r up u down d';
        }
        return this;
    }


    // Maybe we don't want Control specific things in here???
    //.  Seems OK for now, though maybe should refactor it out later on.
    //.  And this gfx-core is specific to jsgui3 so let's do it.

    overlaps(overlap_target) {

        const a = arguments;
        const al = a.length;

        if (al === 1) {

            // Identify if it's an array of controls....

            // shared_tof ???

            const t_overlap_target = tof(overlap_target);
            if (t_overlap_target === 'array') {
                if (is_arr_of_t(overlap_target, 'control')) {
                    const res = [];

                    // then go through the overlap target array of controls...

                    for (const target_ctrl of overlap_target) {
                        //const target_bcr = target_ctrl.bcr();
                        const target_overlap = this.overlaps(target_ctrl);
                        if (target_overlap) { res.push(target_overlap)}
                        
                    }
                    return res;

                }
            } else if (t_overlap_target === 'control') {
                const target_bcr = overlap_target.bcr();
                return this.overlaps(target_bcr);

            } else if (overlap_target instanceof Rectangle) {

                // Need to do the computation....

                // Want to produce the overlapping rect if there is such a thing.
                //.  Otherwise, false.

                // Possibly rule it out quickly first....

                // Calculate a bunch of offsets...? (subtractions)

                // rect 1 is above rect 2
                // rect 2 is above rect 1
                //  below
                //. left of
                //. right of

                // So that is 8 checks.
                //.  Then if it's not checked like that, we have an overlap.
                //.   Then detect where the overlap is....

                const calculate_overlap = (box1, box2) => {
                    const x = Math.max(box1.x, box2.x);
                    const y = Math.max(box1.y, box2.y);
                    const w = Math.min(box1.x + box1.w, box2.x + box2.w) - x;
                    const h = Math.min(box1.y + box1.h, box2.y + box2.h) - y;
                  
                    if (w <= 0 || h <= 0) {
                        return false; // No overlap
                    } else {
                        return new Rectangle([w, h], [x, y]);
                    }
                  
                    
                };

                return calculate_overlap(this, overlap_target);


            }

            


        } else {
            console.trace();
            throw 'NYI';
        }

        // Or even have it able to take an array of targets in the multiple params?

        // is overlap_target an array of controls???

        // Is the overlap target an array? a collective???

        // array of controls?
        // iterator of controls?
        // iterable function of controls?

    }

    // Properties



}


if (require.main === module) {
    const rect = new Rectangle([30, 40], [100, 100]);
    console.log('rect', rect);

    console.log('rect.right', rect.right);

    rect.extend('l', 40);
    rect.extend('u', 40);


    console.log('rect.left', rect.left);
    console.log('rect.top', rect.top);
    console.log('rect.right', rect.right);

    // rect.pos


}


module.exports = Rectangle;
},{"./Shape":35,"lang-mini":47,"obext":382}],34:[function(require,module,exports){
const DEBUG = require('./is_debug');

class ScanlineProcessor {
    constructor(polygon_scanline_edges, width, height, bitmap, options = {}) {
        this.edges = polygon_scanline_edges;
        this.width = width;
        this.height = height;
        this.bitmap = bitmap;
        this.dataView = new DataView(bitmap.buffer, bitmap.byteOffset, bitmap.byteLength);
        this.draw_edges = options.draw_edges || false; // Option to draw edges
    }

    process_1bipp() {
        if (DEBUG) {
            console.log(`Processing polygon fill: width=${this.width}, height=${this.height}`);
        }

        const h = this.height, edges = this.edges;

        for (let y = 0; y < h; y++) {
            edges.update_active_edges(y);
            edges.sort_active_edges_by_x();

            if (DEBUG) {
                console.log(`Scanline ${y}: Active Edges`, edges.active_edges.slice(0, edges.num_active_edges));
            }

            if (this.draw_edges) {
                this.fill_scanline_with_edges_1bipp(y);
            } else {
                this.fill_scanline_no_edges_1bipp(y);
            }
            this._update_x_intercepts();
        }
    }

    _set_pixels_span_1bipp(bitmap, row_offset, x_start, x_end) {
        const total_pixels = x_end - x_start + 1;
        const start_index = row_offset + x_start;
        
        const end_index = row_offset + x_end;
        let pixel_index = start_index;

        if (total_pixels < 12) {
            // Default behavior for fewer than 16 pixels
            
            for (; pixel_index <= end_index; pixel_index++) {
                const byte_offset = pixel_index >> 3;
                bitmap[byte_offset] |= (128 >> (pixel_index & 7));
            }

            
        } else {
            const start_byte = start_index >> 3;
            const start_bit_offset = pixel_index & 7;
            let num_pixels_remaining = total_pixels;
            if (total_pixels < 90) {
                //let pixel_index = row_offset + x_start;
                //const start_byte = pixel_index >> 3;
                
                

                // Handle first byte if not aligned
                if (start_bit_offset !== 0) {
                    const bits_to_set = Math.min(8 - start_bit_offset, num_pixels_remaining);
                    bitmap[start_byte] |= ((0xFF >> (8 - bits_to_set)) << (8 - start_bit_offset - bits_to_set));
                    pixel_index += bits_to_set;
                    num_pixels_remaining -= bits_to_set;
                }

                // Handle remaining whole bytes
                while (num_pixels_remaining >= 8) {
                    const byte_offset = pixel_index >> 3;
                    bitmap[byte_offset] |= 0xFF;
                    pixel_index += 8;
                    num_pixels_remaining -= 8;
                }

                // Handle remaining bits
                if (num_pixels_remaining > 0) {
                    const byte_offset = pixel_index >> 3;
                    bitmap[byte_offset] |= (0xFF << (8 - num_pixels_remaining));
                }
            } else {
                const dataView = this.dataView;
                //let pixel_index = row_offset + x_start;
                //const start_byte = pixel_index >> 3;
                //const start_bit_offset = pixel_index & 7;
                //let num_pixels_remaining = total_pixels;

                // Handle first byte if not aligned
                if (start_bit_offset !== 0) {
                    const bits_to_set = Math.min(8 - start_bit_offset, num_pixels_remaining);
                    bitmap[start_byte] |= ((0xFF >> (8 - bits_to_set)) << (8 - start_bit_offset - bits_to_set));
                    pixel_index += bits_to_set;
                    num_pixels_remaining -= bits_to_set;
                }

                // Handle 64-bit chunks
                while (num_pixels_remaining >= 64) {
                    const byte_offset = pixel_index >> 3;
                    dataView.setBigUint64(byte_offset, 0xFFFFFFFFFFFFFFFFn, false);
                    pixel_index += 64;
                    num_pixels_remaining -= 64;
                }

                // Handle remaining whole bytes
                while (num_pixels_remaining >= 8) {
                    const byte_offset = pixel_index >> 3;
                    bitmap[byte_offset] |= 0xFF;
                    pixel_index += 8;
                    num_pixels_remaining -= 8;
                }

                // Handle remaining bits
                if (num_pixels_remaining > 0) {
                    const byte_offset = pixel_index >> 3;
                    bitmap[byte_offset] |= (0xFF << (8 - num_pixels_remaining));
                }
            }
        } 
        
        
        

       
    }

    

    fill_scanline_with_edges_1bipp(scanline_y) {
        const { edges } = this;
        const { active_edges, num_active_edges } = this.edges;

        if (num_active_edges < 2) {
            if (DEBUG) console.log(`Scanline ${scanline_y}: Not enough active edges to form spans.`);
            return;
        }

        const bitmap = this.bitmap;
        const row_offset = scanline_y * this.width;
        const naem1 = num_active_edges - 1;

        for (let i = 0; i < naem1; i += 2) {
            const x_start = Math.round(edges.get(active_edges[i], 0));
            const x_end = Math.round(edges.get(active_edges[i + 1], 0));

            this._set_pixels_span_1bipp(bitmap, row_offset, x_start, x_end);

            //const is_horizontal = edges.get(active_edges[i], 5) === 1; // Check if edge is horizontal

            // Draw the left edge pixel
            //const left_edge_pixel_index = row_offset + x_start;
            //const left_byte_offset = left_edge_pixel_index >> 3;
            //bitmap[left_byte_offset] |= (128 >> (left_edge_pixel_index & 7));

            //if (is_horizontal) {
                // Draw the entire horizontal edge as a span
                
                //continue; // Horizontal edge fully handled here
            //} else {
                // Fill the span between edges
            //    this._set_pixels_span_1bipp(bitmap, row_offset, x_start, x_end);

                // Draw the right edge pixel
                //const right_edge_pixel_index = row_offset + x_end;
                //const right_byte_offset = right_edge_pixel_index >> 3;
                //bitmap[right_byte_offset] |= (128 >> (right_edge_pixel_index & 7));
            //}

            

            if (DEBUG) {
                console.log(`Scanline ${scanline_y}: Processed span from x=${x_start} to x=${x_end}`);
            }
        }
    }

    fill_scanline_no_edges_1bipp(scanline_y) {
        const { edges } = this;
        const { active_edges, num_active_edges } = this.edges;

        if (num_active_edges < 2) {
            if (DEBUG) console.log(`Scanline ${scanline_y}: Not enough active edges to form spans.`);
            return;
        }

        const bitmap = this.bitmap;
        const row_offset = scanline_y * this.width;
        const naem1 = num_active_edges - 1;

        for (let i = 0; i < naem1; i += 2) {
            const x_start = Math.ceil(edges.get(active_edges[i], 0));
            const x_end = Math.floor(edges.get(active_edges[i + 1], 0));

            // Fill the span between edges
            this._set_pixels_span_1bipp(bitmap, row_offset, x_start, x_end);

            if (DEBUG) {
                console.log(`Scanline ${scanline_y}: Filling span from x=${x_start} to x=${x_end}`);
            }
        }
    }

    *iterate_process() {
        const h = this.height, edges = this.edges;

        for (let y = 0; y < h; y++) {
            edges.update_active_edges(y);
            edges.sort_active_edges_by_x();

            if (DEBUG) {
                console.log(`Scanline ${y}: Active Edges`, edges.active_edges.slice(0, edges.num_active_edges));
            }

            yield* this.iterate_scanline(y);
            this._update_x_intercepts();
        }
    }

    *iterate_scanline(scanline_y) {
        const { edges } = this;
        const { active_edges, num_active_edges } = this.edges;

        if (num_active_edges < 2) {
            if (DEBUG) console.log(`Scanline ${scanline_y}: Not enough active edges to form spans.`);
            return;
        }

        for (let i = 0; i < num_active_edges - 1; i += 2) {
            const x_start = Math.ceil(edges.get(active_edges[i], 0));
            const x_end = Math.floor(edges.get(active_edges[i + 1], 0));

            if (x_start <= x_end) {
                yield [scanline_y, x_start, x_end];
            }
        }
    }

    _update_x_intercepts() {
        const edges = this.edges;
        const { active_edges, num_active_edges } = edges;

        for (let i = 0; i < num_active_edges; i++) {
            const edge_index = active_edges[i];
            edges.set(edge_index, 0, edges.get(edge_index, 0) + edges.get(edge_index, 4));

            if (DEBUG) {
                console.log(`Edge ${edge_index}: Updated x=${edges.get(edge_index, 0)} using slope=${edges.get(edge_index, 4)}`);
            }
        }
    }
}

module.exports = ScanlineProcessor;

},{"./is_debug":37}],35:[function(require,module,exports){


class Shape {

}

module.exports = Shape;
},{}],36:[function(require,module,exports){
class TA_Table_8_Columns {
    constructor(row_count) {
        this.row_size = 8; // Fixed row size of 8
        this.row_count = row_count;
        this.ta = new Float32Array(this.row_size * this.row_count);
        const sorted_indices = this.sorted_indices = new Uint32Array(this.row_count); // Sorted logical indices

        for (let i = 0; i < row_count; i++) {
            sorted_indices[i] = i;
        }
    }

    get(row, col) {
        return this.ta[(row << 3) + col];
    }

    set(row, col, value) {
        this.ta[(row << 3) + col] = value;
    }

    sort_indices(comparator) {
        this.sorted_indices.sort((a, b) => comparator(a, b, this));
    }
}

module.exports = TA_Table_8_Columns;

},{}],37:[function(require,module,exports){
module.exports = false;
},{}],38:[function(require,module,exports){


const copy = require('./ta-math/copy');
const info = require('./ta-math/info');
const read = require('./ta-math/read');
const transform = require('./ta-math/transform');
const write = require('./ta-math/write');

const bitwise = require('./ta-math/bitwise');

const {
    right_shift_32bit_with_carry,
    xor_typed_arrays,
    each_1_index,
    count_1s,
    get_ta_bits_that_differ_from_previous_as_1s,
    get_bit,
    fast_find_next_set_ta_bit
} = bitwise;


const draw = require('./ta-math/draw');

const {draw_polygon_outline_to_ta_1bipp, ensure_polygon_is_ta, calc_polygon_stroke_points_x_y} = draw;
    
const {copy_rect_to_same_size_8bipp, copy_rect_to_same_size_24bipp, copy_ta_byte_range, unaligned_copy_rect_1to4bypp,
    dest_aligned_copy_rect_1to4bypp} = copy;

const {overlapping_bounds} = info;

const {fill_solid_rect_by_bounds} = write;

const {read_1x2_rect, read_2x1_rect, read_2x2_rect, read_px} = read;
const {resize_ta_colorspace} = transform;


module.exports = {

    draw_polygon_outline_to_ta_1bipp,
    ensure_polygon_is_ta,

    right_shift_32bit_with_carry,
    xor_typed_arrays,
    each_1_index,
    count_1s,
    get_ta_bits_that_differ_from_previous_as_1s,
    calc_polygon_stroke_points_x_y,
    get_bit,
    fast_find_next_set_ta_bit,



    draw,
    copy: copy,
    info: info,
    read: read,
    transform: transform,
    write: write,
    bitwise,


    overlapping_bounds: overlapping_bounds,
    copy_rect_to_same_size_8bipp: copy_rect_to_same_size_8bipp,
    copy_rect_to_same_size_24bipp: copy_rect_to_same_size_24bipp,
    copy_ta_byte_range: copy_ta_byte_range,
    unaligned_copy_rect_1to4bypp: unaligned_copy_rect_1to4bypp,
    dest_aligned_copy_rect_1to4bypp: dest_aligned_copy_rect_1to4bypp,
    fill_solid_rect_by_bounds: fill_solid_rect_by_bounds,
    read_1x2_rect: read_1x2_rect,
    read_2x1_rect: read_2x1_rect,
    read_2x2_rect: read_2x2_rect,
    read_px: read_px,
    read_pixel: read_px,

    resize_ta_colorspace: resize_ta_colorspace//,
    //override: override,

    //get_instance: get_instance
}
},{"./ta-math/bitwise":39,"./ta-math/copy":40,"./ta-math/draw":41,"./ta-math/info":42,"./ta-math/read":43,"./ta-math/transform":44,"./ta-math/write":45}],39:[function(require,module,exports){
// Convert a Uint8Array to a continuous binary string (for debugging purposes)
const to_binary_string = (uint8Array) => {
    return Array.from(uint8Array)
        .map(byte => byte.toString(2).padStart(8, '0')) // Convert each byte to an 8-bit binary string
        .join(''); // Join all binary strings into one continuous string
};

/**
 * Right-shift a Uint8Array by 1 bit with carry propagation between 32-bit chunks.
 * @param {Uint8Array} image - The input image as a Uint8Array.
 * @returns {Uint8Array} - The resulting shifted image.
 */
const right_shift_32bit_with_carry = (image) => {
    const length = image.length;
    const shifted_result = new Uint8Array(length); // To hold the shifted image
    
    const dataView = new DataView(image.buffer);
    const resultView = new DataView(shifted_result.buffer);
    
    const chunks = length >> 2; // Number of 32-bit chunks (4 bytes per chunk)
    const remainder = length & 3; // Remainder bytes (length % 4)
    let carry = 0; // Carry bit from previous 32-bit chunk
    
    for (let i = 0; i < chunks; i++) {
        const original = dataView.getUint32(i * 4); // Read original 32-bit chunk in little-endian
        
        // Right-shift 32-bit chunk and add carry from previous chunk
        const shifted = (carry << 31) | (original >>> 1); // Carry into MSB
        
        // Store the shifted result in little-endian
        resultView.setUint32(i * 4, shifted);
        
        // Capture the least significant bit to carry into the next chunk
        carry = original & 1; // Get the LSB of the original chunk
    }

    // Handle the remaining bytes (if any)
    if (remainder > 0) {
        const lastIndex = chunks * 4; // Start index for the remaining bytes
        const lastChunk = new Uint8Array(4); // To hold the last 32-bit chunk
        
        // Copy the remaining bytes into the lastChunk
        lastChunk.set(image.slice(lastIndex));

        // Right-shift the last chunk and add carry
        const lastOriginal = new DataView(lastChunk.buffer).getUint32(0);
        const lastShifted = (carry << 31) | (lastOriginal >>> 1);
        
        // Store the last shifted result, considering the actual length
        for (let j = 0; j < remainder; j++) {
            resultView.setUint8(lastIndex + j, (lastShifted >>> (8 * (3 - j))) & 0xFF);
        }
    }
    
    return shifted_result;
};

/**
 * XOR two TypedArrays. Both arrays must be of the same length.
 * If a result array is not provided, a new array will be created.
 * @param {Uint8Array | TypedArray} original_image - The first TypedArray.
 * @param {Uint8Array | TypedArray} shifted_image - The second TypedArray.
 * @param {TypedArray} [res] - Optional TypedArray to store the result. If not provided, a new one will be created.
 * @returns {TypedArray} - The XOR result array.
 */
const xor_typed_arrays = (original_image, shifted_image, res) => {
    const length = original_image.length;
    if (length !== shifted_image.length) {
        throw new Error('Typed arrays must be of the same length.');
    }

    const xor_result = res || new Uint8Array(length); // Create result array if not provided

    const originalView = new DataView(original_image.buffer);
    const shiftedView = new DataView(shifted_image.buffer);
    const resultView = new DataView(xor_result.buffer);
    
    const chunks = length >>> 2; // Number of 32-bit chunks (length / 4)
    const remaining_start_index = chunks << 2; // Calculate start index for remaining bytes

    // XOR each 32-bit chunk
    for (let i = 0; i < chunks; i++) {
        const byteOffset = i << 2; // Calculate byte offset (i * 4) using left shift
        const original = originalView.getUint32(byteOffset, false); // Read in big-endian
        const shifted = shiftedView.getUint32(byteOffset, false); // Read in big-endian
        const xor_result_chunk = original ^ shifted; // Perform XOR
        resultView.setUint32(byteOffset, xor_result_chunk, false); // Store result in big-endian
    }

    // Handle remaining bytes using DataView
    for (let i = remaining_start_index; i < length; i++) {
        const originalByte = originalView.getUint8(i); // Read remaining byte from original
        const shiftedByte = shiftedView.getUint8(i); // Read remaining byte from shifted
        resultView.setUint8(i, originalByte ^ shiftedByte); // Store XOR of remaining bytes
    }

    return xor_result;
};
const copy_row_beginning_bits = (ta_source, row_width, ta_dest) => {
    // source and dest must be the same lengths.
    if (ta_source.length !== ta_dest.length) {
        throw new Error("Source and destination arrays must be the same length.");
    }

    const total_bits = ta_source.length * 8; // Total number of bits in the source and destination arrays
    const dataViewSource = new DataView(ta_source.buffer, ta_source.byteOffset);
    const dataViewDest = new DataView(ta_dest.buffer, ta_dest.byteOffset);

    // Calculate the number of rows based on row width in bits
    const height = Math.floor(total_bits / row_width); // Number of rows

    let bit_index = 0; // Bit-level index

    for (let y = 0; y < height; y++) {
        const byte_index = Math.floor(bit_index / 8); // Determine which byte the bit is in
        const bit_in_byte = bit_index % 8;            // Determine the bit position within the byte

        // Read the byte from the source where the row starts
        const source_byte = dataViewSource.getUint8(byte_index);

        // Extract the first bit of the row (most significant bit at the beginning of each row)
        const first_bit = (source_byte >> (7 - bit_in_byte)) & 1; // Extract the specific bit

        // Read the destination byte and modify its first bit
        const dest_byte = dataViewDest.getUint8(byte_index);
        const updated_dest_byte = (dest_byte & ~(1 << (7 - bit_in_byte))) | (first_bit << (7 - bit_in_byte));

        // Write the updated byte back into the destination
        dataViewDest.setUint8(byte_index, updated_dest_byte);

        bit_index += row_width; // Move to the next row (row_width is in bits, so move by that many bits)
    }
};

/**
 * Sets the beginning bit of each row to 0 in a binary grid represented by a typed array.
 * @param {Uint8Array} ta - The typed array representing the binary grid.
 * @param {number} row_width - The width of each row in bits.
 */
const set_row_beginning_bits_to_0 = (ta, row_width) => {
    const total_bits = ta.length * 8; // Total number of bits in the array
    const dataView = new DataView(ta.buffer, ta.byteOffset);
    const height = Math.floor(total_bits / row_width); // Number of rows

    let bit_index = 0; // Bit-level index

    for (let y = 0; y < height; y++) {
        const byte_index = Math.floor(bit_index / 8); // Determine which byte the bit is in
        const bit_in_byte = bit_index % 8;            // Determine the bit position within the byte

        // Read the current byte from the DataView
        const byte = dataView.getUint8(byte_index);

        // Clear the bit at the specific position (set it to 0)
        const updated_byte = byte & ~(1 << (7 - bit_in_byte));

        // Write the updated byte back into the DataView
        dataView.setUint8(byte_index, updated_byte);

        // Move to the start of the next row (row_width is in bits, so move by that many bits)
        bit_index += row_width;
    }
};

const _copy_row_beginning_bits = (ta_source, row_width, ta_dest) => {
    // source and dest must be the same lengths.

    if (ta_source.length === ta_dest.length) {

        const l = ta_source.length;
        // calculate the number or rows.... (height)

        const height = l / row_width;

        let bit_index = 0;
        for (let y = 0; y < height; y++) {
            // Copy 


            bit_index += row_width;
        }

    }

}



/**
 * Fast method to find the index of the next set bit in a 32-bit integer.
 * @param {number} num - The number to search within.
 * @param {number} start_index - The starting index to search from.
 * @returns {number|boolean} - The index of the next set bit, or false if none found.
 */
const fast_find_next_set_bit = (num, start_index) => {
    // Check if start_index is out of range
    if (start_index < -1 || start_index > 31) return false; // Ensure start_index is within valid range

    // Handle case where start_index is 31 (no more bits after that)
    if (start_index === 31) return false;

    // Mask out all bits up to and including the start_index
    if (start_index >= 0) {
        // Shift bits to the left to clear bits up to start_index
        num = num & ((1 << (31 - start_index)) - 1);
    }

    // Use clz32 to find the number of leading zeros
    if (num === 0) return false; // No bits set after start_index
    
    const next_set_bit = Math.clz32(num); // Number of leading zeros in remaining bits
    return next_set_bit < 32 ? next_set_bit : false; // Return the index of the next set bit
};
/**
 * Finds the index of the next set bit in a typed array, processing in 32-bit chunks where possible.
 *
 * @param {Uint8Array | Uint16Array | Uint32Array} ta - The typed array to search within.
 * @param {number} start_index - The starting bit index to search from.
 * @param {number} limit - The maximum number of bits to search.
 * @returns {number|boolean} - The index of the next set bit or false if none found.
 *//**
 * Finds the index of the next set bit in a typed array, processing in 32-bit chunks where possible.
 *
 * @param {Uint8Array | Uint16Array | Uint32Array} ta - The typed array to search within.
 * @param {number} start_index - The starting bit index to search from.
 * @param {number} limit - The maximum number of bits to search.
 * @returns {number|boolean} - The index of the next set bit or false if none found.
 */
const _____fast_find_next_set_ta_bit = (ta, start_index = 0, limit = ta.length * 8) => {
    const total_bits = ta.length * 8;
    if (start_index >= total_bits || limit <= 0) return false;

    const end_index = Math.min(start_index + limit, total_bits);
    const dv = new DataView(ta.buffer, ta.byteOffset, ta.byteLength);

    let bit_index = start_index;

    // Process each bit, leveraging 32-bit chunk processing where possible
    while (bit_index < end_index) {
        const byte_offset = bit_index >>> 3; // Convert bit index to byte index
        const bit_offset_in_byte = bit_index & 7; // Position of bit within byte

        // If aligned to 32-bit boundary and at least 32 bits left, read a full 32-bit word
        if (bit_offset_in_byte === 0 && bit_index + 32 <= end_index) {
            const chunk = dv.getUint32(byte_offset, false); // Read 32 bits in big-endian
            const chunk_start_index = bit_index & 31; // Offset within the chunk

            let relative_bit_index = fast_find_next_set_bit(chunk, chunk_start_index);

            if (relative_bit_index !== false) {
                return bit_index + relative_bit_index; // Return absolute bit index
            }

            // Move by 32 bits if no set bit found in this chunk
            bit_index += 32;
        } else {
            // Check single bits for any remaining positions
            const byte = dv.getUint8(byte_offset);
            const bit_pos_in_byte = 7 - (bit_index & 7);

            if ((byte & (1 << bit_pos_in_byte)) !== 0) {
                return bit_index;
            }

            bit_index++;
        }
    }

    return false; // No set bit found
};

/**
 * Finds the index of the next set bit in a typed array within a specified limit, ensuring it moves forward from the start_index.
 * @param {Uint8Array | Uint16Array | Uint32Array} ta - The typed array to search within.
 * @param {number} start_index - The starting bit index to search from.
 * @param {number} limit - The maximum number of bits to search.
 * @returns {number|boolean} - The index of the next set bit within the typed array, or false if none found.
 */
const fast_find_next_set_ta_bit = (ta, start_index = 0, limit = ta.length * 8) => {
    const total_bits = ta.length * 8;
    const end_index = Math.min(start_index + limit, total_bits);

    // Start searching from the bit after start_index
    for (let bit_index = start_index + 1; bit_index < end_index; bit_index++) {
        const byte_index = bit_index >>> 3;
        const bit_in_byte = bit_index & 7;
        
        // Check if the specific bit is set (1)
        if ((ta[byte_index] & (1 << (7 - bit_in_byte))) !== 0) {
            return bit_index; // Return the first found set bit index
        }
    }
    return false; // No set bit found within the range
};

/**
 * Iterate through a TypedArray and call a callback for each index where the bit is '1'.
 * @param {TypedArray} ta - The TypedArray to iterate over.
 * @param {function} cb - The callback to invoke for each index with a bit of '1'.
 */
const each_1_index = (ta, cb) => {
    const length = ta.length;

    // Check if the TypedArray is empty
    if (length === 0) return;

    const view = new DataView(ta.buffer, ta.byteOffset); // Ensure DataView respects byteOffset
    const chunks = length >>> 2; // Number of 32-bit chunks
    const remaining_start_index = chunks << 2; // Start index for remaining bytes
    const remaining_length = length % 4; // Length of remaining bytes

    // Iterate through each 32-bit chunk
    for (let i = 0; i < chunks; i++) {
        const value = view.getUint32(i << 2, false); // Read 32-bit chunk in big-endian
        let bit_index = fast_find_next_set_bit(value, -1); // Start searching from the beginning

        // While there are set bits in this chunk
        while (bit_index !== false) {
            cb((i << 5) + bit_index); // `i << 5` accounts for 32 bits (not bytes) in the chunk
            bit_index = fast_find_next_set_bit(value, bit_index); // Find the next set bit
        }
    }

    // Handle remaining bytes if any
    for (let i = 0; i < remaining_length; i++) {
        const byte = view.getUint8(remaining_start_index + i); // Read the remaining byte
        // Check each bit in the byte
        for (let bit = 0; bit < 8; bit++) {
            if (byte & (1 << (7 - bit))) { // Check if the bit is '1' (start from MSB)
                // Calculate the absolute index in the original TypedArray
                const absolute_index = (remaining_start_index * 8) + (i * 8) + bit;
                cb(absolute_index); // Call the callback with the bit index
            }
        }
    }
};


/*
const pop_cnt = (n) => {
    n = n - ((n >> 1) & 0x55555555);             // Put count of each 2 bits into those 2 bits
    n = (n & 0x33333333) + ((n >> 2) & 0x33333333); // Put count of each 4 bits into those 4 bits
    n = (n + (n >> 4)) & 0x0F0F0F0F;             // Put count of each 8 bits into those 8 bits
    n = n + (n >> 8);                            // Put count of each 16 bits into those 16 bits
    n = n + (n >> 16);                           // Put count of each 32 bits into those 32 bits
    return n & 0x3F;                             // Mask to get the last 6 bits (which is enough to store the result)
  };

const count_1s = ta => {
    const length = ta.length;
    let res = 0;

    // Check if the TypedArray is empty
    if (length === 0) return;

    const view = new DataView(ta.buffer);
    const chunks = length >>> 2; // Number of 32-bit chunks
    const remaining_start_index = chunks << 2; // Start index for remaining bytes
    const remaining_length = length % 4; // Length of remaining bytes

    // Iterate through each 32-bit chunk
    for (let i = 0; i < chunks; i++) {


        
       res += pop_cnt(value);
    }

    // Handle remaining bytes if any
    for (let i = 0; i < remaining_length; i++) {
        const byte = view.getUint8(remaining_start_index + i); // Read the remaining byte
        // Check each bit in the byte
        for (let bit = 0; bit < 8; bit++) {
            if (byte & (1 << bit)) { // If the bit is '1'
                // Calculate the absolute index in the original TypedArray
                //const absolute_index = remaining_start_index + (i * 8) + bit; // Index within the TypedArray
                //cb(absolute_index); // Call the callback with the bit index
                res++;
            }
        }
    }

    return res;

}
    */


const pop_cnt = (n) => {
    n = n - ((n >> 1) & 0x55555555);             // Put count of each 2 bits into those 2 bits
    n = (n & 0x33333333) + ((n >> 2) & 0x33333333); // Put count of each 4 bits into those 4 bits
    n = (n + (n >> 4)) & 0x0F0F0F0F;             // Put count of each 8 bits into those 8 bits
    n = n + (n >> 8);                            // Put count of each 16 bits into those 16 bits
    n = n + (n >> 16);                           // Put count of each 32 bits into those 32 bits
    return n & 0x3F;                             // Mask to get the last 6 bits (which is enough to store the result)
};

// Count the number of 1 bits in a whole TypedArray
const pop_cnt_typed_array = (typedArray, is_little_endian = true) => {
    let total_count = 0;
    const length = typedArray.length;
    if (length === 0) return total_count; // Edge case: Empty array
    const view = new DataView(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
    // Process full 32-bit (4-byte) chunks
    const chunks = length >>> 2; // Integer division by 4
    for (let i = 0; i < chunks; i++) {
        const value = view.getUint32(i << 2, is_little_endian); // Read each 32-bit chunk
        total_count += pop_cnt(value); // Count the '1' bits in this chunk
    }
    // Handle any remaining bytes (less than 32 bits)
    const remaining_start_index = chunks << 2; // Start index for remaining bytes
    const remaining_length = length - remaining_start_index; // Remaining bytes count
    for (let i = 0; i < remaining_length; i++) {
        const byte = view.getUint8(remaining_start_index + i); // Read each remaining byte
        // Count '1' bits manually for each byte
        total_count += (byte & 1) + ((byte >> 1) & 1) + ((byte >> 2) & 1) + ((byte >> 3) & 1) +
                        ((byte >> 4) & 1) + ((byte >> 5) & 1) + ((byte >> 6) & 1) + ((byte >> 7) & 1);
    }
    return total_count;
};

const count_1s = pop_cnt_typed_array;


// const iterate 1 positions.

// each_1_index


class BitwiseTester {
    constructor(ta = null) {
        // Create a default TypedArray if none is provided.
        if (ta) {
            this.ta = ta;
        } else {
            // Create a default TypedArray with Fibonacci-influenced pattern
            this.ta = new Uint8Array([0, 1, 1, 2, 3, 5, 8, 13]);
        }
    }

    // Testing shift_typed_array_right using string representation
    test_shift_typed_array_right() {
        const result = right_shift_32bit_with_carry(this.ta);
    
        // Convert the original TypedArray to a binary string representation
        const binary_ta1 = to_binary_string(this.ta);
        // Convert the result TypedArray to a binary string representation
        const binary_ta2 = to_binary_string(result);
    
        // Remove the first bit from ta1 and add a 0 to the end to simulate the right shift by 1
        const expected_shift = '0' + binary_ta1.slice(0, -1);
    
        // Check if the expected shifted binary string matches the actual result
        if (expected_shift === binary_ta2) {
            return {
                passed: true,
                messages: ["Test Passed: The shift operation works correctly."]
            };
        } else {
            return {
                passed: false,
                messages: [`Test Failed: The shifted result does not match the expected output. Expected: ${expected_shift}, Got: ${binary_ta2}`]
            };
        }
    }

    // Testing xor_typed_arrays (unchanged for context)
    test_xor_typed_arrays() {
        const ta2 = new Uint8Array(this.ta.length).fill(1); // Example second array for XOR
        const result = xor_typed_arrays(this.ta, ta2);
        
        // Create string representations
        let resultBinary = '';
        for (const byte of result) {
            resultBinary += byte.toString(2).padStart(8, '0');
        }
        
        let expectedBinary = '';
        for (let i = 0; i < this.ta.length; i++) {
            expectedBinary += (this.ta[i] ^ ta2[i]).toString(2).padStart(8, '0');
        }

        const passed = resultBinary === expectedBinary;
        const messages = [];
        
        if (!passed) {
            messages.push('XOR test failed. Expected: ' + expectedBinary + ', Got: ' + resultBinary);
        } else {

        }

        return {
            passed,
            messages,
        };
    }

    // Method to run all tests (unchanged for context)
    test() {
        const results = [];
        let count_passed = 0;
        let count_failed = 0;

        const shift_test_result = this.test_shift_typed_array_right();
        results.push(shift_test_result);
        if (shift_test_result.passed) count_passed++;
        else count_failed++;

        const xor_test_result = this.test_xor_typed_arrays();
        results.push(xor_test_result);
        if (xor_test_result.passed) count_passed++;
        else count_failed++;

        return {
            passed: count_failed === 0,
            count_passed,
            count_failed,
            results,
        };
    }
}


if (require.main === module) {
    const tester = new BitwiseTester();
    const test_res = tester.test();
    console.log('test_res', JSON.stringify(test_res, null, 2));


}

const get_ta_bits_that_differ_from_previous_as_1s = (ta_source, bits_per_row, ta_dest = new ta_source.constructor(ta_source.length), copy_original_x0_values = false) => {
    // no wrapping

    const rshifted = right_shift_32bit_with_carry(ta_source);
    xor_typed_arrays(ta_source, rshifted, ta_dest);


    if (copy_original_x0_values) {
        copy_row_beginning_bits(ta_source, bits_per_row, ta_dest);
    } else {
        // Set row beginning bits to 0 as they do not differ from the (theoretical) pixel before them that is not a pixel with a different color because it is a virtual pixel without a different color.

        set_row_beginning_bits_to_0(ta_dest);

    }
    
    return ta_dest;

}

const get_bit = (ta, i) => (ta[i >> 3] >> (7 - (i & 0b111))) & 1;

// Exports
module.exports = {
    right_shift_32bit_with_carry,
    xor_typed_arrays,
    each_1_index,
    count_1s,
    pop_cnt,
    pop_cnt_typed_array,
    copy_row_beginning_bits,
    get_ta_bits_that_differ_from_previous_as_1s,
    get_bit,
    fast_find_next_set_ta_bit
};

},{}],40:[function(require,module,exports){



// dest_aligned_copy_rect_1to4bypp
//  the destination size is aligned with the ta_source_bounds
//   could check that previously in a more generalised copy_rect function.

const get_instance = () => {

    const copy_ta_byte_range = (ta_source, ta_dest, byte_idx_source_start, byte_idx_dest_start, length) => {

        // Try the system from row copy.
    
        // Could try version with inner loop?
    
        ta_dest.set(ta_source.subarray(byte_idx_source_start, byte_idx_source_start + length), byte_idx_dest_start);
    
    }
    
    
    // Need more general version of this.
    
    // Some more work on copying aligned / non-aligned tas.
    //  Different mathematical operations needed for different image operations specifics.
    
    
    // Should rename this to be more specific about it writing into the full ta space.
    //  dest is the same size as the bounds.
    
    // copy to same bounds size.
    
    const copy_rect_to_same_size_8bipp = (xy, bounds, ta, ta_res, ta_byte_indexes, bytes_read_row_end_jump) => {
            // bytes_read_row_end_jump : ta_op_further_info[0]
        //const bytes_read_row_end_jump = ta_op_further_info[0];
        // Safety checking to begin with?
    
        // May as well use local variables for loop...
        
    
    
        for (xy[1] = bounds[1]; xy[1] < bounds[3]; xy[1]++) {
            for (xy[0] = bounds[0]; xy[0] < bounds[2]; xy[0]++) {
                ta_res[ta_byte_indexes[1]++] = ta[ta_byte_indexes[0]++];
            }
            // then row jump increase.
            ta_byte_indexes[0] += bytes_read_row_end_jump;
        }
    }
    
    
    const copy_rect_to_same_size_24bipp = (xy, bounds, ta, ta_res, ta_byte_indexes, bytes_read_row_end_jump) => {
        
        // Safety checking to begin with?
        for (xy[1] = bounds[1]; xy[1] < bounds[3]; xy[1]++) {
            for (xy[0] = bounds[0]; xy[0] < bounds[2]; xy[0]++) {
    
                //const ui8_px_value = ta[byte_idx_pb_read];
                //ui8_px_value = ta[byte_idx_pb_read];
    
                //console.log('byte_idx_pb_read')
    
                ta_res[ta_byte_indexes[1]++] = ta[ta_byte_indexes[0]++];
                ta_res[ta_byte_indexes[1]++] = ta[ta_byte_indexes[0]++];
                ta_res[ta_byte_indexes[1]++] = ta[ta_byte_indexes[0]++];
    
                // But don't need to copy the px value in many cases.
    
                //  Maybe have / use lower level fuctions for copying between different pbs / tas.
                //  Iterating spaces.
                //   Iterating spaces defined by a function / equation?
                //    Eg could functionally / mathematically define a circle and draw it.
                
                // got the xy iteration pos set correctly here :)
    
                // could copy px values?
                //  reading and using them directly may work best....
    
                //byte_idx_pb_read += bytes_per_pixel;
    
            }
            // then row jump increase.
            ta_byte_indexes[0] += bytes_read_row_end_jump;
        }
    }
    
    // pre-running functions to uptimize them?
    
    
    // Worth writing and trying / exemplifying fast copy algorithms.
    
    // copy from 8bipp to 24 bipp as well.
    //   likely should read and write by pixel?
    //   should be easy to make synced algorithm for this.
    
    
    // for the moment, likely to use many function parameters...
    
    // Will use byte index iteration?
    //  Will do xy iteration having been given the source bounds and the dest pos?
    
    
    // Use byte indexes?
    
    // bytes_pre_row source
    // bytes_per_row_dest
    
    // bypr_source
    
    
    // dest_pos is alway [0, 0]. For when the size of the copied area = the size of the dest.
    
    const dest_aligned_copy_rect_1to4bypp = (ta_source, ta_dest, bypr_source, bytes_per_pixel, ta_source_bounds) => {
        let y;
    
        // check ta_dest.length meets expectation?
    
    
        //console.log('ta_source_bounds', ta_source_bounds);
        //console.log('bytes_per_pixel', bytes_per_pixel);
    
    
        // Uses copy ta byte range function underneith.
    
        // need to calculate initial read and write byte idxs
    
        // calculate the start index for both the source and the dest.
    
        const bounds_row_width = ta_source_bounds[2] - ta_source_bounds[0];
        const bypr_dest = bounds_row_width * bytes_per_pixel;
        //console.log('bounds_row_width', bounds_row_width);
        const bytes_per_bounds_row = bytes_per_pixel * bounds_row_width;
        const byi_read_start = (ta_source_bounds[0] * bytes_per_pixel) + (ta_source_bounds[1] * bypr_source);
        //const byi_dest_start = (bytes_per_pixel) + (ta_dest_pos[1] * bypr_dest);
        const byi_dest_start = 0;
    
        let byi_read = byi_read_start, byi_write = byi_dest_start;
        //const bytes_source_row_jump = bypr_source - bytes_per_bounds_row, bytes_dest_row_jump = bypr_dest - bytes_per_bounds_row;
    
        //console.log('bytes_source_row_jump', bytes_source_row_jump);
        //console.log('bytes_dest_row_jump', bytes_dest_row_jump);
    
        //console.log('bytes_per_bounds_row', bytes_per_bounds_row);
    
    
        for (y = ta_source_bounds[1]; y < ta_source_bounds[3]; y++) {
            //console.log('byi_read, byi_write', [byi_read, byi_write]);
            copy_ta_byte_range(ta_source, ta_dest, byi_read, byi_write, bytes_per_bounds_row);
    
            byi_read += bypr_source;
            byi_write += bypr_dest;
    
            // use the sopy row function?
            //  worth giving it a try.
    
            // Can use the full row copy procedure.
            //copy_ta_byte_range
        }
    }
    
    // Worth writing and using some copy algorithms. Further work on supporting abstractions / data.
    
    const unaligned_copy_rect_1to4bypp = (ta_source, ta_dest, bypr_source, bypr_dest, bytes_per_pixel, ta_source_bounds, ta_dest_pos) => {
        // try own local y and x...
    
        let y;
    
        //console.log('ta_source_bounds', ta_source_bounds);
        //console.log('bytes_per_pixel', bytes_per_pixel);
    
    
        // Uses copy ta byte range function underneith.
    
        // need to calculate initial read and write byte idxs
    
        // calculate the start index for both the source and the dest.
    
        const bounds_row_width = ta_source_bounds[2] - ta_source_bounds[0];
        //console.log('bounds_row_width', bounds_row_width);
        const bytes_per_bounds_row = bytes_per_pixel * bounds_row_width;
    
        //console.log('bypr_source', bypr_source);
        //console.log('bypr_dest', bypr_dest);
    
    
        const byi_read_start = (ta_source_bounds[0] * bytes_per_pixel) + (ta_source_bounds[1] * bypr_source);
        const byi_dest_start = (ta_dest_pos[0] * bytes_per_pixel) + (ta_dest_pos[1] * bypr_dest);
    
        //console.log('byi_read_start', byi_read_start);
        //console.log('byi_dest_start', byi_dest_start);
    
        let byi_read = byi_read_start, byi_write = byi_dest_start;
    
    
        // Use this 'jump' method when dealing with advancing the position to the end of the r/w row.
        //  Copying whole rows, need to advance the whole row position.
        //const bytes_source_row_jump = bypr_source - bytes_per_bounds_row, bytes_dest_row_jump = bypr_dest - bytes_per_bounds_row;
    
        //console.log('bytes_source_row_jump', bytes_source_row_jump);
        //console.log('bytes_dest_row_jump', bytes_dest_row_jump);
    
        //console.log('bytes_per_bounds_row', bytes_per_bounds_row);
    
        for (y = ta_source_bounds[1]; y < ta_source_bounds[3]; y++) {
            //console.log('byi_read, byi_write', [byi_read, byi_write]);
            copy_ta_byte_range(ta_source, ta_dest, byi_read, byi_write, bytes_per_bounds_row);
    
            byi_read += bypr_source;
            byi_write += bypr_dest;
    
            // use the sopy row function?
            //  worth giving it a try.
    
            // Can use the full row copy procedure.
    
            //copy_ta_byte_range
        }
    }
        
    const copy_px_to_ta_dest_byi = (ta_source, source_colorspace, source_xy, ta_dest, byi_dest) => {
        const [width, height, bypp, bypr, bipp, bipr] = source_colorspace;

        if (bipp === 24) {
            let byi_read = source_xy[0] * bypp + source_xy[1] * bypr;
            ta_dest[byi_dest] = ta_source[byi_read++];
            ta_dest[byi_dest + 1] = ta_source[byi_read++];
            ta_dest[byi_dest + 2] = ta_source[byi_read++];

        } else {
            console.trace();
            throw 'NYI';
        }
    }

        
    const copy_px_24bipp = (ta_source, byi_read, ta_dest, byi_write) => {
        ta_dest[byi_write] = ta_source[byi_read++];
        ta_dest[byi_write + 1] = ta_source[byi_read++];
        ta_dest[byi_write + 2] = ta_source[byi_read++];
    }


    return {
    
        unaligned_copy_rect_1to4bypp: unaligned_copy_rect_1to4bypp,
        dest_aligned_copy_rect_1to4bypp: dest_aligned_copy_rect_1to4bypp,
        copy_rect_to_same_size_24bipp: copy_rect_to_same_size_24bipp,
        copy_rect_to_same_size_8bipp: copy_rect_to_same_size_8bipp,
        copy_ta_byte_range: copy_ta_byte_range,
        get_instance: get_instance,
        copy_px_to_ta_dest_byi: copy_px_to_ta_dest_byi,
        copy_px_24bipp: copy_px_24bipp
    };
}



// copy_px_to_ta

module.exports = get_instance();
},{}],41:[function(require,module,exports){



const is_integer_typed_array = (obj) => {
    if (ArrayBuffer.isView(obj)) {
        return (
            obj instanceof Int8Array ||
            obj instanceof Uint8Array ||
            obj instanceof Int16Array ||
            obj instanceof Uint16Array ||
            obj instanceof Int32Array ||
            obj instanceof Uint32Array ||
            obj instanceof BigInt64Array ||
            obj instanceof BigUint64Array
        );
    }
    return false;
};


const ensure_polygon_is_ta = polygon => {
    if (is_integer_typed_array(polygon)) {
        // Length must be divisible by 2.

        if (polygon.length % 2 === 0) {
            return polygon;
        } else {
            throw 'ta must have even number length, being [x, y] pairs';
        }
    } else {
        return new Uint32Array(polygon.flat());
    }
}


// Polygon really should be as a ta.

const draw_polygon_outline_to_ta_1bipp = (ta, img_width, polygon) => {
    polygon = ensure_polygon_is_ta(polygon);


    // Then go through the points of the polygon....
    //   Connect the dots.

    const num_points = polygon.length >>> 1;
    //console.log('num_points', num_points);
    // then go from point 1 (not 0), looking back at the prev.

    let r = 0, x = polygon[r++], y = polygon[r++], next_x, next_y;
    let dx, dy, sx, sy, err, e2;

    //throw 'stop';

    // set_pixel_on function.....

    const set_pixel_on = (x, y) => {
        const idx_bit = (y * img_width) + x;
        const byte = idx_bit >> 3;
        const bit = (idx_bit & 0b111);
        ta[byte] |= (128 >> bit);
    }



    for (let p = 1; p < num_points; p++) {
        // And compare with the previous....

        next_x = polygon[r++]; next_y = polygon[r++];

        dx = Math.abs(next_x - x);
        dy = Math.abs(next_y - y);
        sx = (x < next_x) ? 1 : -1;
        sy = (y < next_y) ? 1 : -1;
        err = dx - dy;

        while (true) {
            //this.set_pixel_1bipp([x, y], 1);
            set_pixel_on(x, y);

            if (x === next_x && y === next_y) {
                break;
            }

            e2 = 2 * err;
            if (e2 > -dy) {
                err -= dy;
                x += sx;
            }

            if (e2 < dx) {
                err += dx;
                y += sy;
            }
        }
        // Draw the line between them....

        x = next_x; y = next_y;
    }

    next_x = polygon[0]; next_y = polygon[1];

    dx = Math.abs(next_x - x);
    dy = Math.abs(next_y - y);
    sx = (x < next_x) ? 1 : -1;
    sy = (y < next_y) ? 1 : -1;
    err = dx - dy;

    while (true) {
        //this.set_pixel_1bipp([x, y], 1);
        set_pixel_on(x, y);

        if (x === next_x && y === next_y) {
            break;
        }

        e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x += sx;
        }

        if (e2 < dx) {
            err += dx;
            y += sy;
        }
    }

    return ta;



    // And have an inline drawing function here?
    //   Or at least re-expressing the set_pixel_on function.

    // converting [x, y] <=> pixel_index

    // draw line function....
    //   copy from before.




}

const remove_duplicates = (ta) => {
    // Step 1: Sort the array by y-values, then by x-values if y's are the same
    quicksort_points(ta); // Assumes quicksort_points is defined as in the previous response

    const numRecords = ta.length >>> 1;

    // Step 2: Count unique entries
    let uniqueCount = 0;
    let prev_x, prev_y;

    for (let i = 0; i < numRecords; i++) {
        const x = ta[i * 2];
        const y = ta[i * 2 + 1];

        if (i === 0 || x !== prev_x || y !== prev_y) {
            uniqueCount++;
            prev_x = x;
            prev_y = y;
        }
    }

    // Step 3: Create a new array with the size of unique entries
    const result = new ta.constructor(uniqueCount * 2);

    // Step 4: Copy unique entries to the result array
    let index = 0;
    prev_x = prev_y = undefined; // Reset previous values for copying loop

    for (let i = 0; i < numRecords; i++) {
        const x = ta[i * 2];
        const y = ta[i * 2 + 1];

        if (i === 0 || x !== prev_x || y !== prev_y) {
            result[index * 2] = x;
            result[index * 2 + 1] = y;
            index++;

            prev_x = x;
            prev_y = y;
        }
    }

    return result;
};

const quicksort_points = (ta) => {
    const partition = (left, right, pivotIndex) => {
        const pivotY = ta[pivotIndex * 2 + 1]; // Pivot y value
        const pivotX = ta[pivotIndex * 2]; // Pivot x value

        // Swap pivot with the rightmost element
        swap(pivotIndex, right);

        let storeIndex = left;

        for (let i = left; i < right; i++) {
            const currentY = ta[i * 2 + 1];
            const currentX = ta[i * 2];
            
            // Compare y-values first, then x-values if y-values are the same
            if (currentY < pivotY || (currentY === pivotY && currentX < pivotX)) {
                swap(i, storeIndex);
                storeIndex++;
            }
        }

        // Move pivot to its final place
        swap(storeIndex, right);

        return storeIndex;
    };

    const quicksort_recursive = (left, right) => {
        if (left < right) {
            const pivotIndex = Math.floor((left + right) / 2); // Choose a middle pivot
            const newPivot = partition(left, right, pivotIndex);

            // Recursively sort the subarrays
            quicksort_recursive(left, newPivot - 1);
            quicksort_recursive(newPivot + 1, right);
        }
    };

    const swap = (i, j) => {
        if (i === j) return;

        // Swap x values
        const tempX = ta[i * 2];
        ta[i * 2] = ta[j * 2];
        ta[j * 2] = tempX;

        // Swap y values
        const tempY = ta[i * 2 + 1];
        ta[i * 2 + 1] = ta[j * 2 + 1];
        ta[j * 2 + 1] = tempY;
    };

    const numRecords = ta.length >>> 1; // Number of records (each record has two values)

    quicksort_recursive(0, numRecords - 1);
    return ta;
};

const calc_polygon_stroke_points_x_y = polygon => {
    polygon = ensure_polygon_is_ta(polygon);

    const arr_stroke_points = [];

    const num_points = polygon.length >>> 1;
    //console.log('num_points', num_points);
    // then go from point 1 (not 0), looking back at the prev.

    let r = 0, x = polygon[r++], y = polygon[r++], next_x, next_y;
    let dx, dy, sx, sy, err, e2;

    //throw 'stop';

    // set_pixel_on function.....

    // and go back further in previousness checks?
    let prev_x, prev_y;

    const set_pixel_on = (x, y) => {
        if (!(prev_x === x && prev_y === y)) {
            arr_stroke_points.push(x, y);
        }
        // But not if it is repeated from previous????
        prev_x = x; prev_y = y;
        
    }



    for (let p = 1; p < num_points; p++) {
        // And compare with the previous....

        next_x = polygon[r++]; next_y = polygon[r++];

        dx = Math.abs(next_x - x);
        dy = Math.abs(next_y - y);
        sx = (x < next_x) ? 1 : -1;
        sy = (y < next_y) ? 1 : -1;
        err = dx - dy;

        while (true) {
            //this.set_pixel_1bipp([x, y], 1);
            set_pixel_on(x, y);

            if (x === next_x && y === next_y) {
                break;
            }

            e2 = 2 * err;
            if (e2 > -dy) {
                err -= dy;
                x += sx;
            }

            if (e2 < dx) {
                err += dx;
                y += sy;
            }
        }
        // Draw the line between them....

        x = next_x; y = next_y;

    }

    next_x = polygon[0]; next_y = polygon[1];

    dx = Math.abs(next_x - x);
    dy = Math.abs(next_y - y);
    sx = (x < next_x) ? 1 : -1;
    sy = (y < next_y) ? 1 : -1;
    err = dx - dy;

    while (true) {
        //this.set_pixel_1bipp([x, y], 1);
        set_pixel_on(x, y);

        if (x === next_x && y === next_y) {
            break;
        }

        e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x += sx;
        }

        if (e2 < dx) {
            err += dx;
            y += sy;
        }
    }

    const res = remove_duplicates(quicksort_points(new Uint16Array(arr_stroke_points)));
    return res;


}


module.exports = {
    ensure_polygon_is_ta,
    draw_polygon_outline_to_ta_1bipp,
    calc_polygon_stroke_points_x_y
}
},{}],42:[function(require,module,exports){




const get_instance = () => {


    // Maybe keeping colorspace as a simple array would work best.
    //  Using consts to get the value from the colorspace... would that work well?
    // const [...] = _colorspace_fields

    const byi_from_cs_pos = (colorspace, pos) => {
        const [width, height, bypp, bypr, bipp, bipr] = colorspace;
        //console.log('bypp, bypr', [bypp, bypr]);

        //console.log('pos', pos)
        //console.trace();

        return pos[0] * bypp + pos[1] * bypr;

    }
    // pb.color_space


    // Could read it as a subarray.
    //  Could then be writable too.

    // Optionally set the res into an existing ta.
    //  Benchmarks...





    //  Could work out somewhat faster? Harder to program though???
    //   May be simpler for C++ and making and using wrappers.
    //   Could use consts to refer to positions in arrays?
    //    Would be worth doing speed comparisons.





    // (source, dest, ta_op_info)



    // Or maybe it's worth providing existing tas? Supporting that at least.
    //  The bounds etc are likely to be given as tas.



    // This is really about:  *** Syncronised iteration of an xy position bounds within 2 typed arrays that share the same bits_per_pixel ***



    // Wonder if the end jump value not in a ta slows it down? Compiler needs to guess / support multiple types.
    //  Maybe calling it with numeric types is good?

    // ta_op_further_info seems unnecessary...


    // Try a version with a callback?


    // Compacted param tas could be of use.

    // all in one ta:?
    //  xy, bounds, ta_byte_indexes, bytes_read_row_end_jump


    // Maybe this will be fastest?

    // Maybe make / make standard an Int32Array(16) or so
    //  Could contain other info...


    // Not using this kind of system for the moment. Going with variable names.
    //  Will help porting too.


    /*

    const idx_ta_vars = {
        0: ['xy', 0],
        1: ['xy', 1],
        2: ['bounds', 0],
        3: ['bounds', 1],
        4: ['bounds', 2],
        5: ['bounds', 3],
        6: 'byte_idx_read',
        7: 'byte_idx_write',
        8: 'bytes_read_row_end_jump'

        // Other...?
        / *
        9?  bytes_per_pixel
        10? bytes_per_read_row
        11? bytes_per_write_row

        * /


    }
    */


    // Overlapping 2d bounds calculations would be useful too.
    // May want a quick (functional) way to describe the interface over the typed array.

    



    // calculate intersecting bounds on 2 given bounds (given as tas)

    const overlapping_bounds = (bounds_1, bounds_2, res_bounds = new Int16Array(4)) => {
        // the area of intersection between both bounds.

        //console.log('overlapping_bounds', overlapping_bounds);
        //console.log('bounds_1', bounds_1);
        //console.log('bounds_2', bounds_2);

        //console.trace();


        // Ensure the result is within the bounds of another...
        //  Need to find the range at which they overlap, if any.

        // A bit more than just ajusting one so it fits within the other?
        //  Maybe not? Could be based on that. Then check that it's not negative?

        // If bounds 1 were to fit within bounds 2, what would those new bounds be?

        // the max value of the lower bounds (x and y)
        // the min value of the higher bounds (x and y)

        //  see if it's positive
        //   otherwise return undefined? false?
        //   false could work well.



        // math.max and min? which would be faster?

        res_bounds[0] = bounds_1[0] < bounds_2[0] ? bounds_2[0] : bounds_1[0];
        res_bounds[1] = bounds_1[1] < bounds_2[1] ? bounds_2[1] : bounds_1[1];
        res_bounds[2] = bounds_1[2] > bounds_2[2] ? bounds_2[2] : bounds_1[2];
        res_bounds[3] = bounds_1[3] > bounds_2[3] ? bounds_2[3] : bounds_1[3];

        //throw 'stop';




        return res_bounds;
    }

    return {
        overlapping_bounds: overlapping_bounds,
        byi_from_cs_pos: byi_from_cs_pos,
        get_instance: get_instance
    }



}

module.exports = get_instance();
},{}],43:[function(require,module,exports){



const get_instance = () => {


        
    const read_px = (ta_source, ta_colorspace, ta_pos) => {

        // calculate byte index from pos and colorspace

        const bipp = ta_colorspace[4];

        //console.log('read_px bipp', bipp);

        if (bipp === 1) {
            // 1bipp
            console.trace();
            throw 'NYI';
        } else if (bipp === 8) {
            const byi = byi_from_cs_pos(ta_colorspace, ta_pos);
            return ta_source[byi];
        } else if (bipp === 24) {
            const byi = byi_from_cs_pos(ta_colorspace, ta_pos);

            //console.log('byi', byi);

            //console.log('ta_source.subarray(byi, byi + 3)', ta_source.subarray(byi, byi + 3));

            return ta_source.subarray(byi, byi + 3);
        } else if (bipp === 32) {
            const byi = byi_from_cs_pos(ta_colorspace, ta_pos);
            return ta_source.subarray(byi, byi + 4);
        }

        

    }

    //const read_4_px_rect = (ta_source, source_width, bytes_per_pixel, bytes_per_row, pos) => {


    const read_2x1_rect = (ta_source, ta_colorspace, ta_pos) => {
        // will just return the values of these 2 px in a single ta.


        const [x, y] = ta_pos;
        const [width, height, bypp, bypr, bipp, bipr] = ta_colorspace;

        if (x < 0) {
            throw 'x position must be between 0 and (width - 1)'
        }
        if (x > width - 1) {
            throw 'x position must be between 0 and (width - 1)'
        }
        if (y < 0) {
            throw 'y position must be between 0 and height'
        }
        if (y > height) {
            throw 'y position must be between 0 and height'
        }

        let byi_read = (x * bypp) + (y * bypr);

        if (bipp === 1) {
            console.trace();
            throw 'NYI';
        } else if (bipp === 8) {
            // different result sizes... maybe return a specific version of this.
            // unsafe_read_4px_rect(different params?)
            
            // lets do the work here... not so much to do.
            const res = new Uint8ClampedArray(2);
            res[0] = ta_source[byi_read];
            res[1] = ta_source[byi_read + 1];
            //res[2] = ta_source[byi_read + bypr];
            //res[3] = ta_source[byi_read + bypr + 1];

            //res[0] = 


            return res;

        } else if (bipp === 24) {
            const res = new Uint8ClampedArray(6);
            //res[0] = 

            // best to read 2 rows of pixels. 6 bytes per row of the copy space.
            res.set(ta_source.subarray(byi_read, byi_read + 6), 0);
            //byi_read += bypr;
            //res.set(ta_source.subarray(byi_read, byi_read + 6), 6);



            return res;
            
        } else if (bipp === 32) {
            //console.trace();
            //throw 'NYI';
            const res = new Uint8ClampedArray(8);
            //res[0] = 

            res.set(ta_source.subarray(byi_read, byi_read + 8), 0);
            //byi_read += bypr;
            //res.set(ta_source.subarray(byi_read, byi_read + 8), 8);


            return res;
        }

    }


    const read_1x2_rect = (ta_source, ta_colorspace, ta_pos) => {
        // will just return the values of these 2 px in a single ta.


        const [x, y] = ta_pos;
        const [width, height, bypp, bypr, bipp, bipr] = ta_colorspace;

        if (x < 0) {
            throw 'x position must be between 0 and (width - 1)'
        }
        if (x > width - 1) {
            throw 'x position must be between 0 and (width - 1)'
        }
        if (y < 0) {
            throw 'y position must be between 0 and height'
        }
        if (y > height) {
            throw 'y position must be between 0 and height'
        }

        let byi_read = (x * bypp) + (y * bypr);

        if (bipp === 1) {
            console.trace();
            throw 'NYI';
        } else if (bipp === 8) {
            // different result sizes... maybe return a specific version of this.
            // unsafe_read_4px_rect(different params?)
            
            // lets do the work here... not so much to do.
            const res = new Uint8ClampedArray(2);
            res[0] = ta_source[byi_read];
            res[1] = ta_source[byi_read + bypr];
            //res[2] = ta_source[byi_read + bypr];
            //res[3] = ta_source[byi_read + bypr + 1];

            //res[0] = 


            return res;

        } else if (bipp === 24) {
            const res = new Uint8ClampedArray(6);
            //res[0] = 

            // best to read 2 rows of pixels. 6 bytes per row of the copy space.
            res.set(ta_source.subarray(byi_read, byi_read + 3), 0);
            byi_read += bypr;

            res.set(ta_source.subarray(byi_read, byi_read + 3), 3);
            //byi_read += bypr;
            //res.set(ta_source.subarray(byi_read, byi_read + 6), 6);



            return res;
            
        } else if (bipp === 32) {
            //console.trace();
            //throw 'NYI';
            const res = new Uint8ClampedArray(8);
            //res[0] = 

            res.set(ta_source.subarray(byi_read, byi_read + 4), 0);
            byi_read += bypr;
            res.set(ta_source.subarray(byi_read, byi_read + 4), 4);
            //res.set(ta_source.subarray(byi_read, byi_read + 8), 8);


            return res;
        }

    }



    // Hopefully will be v fast!
    //  Consider C++ optimization too - but likely will be implemented and called in C++ because its very low level for some operations.
    const read_2x2_rect = (ta_source, ta_colorspace, ta_pos) => {

        const [x, y] = ta_pos;

        const [width, height, bypp, bypr, bipp, bipr] = ta_colorspace;

        //console.log('read_4_px_rect [width, height, bypp, bypr, bipp, bipr]', [width, height, bypp, bypr, bipp, bipr]);

        // Worth using pixel index / necessary to do so.
        //  Seems to come down to that at the lowest levels.





        // can not read an out of bounds 4px block
        //  should raise an error if it's attempted. it should not be attempted.

        // check it's within bounds...
        //  maybe better not to. see about speed increase when this is commented out.

        if (x < 0) {
            throw 'x position must be between 0 and (width - 1)'
        }
        if (x > width - 1) {
            throw 'x position must be between 0 and (width - 1)'
        }
        if (y < 0) {
            throw 'y position must be between 0 and (height - 1)'
        }
        if (y > height - 1) {
            throw 'y position must be between 0 and (height - 1)'
        }

        let byi_read = (x * bypp) + (y * bypr);

        if (bipp === 1) {
            console.trace();
            throw 'NYI';
        } else if (bipp === 8) {
            // different result sizes... maybe return a specific version of this.
            // unsafe_read_4px_rect(different params?)
            
            // lets do the work here... not so much to do.
            const res = new Uint8ClampedArray(4);
            res[0] = ta_source[byi_read];
            res[1] = ta_source[byi_read + 1];
            res[2] = ta_source[byi_read + bypr];
            res[3] = ta_source[byi_read + bypr + 1];

            //res[0] = 


            return res;

        } else if (bipp === 24) {
            const res = new Uint8ClampedArray(12);
            //res[0] = 

            // best to read 2 rows of pixels. 6 bytes per row of the copy space.
            res.set(ta_source.subarray(byi_read, byi_read + 6), 0);
            byi_read += bypr;
            res.set(ta_source.subarray(byi_read, byi_read + 6), 6);



            return res;
            
        } else if (bipp === 32) {
            //console.trace();
            //throw 'NYI';
            const res = new Uint8ClampedArray(16);
            //res[0] = 

            res.set(ta_source.subarray(byi_read, byi_read + 8), 0);
            byi_read += bypr;
            res.set(ta_source.subarray(byi_read, byi_read + 8), 8);


            return res;
        }






    }

    const read_merged_vfpx_24bipp = (ta_source, colorspace, vfpx) => {

        // Other version of algo that bypasses the vfpx?


        const [width, height, bypp, bypr, bipp, bipr] = colorspace;
        const {weights, i_any_coverage_bounds} = vfpx;
        // 
        const xy = new Int16Array(2);
        let byi_read = 3 * i_any_coverage_bounds[0] + bypr * i_any_coverage_bounds[1];
        let byi_weight = 0;
        // 

        const iw = i_any_coverage_bounds[2] - i_any_coverage_bounds[0];

        const bytes_read_row_end_jump = bypr - iw * 3;
        const acc_rgb = new Float32Array(3);
        // Probably a problem at this merging stage.

        //console.log('colorspace: [width, height, bypp, bypr, bipp, bipr]', [width, height, bypp, bypr, bipp, bipr]);
        //console.log('vfpx.i_size', vfpx.i_size);
        //console.log('vfpx.i_any_coverage_bounds', vfpx.i_any_coverage_bounds);

        //console.log('weights', weights);

        // Direct accumulation without createing any weights object...


        for (xy[1] = i_any_coverage_bounds[1]; xy[1] < i_any_coverage_bounds[3]; xy[1]++) {
            for (xy[0] = i_any_coverage_bounds[0]; xy[0] < i_any_coverage_bounds[2]; xy[0]++) {

                //const ui8_px_value = ta[byte_idx_pb_read];
                //ui8_px_value = ta[byte_idx_pb_read];

                //console.log('byte_idx_pb_read')

                acc_rgb[0] += ta_source[byi_read++] * weights[byi_weight];
                acc_rgb[1] += ta_source[byi_read++] * weights[byi_weight];
                acc_rgb[2] += ta_source[byi_read++] * weights[byi_weight++];
                //ta_res[ta_byte_indexes[1]++] = ta[byi_read[0]++];
                //ta_res[ta_byte_indexes[1]++] = ta[byi_read[0]++];

                // But don't need to copy the px value in many cases.

                //  Maybe have / use lower level fuctions for copying between different pbs / tas.
                //  Iterating spaces.
                //   Iterating spaces defined by a function / equation?
                //    Eg could functionally / mathematically define a circle and draw it.
                
                // got the xy iteration pos set correctly here :)

                // could copy px values?
                //  reading and using them directly may work best....

                //byte_idx_pb_read += bytes_per_pixel;

            }
            // then row jump increase.
            byi_read += bytes_read_row_end_jump;
        }
        // then copy the weighted values into the result...
        /*
        console.log('acc_rgb', acc_rgb);
        if (acc_rgb[0] === 0) {
            console.trace();
            throw 'stop';
        }
        */

        const res = new Uint8ClampedArray(acc_rgb);
        //console.log('read_merged_vfpx_24bipp res', res);
        return res;


    }


    const read_merged_vfpx = (ta_source, colorspace, vfpx) => {
        // get the weights for that vfpx ... very useful to have them!
        //  need to know the any coverage row width
        //console.log('colorspace', colorspace);
        //const [width, height, bypp, bypr, bipp, bipr] = colorspace;
        const bipp = colorspace[4];

        if (bipp === 1) {
            console.trace(); throw 'NYI';
        } else if (bipp === 8) {
            console.trace(); throw 'NYI';
        } else if (bipp === 24) {
            return read_merged_vfpx_24bipp(ta_source, colorspace, vfpx)
        } else if (bipp === 32) {
            console.trace(); throw 'NYI';
        }

        //const {weights, i_total_coverage_bounds} = vfpx;


        // Worth having separate methods... different sized accumulator for different bipp.

        // RGB accumulator...?

        // depending on the number of bipp in the colorspace too.

        



    }

    const each_pixel_in_colorspace = (colorspace, callback) => {
        const [width, height, bypp, bypr, bipp, bipr] = colorspace;
        let byi = 0;
        const xy = new Int16Array(2);
        for (xy[1] = 0; xy[1] < height; xy[1]++) {
            for (xy[0] = 0; xy[0] < width; xy[0]++) {
                callback(xy, byi);
                byi += bypp;
            }
        }
    }

    return {
        read_2x2_rect: read_2x2_rect,
        read_1x2_rect: read_1x2_rect,
        read_2x1_rect: read_2x1_rect,
        read_merged_vfpx_24bipp: read_merged_vfpx_24bipp,
        read_merged_vfpx: read_merged_vfpx,
        get_instance: get_instance,
        each_pixel_in_colorspace: each_pixel_in_colorspace
    }
    


}


module.exports = get_instance();
},{}],44:[function(require,module,exports){
const copy_px_to_ta_dest_byi = (ta_source, source_colorspace, source_xy, ta_dest, byi_dest) => {
    const [width, height, bypp, bypr, bipp, bipr] = source_colorspace;
    if (bipp === 24) {
        let byi_read = source_xy[0] * bypp + source_xy[1] * bypr;
        ta_dest[byi_dest] = ta_source[byi_read++];
        ta_dest[byi_dest + 1] = ta_source[byi_read++];
        ta_dest[byi_dest + 2] = ta_source[byi_read++];
    } else {
        console.trace();
        throw 'NYI';
    }
}
const each_pixel_in_colorspace = (colorspace, callback) => {
    const [width, height, bypp, bypr, bipp, bipr] = colorspace;
    let byi = 0;
    const xy = new Int16Array(2);
    for (xy[1] = 0; xy[1] < height; xy[1]++) {
        for (xy[0] = 0; xy[0] < width; xy[0]++) {
            callback(xy, byi);
            byi += bypp;
        }
    }
}
const __each_source_dest_pixels_resized = (source_colorspace, dest_size, callback) => {
    const [width, height, bypp, bypr, bipp, bipr] = source_colorspace;
    const dest_colorspace = new Int32Array([dest_size[0], dest_size[1], bypp, bypp * dest_size[0], bipp, bipp * dest_size[0]]);
    const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
    const source_fbounds = new Float32Array(4);
    const source_ibounds = new Int16Array(4);
    const source_i_any_coverage_size = new Int16Array(2);
    const source_total_coverage_ibounds = new Int16Array(4);
    let byi_read;
    each_pixel_in_colorspace(dest_colorspace, (dest_xy, dest_byi) => {
        source_fbounds[0] = dest_xy[0] * dest_to_source_ratio[0];
        source_fbounds[1] = dest_xy[1] * dest_to_source_ratio[1];
        source_fbounds[2] = source_fbounds[0] + dest_to_source_ratio[0];
        source_fbounds[3] = source_fbounds[1] + dest_to_source_ratio[1];
        source_ibounds[0] = source_fbounds[0];
        source_ibounds[1] = source_fbounds[1];
        source_ibounds[2] = Math.ceil(source_fbounds[2]);
        source_ibounds[3] = Math.ceil(source_fbounds[3]);
        source_i_any_coverage_size[0] = source_ibounds[2] - source_ibounds[0];
        source_i_any_coverage_size[1] = source_ibounds[3] - source_ibounds[1];
        byi_read = source_ibounds[0] * bypp + source_ibounds[1] * bypr;
        source_total_coverage_ibounds[0] = Math.ceil(source_fbounds[0]);
        source_total_coverage_ibounds[1] = Math.ceil(source_fbounds[1]);
        source_total_coverage_ibounds[2] = source_fbounds[2];
        source_total_coverage_ibounds[3] = source_fbounds[3];
        callback(dest_xy, dest_byi, source_fbounds, source_ibounds, source_i_any_coverage_size, source_total_coverage_ibounds, byi_read);
    });
}
const each_source_dest_pixels_resized_inline = (source_colorspace, dest_size, callback) => {
    let [width, height, bypp, bypr, bipp, bipr] = source_colorspace;
    const source_bypr = bypr;
    const dest_colorspace = new Int32Array([dest_size[0], dest_size[1], bypp, bypp * dest_size[0], bipp, bipp * dest_size[0]]);
    const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
    const source_fbounds = new Float32Array(4);
    const source_ibounds = new Int16Array(4);
    const source_i_any_coverage_size = new Int16Array(2);
    const source_total_coverage_ibounds = new Int16Array(4);
    let byi_read = 0;
    let dest_byi = 0;
    const dest_xy = new Int16Array(2);
    [width, height, bypp, bypr, bipp, bipr] = dest_colorspace;
    const _x_source_fbounds0 = new Float32Array(width);
    const _x_source_fbounds2 = new Float32Array(width);
    const _x_source_ibounds0 = new Int16Array(width);
    const _x_source_ibounds2 = new Int16Array(width);
    const _x_source_i_any_coverage_size = new Int16Array(width);
    const _x_source_i_total_coverage_l = new Int16Array(width);
    const _x_source_i_total_coverage_r = new Int16Array(width);
    const _x_byi_read = new Int32Array(width);
    for (dest_xy[0] = 0; dest_xy[0] < width; dest_xy[0]++) {
        _x_source_fbounds0[dest_xy[0]] = dest_xy[0] * dest_to_source_ratio[0];
        _x_source_fbounds2[dest_xy[0]] = _x_source_fbounds0[dest_xy[0]] + dest_to_source_ratio[0];
        _x_source_ibounds0[dest_xy[0]] = _x_source_fbounds0[dest_xy[0]];
        _x_source_ibounds2[dest_xy[0]] = Math.ceil(_x_source_fbounds2[dest_xy[0]]);
        _x_source_i_any_coverage_size[dest_xy[0]] = _x_source_ibounds2[dest_xy[0]] - _x_source_ibounds0[dest_xy[0]];
        _x_byi_read[dest_xy[0]] = _x_source_ibounds0[dest_xy[0]] * bypp;
        _x_source_i_total_coverage_l[dest_xy[0]] = Math.ceil(_x_source_fbounds0[dest_xy[0]]);
        _x_source_i_total_coverage_r[dest_xy[0]] = Math.floor(_x_source_fbounds2[dest_xy[0]]);
    }
    let row_byi;
    for (dest_xy[1] = 0; dest_xy[1] < height; dest_xy[1]++) {
        source_fbounds[1] = dest_xy[1] * dest_to_source_ratio[1];
        source_ibounds[1] = source_fbounds[1];
        source_fbounds[3] = source_fbounds[1] + dest_to_source_ratio[1];
        source_ibounds[3] = Math.ceil(source_fbounds[3]);
        source_i_any_coverage_size[1] = source_ibounds[3] - source_ibounds[1];
        source_total_coverage_ibounds[1] = Math.ceil(source_fbounds[1]);
        source_total_coverage_ibounds[3] = source_fbounds[3];
        row_byi = source_ibounds[1] * source_bypr;
        for (dest_xy[0] = 0; dest_xy[0] < width; dest_xy[0]++) {
            source_fbounds[0] = _x_source_fbounds0[dest_xy[0]];
            source_fbounds[2] = _x_source_fbounds2[dest_xy[0]];
            source_ibounds[0] = _x_source_ibounds0[dest_xy[0]];
            source_ibounds[2] = _x_source_ibounds2[dest_xy[0]];
            source_i_any_coverage_size[0] = _x_source_i_any_coverage_size[dest_xy[0]];
            byi_read = _x_byi_read[dest_xy[0]] + row_byi;
            source_total_coverage_ibounds[0] = _x_source_i_total_coverage_l[dest_xy[0]];
            source_total_coverage_ibounds[2] = _x_source_i_total_coverage_r[dest_xy[0]];
            callback(dest_xy, dest_byi, source_fbounds, source_ibounds, source_i_any_coverage_size, source_total_coverage_ibounds, byi_read);
            dest_byi += bypp;
        }
    }
}
each_source_dest_pixels_resized = each_source_dest_pixels_resized_inline;
const __each_source_dest_pixels_resized_limited_further_info = (source_colorspace, dest_size, callback) => {
    const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
    const source_edge_distances = new Float32Array(4);
    const edge_distances_proportions_of_total = new Float32Array(4);
    const edge_segment_areas_proportion_of_total_area = new Float32Array(4);
    const corner_areas_proportions_of_total = new Float32Array(4);
    const fpx_area = dest_to_source_ratio[0] * dest_to_source_ratio[1];
    each_source_dest_pixels_resized(source_colorspace, dest_size, (dest_xy, dest_byi, source_fbounds, source_ibounds, source_i_any_coverage_size, source_total_coverage_ibounds, byi_read) => {
        if (source_i_any_coverage_size[0] === 1 && source_i_any_coverage_size[1] === 1) {
            callback(dest_byi, source_i_any_coverage_size, undefined, undefined, byi_read);
        } else if (source_i_any_coverage_size[0] === 1 && source_i_any_coverage_size[1] === 2) {
            source_edge_distances[1] = source_total_coverage_ibounds[1] - source_fbounds[1];
            source_edge_distances[3] = source_fbounds[3] - source_total_coverage_ibounds[3];
            if (source_edge_distances[1] === 0) source_edge_distances[1] = 1;
            if (source_edge_distances[3] === 0) source_edge_distances[3] = 1;
            edge_distances_proportions_of_total[1] = source_edge_distances[1] / dest_to_source_ratio[1];
            edge_distances_proportions_of_total[3] = source_edge_distances[3] / dest_to_source_ratio[1];
            callback(dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, undefined, byi_read);
        } else if (source_i_any_coverage_size[0] === 2 && source_i_any_coverage_size[1] === 1) {
            source_edge_distances[0] = source_total_coverage_ibounds[0] - source_fbounds[0];
            source_edge_distances[2] = source_fbounds[2] - source_total_coverage_ibounds[2];
            if (source_edge_distances[0] === 0) source_edge_distances[0] = 1;
            if (source_edge_distances[2] === 0) source_edge_distances[2] = 1;
            edge_distances_proportions_of_total[0] = source_edge_distances[0] / dest_to_source_ratio[0];
            edge_distances_proportions_of_total[2] = source_edge_distances[2] / dest_to_source_ratio[0];
            callback(dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, undefined, byi_read);
        } else if (source_i_any_coverage_size[0] === 2 && source_i_any_coverage_size[1] === 2) {
            source_edge_distances[0] = source_total_coverage_ibounds[0] - source_fbounds[0];
            source_edge_distances[1] = source_total_coverage_ibounds[1] - source_fbounds[1];
            source_edge_distances[2] = source_fbounds[2] - source_total_coverage_ibounds[2];
            source_edge_distances[3] = source_fbounds[3] - source_total_coverage_ibounds[3];
            if (source_edge_distances[0] === 0) source_edge_distances[0] = 1;
            if (source_edge_distances[1] === 0) source_edge_distances[1] = 1;
            if (source_edge_distances[2] === 0) source_edge_distances[2] = 1;
            if (source_edge_distances[3] === 0) source_edge_distances[3] = 1;
            corner_areas_proportions_of_total[0] = source_edge_distances[0] * source_edge_distances[1] / fpx_area;
            corner_areas_proportions_of_total[1] = source_edge_distances[2] * source_edge_distances[1] / fpx_area;
            corner_areas_proportions_of_total[2] = source_edge_distances[0] * source_edge_distances[3] / fpx_area;
            corner_areas_proportions_of_total[3] = source_edge_distances[2] * source_edge_distances[3] / fpx_area;
            callback(dest_byi, source_i_any_coverage_size, undefined, corner_areas_proportions_of_total, byi_read);
        } else {
            source_edge_distances[0] = source_total_coverage_ibounds[0] - source_fbounds[0];
            source_edge_distances[1] = source_total_coverage_ibounds[1] - source_fbounds[1];
            source_edge_distances[2] = source_fbounds[2] - source_total_coverage_ibounds[2];
            source_edge_distances[3] = source_fbounds[3] - source_total_coverage_ibounds[3];
            if (source_edge_distances[0] === 0) source_edge_distances[0] = 1;
            if (source_edge_distances[1] === 0) source_edge_distances[1] = 1;
            if (source_edge_distances[2] === 0) source_edge_distances[2] = 1;
            if (source_edge_distances[3] === 0) source_edge_distances[3] = 1;
            edge_distances_proportions_of_total[0] = source_edge_distances[0] / fpx_area;
            edge_distances_proportions_of_total[1] = source_edge_distances[1] / fpx_area;
            edge_distances_proportions_of_total[2] = source_edge_distances[2] / fpx_area;
            edge_distances_proportions_of_total[3] = source_edge_distances[3] / fpx_area;
            edge_segment_areas_proportion_of_total_area[0] = source_edge_distances[0] * source_edge_distances[1] / fpx_area;
            edge_segment_areas_proportion_of_total_area[1] = source_edge_distances[2] * source_edge_distances[1] / fpx_area;
            edge_segment_areas_proportion_of_total_area[2] = source_edge_distances[0] * source_edge_distances[3] / fpx_area;
            edge_segment_areas_proportion_of_total_area[3] = source_edge_distances[2] * source_edge_distances[3] / fpx_area;
            callback(dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, edge_segment_areas_proportion_of_total_area, byi_read);
        }
    });
}
const each_source_dest_pixels_resized_limited_further_info$inline = (source_colorspace, dest_size, callback) => {
    const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
    const source_edge_distances = new Float32Array(4);
    const edge_distances_proportions_of_total = new Float32Array(4);
    const corner_areas_proportions_of_total = new Float32Array(4);
    const fpx_area = dest_to_source_ratio[0] * dest_to_source_ratio[1];
    let [width, height, bypp, bypr, bipp, bipr] = source_colorspace;
    const source_bypr = bypr;
    const dest_colorspace = new Int32Array([dest_size[0], dest_size[1], bypp, bypp * dest_size[0], bipp, bipp * dest_size[0]]);
    const source_fbounds = new Float32Array(4);
    const source_ibounds = new Int16Array(4);
    const source_i_any_coverage_size = new Int16Array(2);
    const source_total_coverage_ibounds = new Int16Array(4);
    let byi_read;
    let dest_byi = 0;
    [width, height, bypp, bypr, bipp, bipr] = dest_colorspace;
    let x, y;
    for (y = 0; y < height; y++) {
        source_fbounds[1] = y * dest_to_source_ratio[1];
        source_fbounds[3] = source_fbounds[1] + dest_to_source_ratio[1];
        source_ibounds[1] = source_fbounds[1];
        source_ibounds[3] = Math.ceil(source_fbounds[3]);
        source_i_any_coverage_size[1] = source_ibounds[3] - source_ibounds[1];
        source_total_coverage_ibounds[1] = Math.ceil(source_fbounds[1]);
        source_total_coverage_ibounds[3] = source_fbounds[3];
        source_edge_distances[1] = source_total_coverage_ibounds[1] - source_fbounds[1];
        source_edge_distances[3] = source_fbounds[3] - source_total_coverage_ibounds[3];
        if (source_edge_distances[1] === 0) source_edge_distances[1] = 1;
        if (source_edge_distances[3] === 0) source_edge_distances[3] = 1;
        edge_distances_proportions_of_total[1] = source_edge_distances[1] / fpx_area;
        edge_distances_proportions_of_total[3] = source_edge_distances[3] / fpx_area;
        for (x = 0; x < width; x++) {
            source_fbounds[0] = x * dest_to_source_ratio[0];
            source_fbounds[2] = source_fbounds[0] + dest_to_source_ratio[0];
            source_ibounds[0] = source_fbounds[0];
            source_ibounds[2] = Math.ceil(source_fbounds[2]);
            source_i_any_coverage_size[0] = source_ibounds[2] - source_ibounds[0];
            byi_read = source_ibounds[0] * bypp + source_ibounds[1] * source_bypr;
            if (source_i_any_coverage_size[0] === 1 && source_i_any_coverage_size[1] === 1) {
                callback(dest_byi, source_i_any_coverage_size, undefined, undefined, byi_read);
            } else {
                source_total_coverage_ibounds[0] = Math.ceil(source_fbounds[0]);
                source_total_coverage_ibounds[2] = source_fbounds[2];
                if (source_i_any_coverage_size[0] === 1 && source_i_any_coverage_size[1] === 2) {
                    callback(dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, undefined, byi_read);
                } else {
                    source_edge_distances[0] = source_total_coverage_ibounds[0] - source_fbounds[0];
                    source_edge_distances[2] = source_fbounds[2] - source_total_coverage_ibounds[2];
                    if (source_edge_distances[0] === 0) source_edge_distances[0] = 1;
                    if (source_edge_distances[2] === 0) source_edge_distances[2] = 1;
                    if (source_i_any_coverage_size[0] === 2 && source_i_any_coverage_size[1] === 1) {
                        edge_distances_proportions_of_total[0] = source_edge_distances[0] / dest_to_source_ratio[0];
                        edge_distances_proportions_of_total[2] = source_edge_distances[2] / dest_to_source_ratio[0];
                        callback(dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, undefined, byi_read);
                    } else if (source_i_any_coverage_size[0] === 2 && source_i_any_coverage_size[1] === 2) {
                        corner_areas_proportions_of_total[0] = source_edge_distances[0] * source_edge_distances[1] / fpx_area;
                        corner_areas_proportions_of_total[1] = source_edge_distances[2] * source_edge_distances[1] / fpx_area;
                        corner_areas_proportions_of_total[2] = source_edge_distances[0] * source_edge_distances[3] / fpx_area;
                        corner_areas_proportions_of_total[3] = source_edge_distances[2] * source_edge_distances[3] / fpx_area;
                        callback(dest_byi, source_i_any_coverage_size, undefined, corner_areas_proportions_of_total, byi_read);
                    } else {
                        edge_distances_proportions_of_total[0] = source_edge_distances[0] / fpx_area;
                        edge_distances_proportions_of_total[2] = source_edge_distances[2] / fpx_area;
                        corner_areas_proportions_of_total[0] = source_edge_distances[0] * source_edge_distances[1] / fpx_area;
                        corner_areas_proportions_of_total[1] = source_edge_distances[2] * source_edge_distances[1] / fpx_area;
                        corner_areas_proportions_of_total[2] = source_edge_distances[0] * source_edge_distances[3] / fpx_area;
                        corner_areas_proportions_of_total[3] = source_edge_distances[2] * source_edge_distances[3] / fpx_area;
                        callback(dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, byi_read);
                    }
                }
            }
            dest_byi += bypp;
        }
    }
}
each_source_dest_pixels_resized_limited_further_info = each_source_dest_pixels_resized_limited_further_info$inline;
const copy_px_24bipp = (ta_source, byi_read, ta_dest, byi_write) => {
    ta_dest[byi_write] = ta_source[byi_read++];
    ta_dest[byi_write + 1] = ta_source[byi_read++];
    ta_dest[byi_write + 2] = ta_source[byi_read++];
}
const read_1x2_weight_write_24bipp = (ta_source, bypr, byi_read, ta_dest, byi_write, weight_t, weight_b) => {
    let byi_read_below = byi_read + bypr;
    ta_dest[byi_write] = weight_t * ta_source[byi_read++] + weight_b * ta_source[byi_read_below++];
    ta_dest[byi_write + 1] = weight_t * ta_source[byi_read++] + weight_b * ta_source[byi_read_below++];
    ta_dest[byi_write + 2] = weight_t * ta_source[byi_read++] + weight_b * ta_source[byi_read_below++];
}
const read_1x2_weight_write_24bipp$ta4byis = (ta_source, ta4byis, ta_dest, byi_write, weight_t, weight_b) => {
    ta_dest[byi_write] = weight_t * ta_source[ta4byis[0]++] + weight_b * ta_source[ta4byis[2]++];
    ta_dest[byi_write + 1] = weight_t * ta_source[ta4byis[0]++] + weight_b * ta_source[ta4byis[2]++];
    ta_dest[byi_write + 2] = weight_t * ta_source[ta4byis[0]++] + weight_b * ta_source[ta4byis[2]++];
}
const read_2x1_weight_write_24bipp = (ta_source, byi_read, ta_dest, byi_write, weight_l, weight_r) => {
    let byi_read_right = byi_read + 3;
    ta_dest[byi_write] = weight_l * ta_source[byi_read++] + weight_r * ta_source[byi_read_right++];
    ta_dest[byi_write + 1] = weight_l * ta_source[byi_read++] + weight_r * ta_source[byi_read_right++];
    ta_dest[byi_write + 2] = weight_l * ta_source[byi_read++] + weight_r * ta_source[byi_read_right++];
}
const read_2x1_weight_write_24bipp$ta4byis = (ta_source, ta4byis, ta_dest, byi_write, weight_l, weight_r) => {
    ta_dest[byi_write] = weight_l * ta_source[ta4byis[0]++] + weight_r * ta_source[ta4byis[1]++];
    ta_dest[byi_write + 1] = weight_l * ta_source[ta4byis[0]++] + weight_r * ta_source[ta4byis[1]++];
    ta_dest[byi_write + 2] = weight_l * ta_source[ta4byis[0]++] + weight_r * ta_source[ta4byis[1]++];
}
const read_2x2_weight_write_24bipp = (ta_source, bypr, byi_read, ta_dest, byi_write, corner_weights_ltrb) => {
    let byi_read_right = byi_read + 3;
    let byi_read_below = byi_read + bypr;
    let byi_read_below_right = byi_read_below + 3;
    ta_dest[byi_write] = corner_weights_ltrb[0] * ta_source[byi_read++] + corner_weights_ltrb[1] * ta_source[byi_read_right++] + corner_weights_ltrb[2] * ta_source[byi_read_below++] + corner_weights_ltrb[3] * ta_source[byi_read_below_right++];
    ta_dest[byi_write + 1] = corner_weights_ltrb[0] * ta_source[byi_read++] + corner_weights_ltrb[1] * ta_source[byi_read_right++] + corner_weights_ltrb[2] * ta_source[byi_read_below++] + corner_weights_ltrb[3] * ta_source[byi_read_below_right++];
    ta_dest[byi_write + 2] = corner_weights_ltrb[0] * ta_source[byi_read++] + corner_weights_ltrb[1] * ta_source[byi_read_right++] + corner_weights_ltrb[2] * ta_source[byi_read_below++] + corner_weights_ltrb[3] * ta_source[byi_read_below_right++];
}
const read_2x2_weight_write_24bipp$locals = (ta_source, source_bypr, byi_read, 
    corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br,                    
    ta_dest, byi_write) => {
    let byi_read_right = byi_read + 3;
    let byi_read_below = byi_read + source_bypr;
    let byi_read_below_right = byi_read_below + 3;
    ta_dest[byi_write] = corner_p_tl * ta_source[byi_read++] + corner_p_tr * ta_source[byi_read_right++] + corner_p_bl * ta_source[byi_read_below++] + corner_p_br * ta_source[byi_read_below_right++];
    ta_dest[byi_write + 1] = corner_p_tl * ta_source[byi_read++] + corner_p_tr * ta_source[byi_read_right++] + corner_p_bl * ta_source[byi_read_below++] + corner_p_br * ta_source[byi_read_below_right++];
    ta_dest[byi_write + 2] = corner_p_tl * ta_source[byi_read++] + corner_p_tr * ta_source[byi_read_right++] + corner_p_bl * ta_source[byi_read_below++] + corner_p_br * ta_source[byi_read_below_right++];
}
const read_2x2_weight_write_24bipp$ta4byis = (ta_source, ta4byis, ta_dest, byi_write, corner_weights_ltrb) => {
    ta_dest[byi_write] = corner_weights_ltrb[0] * ta_source[ta4byis[0]++] + corner_weights_ltrb[1] * ta_source[ta4byis[1]++] + corner_weights_ltrb[2] * ta_source[ta4byis[2]++] + corner_weights_ltrb[3] * ta_source[ta4byis[3]++];
    ta_dest[byi_write + 1] = corner_weights_ltrb[0] * ta_source[ta4byis[0]++] + corner_weights_ltrb[1] * ta_source[ta4byis[1]++] + corner_weights_ltrb[2] * ta_source[ta4byis[2]++] + corner_weights_ltrb[3] * ta_source[ta4byis[3]++];
    ta_dest[byi_write + 2] = corner_weights_ltrb[0] * ta_source[ta4byis[0]++] + corner_weights_ltrb[1] * ta_source[ta4byis[1]++] + corner_weights_ltrb[2] * ta_source[ta4byis[2]++] + corner_weights_ltrb[3] * ta_source[ta4byis[3]++];
}
const read_2x2_weight_write_24bipp$2_weight_ints = (ta_source, bypr, byi_read, ta_dest, byi_write, ta_lt_props) => {
    const tl = l_prop * t_prop;
    const tr = (1 - l_prop) * t_prop;
    const bl = l_prop * (1 - t_prop);
    const br = (1 - l_prop) * (1 - t_prop);
    let byi_read_right = byi_read + 3;
    let byi_read_below = byi_read + bypr;
    let byi_read_below_right = byi_read_below + 3;
    ta_dest[byi_write] = l_prop * t_prop * ta_source[byi_read++] + (1 - l_prop) * t_prop * ta_source[byi_read_right++] + l_prop * (1 - t_prop) * ta_source[byi_read_below++] + (1 - l_prop) * (1 - t_prop) * ta_source[byi_read_below_right++];
    ta_dest[byi_write + 1] = l_prop * t_prop * ta_source[byi_read++] + (1 - l_prop) * t_prop * ta_source[byi_read_right++] + l_prop * (1 - t_prop) * ta_source[byi_read_below++] + (1 - l_prop) * (1 - t_prop) * ta_source[byi_read_below_right++];
    ta_dest[byi_write + 2] = l_prop * t_prop * ta_source[byi_read++] + (1 - l_prop) * t_prop * ta_source[byi_read_right++] + l_prop * (1 - t_prop) * ta_source[byi_read_below++] + (1 - l_prop) * (1 - t_prop) * ta_source[byi_read_below_right++];
}
const read_3x2_weight_write_24bipp = (ta_source, bypr, byi_read, edge_distances_proportions_of_total, corner_weights_ltrb, ta_dest, dest_byi) => {
    const bypp = 3;
    let byi_tl = byi_read;
    let byi_tm = byi_tl + bypp, byi_tr = byi_tm + bypp;
    let byi_bl = byi_tm + bypr, byi_bm = byi_bl + bypp, byi_br = byi_bm + bypp;
    ta_dest[dest_byi] =     ta_source[byi_tl++] * corner_weights_ltrb[0] + ta_source[byi_tm++] * edge_distances_proportions_of_total[1] + ta_source[byi_tr++] * corner_weights_ltrb[1] +
                            ta_source[byi_bl++] * corner_weights_ltrb[2] + ta_source[byi_bm++] * edge_distances_proportions_of_total[3] + ta_source[byi_br++] * corner_weights_ltrb[3];
    ta_dest[dest_byi + 1] = ta_source[byi_tl++] * corner_weights_ltrb[0] + ta_source[byi_tm++] * edge_distances_proportions_of_total[1] + ta_source[byi_tr++] * corner_weights_ltrb[1] +
                            ta_source[byi_bl++] * corner_weights_ltrb[2] + ta_source[byi_bm++] * edge_distances_proportions_of_total[3] + ta_source[byi_br++] * corner_weights_ltrb[3];
    ta_dest[dest_byi + 2] = ta_source[byi_tl++] * corner_weights_ltrb[0] + ta_source[byi_tm++] * edge_distances_proportions_of_total[1] + ta_source[byi_tr++] * corner_weights_ltrb[1] +
                            ta_source[byi_bl++] * corner_weights_ltrb[2] + ta_source[byi_bm++] * edge_distances_proportions_of_total[3] + ta_source[byi_br++] * corner_weights_ltrb[3];
}
const read_3x2_weight_write_24bipp$locals = (ta_source, bypr, byi_read, 
    edge_p_l, edge_p_t, edge_p_r, edge_p_b, 
    corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br,
    ta_dest, dest_byi) => {
    const bypp = 3;
    let byi_tl = byi_read;
    let byi_tm = byi_tl + bypp, byi_tr = byi_tm + bypp;
    let byi_bl = byi_tm + bypr, byi_bm = byi_bl + bypp, byi_br = byi_bm + bypp;
    ta_dest[dest_byi] =     ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br;
    ta_dest[dest_byi + 1] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br;
    ta_dest[dest_byi + 2] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br;
}
const read_2x3_weight_write_24bipp = (ta_source, bypr, byi_read, edge_distances_proportions_of_total, corner_weights_ltrb, ta_dest, dest_byi) => {
    const bypp = 3;
    let byi_tl = byi_read, byi_tr = byi_tl + bypp;
    let byi_ml = byi_tl + bypr, byi_mr = byi_ml + bypp;
    let byi_bl = byi_ml + bypr, byi_br = byi_bl + bypp;
    ta_dest[dest_byi] =     ta_source[byi_tl++] * corner_weights_ltrb[0] + ta_source[byi_tr++] * corner_weights_ltrb[1] +
                            ta_source[byi_ml++] * edge_distances_proportions_of_total[0] + ta_source[byi_mr++] * edge_distances_proportions_of_total[2] +
                            ta_source[byi_bl++] * corner_weights_ltrb[2] + ta_source[byi_br++] * corner_weights_ltrb[3]
    ta_dest[dest_byi + 1] = ta_source[byi_tl++] * corner_weights_ltrb[0] + ta_source[byi_tr++] * corner_weights_ltrb[1] +
                            ta_source[byi_ml++] * edge_distances_proportions_of_total[0] + ta_source[byi_mr++] * edge_distances_proportions_of_total[2] +
                            ta_source[byi_bl++] * corner_weights_ltrb[2] + ta_source[byi_br++] * corner_weights_ltrb[3]
    ta_dest[dest_byi + 2] = ta_source[byi_tl++] * corner_weights_ltrb[0] + ta_source[byi_tr++] * corner_weights_ltrb[1] +
                            ta_source[byi_ml++] * edge_distances_proportions_of_total[0] + ta_source[byi_mr++] * edge_distances_proportions_of_total[2] +
                            ta_source[byi_bl++] * corner_weights_ltrb[2] + ta_source[byi_br++] * corner_weights_ltrb[3]
}
const read_2x3_weight_write_24bipp$locals = (ta_source, bypr, byi_read, 
    edge_p_l, edge_p_t, edge_p_r, edge_p_b, 
    corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br,
    ta_dest, dest_byi) => {
    let byi_tl = byi_read, byi_tr = byi_tl + 3;
    let byi_ml = byi_tl + bypr, byi_mr = byi_ml + 3;
    let byi_bl = byi_ml + bypr, byi_br = byi_bl + 3;
    ta_dest[dest_byi] =     ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tr++] * corner_p_tr +
                            ta_source[byi_ml++] * edge_p_l + ta_source[byi_mr++] * edge_p_r +
                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_br++] * corner_p_br
    ta_dest[dest_byi + 1] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tr++] * corner_p_tr +
                            ta_source[byi_ml++] * edge_p_l + ta_source[byi_mr++] * edge_p_r +
                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_br++] * corner_p_br
    ta_dest[dest_byi + 2] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tr++] * corner_p_tr +
                            ta_source[byi_ml++] * edge_p_l + ta_source[byi_mr++] * edge_p_r +
                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_br++] * corner_p_br
}
const read_3x3_weight_write_24bipp = (ta_source, bypr, byi_read, edge_weights, corner_weights_ltrb, fpx_area_recip, ta_dest, dest_byi) => {
    const bypp = 3;
    let byi_tl = byi_read, byi_tm = byi_tl + bypp, byi_tr = byi_tm + bypp;
    let byi_ml = byi_tl + bypr, byi_mm = byi_ml + bypp, byi_mr = byi_mm + bypp;
    let byi_bl = byi_ml + bypr, byi_bm = byi_bl + bypp, byi_br = byi_bm + bypp;
    ta_dest[dest_byi] =     ta_source[byi_tl++] * corner_weights_ltrb[0] + ta_source[byi_tm++] * edge_weights[1] + ta_source[byi_tr++] * corner_weights_ltrb[1] +
                            ta_source[byi_ml++] * edge_weights[0] + ta_source[byi_mm++] * fpx_area_recip + ta_source[byi_mr++] * edge_weights[2] +
                            ta_source[byi_bl++] * corner_weights_ltrb[2] + ta_source[byi_bm++] * edge_weights[3] + ta_source[byi_br++] * corner_weights_ltrb[3]
    ta_dest[dest_byi + 1] = ta_source[byi_tl++] * corner_weights_ltrb[0] + ta_source[byi_tm++] * edge_weights[1] + ta_source[byi_tr++] * corner_weights_ltrb[1] +
                            ta_source[byi_ml++] * edge_weights[0] + ta_source[byi_mm++] * fpx_area_recip + ta_source[byi_mr++] * edge_weights[2] +
                            ta_source[byi_bl++] * corner_weights_ltrb[2] + ta_source[byi_bm++] * edge_weights[3] + ta_source[byi_br++] * corner_weights_ltrb[3]
    ta_dest[dest_byi + 2] = ta_source[byi_tl++] * corner_weights_ltrb[0] + ta_source[byi_tm++] * edge_weights[1] + ta_source[byi_tr++] * corner_weights_ltrb[1] +
                            ta_source[byi_ml++] * edge_weights[0] + ta_source[byi_mm++] * fpx_area_recip + ta_source[byi_mr++] * edge_weights[2] +
                            ta_source[byi_bl++] * corner_weights_ltrb[2] + ta_source[byi_bm++] * edge_weights[3] + ta_source[byi_br++] * corner_weights_ltrb[3]
}
const read_3x3_weight_write_24bipp$locals = (ta_source, bypr, byi_read, 
    edge_p_l, edge_p_t, edge_p_r, edge_p_b, 
    corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br,
    fpx_area_recip, 
    ta_dest, dest_byi) => {
    const bypp = 3;
    let byi_tl = byi_read, byi_tm = byi_tl + bypp, byi_tr = byi_tm + bypp;
    let byi_ml = byi_tl + bypr, byi_mm = byi_ml + bypp, byi_mr = byi_mm + bypp;
    let byi_bl = byi_ml + bypr, byi_bm = byi_bl + bypp, byi_br = byi_bm + bypp;
    ta_dest[dest_byi] =     ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                            ta_source[byi_ml++] * edge_p_l + ta_source[byi_mm++] * fpx_area_recip + ta_source[byi_mr++] * edge_p_r +
                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br
    ta_dest[dest_byi + 1] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                            ta_source[byi_ml++] * edge_p_l + ta_source[byi_mm++] * fpx_area_recip + ta_source[byi_mr++] * edge_p_r +
                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br
    ta_dest[dest_byi + 2] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                            ta_source[byi_ml++] * edge_p_l + ta_source[byi_mm++] * fpx_area_recip + ta_source[byi_mr++] * edge_p_r +
                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br
}
const read_gt3x3_weight_write_24bipp = (ta_source, bypr, byi_read, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_weights_ltrb, fpx_area_recip, ta_dest, dest_byi) => {
    const byi_tl = byi_read;
    let r = 0, g = 0, b = 0;
    let x, y;
    const end_hmiddle = source_i_any_coverage_size[0] - 1, end_vmiddle = source_i_any_coverage_size[1] - 1;
    r += ta_source[byi_read++] * corner_weights_ltrb[0];
    g += ta_source[byi_read++] * corner_weights_ltrb[0];
    b += ta_source[byi_read++] * corner_weights_ltrb[0];
    for (x = 1; x < end_hmiddle; x++) {
        r += ta_source[byi_read++] * edge_distances_proportions_of_total[1];
        g += ta_source[byi_read++] * edge_distances_proportions_of_total[1];
        b += ta_source[byi_read++] * edge_distances_proportions_of_total[1];
    }
    r += ta_source[byi_read++] * corner_weights_ltrb[1];
    g += ta_source[byi_read++] * corner_weights_ltrb[1];
    b += ta_source[byi_read++] * corner_weights_ltrb[1];
    for (y = 1; y < end_vmiddle; y++) {
        byi_read = byi_tl + y * bypr;
        r += ta_source[byi_read++] * edge_distances_proportions_of_total[0];
        g += ta_source[byi_read++] * edge_distances_proportions_of_total[0];
        b += ta_source[byi_read++] * edge_distances_proportions_of_total[0];
        for (x = 1; x < end_hmiddle; x++) {
            r += ta_source[byi_read++] * fpx_area_recip;
            g += ta_source[byi_read++] * fpx_area_recip;
            b += ta_source[byi_read++] * fpx_area_recip;
        }
        r += ta_source[byi_read++] * edge_distances_proportions_of_total[2];
        g += ta_source[byi_read++] * edge_distances_proportions_of_total[2];
        b += ta_source[byi_read++] * edge_distances_proportions_of_total[2];
    }
    byi_read = byi_tl + end_vmiddle * bypr;
    r += ta_source[byi_read++] * corner_weights_ltrb[2];
    g += ta_source[byi_read++] * corner_weights_ltrb[2];
    b += ta_source[byi_read++] * corner_weights_ltrb[2];
    for (x = 1; x < end_hmiddle; x++) {
        r += ta_source[byi_read++] * edge_distances_proportions_of_total[3];
        g += ta_source[byi_read++] * edge_distances_proportions_of_total[3];
        b += ta_source[byi_read++] * edge_distances_proportions_of_total[3];
    }
    r += ta_source[byi_read++] * corner_weights_ltrb[3];
    g += ta_source[byi_read++] * corner_weights_ltrb[3];
    b += ta_source[byi_read++] * corner_weights_ltrb[3];
    ta_dest[dest_byi] = Math.round(r);
    ta_dest[dest_byi + 1] = Math.round(g);
    ta_dest[dest_byi + 2] = Math.round(b);
}
const read_gt3x3_weight_write_24bipp$locals = (ta_source, bypr, byi_read, 
    any_coverage_w, any_coverage_h,
    edge_p_l, edge_p_t, edge_p_r, edge_p_b,
    corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br,
    fpx_area_recip, 
    ta_dest, dest_byi) => {
    const byi_tl = byi_read;
    let r = 0, g = 0, b = 0;
    let x, y;
    const end_hmiddle = any_coverage_w - 1, end_vmiddle = any_coverage_h - 1;
    r += ta_source[byi_read++] * corner_p_tl;
    g += ta_source[byi_read++] * corner_p_tl;
    b += ta_source[byi_read++] * corner_p_tl;
    for (x = 1; x < end_hmiddle; x++) {
        r += ta_source[byi_read++] * edge_p_t;
        g += ta_source[byi_read++] * edge_p_t;
        b += ta_source[byi_read++] * edge_p_t;
    }
    r += ta_source[byi_read++] * corner_p_tr;
    g += ta_source[byi_read++] * corner_p_tr;
    b += ta_source[byi_read++] * corner_p_tr;
    for (y = 1; y < end_vmiddle; y++) {
        byi_read = byi_tl + y * bypr;
        r += ta_source[byi_read++] * edge_p_l;
        g += ta_source[byi_read++] * edge_p_l;
        b += ta_source[byi_read++] * edge_p_l;
        for (x = 1; x < end_hmiddle; x++) {
            r += ta_source[byi_read++] * fpx_area_recip;
            g += ta_source[byi_read++] * fpx_area_recip;
            b += ta_source[byi_read++] * fpx_area_recip;
        }
        r += ta_source[byi_read++] * edge_p_r;
        g += ta_source[byi_read++] * edge_p_r;
        b += ta_source[byi_read++] * edge_p_r;
    }
    byi_read = byi_tl + end_vmiddle * bypr;
    r += ta_source[byi_read++] * corner_p_bl;
    g += ta_source[byi_read++] * corner_p_bl;
    b += ta_source[byi_read++] * corner_p_bl;
    for (x = 1; x < end_hmiddle; x++) {
        r += ta_source[byi_read++] * edge_p_b;
        g += ta_source[byi_read++] * edge_p_b;
        b += ta_source[byi_read++] * edge_p_b;
    }
    r += ta_source[byi_read++] * corner_p_br;
    g += ta_source[byi_read++] * corner_p_br;
    b += ta_source[byi_read++] * corner_p_br;
    ta_dest[dest_byi] = Math.round(r);
    ta_dest[dest_byi + 1] = Math.round(g);
    ta_dest[dest_byi + 2] = Math.round(b);
}
const __resize_ta_colorspace_24bipp$subpixel = (ta_source, source_colorspace, dest_size, ta_dest) => {
    const source_bypp = source_colorspace[2];
    const source_bypr = source_colorspace[3];
    const [f_px_w, f_px_h] = [source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]];
    let f_source_x, f_source_r;
    let i_source_l, i_source_lr_crossover;
    let f_source_y, f_source_b;
    let i_source_t, i_source_tb_crossover;
    let i_dest_x, i_dest_y;
    const ta_left_proportions = new Float32Array(dest_size[0]);
    const ta_top_proportions = new Float32Array(dest_size[1]);
    const ta_source_x = new Int16Array(dest_size[0]);
    const ta_source_y = new Int16Array(dest_size[1]);
    const ta_source_x_byi_component = new Int32Array(dest_size[0]);
    const ta_source_y_byi_component = new Int32Array(dest_size[1]);
    for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
        f_source_x = i_dest_x * f_px_w;
        f_source_r = f_source_x + f_px_w;
        i_source_l = Math.floor(f_source_x);
        i_source_lr_crossover = i_source_l + 1;
        ta_source_x[i_dest_x] = i_source_l;
        ta_source_x_byi_component[i_dest_x] = i_source_l * source_bypp;
        if (f_source_r < i_source_lr_crossover || i_source_l === f_source_x) {
            ta_left_proportions[i_dest_x] = 1;
        } else {
            ta_left_proportions[i_dest_x] = (i_source_lr_crossover - f_source_x) / f_px_w;
        }
    }
    for (i_dest_y = 0; i_dest_y < dest_size[1]; i_dest_y++) {
        f_source_y = i_dest_y * f_px_h;
        f_source_b = f_source_y + f_px_h;
        i_source_t = Math.floor(f_source_y);
        i_source_tb_crossover = i_source_t + 1;
        ta_source_y[i_dest_y] = i_source_t;
        ta_source_y_byi_component[i_dest_y] = i_source_t * source_bypr;
        if (f_source_b < i_source_tb_crossover || i_source_t === f_source_y) {
            ta_top_proportions[i_dest_y] = 1;
        } else {
            ta_top_proportions[i_dest_y] = (i_source_tb_crossover - f_source_y) / f_px_h;
        }
    }
    const ta_ltrb_edge_props = new Float32Array(4);
    let byi_source;
    let byi_write = 0;
    const ta_ltrb_corner_props = new Float32Array(4);
    for (i_dest_y = 0; i_dest_y < dest_size[1]; i_dest_y++) {
        ta_ltrb_edge_props[1] = ta_top_proportions[i_dest_y];
        ta_ltrb_edge_props[3] = 1 - ta_top_proportions[i_dest_y];
        for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
            ta_ltrb_edge_props[0] = ta_left_proportions[i_dest_x];
            ta_ltrb_edge_props[2] = 1 - ta_left_proportions[i_dest_x];
            byi_source = ta_source_x_byi_component[i_dest_x] + ta_source_y_byi_component[i_dest_y];
            if (ta_ltrb_edge_props[0] === 1) {
                if (ta_ltrb_edge_props[1] === 1) {
                    copy_px_24bipp(ta_source, byi_source, ta_dest, byi_write);
                } else {
                    read_1x2_weight_write_24bipp(ta_source, source_bypr, byi_source, ta_dest, byi_write, ta_ltrb_edge_props[1], ta_ltrb_edge_props[3]);
                }
            } else {
                if (ta_ltrb_edge_props[1] === 1) {
                    read_2x1_weight_write_24bipp(ta_source, byi_source, ta_dest, byi_write, ta_ltrb_edge_props[0], ta_ltrb_edge_props[2]);
                } else {
                    ta_ltrb_corner_props[0] = ta_ltrb_edge_props[0] * ta_ltrb_edge_props[1];
                    ta_ltrb_corner_props[1] = ta_ltrb_edge_props[2] * ta_ltrb_edge_props[1];
                    ta_ltrb_corner_props[2] = ta_ltrb_edge_props[0] * ta_ltrb_edge_props[3];
                    ta_ltrb_corner_props[3] = ta_ltrb_edge_props[2] * ta_ltrb_edge_props[3];
                    read_2x2_weight_write_24bipp(ta_source, source_bypr, byi_source, ta_dest, byi_write, ta_ltrb_corner_props);
                }
            }
            byi_write += 3;
        }
    }
}
const resize_ta_colorspace_24bipp$subpixel$inline = (ta_source, source_colorspace, dest_size, ta_dest) => {
    const source_bypp = source_colorspace[2];
    const source_bypr = source_colorspace[3];
    const [f_px_w, f_px_h] = [source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]];
    let f_source_x, f_source_r;
    let i_source_l, i_source_lr_crossover;
    let f_source_y, f_source_b;
    let i_source_t, i_source_tb_crossover;
    let i_dest_x, i_dest_y;
    const ta_left_proportions = new Float32Array(dest_size[0]);
    const ta_top_proportions = new Float32Array(dest_size[1]);
    const ta_source_x_byi_component = new Int32Array(dest_size[0]);
    for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
        f_source_x = i_dest_x * f_px_w;
        f_source_r = f_source_x + f_px_w;
        i_source_l = Math.floor(f_source_x);
        i_source_lr_crossover = i_source_l + 1;
        ta_source_x_byi_component[i_dest_x] = i_source_l * source_bypp;
        if (f_source_r < i_source_lr_crossover || i_source_l === f_source_x) {
            ta_left_proportions[i_dest_x] = 1;
        } else {
            ta_left_proportions[i_dest_x] = (i_source_lr_crossover - f_source_x) / f_px_w;
        }
    }
    let byi_source;
    let byi_write = 0;
    let byi_read_below, byi_read_right, byi_read_below_right;
    let edge_l, edge_t, edge_r;
    let corner_tl, corner_tr, corner_bl, corner_br;
    let y_byi;
    for (i_dest_y = 0; i_dest_y < dest_size[1]; i_dest_y++) {
        f_source_y = i_dest_y * f_px_h;
        f_source_b = f_source_y + f_px_h;
        i_source_t = Math.floor(f_source_y);
        i_source_tb_crossover = i_source_t + 1;
        y_byi = i_source_t * source_bypr;
        if (f_source_b < i_source_tb_crossover || i_source_t === f_source_y) {
            ta_top_proportions[i_dest_y] = 1;
        } else {
            ta_top_proportions[i_dest_y] = (i_source_tb_crossover - f_source_y) / f_px_h;
        }
        edge_t = ta_top_proportions[i_dest_y];
        
        if (edge_t === 1) {

            for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
                edge_l = ta_left_proportions[i_dest_x];
                edge_r = 1 - ta_left_proportions[i_dest_x];
                byi_source = ta_source_x_byi_component[i_dest_x] + y_byi;
                if (edge_l === 1) {
                    ta_dest[byi_write++] = ta_source[byi_source++];
                    ta_dest[byi_write++] = ta_source[byi_source++];
                    ta_dest[byi_write++] = ta_source[byi_source++];
                } else {
                    byi_read_right = byi_source + 3;
                    ta_dest[byi_write++] = edge_l * ta_source[byi_source++] + edge_r * ta_source[byi_read_right++];
                    ta_dest[byi_write++] = edge_l * ta_source[byi_source++] + edge_r * ta_source[byi_read_right++];
                    ta_dest[byi_write++] = edge_l * ta_source[byi_source++] + edge_r * ta_source[byi_read_right++];
                }
            }



        } else {
            const edge_b = 1 - ta_top_proportions[i_dest_y];
            for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
                edge_l = ta_left_proportions[i_dest_x];
                edge_r = 1 - ta_left_proportions[i_dest_x];
                byi_source = ta_source_x_byi_component[i_dest_x] + y_byi;
                if (edge_l === 1) {
                    byi_read_below = byi_source + source_bypr;
                    ta_dest[byi_write++] = edge_t * ta_source[byi_source++] + edge_b * ta_source[byi_read_below++];
                    ta_dest[byi_write++] = edge_t * ta_source[byi_source++] + edge_b * ta_source[byi_read_below++];
                    ta_dest[byi_write++] = edge_t * ta_source[byi_source++] + edge_b * ta_source[byi_read_below++];
                } else {
                    corner_tl = edge_l * edge_t;
                    corner_tr = edge_r * edge_t;
                    corner_bl = edge_l * edge_b;
                    corner_br = edge_r * edge_b;
                    byi_read_right = byi_source + 3;
                    byi_read_below = byi_source + source_bypr;
                    byi_read_below_right = byi_read_below + 3;
                    ta_dest[byi_write++] = corner_tl * ta_source[byi_source++] + corner_tr * ta_source[byi_read_right++] + corner_bl * ta_source[byi_read_below++] + corner_br * ta_source[byi_read_below_right++];
                    ta_dest[byi_write++] = corner_tl * ta_source[byi_source++] + corner_tr * ta_source[byi_read_right++] + corner_bl * ta_source[byi_read_below++] + corner_br * ta_source[byi_read_below_right++];
                    ta_dest[byi_write++] = corner_tl * ta_source[byi_source++] + corner_tr * ta_source[byi_read_right++] + corner_bl * ta_source[byi_read_below++] + corner_br * ta_source[byi_read_below_right++];
                }
            }
        }
        /*
        for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
            edge_l = ta_left_proportions[i_dest_x];
            edge_r = 1 - ta_left_proportions[i_dest_x];
            byi_source = ta_source_x_byi_component[i_dest_x] + y_byi;
            if (edge_l === 1) {
                if (edge_t === 1) {
                    ta_dest[byi_write++] = ta_source[byi_source++];
                    ta_dest[byi_write++] = ta_source[byi_source++];
                    ta_dest[byi_write++] = ta_source[byi_source++];
                } else {
                    byi_read_below = byi_source + source_bypr;
                    ta_dest[byi_write++] = edge_t * ta_source[byi_source++] + edge_b * ta_source[byi_read_below++];
                    ta_dest[byi_write++] = edge_t * ta_source[byi_source++] + edge_b * ta_source[byi_read_below++];
                    ta_dest[byi_write++] = edge_t * ta_source[byi_source++] + edge_b * ta_source[byi_read_below++];
                }
            } else {
                if (edge_t === 1) {
                    byi_read_right = byi_source + 3;
                    ta_dest[byi_write++] = edge_l * ta_source[byi_source++] + edge_r * ta_source[byi_read_right++];
                    ta_dest[byi_write++] = edge_l * ta_source[byi_source++] + edge_r * ta_source[byi_read_right++];
                    ta_dest[byi_write++] = edge_l * ta_source[byi_source++] + edge_r * ta_source[byi_read_right++];
                } else {
                    corner_tl = edge_l * edge_t;
                    corner_tr = edge_r * edge_t;
                    corner_bl = edge_l * edge_b;
                    corner_br = edge_r * edge_b;
                    byi_read_right = byi_source + 3;
                    byi_read_below = byi_source + source_bypr;
                    byi_read_below_right = byi_read_below + 3;
                    ta_dest[byi_write++] = corner_tl * ta_source[byi_source++] + corner_tr * ta_source[byi_read_right++] + corner_bl * ta_source[byi_read_below++] + corner_br * ta_source[byi_read_below_right++];
                    ta_dest[byi_write++] = corner_tl * ta_source[byi_source++] + corner_tr * ta_source[byi_read_right++] + corner_bl * ta_source[byi_read_below++] + corner_br * ta_source[byi_read_below_right++];
                    ta_dest[byi_write++] = corner_tl * ta_source[byi_source++] + corner_tr * ta_source[byi_read_right++] + corner_bl * ta_source[byi_read_below++] + corner_br * ta_source[byi_read_below_right++];
                }
            }
        }
            */
    }
}
const resize_ta_colorspace_24bipp$subpixel = resize_ta_colorspace_24bipp$subpixel$inline;
let __attempt__resize_ta_colorspace_24bipp$superpixel = (ta_source, source_colorspace, dest_size, ta_dest) => {
    console.log('resize_ta_colorspace_24bipp$superpixel');
    const source_bypp = source_colorspace[2];
    const source_bypr = source_colorspace[3];
    const [f_px_w, f_px_h] = [source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]];
    let f_source_x, f_source_r;
    let i_source_l, i_source_r;
    let f_source_y, f_source_b;
    let i_source_t, i_source_b;
    let i_dest_x, i_dest_y;
    let left_edge_dist, top_edge_dist, right_edge_dist, bottom_edge_dist;
    const ta_left_edge_segment_proportions = new Float32Array(dest_size[0]);
    const ta_top_edge_segment_proportions = new Float32Array(dest_size[1]);
    const ta_right_edge_segment_proportions = new Float32Array(dest_size[0]);
    const ta_bottom_edge_segment_proportions = new Float32Array(dest_size[1]);
    const ta_source_x = new Int16Array(dest_size[0]);
    const ta_source_y = new Int16Array(dest_size[1]);
    const ta_source_x_byi_component = new Int32Array(dest_size[0]);
    const ta_source_y_byi_component = new Int32Array(dest_size[1]);
    const ta_source_x_any_coverage_w = new Int16Array(dest_size[0]);
    const ta_source_y_any_coverage_h = new Int16Array(dest_size[1]);
    const source_i_any_coverage_size = new Int16Array(2);
    let fpx_area_recip = 1 / (f_px_w * f_px_h);
    for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
        f_source_x = i_dest_x * f_px_w;
        f_source_r = (i_dest_x + 1) * f_px_w;
        i_source_l = Math.floor(f_source_x);
        i_source_r = Math.ceil(f_source_r);
        ta_source_x[i_dest_x] = i_source_l;
        ta_source_x_byi_component[i_dest_x] = i_source_l * source_bypp;
        ta_source_x_any_coverage_w[i_dest_x] = i_source_r - i_source_l;
        left_edge_dist = f_source_x - i_source_l;
        if (left_edge_dist === 0) left_edge_dist = 1;
        right_edge_dist = i_source_r - f_source_r;
        if (right_edge_dist === 0) right_edge_dist = 1;
        ta_left_edge_segment_proportions[i_dest_x] = (left_edge_dist) * fpx_area_recip;
        ta_right_edge_segment_proportions[i_dest_x] = (right_edge_dist) * fpx_area_recip;
    }
    for (i_dest_y = 0; i_dest_y < dest_size[1]; i_dest_y++) {
        f_source_y = i_dest_y * f_px_h;
        f_source_b = (i_dest_y + 1) * f_px_h;
        i_source_t = Math.floor(f_source_y);
        i_source_b = Math.ceil(f_source_b);
        ta_source_y[i_dest_y] = i_source_t;
        ta_source_y_byi_component[i_dest_y] = i_source_t * source_bypr;
        ta_source_y_any_coverage_h[i_dest_y] = i_source_b - i_source_t;
        top_edge_dist = f_source_y - i_source_t;
        if (top_edge_dist === 0) top_edge_dist = 1;
        bottom_edge_dist = i_source_b - f_source_b;
        if (bottom_edge_dist === 0) bottom_edge_dist = 1;
        ta_top_edge_segment_proportions[i_dest_y] = (top_edge_dist) * fpx_area_recip;
        ta_bottom_edge_segment_proportions[i_dest_y] = (bottom_edge_dist) * fpx_area_recip;
    }
    const ta_ltrb_edge_props = new Float32Array(4);
    let byi_source;
    let byi_write = 0;
    const ta_ltrb_corner_props = new Float32Array(4);
    for (i_dest_y = 0; i_dest_y < dest_size[1]; i_dest_y++) {
        ta_ltrb_edge_props[1] = ta_top_edge_segment_proportions[i_dest_y];
        ta_ltrb_edge_props[3] = ta_bottom_edge_segment_proportions[i_dest_y];
        source_i_any_coverage_size[1] = ta_source_y_any_coverage_h[i_dest_y];
        for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
            source_i_any_coverage_size[0] = ta_source_x_any_coverage_w[i_dest_x];
            byi_source = ta_source_x_byi_component[i_dest_x] + ta_source_y_byi_component[i_dest_y];
            ta_ltrb_edge_props[0] = ta_left_edge_segment_proportions[i_dest_x];
            ta_ltrb_edge_props[2] = ta_right_edge_segment_proportions[i_dest_x];
            ta_ltrb_corner_props[0] = ta_ltrb_edge_props[0] * ta_ltrb_edge_props[1];
            ta_ltrb_corner_props[1] = ta_ltrb_edge_props[2] * ta_ltrb_edge_props[1];
            ta_ltrb_corner_props[2] = ta_ltrb_edge_props[0] * ta_ltrb_edge_props[3];
            ta_ltrb_corner_props[3] = ta_ltrb_edge_props[2] * ta_ltrb_edge_props[3];
            if (source_i_any_coverage_size[0] === 2) {
                if (source_i_any_coverage_size[1] === 2) {
                    read_2x2_weight_write_24bipp(ta_source, source_bypr, byi_source, ta_dest, byi_write, ta_ltrb_corner_props);
                } else if (source_i_any_coverage_size[1] === 3) {
                    read_2x3_weight_write_24bipp(ta_source, source_bypr, byi_source, ta_dest, byi_write, ta_ltrb_edge_props[1], ta_ltrb_edge_props[3]);
                } else {
                    read_gt3x3_weight_write_24bipp(ta_source, source_bypr, byi_source, source_i_any_coverage_size, ta_ltrb_edge_props, ta_ltrb_corner_props, fpx_area_recip, ta_dest, byi_write);
                }
            } else if (source_i_any_coverage_size[0] === 3) {
                if (source_i_any_coverage_size[1] === 2) {
                    read_3x2_weight_write_24bipp(ta_source, source_bypr, byi_source, ta_ltrb_edge_props, ta_ltrb_corner_props, ta_dest, byi_write);
                } else if (source_i_any_coverage_size[1] === 3) {
                    read_3x3_weight_write_24bipp(ta_source, source_bypr, byi_source, ta_ltrb_edge_props, ta_ltrb_corner_props, ta_dest, byi_write);
                } else {
                    read_gt3x3_weight_write_24bipp(ta_source, source_bypr, byi_source, source_i_any_coverage_size, ta_ltrb_edge_props, ta_ltrb_corner_props, fpx_area_recip, ta_dest, byi_write);
                }
            } else {
                read_gt3x3_weight_write_24bipp(ta_source, source_bypr, byi_source, source_i_any_coverage_size, ta_ltrb_edge_props, ta_ltrb_corner_props, fpx_area_recip, ta_dest, byi_write);
            }
            byi_write += 3;
        }
    }
}
const resize_ta_colorspace_24bipp$subpixel$ta4byis = (ta_source, source_colorspace, dest_size, ta_dest) => {
    const source_bypp = source_colorspace[2];
    const source_bypr = source_colorspace[3];
    const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
    const [f_px_w, f_px_h] = [source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]];
    let f_source_x, f_source_r;
    let i_source_l, i_source_lr_crossover;
    let f_source_y, f_source_b;
    let i_source_t, i_source_tb_crossover;
    let i_dest_x, i_dest_y;
    const ta_left_proportions = new Float32Array(dest_size[0]);
    const ta_top_proportions = new Float32Array(dest_size[1]);
    const ta_source_x = new Int16Array(dest_size[0]);
    const ta_source_y = new Int16Array(dest_size[1]);
    const ta_source_x_byi_component = new Int32Array(dest_size[0]);
    const ta_source_y_byi_component = new Int32Array(dest_size[1]);
    for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
        f_source_x = i_dest_x * f_px_w;
        f_source_r = f_source_x + f_px_w;
        i_source_l = Math.floor(f_source_x);
        i_source_lr_crossover = i_source_l + 1;
        ta_source_x[i_dest_x] = i_source_l;
        ta_source_x_byi_component[i_dest_x] = i_source_l * source_bypp;
        if (f_source_r < i_source_lr_crossover || i_source_l === f_source_x) {
            ta_left_proportions[i_dest_x] = 1;
        } else {
            ta_left_proportions[i_dest_x] = (i_source_lr_crossover - f_source_x) / f_px_w;
        }
    }
    for (i_dest_y = 0; i_dest_y < dest_size[0]; i_dest_y++) {
        f_source_y = i_dest_y * f_px_h;
        f_source_b = f_source_y + f_px_h;
        i_source_t = Math.floor(f_source_y);
        i_source_tb_crossover = i_source_t + 1;
        ta_source_y[i_dest_y] = i_source_t;
        ta_source_y_byi_component[i_dest_y] = i_source_t * source_bypr;
        if (f_source_b < i_source_tb_crossover || i_source_t === f_source_y) {
            ta_top_proportions[i_dest_y] = 1;
        } else {
            ta_top_proportions[i_dest_y] = (i_source_tb_crossover - f_source_y) / f_px_h;
        }
    }
    const ta_ltrb_edge_props = new Float32Array(4);
    let byi_source;
    let byi_write = 0;
    const ta_tl_weight_props = new Float32Array(2);
    const ta_byi_reads = new Int32Array(4);
    const ta_ltrb_corner_props = new Float32Array(4);
    for (i_dest_y = 0; i_dest_y < dest_size[1]; i_dest_y++) {
        ta_ltrb_edge_props[1] = ta_top_proportions[i_dest_y];
        ta_ltrb_edge_props[3] = 1 - ta_top_proportions[i_dest_y];
        for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
            ta_ltrb_edge_props[0] = ta_left_proportions[i_dest_x];
            ta_ltrb_edge_props[2] = 1 - ta_left_proportions[i_dest_x];
            ta_byi_reads[0] = ta_source_x_byi_component[i_dest_x] + ta_source_y_byi_component[i_dest_y];
            if (ta_ltrb_edge_props[0] === 1) {
                if (ta_ltrb_edge_props[1] === 1) {
                    copy_px_24bipp(ta_source, ta_byi_reads[0], ta_dest, byi_write);
                } else {
                    ta_byi_reads[2] = ta_byi_reads[0] + source_bypr;
                    read_1x2_weight_write_24bipp$ta4byis(ta_source, ta_byi_reads, ta_dest, byi_write, ta_ltrb_edge_props[1], ta_ltrb_edge_props[3]);
                }
            } else {
                if (ta_ltrb_edge_props[1] === 1) {
                    ta_byi_reads[1] = ta_byi_reads[0] + source_bypp;
                    read_2x1_weight_write_24bipp$ta4byis(ta_source, ta_byi_reads, ta_dest, byi_write, ta_ltrb_edge_props[0], ta_ltrb_edge_props[2]);
                } else {
                    ta_byi_reads[1] = ta_byi_reads[0] + source_bypp;
                    ta_byi_reads[2] = ta_byi_reads[0] + source_bypr;
                    ta_byi_reads[3] = ta_byi_reads[2] + source_bypp;
                    ta_ltrb_corner_props[0] = ta_ltrb_edge_props[0] * ta_ltrb_edge_props[1];
                    ta_ltrb_corner_props[1] = ta_ltrb_edge_props[2] * ta_ltrb_edge_props[1];
                    ta_ltrb_corner_props[2] = ta_ltrb_edge_props[0] * ta_ltrb_edge_props[3];
                    ta_ltrb_corner_props[3] = ta_ltrb_edge_props[2] * ta_ltrb_edge_props[3];
                    read_2x2_weight_write_24bipp$ta4byis(ta_source, ta_byi_reads, ta_dest, byi_write, ta_ltrb_corner_props);
                }
            }
            byi_write += 3;
        }
    }
}
const __resize_ta_colorspace_24bipp$superpixel = (ta_source, source_colorspace, dest_size, opt_ta_dest) => {
    const bypr = source_colorspace[3];
    const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
    const fpx_area_recip = 1 / (dest_to_source_ratio[0] * dest_to_source_ratio[1]);
    each_source_dest_pixels_resized_limited_further_info(source_colorspace, dest_size, (dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, byi_read) => {
        if (source_i_any_coverage_size[0] === 2 && source_i_any_coverage_size[1] === 2) {
            read_2x2_weight_write_24bipp(ta_source, bypr, byi_read, opt_ta_dest, dest_byi, corner_areas_proportions_of_total);
        } else if (source_i_any_coverage_size[0] === 2 && source_i_any_coverage_size[1] === 3) {
            read_2x3_weight_write_24bipp(ta_source, bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, opt_ta_dest, dest_byi);
        } else if (source_i_any_coverage_size[0] === 3 && source_i_any_coverage_size[1] === 2) {
            read_3x2_weight_write_24bipp(ta_source, bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, opt_ta_dest, dest_byi);
        } else if (source_i_any_coverage_size[0] === 3 && source_i_any_coverage_size[1] === 3) {
            read_3x3_weight_write_24bipp(ta_source, bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip, opt_ta_dest, dest_byi);
        } else {
            read_gt3x3_weight_write_24bipp(ta_source, bypr, byi_read, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip, opt_ta_dest, dest_byi);
        }
    });
}
const __resize_ta_colorspace_24bipp$superpixel$inline = (ta_source, source_colorspace, dest_size, opt_ta_dest) => {
    const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
    const fpx_area_recip = 1 / (dest_to_source_ratio[0] * dest_to_source_ratio[1]);
    const source_edge_distances = new Float32Array(4);
    const edge_distances_proportions_of_total = new Float32Array(4);
    const corner_areas_proportions_of_total = new Float32Array(4);
    const fpx_area = dest_to_source_ratio[0] * dest_to_source_ratio[1];
    const source_bypp = source_colorspace[2];
    const source_bypr = source_colorspace[3];
    const source_bipp = source_colorspace[4];
    const dest_colorspace = new Int32Array([dest_size[0], dest_size[1], source_bypp, source_bypp * dest_size[0], source_bipp, source_bipp * dest_size[0]]);
    const source_fbounds = new Float32Array(4);
    const source_ibounds = new Int16Array(4);
    const source_i_any_coverage_size = new Int16Array(2);
    const source_total_coverage_ibounds = new Int16Array(4);
    let byi_read;
    let dest_byi = 0;
    const width = dest_colorspace[0], height = dest_colorspace[1];
    let x, y;
    for (y = 0; y < height; y++) {
        source_fbounds[1] = y * dest_to_source_ratio[1];
        source_fbounds[3] = source_fbounds[1] + dest_to_source_ratio[1];
        source_ibounds[1] = source_fbounds[1];
        source_ibounds[3] = Math.ceil(source_fbounds[3]);
        source_i_any_coverage_size[1] = source_ibounds[3] - source_ibounds[1];
        source_total_coverage_ibounds[1] = Math.ceil(source_fbounds[1]);
        source_total_coverage_ibounds[3] = source_fbounds[3];
        source_edge_distances[1] = source_total_coverage_ibounds[1] - source_fbounds[1];
        source_edge_distances[3] = source_fbounds[3] - source_total_coverage_ibounds[3];
        if (source_edge_distances[1] === 0) source_edge_distances[1] = 1;
        if (source_edge_distances[3] === 0) source_edge_distances[3] = 1;
        edge_distances_proportions_of_total[1] = source_edge_distances[1] / fpx_area;
        edge_distances_proportions_of_total[3] = source_edge_distances[3] / fpx_area;
        for (x = 0; x < width; x++) {
            source_fbounds[0] = x * dest_to_source_ratio[0];
            source_fbounds[2] = source_fbounds[0] + dest_to_source_ratio[0];
            source_ibounds[0] = source_fbounds[0];
            source_ibounds[2] = Math.ceil(source_fbounds[2]);
            source_i_any_coverage_size[0] = source_ibounds[2] - source_ibounds[0];
            byi_read = source_ibounds[0] * source_bypp + source_ibounds[1] * source_bypr;
            source_total_coverage_ibounds[0] = Math.ceil(source_fbounds[0]); 
            source_total_coverage_ibounds[2] = Math.floor(source_fbounds[2]);
            source_edge_distances[0] = source_total_coverage_ibounds[0] - source_fbounds[0];
            source_edge_distances[2] = source_fbounds[2] - source_total_coverage_ibounds[2];
            if (source_edge_distances[0] === 0) source_edge_distances[0] = 1;
            if (source_edge_distances[2] === 0) source_edge_distances[2] = 1;
            corner_areas_proportions_of_total[0] = source_edge_distances[0] * source_edge_distances[1] / fpx_area;
            corner_areas_proportions_of_total[1] = source_edge_distances[2] * source_edge_distances[1] / fpx_area;
            corner_areas_proportions_of_total[2] = source_edge_distances[0] * source_edge_distances[3] / fpx_area;
            corner_areas_proportions_of_total[3] = source_edge_distances[2] * source_edge_distances[3] / fpx_area;
            if (source_i_any_coverage_size[0] > 3 ||  source_i_any_coverage_size[1] > 3) {
                edge_distances_proportions_of_total[0] = source_edge_distances[0] / fpx_area;
                edge_distances_proportions_of_total[2] = source_edge_distances[2] / fpx_area;
                read_gt3x3_weight_write_24bipp(ta_source, source_bypr, byi_read, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip, opt_ta_dest, dest_byi);
            } else {
                if (source_i_any_coverage_size[0] === 2 && source_i_any_coverage_size[1] === 2) {
                    read_2x2_weight_write_24bipp(ta_source, source_bypr, byi_read, opt_ta_dest, dest_byi, corner_areas_proportions_of_total);
                } else {
                    edge_distances_proportions_of_total[0] = source_edge_distances[0] / fpx_area;
                    edge_distances_proportions_of_total[2] = source_edge_distances[2] / fpx_area;
                    if (source_i_any_coverage_size[0] === 2 && source_i_any_coverage_size[1] === 3) {
                        read_2x3_weight_write_24bipp(ta_source, source_bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, opt_ta_dest, dest_byi);
                    } else if (source_i_any_coverage_size[0] === 3 && source_i_any_coverage_size[1] === 2) {
                        read_3x2_weight_write_24bipp(ta_source, source_bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, opt_ta_dest, dest_byi);
                    } else if (source_i_any_coverage_size[0] === 3 && source_i_any_coverage_size[1] === 3) {
                        read_3x3_weight_write_24bipp(ta_source, source_bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip, opt_ta_dest, dest_byi);
                    } else {
                        console.trace();
                        throw 'stop';
                    }
                }
            }
            dest_byi += source_bypp;
        }
    }
}
const resize_ta_colorspace_24bipp$superpixel$inline$locals = (ta_source, source_colorspace, dest_size, opt_ta_dest) => {
    const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
    const fpx_area_recip = 1 / (dest_to_source_ratio[0] * dest_to_source_ratio[1]);
    const [fpxw, fpxh] = [source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]];
    let edge_l, edge_t, edge_r, edge_b;
    let edge_p_l, edge_p_t, edge_p_r, edge_p_b;
    let corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br;
    const fpx_area = dest_to_source_ratio[0] * dest_to_source_ratio[1];
    const source_bypp = source_colorspace[2];
    const source_bypr = source_colorspace[3];
    const source_bipp = source_colorspace[4];
    const dest_colorspace = new Int32Array([dest_size[0], dest_size[1], source_bypp, source_bypp * dest_size[0], source_bipp, source_bipp * dest_size[0]]);
    let fbounds_l, fbounds_t, fbounds_r, fbounds_b;
    let ibounds_l, ibounds_t, ibounds_r, ibounds_b;
    let any_coverage_w, any_coverage_h;
    let total_coverage_l, total_coverage_t, total_coverage_r, total_coverage_b;
    let byi_read;
    let dest_byi = 0;
    const width = dest_colorspace[0], height = dest_colorspace[1];
    let x, y;
    for (y = 0; y < height; y++) {
        fbounds_t = y * fpxh;
        fbounds_b = fbounds_t + fpxh;
        ibounds_t = Math.floor(fbounds_t);
        ibounds_b = Math.ceil(fbounds_b);
        any_coverage_h = ibounds_b - ibounds_t;
        total_coverage_t = Math.ceil(fbounds_t);
        total_coverage_b = Math.floor(fbounds_b);
        edge_t = total_coverage_t - fbounds_t;
        edge_b = fbounds_b - total_coverage_b;
        if (edge_t === 0) edge_t = 1;
        if (edge_b === 0) edge_b = 1;
        edge_p_t = edge_t / fpx_area;
        edge_p_b = edge_b / fpx_area;
        fbounds_l = 0;
        fbounds_r = fpxw;
        for (x = 0; x < width; x++) {
            fbounds_l = x * fpxw;
            fbounds_r = (x + 1) * fpxw;
            ibounds_l = Math.floor(fbounds_l);
            ibounds_r = Math.ceil(fbounds_r);
            any_coverage_w = ibounds_r - ibounds_l;
            byi_read = ibounds_l * source_bypp + ibounds_t * source_bypr;
            total_coverage_l = Math.ceil(fbounds_l);
            total_coverage_r = Math.floor(fbounds_r);
            edge_l = total_coverage_l - fbounds_l;
            edge_r = fbounds_r - total_coverage_r;
            if (edge_l === 0) edge_l = 1;
            if (edge_r === 0) edge_r = 1;
            corner_p_tl = edge_l * edge_p_t;
            corner_p_tr = edge_r * edge_p_t;
            corner_p_bl = edge_l * edge_p_b;
            corner_p_br = edge_r * edge_p_b;
            if (any_coverage_w > 3 ||  any_coverage_h > 3) {
                edge_p_l = edge_l / fpx_area;
                edge_p_r = edge_r / fpx_area;
                read_gt3x3_weight_write_24bipp$locals(ta_source, source_bypr, byi_read,
                    any_coverage_w, any_coverage_h,
                    edge_p_l, edge_p_t, edge_p_r, edge_p_b,
                    corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br,
                    fpx_area_recip,
                    opt_ta_dest, dest_byi
                    )
            } else {
                if (any_coverage_w === 2 && any_coverage_h === 2) {
                    read_2x2_weight_write_24bipp$locals(ta_source, source_bypr, byi_read, 
                        corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br,
                        opt_ta_dest, dest_byi);
                } else {
                    edge_p_l = edge_l / fpx_area;
                    edge_p_r = edge_r / fpx_area;
                    if (any_coverage_w === 2 && any_coverage_h === 3) {
                        read_2x3_weight_write_24bipp$locals(ta_source, source_bypr, byi_read,
                            edge_p_l, edge_p_t, edge_p_r, edge_p_b,
                            corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br,
                            opt_ta_dest, dest_byi);
                    } else if (any_coverage_w === 3 && any_coverage_h === 2) {
                        read_3x2_weight_write_24bipp$locals(ta_source, source_bypr, byi_read,
                            edge_p_l, edge_p_t, edge_p_r, edge_p_b,
                            corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br,
                            opt_ta_dest, dest_byi);
                    } else if (any_coverage_w === 3 && any_coverage_h === 3) {
                        read_3x3_weight_write_24bipp$locals(ta_source, source_bypr, byi_read,
                            edge_p_l, edge_p_t, edge_p_r, edge_p_b,
                            corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br,
                            fpx_area_recip,
                            opt_ta_dest, dest_byi);
                    } else {
                        console.trace();
                        throw 'stop';
                    }
                }
            }
            dest_byi += source_bypp;
        }
    }
}
const resize_ta_colorspace_24bipp$superpixel$inline$locals$inline = (ta_source, source_colorspace, dest_size, opt_ta_dest) => {
    const ta_dest = opt_ta_dest;
    const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
    const fpx_area_recip = 1 / (dest_to_source_ratio[0] * dest_to_source_ratio[1]);
    const [fpxw, fpxh] = [source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]];
    let edge_l, edge_t, edge_r, edge_b;
    let edge_p_l, edge_p_t, edge_p_r, edge_p_b;
    let corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br;
    const fpx_area = dest_to_source_ratio[0] * dest_to_source_ratio[1];
    const source_bypp = source_colorspace[2];
    const source_bypr = source_colorspace[3];
    const source_bipp = source_colorspace[4];
    const dest_colorspace = new Int32Array([dest_size[0], dest_size[1], source_bypp, source_bypp * dest_size[0], source_bipp, source_bipp * dest_size[0]]);
    let fbounds_l, fbounds_t, fbounds_r, fbounds_b;
    let ibounds_l, ibounds_t, ibounds_r, ibounds_b;
    let any_coverage_w, any_coverage_h;
    let total_coverage_l, total_coverage_t, total_coverage_r, total_coverage_b;
    let byi_read;
    let dest_byi = 0;
    const width = dest_colorspace[0], height = dest_colorspace[1];
    let x, y;
    let r = 0, g = 0, b = 0;
    let x_inner, y_inner;
    let byi_read_right, byi_read_below, byi_read_below_right;
    let byi_tl, byi_tm, byi_tr;
    let byi_ml, byi_mm, byi_mr;
    let byi_bl, byi_bm, byi_br;
    let end_hmiddle, end_vmiddle;
    for (y = 0; y < height; y++) {
        fbounds_t = y * fpxh;
        fbounds_b = fbounds_t + fpxh;
        ibounds_t = Math.floor(fbounds_t);
        ibounds_b = Math.ceil(fbounds_b);
        any_coverage_h = ibounds_b - ibounds_t;
        total_coverage_t = Math.ceil(fbounds_t);
        total_coverage_b = Math.floor(fbounds_b);
        edge_t = total_coverage_t - fbounds_t;
        edge_b = fbounds_b - total_coverage_b;
        if (edge_t === 0) edge_t = 1;
        if (edge_b === 0) edge_b = 1;
        edge_p_t = edge_t / fpx_area;
        edge_p_b = edge_b / fpx_area;
        fbounds_l = 0;
        fbounds_r = fpxw;
        for (x = 0; x < width; x++) {
            fbounds_l = x * fpxw;
            fbounds_r = (x + 1) * fpxw;
            ibounds_l = Math.floor(fbounds_l);
            ibounds_r = Math.ceil(fbounds_r);
            any_coverage_w = ibounds_r - ibounds_l;
            byi_read = ibounds_l * source_bypp + ibounds_t * source_bypr;
            total_coverage_l = Math.ceil(fbounds_l);
            total_coverage_r = Math.floor(fbounds_r);
            edge_l = total_coverage_l - fbounds_l;
            edge_r = fbounds_r - total_coverage_r;
            if (edge_l === 0) edge_l = 1;
            if (edge_r === 0) edge_r = 1;
            corner_p_tl = edge_l * edge_p_t;
            corner_p_tr = edge_r * edge_p_t;
            corner_p_bl = edge_l * edge_p_b;
            corner_p_br = edge_r * edge_p_b;
            if (any_coverage_w > 3 ||  any_coverage_h > 3) {
                edge_p_l = edge_l / fpx_area;
                edge_p_r = edge_r / fpx_area;
                byi_tl = byi_read;
                end_hmiddle = any_coverage_w - 1; end_vmiddle = any_coverage_h - 1;
                r = g = b = 0;
                r += ta_source[byi_read++] * corner_p_tl;
                g += ta_source[byi_read++] * corner_p_tl;
                b += ta_source[byi_read++] * corner_p_tl;
                for (x_inner = 1; x_inner < end_hmiddle; x_inner++) {
                    r += ta_source[byi_read++] * edge_p_t;
                    g += ta_source[byi_read++] * edge_p_t;
                    b += ta_source[byi_read++] * edge_p_t;
                }
                r += ta_source[byi_read++] * corner_p_tr;
                g += ta_source[byi_read++] * corner_p_tr;
                b += ta_source[byi_read++] * corner_p_tr;
                for (y_inner = 1; y_inner < end_vmiddle; y_inner++) {
                    byi_read = byi_tl + y_inner * source_bypr;
                    r += ta_source[byi_read++] * edge_p_l;
                    g += ta_source[byi_read++] * edge_p_l;
                    b += ta_source[byi_read++] * edge_p_l;
                    for (x_inner = 1; x_inner < end_hmiddle; x_inner++) {
                        r += ta_source[byi_read++] * fpx_area_recip;
                        g += ta_source[byi_read++] * fpx_area_recip;
                        b += ta_source[byi_read++] * fpx_area_recip;
                    }
                    r += ta_source[byi_read++] * edge_p_r;
                    g += ta_source[byi_read++] * edge_p_r;
                    b += ta_source[byi_read++] * edge_p_r;
                }
                byi_read = byi_tl + end_vmiddle * source_bypr;
                r += ta_source[byi_read++] * corner_p_bl;
                g += ta_source[byi_read++] * corner_p_bl;
                b += ta_source[byi_read++] * corner_p_bl;
                for (x_inner = 1; x_inner < end_hmiddle; x_inner++) {
                    r += ta_source[byi_read++] * edge_p_b;
                    g += ta_source[byi_read++] * edge_p_b;
                    b += ta_source[byi_read++] * edge_p_b;
                }
                r += ta_source[byi_read++] * corner_p_br;
                g += ta_source[byi_read++] * corner_p_br;
                b += ta_source[byi_read++] * corner_p_br;
                ta_dest[dest_byi] = Math.round(r);
                ta_dest[dest_byi + 1] = Math.round(g);
                ta_dest[dest_byi + 2] = Math.round(b);
            } else {
                if (any_coverage_w === 2 && any_coverage_h === 2) {
                    byi_read_right = byi_read + 3;
                    byi_read_below = byi_read + source_bypr;
                    byi_read_below_right = byi_read_below + 3;
                    ta_dest[dest_byi] = corner_p_tl * ta_source[byi_read++] + corner_p_tr * ta_source[byi_read_right++] + corner_p_bl * ta_source[byi_read_below++] + corner_p_br * ta_source[byi_read_below_right++];
                    ta_dest[dest_byi + 1] = corner_p_tl * ta_source[byi_read++] + corner_p_tr * ta_source[byi_read_right++] + corner_p_bl * ta_source[byi_read_below++] + corner_p_br * ta_source[byi_read_below_right++];
                    ta_dest[dest_byi + 2] = corner_p_tl * ta_source[byi_read++] + corner_p_tr * ta_source[byi_read_right++] + corner_p_bl * ta_source[byi_read_below++] + corner_p_br * ta_source[byi_read_below_right++];
                } else {
                    edge_p_l = edge_l / fpx_area;
                    edge_p_r = edge_r / fpx_area;
                    if (any_coverage_w === 2 && any_coverage_h === 3) {
                        byi_tl = byi_read; byi_tr = byi_tl + 3;
                        byi_ml = byi_tl + source_bypr; byi_mr = byi_ml + 3;
                        byi_bl = byi_ml + source_bypr; byi_br = byi_bl + 3;
                        ta_dest[dest_byi] =     ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tr++] * corner_p_tr +
                                                ta_source[byi_ml++] * edge_p_l + ta_source[byi_mr++] * edge_p_r +
                                                ta_source[byi_bl++] * corner_p_bl + ta_source[byi_br++] * corner_p_br
                        ta_dest[dest_byi + 1] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tr++] * corner_p_tr +
                                                ta_source[byi_ml++] * edge_p_l + ta_source[byi_mr++] * edge_p_r +
                                                ta_source[byi_bl++] * corner_p_bl + ta_source[byi_br++] * corner_p_br
                        ta_dest[dest_byi + 2] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tr++] * corner_p_tr +
                                                ta_source[byi_ml++] * edge_p_l + ta_source[byi_mr++] * edge_p_r +
                                                ta_source[byi_bl++] * corner_p_bl + ta_source[byi_br++] * corner_p_br
                    } else if (any_coverage_w === 3 && any_coverage_h === 2) {
                        byi_tl = byi_read;
                        byi_tm = byi_tl + 3; byi_tr = byi_tm + 3;
                        byi_bl = byi_tm + source_bypr; byi_bm = byi_bl + 3; byi_br = byi_bm + 3;
                        ta_dest[dest_byi] =     ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br;
                        ta_dest[dest_byi + 1] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br;
                        ta_dest[dest_byi + 2] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br;
                    } else if (any_coverage_w === 3 && any_coverage_h === 3) {
                        byi_tl = byi_read; byi_tm = byi_tl + source_bypp; byi_tr = byi_tm + source_bypp;
                        byi_ml = byi_tl + source_bypr; byi_mm = byi_ml + source_bypp; byi_mr = byi_mm + source_bypp;
                        byi_bl = byi_ml + source_bypr; byi_bm = byi_bl + source_bypp; byi_br = byi_bm + source_bypp;
                        ta_dest[dest_byi] =     ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                                                ta_source[byi_ml++] * edge_p_l + ta_source[byi_mm++] * fpx_area_recip + ta_source[byi_mr++] * edge_p_r +
                                                ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br
                        ta_dest[dest_byi + 1] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                                                ta_source[byi_ml++] * edge_p_l + ta_source[byi_mm++] * fpx_area_recip + ta_source[byi_mr++] * edge_p_r +
                                                ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br
                        ta_dest[dest_byi + 2] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                                                ta_source[byi_ml++] * edge_p_l + ta_source[byi_mm++] * fpx_area_recip + ta_source[byi_mr++] * edge_p_r +
                                                ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br
                    } else {
                        console.trace();
                        throw 'stop';
                    }
                }
            }
            dest_byi += source_bypp;
        }
    }
}
const resize_ta_colorspace_24bipp$superpixel = resize_ta_colorspace_24bipp$superpixel$inline$locals$inline;
const resize_ta_colorspace_24bipp$general = (ta_source, source_colorspace, dest_size, opt_ta_dest) => {
    const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
    const [width, height, bypp, bypr, bipp, bipr] = source_colorspace;
    const fpx_area_recip = 1 / (dest_to_source_ratio[0] * dest_to_source_ratio[1]);
    each_source_dest_pixels_resized_limited_further_info(source_colorspace, dest_size, (dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, byi_read) => {
        if (source_i_any_coverage_size[0] === 1) {
            if (source_i_any_coverage_size[1] === 1) {
                copy_px_24bipp(ta_source, byi_read, opt_ta_dest, dest_byi);
            } else if (source_i_any_coverage_size[1] === 2) {
                read_1x2_weight_write_24bipp(ta_source, bypr, byi_read, opt_ta_dest, dest_byi, edge_distances_proportions_of_total[1], edge_distances_proportions_of_total[3]);
            } else {
                console.log('source_i_any_coverage_size', source_i_any_coverage_size);
                console.trace();
                throw 'NYI';
            }
        } else if (source_i_any_coverage_size[0] === 2) {
            if (source_i_any_coverage_size[1] === 1) {
                read_2x1_weight_write_24bipp(ta_source, byi_read, opt_ta_dest, dest_byi, edge_distances_proportions_of_total[0], edge_distances_proportions_of_total[2]);
            } else if (source_i_any_coverage_size[1] === 2) {
                read_2x2_weight_write_24bipp(ta_source, bypr, byi_read, opt_ta_dest, dest_byi, corner_areas_proportions_of_total);
            } else {
                read_2x3_weight_write_24bipp(ta_source, bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, opt_ta_dest, dest_byi);
            }
        } else if (source_i_any_coverage_size[0] === 3) {
            if (source_i_any_coverage_size[1] === 1) {
                console.log('source_i_any_coverage_size', source_i_any_coverage_size);
                console.trace();
                throw 'NYI';
            } else if (source_i_any_coverage_size[1] === 2) {
                read_3x2_weight_write_24bipp(ta_source, bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, opt_ta_dest, dest_byi);
            } else if (source_i_any_coverage_size[1] === 3) {
                read_3x3_weight_write_24bipp(ta_source, bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip, opt_ta_dest, dest_byi);
            } else {
                read_gt3x3_weight_write_24bipp(ta_source, bypr, byi_read, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip, opt_ta_dest, dest_byi);
            }
        } else {
            read_gt3x3_weight_write_24bipp(ta_source, bypr, byi_read, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip, opt_ta_dest, dest_byi);
        }
    });
}
const resize_ta_colorspace_24bipp = (ta_source, source_colorspace, dest_size, opt_ta_dest) => {
    const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
    if (dest_to_source_ratio[0] < 1 && dest_to_source_ratio[1] < 1) {
        return resize_ta_colorspace_24bipp$subpixel(ta_source, source_colorspace, dest_size, opt_ta_dest);
    } else if (dest_to_source_ratio[0] > 1 && dest_to_source_ratio[1] > 1) {
        return resize_ta_colorspace_24bipp$superpixel(ta_source, source_colorspace, dest_size, opt_ta_dest);
    } else {
        return resize_ta_colorspace_24bipp$general(ta_source, source_colorspace, dest_size, opt_ta_dest);
    }
}
const read_fpx_weight_write_24bipp = (dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, byi_read) => {
    if (source_i_any_coverage_size[0] === 1) {
        if (source_i_any_coverage_size[1] === 1) {
            opt_ta_dest[dest_byi] = ta_source[byi_read++];
            opt_ta_dest[dest_byi + 1] = ta_source[byi_read++];
            opt_ta_dest[dest_byi + 2] = ta_source[byi_read++];
        } else if (source_i_any_coverage_size[1] === 2) {
            byi_read_below = byi_read + bypr;
            opt_ta_dest[dest_byi] = edge_distances_proportions_of_total[1] * ta_source[byi_read++] + edge_distances_proportions_of_total[3] * ta_source[byi_read_below++];
            opt_ta_dest[dest_byi + 1] = edge_distances_proportions_of_total[1] * ta_source[byi_read++] + edge_distances_proportions_of_total[3] * ta_source[byi_read_below++];
            opt_ta_dest[dest_byi + 2] = edge_distances_proportions_of_total[1] * ta_source[byi_read++] + edge_distances_proportions_of_total[3] * ta_source[byi_read_below++];
        } else {
            console.log('source_i_any_coverage_size', source_i_any_coverage_size);
            console.trace();
            throw 'NYI';
        }
    } else if (source_i_any_coverage_size[0] === 2) {
        if (source_i_any_coverage_size[1] === 1) {
            byi_read_right = byi_read + bypp;
            opt_ta_dest[dest_byi] = edge_distances_proportions_of_total[0] * ta_source[byi_read++] + edge_distances_proportions_of_total[2] * ta_source[byi_read_right++];
            opt_ta_dest[dest_byi + 1] = edge_distances_proportions_of_total[0] * ta_source[byi_read++] + edge_distances_proportions_of_total[2] * ta_source[byi_read_right++];
            opt_ta_dest[dest_byi + 2] = edge_distances_proportions_of_total[0] * ta_source[byi_read++] + edge_distances_proportions_of_total[2] * ta_source[byi_read_right++];
        } else if (source_i_any_coverage_size[1] === 2) {
            byi_read_right = byi_read + bypp;
            byi_read_below = byi_read + bypr;
            byi_read_below_right = byi_read_below + bypp;
            opt_ta_dest[dest_byi] = corner_areas_proportions_of_total[0] * ta_source[byi_read++] + corner_areas_proportions_of_total[1] * ta_source[byi_read_right++] + corner_areas_proportions_of_total[2] * ta_source[byi_read_below++] + corner_areas_proportions_of_total[3] * ta_source[byi_read_below_right++];
            opt_ta_dest[dest_byi + 1] = corner_areas_proportions_of_total[0] * ta_source[byi_read++] + corner_areas_proportions_of_total[1] * ta_source[byi_read_right++] + corner_areas_proportions_of_total[2] * ta_source[byi_read_below++] + corner_areas_proportions_of_total[3] * ta_source[byi_read_below_right++];
            opt_ta_dest[dest_byi + 2] = corner_areas_proportions_of_total[0] * ta_source[byi_read++] + corner_areas_proportions_of_total[1] * ta_source[byi_read_right++] + corner_areas_proportions_of_total[2] * ta_source[byi_read_below++] + corner_areas_proportions_of_total[3] * ta_source[byi_read_below_right++];
        } else {
            read_2x3_weight_write_24bipp(ta_source, bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, opt_ta_dest, dest_byi);
        }
    } else if (source_i_any_coverage_size[0] === 3) {
        if (source_i_any_coverage_size[1] === 1) {
            console.log('source_i_any_coverage_size', source_i_any_coverage_size);
            console.trace();
            throw 'NYI';
        } else if (source_i_any_coverage_size[1] === 2) {
            read_3x2_weight_write_24bipp(ta_source, bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, opt_ta_dest, dest_byi);
        } else if (source_i_any_coverage_size[1] === 3) {
            read_3x3_weight_write_24bipp(ta_source, bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip, opt_ta_dest, dest_byi);
        } else {
            read_gt3x3_weight_write_24bipp(ta_source, bypr, byi_read, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip, opt_ta_dest, dest_byi);
        }
    } else {
        read_gt3x3_weight_write_24bipp(ta_source, bypr, byi_read, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip, opt_ta_dest, dest_byi);
    }
}
const resize_ta_colorspace = (ta_source, source_colorspace, dest_size, opt_ta_dest) => {
    const bipp = source_colorspace[4];
    if (bipp === 1) {
        console.trace(); throw 'NYI';
    } else if (bipp === 8) {
        console.trace(); throw 'NYI';
    } else if (bipp === 24) {
        return resize_ta_colorspace_24bipp(ta_source, source_colorspace, dest_size, opt_ta_dest);
    } else if (bipp === 32) {
        console.trace(); throw 'NYI';
    } else {
        console.trace();
        throw 'unsupported bipp: ' + bipp;
    }
}
module.exports = {
    resize_ta_colorspace: resize_ta_colorspace,
    resize_ta_colorspace_24bipp: resize_ta_colorspace_24bipp,
    resize_ta_colorspace_24bipp$subpixel: resize_ta_colorspace_24bipp$subpixel
}

},{}],45:[function(require,module,exports){

const get_instance = () => {

    // Write, not paint?



    const fill_solid_rect_by_bounds_8bipp = (ta_dest, bypr_dest, ta_bounds, ui8_color) => {
        // create a row filled with that color.

        // need the bypr of dest.

        const row_width = ta_bounds[2] - ta_bounds[0];
        const bytes_per_row = row_width;
        const ta_write_row = (new Uint8ClampedArray(bytes_per_row)).fill(ui8_color);
        // iterate through you values...

        const byi_dest_start = (ta_bounds[0]) + (ta_bounds[1] * bypr_dest);
        let byi_write = byi_dest_start;

        for (let y = ta_bounds[1]; y < ta_bounds[3]; y++) {
            //console.log('byi_read, byi_write', [byi_read, byi_write]);
            ta_dest.set(ta_write_row, byi_write);
            //byi_read += bytes_source_row_jump;
            byi_write += bypr_dest;
        }
    }

    // And make the 24 bipp version.
    //  Setting up the initial row would take longer.
    //   Worth having the function written in a ta-access more purely mathematical way.
    //    May make more functions for the pb classes that wrap these in a cool / efficient way.


    const fill_solid_rect_by_bounds_24bipp = (ta_dest, bypr_dest, ta_bounds, ta_rgb) => {
        // create a row filled with that color.

        // need the bypr of dest.

        const row_width = ta_bounds[2] - ta_bounds[0];
        const bytes_per_row = row_width * 3;
        const ta_write_row = (new Uint8ClampedArray(bytes_per_row));

        //const l = 

        let cc = 0, c = 0;
        while (c < bytes_per_row) {
            ta_write_row[c++] = ta_rgb[cc++];
            //cc++;
            if (cc === 3) cc = 0;
            //c++;
        }
        // iterate through you values...

        const byi_dest_start = (ta_bounds[0] * 3) + (ta_bounds[1] * bypr_dest);
        let byi_write = byi_dest_start;

        for (let y = ta_bounds[1]; y < ta_bounds[3]; y++) {
            //console.log('byi_read, byi_write', [byi_read, byi_write]);
            ta_dest.set(ta_write_row, byi_write);
            //byi_read += bytes_source_row_jump;
            byi_write += bypr_dest;
        }
    }


    // A ta-math directory may be better.
    //  directories:
    //  read
    //  copy
    //  write / paint




    // paint_rect
    //  maybe have paint functions separate
    //  copy functions separate




    const fill_solid_rect_by_bounds = (ta_dest, bypr_dest, ta_bounds, bipp, color) => {
        // Polymorphism with color being a number or a typed array?
        

        // Call a different specific function depending on curcumstances?

        if (bipp === 8) {
            return fill_solid_rect_by_bounds_8bipp(ta_dest, bypr_dest, ta_bounds, color);
        } else if (bipp === 24) {
            return fill_solid_rect_by_bounds_24bipp(ta_dest, bypr_dest, ta_bounds, color);
        } else if (bipp === 32) {
            console.trace();
            throw 'NYI';
        } else {
            console.trace();
            
            throw 'Unsupported bipp: ' + bipp;
        }
    }




    return {
        fill_solid_rect_by_bounds: fill_solid_rect_by_bounds,
        fill_solid_rect_by_bounds_24bipp: fill_solid_rect_by_bounds_24bipp,
        fill_solid_rect_by_bounds_8bipp: fill_solid_rect_by_bounds_8bipp,

        get_instance: get_instance
    }
}

module.exports = get_instance();

},{}],46:[function(require,module,exports){
(function (Buffer){(function (){
// Late 2023 - Should include field from obext as well?

// Bring more data functionality to a lower level...?
//   Have more of a platform to support Data_Model, Data_Value and Data_Object with.

// data.schema?
// data.model.schema???

// Would be worth integrating various parts together here and with Data_Model, Data_Object, Data_Value


const running_in_browser = typeof window !== 'undefined';
const running_in_node = !running_in_browser;
let Readable_Stream, Writable_Stream, Transform_Stream;
const get_stream = () => {
	if (running_in_node) {
		return (() => {
			const str_libname = ('str') + ('eam');
			const stream = require(str_libname);
			Readable_Stream = stream.Readable;
			Writable_Stream = stream.Writable;
			Transform_Stream = stream.Transform;
			return stream;
		})();
	} else {
		return undefined;
	}
}
const stream = get_stream();
const each = (collection, fn, context) => {
	if (collection) {
		if (collection.__type == 'collection') {
			return collection.each(fn, context);
		}
		let ctu = true;
		let stop = function () {
			ctu = false;
		};
		if (is_array(collection)) {
			let res = [],
				res_item;
			for (let c = 0, l = collection.length; c < l; c++) {
				res_item;
				if (ctu == false) break;
				if (context) {
					res_item = fn.call(context, collection[c], c, stop);
				} else {
					res_item = fn(collection[c], c, stop);
				}
				res.push(res_item);
			}
			return res;
		} else {
			let name, res = {};
			for (name in collection) {
				if (ctu === false) break;
				if (context) {
					res[name] = fn.call(context, collection[name], name, stop);
				} else {
					res[name] = fn(collection[name], name, stop);
				}
			}
			return res;
		}
	}
};
const is_array = Array.isArray;
const is_dom_node = function isDomNode(obj) {
	return (!!obj && typeof obj.nodeType !== 'undefined' && typeof obj.childNodes !== 'undefined');
};
const get_truth_map_from_arr = function (arr) {
	let res = {};
	each(arr, function (v, i) {
		res[v] = true;
	});
	return res;
};
const get_arr_from_truth_map = function (truth_map) {
	let res = [];
	each(truth_map, function (v, i) {
		res.push(i);
	});
	return res;
};
const get_map_from_arr = function (arr) {
	let res = {};
	for (let c = 0, l = arr.length; c < l; c++) {
		res[arr[c]] = c;
	}
	return res;
}
const arr_like_to_arr = function (arr_like) {
	let res = new Array(arr_like.length);
	for (let c = 0, l = arr_like.length; c < l; c++) {
		res[c] = arr_like[c];
	};
	return res;
};
const is_ctrl = function (obj) {
	return (typeof obj !== 'undefined' && obj !== null && is_defined(obj.__type_name) && is_defined(obj.content) && is_defined(obj.dom));
};
const map_loaded_type_fn_checks = {},
	map_loaded_type_abbreviations = {
		'object': 'o',
		'number': 'n',
		'string': 's',
		'function': 'f',
		'boolean': 'b',
		'undefined': 'u',
		'array': 'a',
		'arguments': 'A',
		'date': 'd',
		'regex': 'r',
		'error': 'e',
		'buffer': 'B',
		'promise': 'p',
		'observable': 'O',
		'readable_stream': 'R',
		'writable_stream': 'W',
		'data_value': 'V'
	};
let using_type_plugins = false;
const invert = (obj) => {
	if (!is_array(obj)) {
		let res = {};
		each(obj, (v, k) => {
			res[v] = k;
		})
		return res;
	} else {
		console.trace();
		throw 'invert(obj) not supported on arrays'
	}
}
const map_loaded_type_names = invert(map_loaded_type_abbreviations);
const load_type = (name, abbreviation, fn_detect_instance) => {
	map_loaded_type_fn_checks[name] = fn_detect_instance;
	map_loaded_type_names[abbreviation] = name;
	map_loaded_type_abbreviations[name] = abbreviation;
	using_type_plugins = true;
}
const tof = (obj, t1) => {
	let res = t1 || typeof obj;
	if (using_type_plugins) {
		let res;
		each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
			if (fn_check(obj)) {
				res = name;
				stop();
			}
		});
		if (res) {
			return res;
		}
	}
	if (res === 'number' || res === 'string' || res === 'function' || res === 'boolean') {
		return res;
	}
	if (res === 'object') {
		if (typeof obj !== 'undefined') {
			if (obj === null) {
				return 'null';
			}
			if (obj.__type) {
				return obj.__type;
			} else if (obj.__type_name) {
				return obj.__type_name;
			} else {
				if (obj instanceof Promise) {
					return 'promise';
				}
				if (is_ctrl(obj)) {
					return 'control';
				}
				if (obj instanceof Date) {
					return 'date';
				}
				if (is_array(obj)) {
					return 'array';
				} else {
					if (obj instanceof Error) {
						res = 'error';
					} else if (obj instanceof RegExp) res = 'regex';
					if (typeof window === 'undefined') {
						if (obj && obj.readInt8) res = 'buffer';
					}
				}
				return res;
			}
		} else {
			return 'undefined';
		}
	}
	return res;
};
const tf = (obj) => {
	let res = typeof obj;
	if (using_type_plugins) {
		let res;
		each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
			if (fn_check(obj)) {
				res = map_loaded_type_abbreviations[name];
				stop();
			}
		});
		if (res) {
			return res;
		}
	}
	if (res === 'number' || res === 'string' || res === 'function' || res === 'boolean' || res === 'undefined') {
		return res[0];
	} else {
		if (obj === null) {
			return 'N';
		} else {
			if (running_in_node) {
				if (obj instanceof Readable_Stream) {
					return 'R';
				} else if (obj instanceof Writable_Stream) {
					return 'W';
				} else if (obj instanceof Transform_Stream) {
					return 'T';
				}
			}
			if (typeof Buffer !== 'undefined' && obj instanceof Buffer) {
				return 'B';
			} else if (obj instanceof Promise) {
				return 'p';
			} else if (obj instanceof Date) {
				return 'd';
			} else if (is_array(obj)) {
				return 'a';
			} else {
				if (obj._is_observable === true) {
					return 'O';
				} else {
					if (typeof obj.callee === 'function') {
						return 'A';
					} else if (obj instanceof Error) {
						return 'e';
					} else if (obj instanceof RegExp) return 'r';
					return 'o';
				}
			}
			return res;
		}
	}
	console.trace();
	console.log('item', item);
	throw 'type not found';
	return res;
};
const atof = (arr) => {
	let res = new Array(arr.length);
	for (let c = 0, l = arr.length; c < l; c++) {
		res[c] = tof(arr[c]);
	}
	return res;
};
const is_defined = (value) => {
		return typeof (value) != 'undefined';
	},
	isdef = is_defined;
const stringify = JSON.stringify;

// Older version???

let _get_item_sig = (i, arr_depth) => {
	let res;
	let t1 = typeof i;
	if (t1 === 'string') {
		res = 's';
	} else if (t1 === 'number') {
		res = 'n';
	} else if (t1 === 'boolean') {
		res = 'b';
	} else if (t1 === 'function') {
		res = 'f';
	} else {
		let t = tof(i, t1);
		if (t === 'array') {
			if (arr_depth) {
				res = '['
				for (let c = 0, l = i.length; c < l; c++) {
					if (c > 0) res = res + ',';
					res = res + get_item_sig(i[c], arr_depth - 1);
				}
				res = res + ']';
			} else {
				res = 'a';
			}
		} else if (t === 'control') {
			res = 'c';
		} else if (t === 'date') {
			res = 'd';
		} else if (t === 'observable') {
			res = 'O';
		} else if (t === 'regex') {
			res = 'r';
		} else if (t === 'buffer') {
			res = 'B';
		} else if (t === 'readable_stream') {
			res = 'R';
		} else if (t === 'writable_stream') {
			res = 'W';
		} else if (t === 'object') {
			res = 'o';
		} else if (t === 'undefined') {
			res = 'u';
		} else {
			if (t === 'collection_index') {
				return 'X';
			} else if (t === 'data_object') {
				if (i._abstract) {
					res = '~D';
				} else {
					res = 'D';
				}
			} else {
				if (t === 'data_value') {
					if (i._abstract) {
						res = '~V';
					} else {
						res = 'V';
					}
				} else if (t === 'null') {
					res = '!';
				} else if (t === 'collection') {
					if (i._abstract) {
						res = '~C';
					} else {
						res = 'C';
					}
				} else {
					res = '?';
				}
			}
		}
	}
	return res;
};
const get_item_sig = (item, arr_depth) => {
	if (arr_depth) {
		return _get_item_sig(item, arr_depth);
	}
	const t = tof(item);

	if (map_loaded_type_abbreviations[t]) {
		return map_loaded_type_abbreviations[t];
	} else {
		let bt = typeof item;
		if (bt === 'object') {
			if (is_array(item)) {
				return 'a';
			} else {
				return 'o';
			}
		} else {
			console.log('map_loaded_type_abbreviations type name not found', t);
			console.log('bt', bt);
			console.trace();
			throw 'stop';
		}
	}
}
const get_a_sig = (a) => {
	let c = 0,
		l = a.length;

	//console.log('is_array(a)', is_array(a));
	//console.log('a', a);
	//console.log('get_a_sig l', l);
	let res = '[';
	let first = true;
	for (c = 0; c < l; c++) {
		if (!first) {
			res = res + ',';
		}
		first = false;
		res = res + get_item_sig(a[c]);
	}
	res = res + ']';
	return res;
}
const deep_sig = (item, max_depth = -1, depth = 0) => {
	const t = tf(item);
	let res = '';
	if (t === 'a') {
		const l = item.length;
		if (max_depth === -1 || depth <= max_depth) {
			res = res + '[';
			let first = true;
			for (let c = 0; c < l; c++) {
				if (!first) res = res + ',';
				res = res + deep_sig(item[c], max_depth, depth + 1);
				first = false;
			}
			res = res + ']';
		} else {
			return 'a';
		}
	} else if (t === 'A') {
		const l = item.length;
		let first = true;
		for (let c = 0; c < l; c++) {
			if (!first) res = res + ',';
			res = res + deep_sig(item[c], max_depth, depth + 1);
			first = false;
		}
	} else if (t === 'o') {
		if (max_depth === -1 || depth <= max_depth) {
			let res = '{';
			let first = true;
			each(item, (v, k) => {
				if (!first) res = res + ',';
				res = res + '"' + k + '":' + deep_sig(v, max_depth, depth + 1);
				first = false;
			});
			res = res + '}';
			return res;
		} else {
			return 'o';
		}
	} else {
		res = res + t;
	}
	return res;
}
const trim_sig_brackets = function (sig) {
	if (tof(sig) === 'string') {
		if (sig.charAt(0) == '[' && sig.charAt(sig.length - 1) == ']') {
			return sig.substring(1, sig.length - 1);
		} else {
			return sig;
		}
	}
};
const arr_trim_undefined = function (arr_like) {
	let res = [];
	let last_defined = -1;
	let t, v;
	for (let c = 0, l = arr_like.length; c < l; c++) {
		v = arr_like[c];
		t = tof(v);
		if (t == 'undefined') {} else {
			last_defined = c;
		}
	}
	for (let c = 0, l = arr_like.length; c < l; c++) {
		if (c <= last_defined) {
			res.push(arr_like[c]);
		}
	}
	return res;
};

// Could see about simply integrating data types into fp....?
//   That could mean habing get_item_sig return sigs for those data types.
//     Would need to define signature abbreviations for them.





const functional_polymorphism = function (options, fn) {
	let a0 = arguments;
	if (a0.length === 1) {
		fn = a0[0];
		options = null;
	}
	let arr_slice = Array.prototype.slice;
	let arr, sig, a2, l, a;
	return function () {
		a = arguments;
		l = a.length;
		if (l === 1) {
			sig = get_item_sig([a[0]], 1);
			a2 = [a[0]];
			a2.l = 1;
			return fn.call(this, a2, sig);
		} else if (l > 1) {
			arr = arr_trim_undefined(arr_slice.call(a, 0));
			sig = get_item_sig(arr, 1);
			arr.l = arr.length;
			return fn.call(this, arr, sig);
		} else if (a.length === 0) {
			arr = new Array(0);
			arr.l = 0;
			return fn.call(this, arr, '[]');
		}
	}
};
const fp = functional_polymorphism;
const parse_sig = (str_sig, opts = {}) => {
	const sig2 = str_sig.split(', ').join(',');
	const sig_items = sig2.split(',');
	const res = [];
	each(sig_items, sig_item => {
		if (sig_item.length === 1) {
			let type_name = map_loaded_type_names[sig_item];
			res.push({
				abbreviation: sig_item,
				type_name: type_name
			});
		} else {
			let suffix_modifiers;
			let zero_or_more = false;
			let one_or_more = false;
			let type_name = sig_item;
			const obj_res = {
				type_name: type_name
			}
			const distil_suffix_modifiers = () => {
				let last_char = type_name.substr(type_name.length - 1);
				if (last_char === '*') {
					type_name = type_name.substr(0, type_name.length - 1);
					zero_or_more = true;
					obj_res.zero_or_more = true;
					obj_res.modifiers = obj_res.modifiers || [];
					obj_res.modifiers.push('*');
					distil_suffix_modifiers();
				} else if (last_char === '+') {
					type_name = type_name.substr(0, type_name.length - 1);
					one_or_more = true;
					obj_res.one_or_more = true;
					obj_res.modifiers = obj_res.modifiers || [];
					obj_res.modifiers.push('+');
					distil_suffix_modifiers();
				} else {}
			}
			distil_suffix_modifiers();
			obj_res.type_name = type_name;
			res.push(obj_res);
		}
	});
	return res;
}
const mfp_not_sigs = get_truth_map_from_arr(['pre', 'default', 'post']);
const mfp_unparse_sig = arr_sig => {
	let res = '[';
	let first = true;
	each(arr_sig, sig_item => {
		if (!first) {
			res = res + ',';
		}
		res = res + sig_item.abbreviation;
		first = false;
	})
	res = res + ']';
	return res;
}
const map_grammar_def_abbreviations = {
	'string': 's',
	'number': 'n',
	'boolean': 'b',
	's': 's',
	'n': 'n',
	'b': 'b'
}
const log = () => {};
const combinations = (arr, arr_idxs_to_ignore) => {
	const map_ignore_idxs = {};
	if (arr_idxs_to_ignore) {
		each(arr_idxs_to_ignore, idx_to_ignore => {
			map_ignore_idxs[idx_to_ignore] = true;
		});
	}

	// Check for empty arrays in the input
	if (arr.some(subArray => subArray.length === 0)) {
		return []; // Return an empty result if any sub-array is empty
	}

	const res = [];
	const l = arr.length;
	const arr_idxs_num_options = new Uint32Array(l);
	each(arr, (arr_item1, i1) => {
		arr_idxs_num_options[i1] = arr_item1.length;
	});
	const arr_current_option_idxs = (new Uint32Array(l)).fill(0);
	const result_from_indexes = (arr, arg_indexes) => {
		const res = new Array(l);
		if (arg_indexes.length === l) {
			for (var c = 0; c < l; c++) {
				res[c] = arr[c][arg_indexes[c]];
			}
		} else {
			console.trace();
			throw 'Arguments length mismatch';
		}
		return res;
	}
	const incr = () => {
		for (c = l - 1; c >= 0; c--) {
			const ival = arr_current_option_idxs[c];
			const max = arr_idxs_num_options[c] - 1;
			if (ival < max) {
				arr_current_option_idxs[c]++;
				break;
			} else {
				if (c === 0) {
					return false;
				} else {
					arr_current_option_idxs.fill(0, c);
				}
			}
		}
		return true;
	}
	let vals = result_from_indexes(arr, arr_current_option_idxs);
	res.push(vals);
	while (incr()) {
		let vals = result_from_indexes(arr, arr_current_option_idxs);
		res.push(vals);
	}
	return res;
}
const map_native_types = {
	'string': true,
	'boolean': true,
	'number': true,
	'object': true
}
const map_native_type_sigs = {
	's': true,
	'n': true,
	'o': true,
	'a': true,
	'd': true
}


// Late 2023 - mfp may be a good basis to proceed with more data-type aware idioms.
//   Want to use it for mid-level precise and concise code where possible.
//     May use it or its conventions in implementing some higher level (incl mid level) things.

// Would be worth setting up and testing (maybe also benchmarking) Data_Value objects that specifically represent numbers between
//  -180 and 180. Also integrating such Data_Value objects within a Data_Object or other Data_Model.
// Maybe want some kind of _, $, or dm or _dm type shorthand for things that are very useful.
//   Though it does make sense to abstractify things that get used a lot to make it mroe concise.
//     Also worth designing and then using the concise idioms.

// mfp seems like some code that could be redone / changed and parts used elsewhere to implement the mid and high level
//   APIs as wanted.





const mfp = function () {

	// mfp looks complex. may need to look into what it's for and can do.
	//   Looks like an old work-in-progress.
	//     Should look into benchmarking its usage in different places.

	const a1 = arguments;
	const sig1 = get_a_sig(a1);
	let options = {};
	let fn_pre, provided_map_sig_fns, inner_map_sig_fns = {},
		inner_map_parsed_sigs = {},
		arr_sig_parsed_sig_fns = [],
		fn_post;
	let tm_sig_fns;
	let fn_default;
	let single_fn;
	let req_sig_single_fn;
	if (sig1 === '[o]') {
		provided_map_sig_fns = a1[0];
	} else if (sig1 === '[o,o]') {
		options = a1[0];
		provided_map_sig_fns = a1[1];
	} else if (sig1 === '[o,f]') {
		options = a1[0];
		single_fn = a1[1];
	} else if (sig1 === '[o,s,f]') {
		options = a1[0];
		req_sig_single_fn = a1[1];
		single_fn = a1[2];
		provided_map_sig_fns = {};
		provided_map_sig_fns[req_sig_single_fn] = single_fn;
	} else if (sig1 === '[f,o]') {
		single_fn = a1[0];
		options = a1[1];
	} else if (sig1 === '[f]') {
		single_fn = a1[0];
	} else {
		console.log('sig1', sig1);
		console.trace();
		throw 'mfp NYI';
	}
	let {
		single,
		name,
		grammar,
		verb,
		noun,
		return_type,
		return_subtype,
		pure,
		main,
		skip
	} = options;
	let parsed_grammar;
	let identify, validate;
	let dsig = deep_sig;
	(() => {
		if (provided_map_sig_fns) {
			if (provided_map_sig_fns.default) fn_default = provided_map_sig_fns.default;
			each(provided_map_sig_fns, (fn, sig) => {
				if (typeof fn === 'function') {
					if (!mfp_not_sigs[sig]) {
						const parsed_sig = parse_sig(sig);
						const arr_args_with_modifiers = [];
						const arr_args_all_modification_versions = [];
						each(parsed_sig, (arg, i) => {
							arr_args_all_modification_versions[i] = [];
							if (arg.modifiers) {
								const arg_num_modifiers = arg.modifiers.length;
								if (arg_num_modifiers > 1) {
									throw 'Use of more than 1 modifier is currently unsupported.';
								} else if (arg_num_modifiers === 1) {
									arr_args_with_modifiers.push([i, arg]);
									const single_modifier = arg.modifiers[0];
									if (single_modifier === '*') {
										arr_args_all_modification_versions[i].push('');
										arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
										const plural_name = grammar.maps.sing_plur[arg.type_name];
										arr_args_all_modification_versions[i].push(plural_name);
									}
									if (single_modifier === '+') {
										arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
										const plural_name = grammar.maps.sing_plur[arg.type_name];
										arr_args_all_modification_versions[i].push(plural_name);
									}
									if (single_modifier === '?') {
										arr_args_all_modification_versions[i].push('');
										arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
									}
								}
							} else {
								arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
							}
						});
						const combo_args = combinations(arr_args_all_modification_versions);
						const combo_sigs = [];
						let i_first_of_last_undefined = -1;
						each(combo_args, arg_set => {
							let combo_sig = '';
							each(arg_set, (arg, i) => {
								let lsigb4 = combo_sig.length;
								if (i > 0) {
									combo_sig = combo_sig + ',';
								}
								if (arg === '') {
									combo_sig = combo_sig + 'u';
									if (i_first_of_last_undefined === -1) {
										i_first_of_last_undefined = lsigb4;
									}
								} else {
									combo_sig = combo_sig + arg;
									i_first_of_last_undefined = -1;
								}
							})
							if (i_first_of_last_undefined > 0) {
								const combo_sig_no_last_undefined = combo_sig.substr(0, i_first_of_last_undefined);
								combo_sigs.push(combo_sig_no_last_undefined);
							}
							combo_sigs.push(combo_sig);
						})
						if (combo_sigs.length > 0) {
							each(combo_sigs, combo_sig => {
								inner_map_sig_fns[combo_sig] = fn;
							});
						} else {
							inner_map_sig_fns[sig] = fn;
						}
						inner_map_parsed_sigs[sig] = parsed_sig;
						arr_sig_parsed_sig_fns.push([sig, parsed_sig, fn]);
					} else {
						console.log('ommiting, not parsing sig', sig);
					}
				} else {
					console.log('fn', fn);
					console.trace();
					throw 'Expected: function';
				};
			});
		}
		each(inner_map_sig_fns, (fn, sig) => {
			tm_sig_fns = tm_sig_fns || {};
			tm_sig_fns[sig] = true;
		});
	})();
	const res = function () {
		const a2 = arguments;
		const l2 = a2.length;
		console.log('');
		console.log('calling mfp function');
		console.log('--------------------');
		console.log('');
		let mfp_fn_call_deep_sig;
		let ltof = tof;
		const lsig = dsig;
		let ltf = tf;
		mfp_fn_call_deep_sig = lsig(a2);
		let do_skip = false;
		if (skip) {
			if (skip(a2)) {
				do_skip = true;
			} else {}
		}
		if (!do_skip) {
			if (inner_map_sig_fns[mfp_fn_call_deep_sig]) {
				return inner_map_sig_fns[mfp_fn_call_deep_sig].apply(this, a2);
			} else {
				let idx_last_fn = -1;
				let idx_last_obj = -1;
				each(a2, (arg, i_arg) => {
					i_arg = parseInt(i_arg, 10);
					const targ = tf(arg);
					if (targ === 'o') {
						idx_last_obj = i_arg;
					}
					if (targ === 'f') {
						idx_last_fn = i_arg;
					}
				})
				const last_arg_is_fn = idx_last_fn > -1 && idx_last_fn === a2.length - 1;
				const last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 1;
				const second_last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 2;
				let possible_options_obj;
				if (last_arg_is_obj) possible_options_obj = a2[idx_last_obj];
				const new_args_arrangement = [];
				for (let f = 0; f < idx_last_obj; f++) {
					new_args_arrangement.push(a2[f]);
				}
				each(possible_options_obj, (value, key) => {
					new_args_arrangement.push(value);
				});
				let naa_sig = lsig(new_args_arrangement);
				naa_sig = naa_sig.substring(1, naa_sig.length - 1);
				if (inner_map_sig_fns[naa_sig]) {
					return inner_map_sig_fns[naa_sig].apply(this, new_args_arrangement);
				} else {
					if (fn_default) {
						return fn_default.call(this, a2, mfp_fn_call_deep_sig);
					} else {
						if (single_fn) {
							console.log('pre apply single_fn');
							return single_fn.apply(this, a2);
						} else {
							console.log('Object.keys(inner_map_parsed_sigs)', Object.keys(inner_map_parsed_sigs));
							console.trace();
							console.log('mfp_fn_call_deep_sig', mfp_fn_call_deep_sig);
							console.log('provided_map_sig_fns', provided_map_sig_fns);
							if (provided_map_sig_fns) log('Object.keys(provided_map_sig_fns)', Object.keys(provided_map_sig_fns));
							console.log('Object.keys(inner_map_sig_fns)', Object.keys(inner_map_sig_fns));
							console.trace();
							throw 'no signature match found. consider using a default signature. mfp_fn_call_deep_sig: ' + mfp_fn_call_deep_sig;
						}
					}
				}
			}
		}
	}
	const _ = {}
	if (name) _.name = name;
	if (single) _.single = single;
	if (skip) _.skip = skip;
	if (grammar) _.grammar = grammar;
	if (typeof options !== 'undefined' && options.async) _.async = options.async;
	if (main === true) _.main = true;
	if (return_type) _.return_type = return_type;
	if (return_subtype) _.return_subtype = return_subtype;
	if (pure) _.pure = pure;
	if (tm_sig_fns) _.map_sigs = tm_sig_fns;
	if (Object.keys(_).length > 0) {
		res._ = _;
	}
	return res;
}
const convert = (input, conversion_schema) => {}
let arrayify = fp(function (a, sig) {
	let param_index, num_parallel = 1,
		delay = 0,
		fn;
	let res;
	let process_as_fn = function () {
		res = function () {
			let a = arr_like_to_arr(arguments),
				ts = atof(a),
				t = this;
			let last_arg = a[a.length - 1];
			if (tof(last_arg) == 'function') {
				if (typeof param_index !== 'undefined' && ts[param_index] == 'array') {
					let res = [];
					let fns = [];
					each(a[param_index], function (v, i) {
						let new_params = a.slice(0, a.length - 1);
						new_params[param_index] = v;
						fns.push([t, fn, new_params]);
					});
					call_multiple_callback_functions(fns, num_parallel, delay, (err, res) => {
						if (err) {
							console.trace();
							throw err;
						} else {
							let a = [];
							a = a.concat.apply(a, res);
							let callback = last_arg;
							callback(null, a);
						}
					})
				} else {
					return fn.apply(t, a);
				}
			} else {
				if (typeof param_index !== 'undefined' && ts[param_index] == 'array') {
					let res = [];
					for (let c = 0, l = a[param_index].length; c < l; c++) {
						a[param_index] = arguments[param_index][c];
						let result = fn.apply(t, a);
						res.push(result);
					}
					return res;
				} else {
					return fn.apply(t, a);
				}
			}
		};
	}
	if (sig == '[o]') {
		let res = [];
		each(a[0], function (v, i) {
			res.push([v, i]);
		});
	} else if (sig == '[f]') {
		param_index = 0, fn = a[0];
		process_as_fn();
	} else if (sig == '[n,f]') {
		param_index = a[0], fn = a[1];
		process_as_fn();
	} else if (sig == '[n,n,f]') {
		param_index = a[0], num_parallel = a[1], fn = a[2];
		process_as_fn();
	} else if (sig == '[n,n,n,f]') {
		param_index = a[0], num_parallel = a[1], delay = a[2], fn = a[3];
		process_as_fn();
	}
	return res;
});
let mapify = (target) => {
	let tt = tof(target);
	if (tt == 'function') {
		let res = fp(function (a, sig) {
			let that = this;
			if (sig == '[o]') {
				let map = a[0];
				each(map, function (v, i) {
					target.call(that, v, i);
				});
			} else if (sig == '[o,f]') {
				let map = a[0];
				let callback = a[1];
				let fns = [];
				each(map, function (v, i) {
					fns.push([target, [v, i]]);
				});
				call_multi(fns, function (err_multi, res_multi) {
					if (err_multi) {
						callback(err_multi);
					} else {
						callback(null, res_multi);
					}
				});
			} else if (a.length >= 2) {
				target.apply(this, a);
			}
		});
		return res;
	} else if (tt == 'array') {
		let res = {};
		if (arguments.length == 1) {
			if (is_arr_of_strs(target)) {
				each(target, function (v, i) {
					res[v] = true;
				});
			} else {
				each(target, function (v, i) {
					res[v[0]] = v[1];
				});
			}
		} else {
			let by_property_name = arguments[1];
			each(target, function (v, i) {
				res[v[by_property_name]] = v;
			});
		}
		return res;
	}
};
let clone = fp((a, sig) => {
	let obj = a[0];
	if (a.l === 1) {
		if (obj && typeof obj.clone === 'function') {
			return obj.clone();
		} else {
			let t = tof(obj);
			if (t === 'array') {
				let res = [];
				each(obj, v => {
					res.push(clone(v));
				});
				return res;
			} else if (t === 'undefined') {
				return undefined;
			} else if (t === 'string') {
				return obj;
			} else if (t === 'number') {
				return obj;
			} else if (t === 'function') {
				return obj;
			} else if (t === 'boolean') {
				return obj;
			} else if (t === 'null') {
				return obj;
			} else {
				return Object.assign({}, obj);
			}
		}
	} else if (a.l === 2 && tof(a[1]) === 'number') {
		let res = [];
		for (let c = 0; c < a[1]; c++) {
			res.push(clone(obj));
		}
		return res;
	}
});
let set_vals = function (obj, map) {
	each(map, function (v, i) {
		obj[i] = v;
	});
};
let ll_set = (obj, prop_name, prop_value) => {
	let arr = prop_name.split('.');
	let c = 0,
		l = arr.length;
	let i = obj._ || obj,
		s;
	while (c < l) {
		s = arr[c];
		if (typeof i[s] == 'undefined') {
			if (c - l == -1) {
				i[s] = prop_value;
			} else {
				i[s] = {};
			}
		} else {
			if (c - l == -1) {
				i[s] = prop_value;
			}
		}
		i = i[s];
		c++;
	};
	return prop_value;
};
let ll_get = (a0, a1) => {
	if (a0 && a1) {
		let i = a0._ || a0;
		if (a1 == '.') {
			if (typeof i['.'] == 'undefined') {
				return undefined;
			} else {
				return i['.'];
			}
		} else {
			let arr = a1.split('.');
			let c = 0,
				l = arr.length,
				s;
			while (c < l) {
				s = arr[c];
				if (typeof i[s] == 'undefined') {
					if (c - l == -1) {} else {
						throw 'object ' + s + ' not found';
					}
				} else {
					if (c - l == -1) {
						return i[s];
					}
				}
				i = i[s];
				c++;
			}
		}
	}
};
let truth = function (value) {
	return value === true;
};
let iterate_ancestor_classes = (obj, callback) => {
	let ctu = true;
	let stop = () => {
		ctu = false;
	}
	callback(obj, stop);
	if (obj._superclass && ctu) {
		iterate_ancestor_classes(obj._superclass, callback);
	}
}
let is_arr_of_t = function (obj, type_name) {
	let t = tof(obj),
		tv;
	if (t === 'array') {
		let res = true;
		each(obj, function (v, i) {
			tv = tof(v);
			if (tv != type_name) res = false;
		});
		return res;
	} else {
		return false;
	}
}
let is_arr_of_arrs = function (obj) {
	return is_arr_of_t(obj, 'array');
}
let is_arr_of_strs = function (obj) {
	return is_arr_of_t(obj, 'string');
}
let input_processors = {};
let output_processors = {};
let call_multiple_callback_functions = fp(function (a, sig) {
	let arr_functions_params_pairs, callback, return_params = false;
	let delay;
	let num_parallel = 1;
	if (a.l === 1) {
	} else if (a.l === 2) {
		arr_functions_params_pairs = a[0];
		callback = a[1];
	} else if (a.l === 3) {
		if (sig === '[a,n,f]') {
			arr_functions_params_pairs = a[0];
			num_parallel = a[1];
			callback = a[2];
		} else if (sig === '[n,a,f]') {
			arr_functions_params_pairs = a[1];
			num_parallel = a[0];
			callback = a[2];
		} else if (sig === '[a,f,b]') {
			arr_functions_params_pairs = a[0];
			callback = a[1];
			return_params = a[2];
		}
	} else if (a.l === 4) {
		if (sig === '[a,n,n,f]') {
			arr_functions_params_pairs = a[0];
			num_parallel = a[1];
			delay = a[2];
			callback = a[3];
		} else if (sig == '[n,n,a,f]') {
			arr_functions_params_pairs = a[2];
			num_parallel = a[0];
			delay = a[1];
			callback = a[3];
		}
	}
	let res = [];
	let l = arr_functions_params_pairs.length;
	let c = 0;
	let count_unfinished = l;
	let num_currently_executing = 0;
	let process = delay => {
		num_currently_executing++;
		let main = () => {
			let pair = arr_functions_params_pairs[c];
			let context;
			let fn, params, fn_callback;
			let pair_sig = get_item_sig(pair);
			let t_pair = tof(pair);
			if (t_pair == 'function') {
				fn = pair;
				params = [];
			} else {
				if (pair) {
					if (pair.length == 1) {}
					if (pair.length == 2) {
						if (tof(pair[1]) == 'function') {
							context = pair[0];
							fn = pair[1];
							params = [];
						} else {
							fn = pair[0];
							params = pair[1];
						}
					}
					if (pair.length == 3) {
						if (tof(pair[0]) === 'function' && tof(pair[1]) === 'array' && tof(pair[2]) === 'function') {
							fn = pair[0];
							params = pair[1];
							fn_callback = pair[2];
						}
						if (tof(pair[1]) === 'function' && tof(pair[2]) === 'array') {
							context = pair[0];
							fn = pair[1];
							params = pair[2];
						}
					}
					if (pair.length == 4) {
						context = pair[0];
						fn = pair[1];
						params = pair[2];
						fn_callback = pair[3];
					}
				} else {}
			}
			let i = c;
			c++;
			let cb = (err, res2) => {
				num_currently_executing--;
				count_unfinished--;
				if (err) {
					let stack = new Error().stack;
					callback(err);
				} else {
					if (return_params) {
						res[i] = [params, res2];
					} else {
						res[i] = res2;
					}
					if (fn_callback) {
						fn_callback(null, res2);
					}
					if (c < l) {
						if (num_currently_executing < num_parallel) {
							process(delay);
						}
					} else {
						if (count_unfinished <= 0) {
							callback(null, res);
						}
					}
				}
			};
			let arr_to_call = params || [];
			arr_to_call.push(cb);
			if (fn) {
				if (context) {
					fn.apply(context, arr_to_call);
				} else {
					fn.apply(this, arr_to_call);
				}
			} else {}
		}
		if (arr_functions_params_pairs[c]) {
			if (delay) {
				setTimeout(main, delay);
			} else {
				main();
			}
		}
	}
	if (arr_functions_params_pairs.length > 0) {
		while ((c < l) && (num_currently_executing < num_parallel)) {
			if (delay) {
				process(delay * c);
			} else {
				process();
			}
		}
	} else {
		if (callback) {}
	}
});
let multi = call_multiple_callback_functions;
let call_multi = call_multiple_callback_functions;
let Fns = function (arr) {
	let fns = arr || [];
	fns.go = function (parallel, delay, callback) {
		let a = arguments;
		let al = a.length;
		if (al == 1) {
			call_multi(fns, a[0]);
		}
		if (al == 2) {
			call_multi(parallel, fns, delay);
		}
		if (al == 3) {
			call_multi(parallel, delay, fns, callback);
		}
	}
	return fns;
}
let native_constructor_tof = function (value) {
	if (value === String) {
		return 'String';
	}
	if (value === Number) {
		return 'Number';
	}
	if (value === Boolean) {
		return 'Boolean';
	}
	if (value === Array) {
		return 'Array';
	}
	if (value === Object) {
		return 'Object';
	}
}
let sig_match = function (sig1, sig2) {
	let sig1_inner = sig1.substr(1, sig1.length - 2);
	let sig2_inner = sig2.substr(1, sig2.length - 2);
	if (sig1_inner.indexOf('[') > -1 || sig1_inner.indexOf(']') > -1 || sig2_inner.indexOf('[') > -1 || sig2_inner.indexOf(']') > -1) {
		throw 'sig_match only supports flat signatures.';
	}
	let sig1_parts = sig1_inner.split(',');
	let sig2_parts = sig2_inner.split(',');
	let res = true;
	if (sig1_parts.length == sig2_parts.length) {
		let c = 0,
			l = sig1_parts.length,
			i1, i2;
		while (res && c < l) {
			i1 = sig1_parts[c];
			i2 = sig2_parts[c];
			if (i1 === i2) {} else {
				if (i1 !== '?') {
					res = false;
				}
			}
			c++;
		}
		return res;
	} else {
		return false;
	}
}
let remove_sig_from_arr_shell = function (sig) {
	if (sig[0] == '[' && sig[sig.length - 1] == ']') {
		return sig.substring(1, sig.length - 1);
	}
	return sig;
};
let str_arr_mapify = function (fn) {
	let res = fp(function (a, sig) {
		if (a.l == 1) {
			if (sig == '[s]') {
				let s_pn = a[0].split(' ');
				if (s_pn.length > 1) {
					return res.call(this, s_pn);
				} else {
					return fn.call(this, a[0]);
				}
			}
			if (tof(a[0]) == 'array') {
				let res2 = {},
					that = this;
				each(a[0], function (v, i) {
					res2[v] = fn.call(that, v);
				});
				return res2;
			}
		}
	});
	return res;
};
let to_arr_strip_keys = (obj) => {
	let res = [];
	each(obj, v => {
		res.push(v);
	});
	return res;
}
let arr_objs_to_arr_keys_values_table = (arr_objs) => {
	let keys = Object.keys(arr_objs[0]);
	let arr_items = [],
		arr_values;
	each(arr_objs, (item) => {
		arr_items.push(to_arr_strip_keys(item));
	});
	return [keys, arr_items];
}
let set_arr_tree_value = (arr_tree, arr_path, value) => {
	let item_current = arr_tree;
	let last_item_current, last_path_item;
	each(arr_path, (path_item) => {
		last_item_current = item_current;
		item_current = item_current[path_item];
		last_path_item = path_item;
	});
	last_item_current[last_path_item] = value;
}
let get_arr_tree_value = (arr_tree, arr_path) => {
	let item_current = arr_tree;
	each(arr_path, (path_item) => {
		item_current = item_current[path_item];
	});
	return item_current;
}
let deep_arr_iterate = (arr, path = [], callback) => {
	if (arguments.length === 2) {
		callback = path;
		path = [];
	}
	each(arr, (item, i) => {
		let c_path = clone(path);
		c_path.push(i);
		let t = tof(item);
		if (t === 'array') {
			deep_arr_iterate(item, c_path, callback);
		} else {
			callback(c_path, item);
		}
	})
}
let prom = (fn) => {
	let fn_res = function () {
		const a = arguments;
		const t_a_last = typeof a[a.length - 1];
		if (t_a_last === 'function') {
			fn.apply(this, a);
		} else {
			return new Promise((resolve, reject) => {
				[].push.call(a, (err, res) => {
					if (err) {
						reject(err);
					} else {
						resolve(res);
					}
				});
				fn.apply(this, a);
			})
		}
	}
	return fn_res;
}
const vectorify = n_fn => {
	let fn_res = fp(function (a, sig) {
		if (a.l > 2) {
			throw 'stop - need to check.'
			let res = a[0];
			for (let c = 1, l = a.l; c < l; c++) {
				res = fn_res(res, a[c]);
			}
			return res;
		} else {
			if (sig === '[n,n]') {
				return n_fn(a[0], a[1]);
			} else {
				const ats = atof(a);
				if (ats[0] === 'array') {
					if (ats[1] === 'number') {
						const res = [],
							n = a[1],
							l = a[0].length
						let c;
						for (c = 0; c < l; c++) {
							res.push(fn_res(a[0][c], n));
						}
						return res;
					} else if (ats[1] === 'array') {
						if (ats[0].length !== ats[1].length) {
							throw 'vector array lengths mismatch';
						} else {
							const l = a[0].length, res = new Array(l),
								arr2 = a[1];
							for (let c = 0; c < l; c++) {
								res[c] = fn_res(a[0][c], arr2[c]);
							}
							return res;
						}
					}
				}
			}
		};
	});
	return fn_res;
};
const n_add = (n1, n2) => n1 + n2,
	n_subtract = (n1, n2) => n1 - n2,
	n_multiply = (n1, n2) => n1 * n2,
	n_divide = (n1, n2) => n1 / n2;
const v_add = vectorify(n_add),
	v_subtract = vectorify(n_subtract),
	v_multiply = vectorify(n_multiply),
	v_divide = vectorify(n_divide);
const vector_magnitude = function (vector) {
	// may calculate magnitudes of larger dimension vectors too.
	// alert(tof(vector[0]));
	// alert(vector[0] ^ 2);
	var res = Math.sqrt((Math.pow(vector[0], 2)) + (Math.pow(vector[1], 2)));
	return res;
};
const distance_between_points = function (points) {
	var offset = v_subtract(points[1], points[0]);
	//console.log('offset ' + stringify(offset));
	return vector_magnitude(offset);
}
// ui8c?
//  ui8x???  for both?
//  
// Getting into some lower level types here.
//   Consider specifying endianness for numbers.
// Specify things from the basics.
//   Have the descriptions make sense in English and programatically.
//   Have it understand the descriptions of data types including signifiers and representations.
// srtype.add_representation(...)
//   .representations.add
// or 'rep' function.
//  rep(str_tsig_name, definition of representaion / instructions)
const map_tas_by_type = {
	'c': Uint8ClampedArray,
	'ui8': Uint8Array,
	'i16': Int16Array,
	'i32': Int32Array,
	'ui16': Uint16Array,
	'ui32': Uint32Array,
	'f32': Float32Array,
	'f64': Float64Array
}
const get_typed_array = function () {
	const a = arguments;
	let length, input_array;
	const type = a[0];
	if (is_array(a[1])) {
		input_array = a[1];
	} else {
		length = a[1];
	}
	const ctr = map_tas_by_type[type];
	if (ctr) {
		if (input_array) {
			return new ctr(input_array);
		} else if (length) {
			return new ctr(length);
		}
	}
}

// Grammar class may be a bit tricky / complex.
//   Maybe it will help because it can be used to define objects easily???
//   Maybe need to get into much more detail??? Maybe a quick and efficient piece of grammar code could work here.

class Grammar {
	constructor(spec) {
		const eg_spec = {
			name: 'User Auth Grammar'
		}
		const {
			name
		} = spec;
		this.name = name;
		const eg_indexing = () => {
			let map_sing_plur = {};
			let map_plur_sing = {};
			let map_sing_def = {};
			let map_sig_sing = {};
			let map_sig0_sing = {};
			let map_sig1_sing = {};
			let map_sig2_sing = {};
		}
		this.maps = {
			sing_plur: {},
			plur_sing: {},
			sing_def: {},
			deep_sig_sing: {},
			obj_sig_sing: {},
			sig_levels_sing: {}
		}
		this.load_grammar(spec.def);
	}
	load_grammar(grammar_def) {
		const {
			sing_plur,
			plur_sing,
			sing_def,
			sig_levels_sing,
			deep_sig_sing,
			obj_sig_sing
		} = this.maps;
		const resolve_def = (def) => {
			const td = tf(def);
			if (td === 'a') {
				const res = [];
				each(def, def_item => {
					res.push(resolve_def(def_item));
				});
				return res;
			} else if (td === 's') {
				if (def === 'string') {
					return 'string';
				} else if (def === 'number') {
					return 'number';
				} else if (def === 'boolean') {
					return 'boolean';
				} else {
					const found_sing_def = sing_def[def];
					return found_sing_def;
				}
			} else if (td === 'n') {
				console.trace();
				throw 'NYI';
			} else if (td === 'b') {
				console.trace();
				throw 'NYI';
			}
		}
		const resolved_def_to_sig = (resolved_def, level = 0) => {
			const trd = tf(resolved_def);
			if (trd === 's') {
				if (resolved_def === 'string') {
					return 's'
				} else if (resolved_def === 'number') {
					return 'n'
				} else if (resolved_def === 'boolean') {
					return 'b'
				}
			} else if (trd === 'a') {
				let res = '';
				if (level === 0) {} else {
					res = res + '[';
				}
				each(resolved_def, (item, c) => {
					if (c > 0) {
						res = res + ',';
					}
					res = res + resolved_def_to_sig(item, level + 1);
				});
				if (level === 0) {} else {
					res = res + ']';
				}
				return res;
			} else {
				console.trace();
				throw 'NYI';
			}
			return res;
		}
		each(grammar_def, (def1, sing_word) => {
			const {
				def,
				plural
			} = def1;
			sing_def[sing_word] = def;
			sing_plur[sing_word] = plural;
			plur_sing[plural] = sing_word;
			const tdef = tf(def);
			const resolved_def = resolve_def(def);
			const resolved_def_sig = resolved_def_to_sig(resolved_def);
			deep_sig_sing[resolved_def_sig] = deep_sig_sing[resolved_def_sig] || [];
			deep_sig_sing[resolved_def_sig].push(sing_word);
			let def_is_all_custom_types = true;
			each(def, (def_item, c, stop) => {
				const tdi = tf(def_item);
				if (tdi === 's') {
					if (sing_def[def_item]) {} else {
						def_is_all_custom_types = false;
						stop();
					}
				} else {
					def_is_all_custom_types = false;
					stop();
				}
			});
			let obj_sig;
			if (def_is_all_custom_types) {
				obj_sig = '{';
				each(def, (def_item, c, stop) => {
					if (c > 0) {
						obj_sig = obj_sig + ',';
					}
					const resolved = resolve_def(def_item);
					const abr_resolved = resolved_def_to_sig(resolved);
					obj_sig = obj_sig + '"' + def_item + '":'
					obj_sig = obj_sig + abr_resolved;
				});
				obj_sig = obj_sig + '}';
			}
			if (obj_sig) {
				obj_sig_sing[obj_sig] = obj_sig_sing[obj_sig] || [];
				obj_sig_sing[obj_sig].push(sing_word);
			}
		})
	}
	tof(item) {
		const {
			sing_plur,
			plur_sing,
			sing_def,
			sig_levels_sing,
			deep_sig_sing,
			obj_sig_sing
		} = this.maps;
		const titem = tf(item);
		console.log('titem', titem);
		if (titem === 'a') {
			let all_arr_items_type;
			each(item, (subitem, c, stop) => {
				const subitem_type = this.tof(subitem);
				console.log('subitem_type', subitem_type);
				if (c === 0) {
					all_arr_items_type = subitem_type;
				} else {
					if (all_arr_items_type === subitem_type) {} else {
						all_arr_items_type = null;
						stop();
					}
				}
			});
			if (all_arr_items_type) {
				console.log('has all_arr_items_type', all_arr_items_type);
				if (!map_native_types[all_arr_items_type]) {
					const res = sing_plur[all_arr_items_type];
					return res;
				}
			} else {
				console.log('no all_arr_items_type');
			}
		} else {
			return tof(item);
		}
		const item_deep_sig = deep_sig(item);
		console.log('Grammar tof() item_deep_sig', item_deep_sig);
		let arr_sing;
		if (titem === 'a') {
			const unenclosed_sig = item_deep_sig.substring(1, item_deep_sig.length - 1);
			console.log('unenclosed_sig', unenclosed_sig);
			arr_sing = deep_sig_sing[unenclosed_sig];
		} else {
			arr_sing = deep_sig_sing[item_deep_sig];
		}
		if (arr_sing) {
			if (arr_sing.length === 1) {
				return arr_sing[0];
			} else {
				console.trace();
				throw 'NYI';
			}
		}
	}
	sig(item, max_depth = -1, depth = 0) {
		const {
			sing_plur,
			plur_sing,
			sing_def,
			sig_levels_sing,
			deep_sig_sing,
			obj_sig_sing
		} = this.maps;
		const extended_sig = item => {
			const ti = tf(item);
			let res = '';
			let same_grammar_type;
			const record_subitem_sigs = item => {
				same_grammar_type = undefined;
				let same_sig = undefined;
				each(item, (subitem, c) => {
					if (c > 0) {
						res = res + ',';
					}
					const sig_subitem = this.sig(subitem, max_depth, depth + 1);
					if (same_sig === undefined) {
						same_sig = sig_subitem;
					} else {
						if (sig_subitem !== same_sig) {
							same_sig = false;
							same_grammar_type = false;
						}
					}
					if (same_sig) {
						if (sing_def[sig_subitem]) {
							if (same_grammar_type === undefined) {
								same_grammar_type = sig_subitem;
							} else {
								if (same_grammar_type === sig_subitem) {} else {
									same_grammar_type = false;
								}
							}
						} else {}
					}
					res = res + sig_subitem;
				});
			}
			if (ti === 'A') {
				record_subitem_sigs(item);
				return res;
			} else if (ti === 'a') {
				record_subitem_sigs(item);
				if (same_grammar_type) {
					const plur_name = sing_plur[same_grammar_type];
					return plur_name;
				} else {
					const found_obj_type = obj_sig_sing[res];
					const found_deep_sig_type = deep_sig_sing[res];
					let found_type_sing;
					if (found_deep_sig_type) {
						if (found_deep_sig_type.length === 1) {
							found_type_sing = found_deep_sig_type[0];
						}
					}
					if (found_type_sing) {
						return found_type_sing;
					} else {
						const enclosed_res = '[' + res + ']';
						return enclosed_res;
					}
				}
			} else if (ti === 'o') {
				if (max_depth === -1 || depth <= max_depth) {
					res = res + '{';
					let first = true;
					each(item, (value, key) => {
						const vsig = this.sig(value, max_depth, depth + 1);
						if (!first) {
							res = res + ',';
						} else {
							first = false;
						}
						res = res + '"' + key + '":' + vsig;
					});
					res = res + '}';
					return res;
				} else {
					return 'o';
				}
			} else if (ti === 's' || ti === 'n' || ti === 'b') {
				return ti;
			} else {
				return ti;
			}
		}
		return extended_sig(item);
	}
	single_forms_sig(item) {
		const {
			sing_plur,
			plur_sing,
			sing_def,
			sig_levels_sing,
			deep_sig_sing,
			obj_sig_sing
		} = this.maps;
		let sig = this.sig(item);
		let s_sig = sig.split(',');
		const arr_res = [];
		each(s_sig, (sig_item, c) => {
			const sing = plur_sing[sig_item] || sig_item;
			arr_res.push(sing);
		});
		const res = arr_res.join(',');
		return res;
	}
}
class Evented_Class {
	'constructor'() {
		Object.defineProperty(this, '_bound_events', {
			value: {}
		});
	}
	'raise_event'() {
		let a = Array.prototype.slice.call(arguments),
			sig = get_a_sig(a);
		a.l = a.length;
		let target = this;
		let c, l, res;
		if (sig === '[s]') {
			let target = this;
			let event_name = a[0];
			let bgh = this._bound_general_handler;
			let be = this._bound_events;
			res = [];
			if (bgh) {
				for (c = 0, l = bgh.length; c < l; c++) {
					res.push(bgh[c].call(target, event_name));
				}
			}
			if (be) {
				let bei = be[event_name];
				if (tof(bei) == 'array') {
					for (c = 0, l = bei.length; c < l; c++) {
						res.push(bei[c].call(target));
					}
					return res;
				}
			}
		}
		if (sig === '[s,a]') {
			let be = this._bound_events;
			let bgh = this._bound_general_handler;
			let event_name = a[0];
			res = [];
			if (bgh) {
				for (c = 0, l = bgh.length; c < l; c++) {
					res.push(bgh[c].call(target, event_name, a[1]));
				}
			}
			if (be) {
				let bei = be[event_name];
				if (tof(bei) === 'array') {
					for (c = 0, l = bei.length; c < l; c++) {
						res.push(bei[c].call(target, a[1]));
					}
				}
			}
		}
		if (sig === '[s,b]' || sig === '[s,s]' || sig === '[s,n]' || sig === '[s,B]' || sig === '[s,O]' || sig === '[s,e]') {
			let be = this._bound_events;
			let bgh = this._bound_general_handler;
			let event_name = a[0];
			res = [];
			if (bgh) {
				for (c = 0, l = bgh.length; c < l; c++) {
					res.push(bgh[c].call(target, event_name, a[1]));
				}
			}
			if (be) {
				let bei = be[event_name];
				if (tof(bei) === 'array') {
					for (c = 0, l = bei.length; c < l; c++) {
						res.push(bei[c].call(target, a[1]));
					}
				}
			}
		}
		if (sig === '[s,o]' || sig === '[s,?]') {
			let be = this._bound_events;
			let bgh = this._bound_general_handler;
			let event_name = a[0];
			res = [];
			if (bgh) {
				for (c = 0, l = bgh.length; c < l; c++) {
					res.push(bgh[c].call(target, event_name, a[1]));
				}
			}
			if (be) {
				let bei = be[event_name];
				if (tof(bei) === 'array') {
					for (c = 0, l = bei.length; c < l; c++) {
						res.push(bei[c].call(target, a[1]));
					}
				}
			}
		} else {
			if (a.l > 2) {
				let event_name = a[0];
				let additional_args = [];
				let bgh_args = [event_name];
				for (c = 1, l = a.l; c < l; c++) {
					additional_args.push(a[c]);
					bgh_args.push(a[c]);
				}
				let be = this._bound_events;
				let bgh = this._bound_general_handler;
				res = [];
				if (bgh) {
					for (c = 0, l = bgh.length; c < l; c++) {
						res.push(bgh[c].apply(target, bgh_args));
					}
				}
				if (be) {
					let bei = be[event_name];
					if (tof(bei) == 'array') {
						if (bei.length > 0) {
							for (c = 0, l = bei.length; c < l; c++) {
								if (bei[c]) res.push(bei[c].apply(target, additional_args));
							}
							return res;
						} else {
							return res;
						}
					}
				}
			} else {}
		}
		return res;
	}
	'add_event_listener'() {
		const {
			event_events
		} = this;
		let a = Array.prototype.slice.call(arguments),
			sig = get_a_sig(a);
		if (sig === '[f]') {
			this._bound_general_handler = this._bound_general_handler || [];
			if (is_array(this._bound_general_handler)) {
				this._bound_general_handler.push(a[0]);
			};
		}
		if (sig === '[s,f]') {
			let event_name = a[0],
				fn_listener = a[1];
			if (!this._bound_events[event_name]) this._bound_events[event_name] = [];
			let bei = this._bound_events[event_name];
			if (is_array(bei)) {
				bei.push(fn_listener);
				if (event_events) {
					this.raise('add-event-listener', {
						'name': event_name
					})
				}
			} else {
				console.trace();
				throw 'Expected: array';
			}
		}
		return this;
	}
	'remove_event_listener'(event_name, fn_listener) {
		const {
			event_events
		} = this;
		if (this._bound_events) {
			let bei = this._bound_events[event_name] || [];
			if (is_array(bei)) {
				let c = 0,
					l = bei.length,
					found = false;
				while (!found && c < l) {
					if (bei[c] === fn_listener) {
						found = true;
					} else {
						c++;
					}
				}
				if (found) {
					bei.splice(c, 1);
					if (event_events) {
						this.raise('remove-event-listener', {
							'name': event_name
						});
					}
				}
			} else {
				console.trace();
				throw 'Expected: array';
			}
		}
		return this;
	}
	get bound_named_event_counts() {
		const res = {};
		if (this._bound_events) {
			const keys = Object.keys(this._bound_events);
			each(keys, key => {
				res[key] = this._bound_events[key].length;
			})
		}
		return res;
	}
	'one'(event_name, fn_handler) {
		let inner_handler = function (e) {
			fn_handler.call(this, e);
			this.off(event_name, inner_handler);
		};
		this.on(event_name, inner_handler);
	}
	'changes'(obj_changes) {
		if (!this.map_changes) {
			this.map_changes = {};
		}
		each(obj_changes, (handler, name) => {
			this.map_changes[name] = this.map_changes[name] || [];
			this.map_changes[name].push(handler);
		})
		if (!this._using_changes) {
			this._using_changes = true;
			this.on('change', e_change => {
				const {
					name,
					value
				} = e_change;
				if (this.map_changes[name]) {
					each(this.map_changes[name], h_change => {
						h_change(value);
					})
				}
			})
		}
	}
};
const p = Evented_Class.prototype;
p.raise = p.raise_event;
p.trigger = p.raise_event;
p.subscribe = p.add_event_listener;
p.on = p.add_event_listener;
p.off = p.remove_event_listener;
const eventify = obj => {
	const bound_events = {};
	const add_event_listener = (name, handler) => {
		if (handler === undefined && typeof name === 'function') {
			handler = name;
			name = '';
		}
		if (!bound_events[name]) bound_events[name] = [];
		bound_events[name].push(handler);
	}
	const remove_event_listener = (name, handler) => {
		if (bound_events[name]) {
			const i = bound_events[name].indexOf(handler);
			if (i > -1) {
				bound_events[name].splice(i, 1);
			}
		}
	}
	const raise_event = (name, optional_param) => {
		const arr_named_events = bound_events[name];
		if (arr_named_events !== undefined) {
			if (optional_param !== undefined) {
				const l = arr_named_events.length;
				for (let c = 0; c < l; c++) {
					arr_named_events[c].call(obj, optional_param);
				}
			} else {
				const l = arr_named_events.length;
				for (let c = 0; c < l; c++) {
					arr_named_events[c].call(obj);
				}
			}
		}
	}
	obj.on = obj.add_event_listener = add_event_listener;
	obj.off = obj.remove_event_listener = remove_event_listener;
	obj.raise = obj.raise_event = raise_event;
	return obj;
}

// Assign_From_Spec_Class


// Assign_From_Spec_Evented_Class




class Publisher extends Evented_Class {
	constructor(spec = {}) {
		super({});
		this.one('ready', () => {
			this.is_ready = true;
		})
	}
	get when_ready () {
		return new Promise((solve, jettison) => {
			if (this.is_ready === true) {
				solve();
			} else {
				this.one('ready', () => {
					solve();
				})
			}
		})
	}
}

const prop = (...a) => {

	// Using (predefined?) data types here?

	// ...args?
	let s = get_a_sig(a);
	const raise_change_events = true;
	const ifn = item => typeof item === "function";

	if (s === "[a]") {
		each(a[0], item_params => {
			prop.apply(this, item_params);
		});
	} else {
		if (a.length === 2) {
			if (ia(a[1])) {
				const target = a[0];
				each(a[1], item => {
					if (ia(item)) {
						throw "NYI 468732";
					} else {
						prop(target, item);
					}
				});
			} else {
				const ta1 = tof(a[1]);
				if (ta1 === "string") {
					[obj, prop_name] = a;
				} else {
					throw "NYI 468732b";
				}
			}
		} else if (a.length > 2) {
			if (is_array(a[0])) {
				// the rest of the properties applied to the array of items.
				throw "stop";
				let objs = a.shift();
				each(objs, obj => {
					prop.apply(this, [obj].concat(item_params)); // bug
				});
			} else {
				let obj, prop_name, default_value, fn_onchange, fn_transform, fn_on_ready, options;
				const load_options = options => {
					prop_name = prop_name || options.name || options.prop_name;
					fn_onchange =
						options.fn_onchange || options.onchange || options.change;
					fn_transform =
						options.fn_transform || options.ontransform || options.transform;
					fn_on_ready = options.ready || options.on_ready;
					default_value = default_value || options.default_value || options.default;
				};
				if (a.length === 2) {
					[obj, options] = a;
					load_options(options);
				} else if (a.length === 3) {
					if (ifn(a[2])) {
						[obj, prop_name, fn_onchange] = a;
					} else {
						if (a[2].change || a[2].ready) {
							load_options(a[2]);

							[obj, prop_name] = a;
						} else {
							[obj, prop_name, default_value] = a;
						}
					}
					//[obj, prop_name, default_value, fn_transform] = a;
				} else if (a.length === 4) {
					if (ifn(a[2]) && ifn(a[3])) {
						[obj, prop_name, fn_transform, fn_onchange] = a;
					} else if (ifn(a[3])) {
						[obj, prop_name, default_value, fn_onchange] = a;
					} else {
						[obj, prop_name, default_value, options] = a;
						load_options(options);
					}
				} else if (a.length === 5) {
					[obj, prop_name, default_value, fn_transform, fn_onchange] = a;
				}
				let _prop_value;

				if (typeof default_value !== 'undefined') _prop_value = default_value;
				// And a silent set function that does not raise the change event.
				const _silent_set = value => {
					let _value;
					if (fn_transform) {
						_value = fn_transform(value);
					} else {
						_value = value;
					}
					_prop_value = _value;
				}
				const _set = value => {
					let _value;
					if (fn_transform) {
						_value = fn_transform(value);
					} else {
						_value = value;
					}
					let old = _prop_value;
					_prop_value = _value;
					if (fn_onchange) {
						fn_onchange({
							old: old,
							value: _prop_value
						});
					}
					if (obj.raise && raise_change_events) {
						obj.raise("change", {
							name: prop_name,
							old: old,
							value: _prop_value
						});
					}
				};
				if (is_defined(default_value)) {
					_prop_value = default_value;
				}
				const t_prop_name = tf(prop_name);
				if (t_prop_name === 's') {

					Object.defineProperty(obj, prop_name, {
						get() {
							return _prop_value;
						},
						set(value) {
							_set(value);
						}
					});

				} else if (t_prop_name === 'a') {
					const l = prop_name.length;
					//console.log('prop_name', prop_name);
					let item_prop_name;
					for (let c = 0; c < l; c++) {
						item_prop_name = prop_name[c];
						//console.log('item_prop_name', item_prop_name);
						Object.defineProperty(obj, item_prop_name, {
							get() {
								return _prop_value;
							},
							set(value) {
								_set(value);
							}
						});
					}
				} else {
					throw 'Unexpected name type: ' + t_prop_name;
				}
				if (fn_on_ready) {
					fn_on_ready({
						silent_set: _silent_set
					})
				}
			}
		}
	}
};



class Data_Type {

}

class Functional_Data_Type extends Data_Type {
    constructor(spec) {

		/*
		named_property_access: true,
		property_names: ['latitude', 'longitude'],
		// And the property types as well being the same in this case?
		abbreviated_property_names: ['lat', 'long'],
		numbered_property_access: true, // Maybe that's good enough to make it like an array when there are 2 properties.

		*/
        
        // fns for: validate as exact type...?
        // convert from whatever it is to that exact type (if possible)
        //   string and binary conversions.
        //   eg a convert_load type operation.

        // it's super / parent type.
        super(spec);

        if (spec.supertype) this.supertype = spec.supertype;
        if (spec.name) this.name = spec.name;
        if (spec.abbreviated_name) this.abbreviated_name = spec.abbreviated_name;
		if (spec.named_property_access) this.named_property_access = spec.named_property_access;
		if (spec.numbered_property_access) this.numbered_property_access = spec.numbered_property_access;
		if (spec.property_names) this.property_names = spec.property_names;
		if (spec.property_data_types) this.property_data_types = spec.property_data_types;
		if (spec.wrap_properties) this.wrap_properties = spec.wrap_properties;
		if (spec.wrap_value_inner_values) this.wrap_value_inner_values = spec.wrap_value_inner_values;
		if (spec.value_js_type) this.value_js_type = spec.value_js_type;
		// value_js_type

		// wrap_value as well????
		//   Though the value kind-of is itself.
		//    maybe .inner_js_value is much clearer here?
		// wrap_value_inner_values



		if (spec.abbreviated_property_names) this.abbreviated_property_names = spec.abbreviated_property_names;
        if (spec.validate) this.validate = spec.validate;
        if (spec.validate_explain) this.validate_explain = spec.validate_explain;
		if (spec.parse_string) this.parse_string = spec.parse_string;
		if (spec.parse) this.parse = spec.parse;

		// But also want it to be able to accept undefined value (usually???)




        // and abbreviated name
        // spec.validate (needs to be perfect...)

        // spec.load_from(...?)
        // spec.poly_load??

        // spec.input transformers???
        //   transform from other identified types...?

        // For the moment, we don't want too many and too complex functions.

    }
}

//lang.Data_Type = Data_Type;
//lang.Functional_Data_Type = Functional_Data_Type;



// And let's define some....

// And a correct value...?
//   Eg if a number is not valid because it has too many decimal points, it could be corrected.
//     Or even an int that's too large, outside a range, corrected to fit in that range.

// So making a Data_Value stick to using these Data_Types could be helpful.

// For the moment this is really simple and should work fine for some things.

// Allow undefined????
//   Or better to have that on a different level.
//     Maybe does make sense as an option here.

//     Or consider it and do it later.


Functional_Data_Type.number = new Functional_Data_Type({
    name: 'number',
    abbreviated_name: 'n',
    validate: x => {
        return !isNaN(x);
    },
	parse_string(str) {
		const p = parseFloat(str);
		// then is it a number???

		// then is its string the same....?
		if (p + '' === str) {
			const parsed_is_valid = this.validate(p);
			if (parsed_is_valid) {
				return p;
			}
		}


	}
});

Functional_Data_Type.integer = new Functional_Data_Type({
    name: 'integer',
    abbreviated_name: 'int',
    validate: x => {
        return Number.isInteger(x);
    },
    parse_string(str) {
        const p = parseInt(str, 10);
        if (!isNaN(p) && p.toString() === str) {
            return p;
        }
        return undefined;
    }
});

// Need fdts for things like a [lat, long] array.
//   Maybe see about making it (easily) from composite data types.
//     Pair(Lat, Long) or similar
//     Maybe want it defined in a few lines of string grammar if it's easy.
//       Would make for a simple API - but would require parsing a custom language.








// Would be worth getting into creating conventions and idioms for higher level code.
//   Though first getting data type systems working right would help.
//     Making them easy to use.

const field = (...a) => {

	// Will also want to set data types of fields....

	// Uses obj._
	//   Seems quite simple, powerful, flexible.
	//     However, would like a different way of doing it too, could use a local variable defined within the 'field' function.

	// Want to incorporate data types, maybe grammar too.

	// Could use fp for this as well????
	//   See about really concise function definitions.

	//  Also want to see about some benchmarks too.
	//    Eg rendering a large page server side 10 times.

	const raise_change_events = true;

	const ifn = item => typeof item === "function";

	let s = get_a_sig(a);
	if (s === "[a]") {
		// prop????
		each(a[0], item_params => {
			prop.apply(this, item_params);
		});
	} else {
		if (a.length > 1) {
			if (is_array(a[0])) {

				throw 'stop - need to fix';
				// the rest of the properties applied to the array of items.

				// But field.apply here...???
				let objs = a.shift();
				each(objs, obj => {
					field.apply(this, [obj].concat(item_params));
				});
			} else {
				// Maybe will have a Data_Type....

				let obj, prop_name, data_type, default_value, fn_transform;
				//let raise_change_events = opts.raise_change_events;
				if (a.length === 2) {
					[obj, prop_name] = a;
				} else if (a.length === 3) {

					// And also check a[2] for being a Data_Type.

					if (a[2] instanceof Data_Type) {
						[obj, prop_name, data_type, default_value] = a;
					} else {
						if (ifn(a[2])) {
							[obj, prop_name, fn_transform] = a;
						} else {
							[obj, prop_name, default_value] = a;
						}
					}


					
				} else if (a.length === 4) {

					// field(this, 'value', this.data_type, spec.value);

					if (a[2] instanceof Data_Type) {
						[obj, prop_name, data_type, default_value] = a;
					} else {
						[obj, prop_name, default_value, fn_transform] = a;
					}

					
				}

				if (obj !== undefined) {

					// Setting with a data_model or data_value ????


					Object.defineProperty(obj, prop_name, {
						get() {
							if (is_defined(obj._)) {
								return obj._[prop_name];
							} else {
								return undefined;
							}
							//return _prop_value;
						},
						set(value) {
							//console.log('setting prop: ' + prop_name);

							// Get an immutable copy of it???

							let old = (obj._ = obj._ || {})[prop_name];

							// Want better tof that can deal with Data_Model, Data_Value
							// Maybe Data_String, Data_Array, Data_Object, Data_Number???

							// Could make some more specifically typed ones....






							// value must be an array of length 2.

							// And what's the typeof value???



							// Upgrade the field set procedure.






							if (old !== value) {

								let is_valid = true;
								if (data_type) {

									const t_value = typeof value;

									is_valid = data_type.validate(value);

									// if not valid directly, can we parse it from a string???

									if (t_value === 'string') {
										const parsed_value = data_type.parse_string(value);
										is_valid = data_type.validate(parsed_value);

										if (is_valid) value = parsed_value;
									}

									console.log('t_value', t_value);

									// but also some type of stringifying the value....





								}
								if (is_valid) {

									let _value;
									if (fn_transform) {
										//try {
										_value = fn_transform(value);
										//} catch (err) {
										//    throw err;
										//}
									} else {
	
	
	
										_value = value;
									}
									obj._[prop_name] = _value;
									if (raise_change_events) {
										obj.raise("change", {
											name: prop_name,
											old: old,
											value: _value
										});
									}
								}
							} else {
								//console.log('old === value');
								//console.log('old', old);
								//console.log('value', value);
							}
						}
					});
					if (is_defined(default_value)) {
						let is_valid = true;
						if (data_type) {
							is_valid = data_type.validate(default_value);
						}
						if (is_valid) {
							(obj._ = obj._ || {})[prop_name] = default_value;
						}
					}
				} else {
					throw 'stop';
				}
			}
		}
	}
};



// Probably need an 'equals' function.
//   Would make use of .equals and .hash functions / properties when available.

// Though Data_Value.toString and toJSON may be most useful sooner...

// lang-tools should have the equals function that supports Data_Value (maybe Data_Model in general).

const lang_mini_props = {
	each,
	is_array,
	is_dom_node,
	is_ctrl,
	clone,
	get_truth_map_from_arr,
	tm: get_truth_map_from_arr,
	get_arr_from_truth_map,
	arr_trim_undefined,
	get_map_from_arr,
	arr_like_to_arr,
	tof,
	atof,
	tf,
	load_type,
	is_defined,
	def: is_defined,
	Grammar,
	stringify,
	functional_polymorphism,
	fp,
	mfp,
	arrayify,
	mapify,
	str_arr_mapify,
	get_a_sig,
	deep_sig,
	get_item_sig,
	set_vals,
	truth,
	trim_sig_brackets,
	ll_set,
	ll_get,
	iterate_ancestor_classes,
	is_arr_of_t,
	is_arr_of_arrs,
	is_arr_of_strs,
	input_processors,
	output_processors,
	call_multiple_callback_functions,
	call_multi,
	multi: call_multi,
	native_constructor_tof,
	Fns,
	sig_match,
	remove_sig_from_arr_shell,
	to_arr_strip_keys,
	arr_objs_to_arr_keys_values_table,
	set_arr_tree_value,
	get_arr_tree_value,
	deep_arr_iterate,
	prom,
	combinations,
	combos: combinations,
	Evented_Class,
	eventify,
	vectorify,
	v_add,
	v_subtract,
	v_multiply,
	v_divide,
	vector_magnitude,
	distance_between_points,
	get_typed_array,
	gta: get_typed_array,
	Publisher,
	field,
	prop,
	Data_Type,
	Functional_Data_Type
};

const lang_mini = new Evented_Class();
Object.assign(lang_mini, lang_mini_props);
lang_mini.note = (str_name, str_state, obj_properties) => {
	obj_properties = obj_properties || {};
	obj_properties.name = str_name;
	obj_properties.state = str_state;
	lang_mini.raise('note', obj_properties)
}
module.exports = lang_mini;

// Bring in grammar / compound types to this typedef type thing.
//   Types in the fields. 

// Detecting invalid view model states.
//   Validating according to the spec of the data basically.

// Defining data types and models with a gui....




if (require.main === module) {



	/*
	function test_evented_class(test_data) {
		const create_empty_test_res = () => {
		  return {
			passed: [],
			failed: []
		  };
		};
	  
		// Initialize res object with empty arrays
		const res = create_empty_test_res();
	  
		// Test each event in test_data
		for (let i = 0; i < test_data.length; i++) {
		  const { event_name, event_data } = test_data[i];
	  
		  // Test adding the event
		  const evented_class = new Evented_Class();
		  evented_class.add_event_listener(event_name, (data) => {
			if (data === event_data) {
			  res.passed.push(event_name);
			} else {
			  res.failed.push(event_name);
			}
		  });
	  
		  // Test raising the event
		  evented_class.raise_event(event_name, event_data);
		}
	  
		// Return test results
		return res;
	  }
	  */

	  const test_data = [
		{
			event_name: 'foo',
			event_data: 'hello'
		},
		{
			event_name: 'bar',
			event_data: 'world'
		},
		{
			event_name: 'baz',
			event_data: true
		}
	];
	
	const create_empty_test_res = () => ({
		passed: [],
		failed: []
	});

	  
	  function test_evented_class(test_data) {
		const res = create_empty_test_res();
	
		// Create a new instance of Evented_Class
		const evented_class = new Evented_Class();
	
		// Test each event in the test data
		test_data.forEach(test_event => {
			const event_name = test_event.event_name;
			const event_data = test_event.event_data;
	
			// Define a listener for the event
			const listener = data => {
				if (data === event_data) {
					// The event was raised with the expected data
					res.passed.push(event_name);
				} else {
					// The event was raised with the wrong data
					res.failed.push(event_name);
				}
			};
	
			// Add the listener to the evented class
			evented_class.on(event_name, listener);
	
			// Raise the event
			evented_class.raise_event(event_name, event_data);
		});
	
		return res;
	}
	


	const result = test_evented_class(test_data);

	// Print the results of the test
	console.log('Passed:', result.passed);
	console.log('Failed:', result.failed);


}
}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":3}],47:[function(require,module,exports){
const lang = require('./lang-mini');

const {each, tof} = lang;


// and lang types...
//  Will use a Type class.
//   Number_Type etc. String_Type perhaps.
//     and then restrictions. JSON_Type is a String_Type.



// Could have first implementation of types here even....
//   Maybe don't use classes for them?
//     Or do because they are so integrated into the language now.

// Representation_Type
//   eg represents a color (in specific way?) How it represents it...?
//     ?? represents a 24bit rgb color ??
//       why not? should be possible.


// Some / all of oext would be nice within lang-mini...?

// oext seems to work with types though, or would benefit from types.
//   No, oext does not have much for types, moving field and prop from oext here, need to get the data types working with Data_Object
//   and Data_Value. 





// Maybe move to lang-tools?
//   fp() may benefit from integration with this.



// What the type represents.
// What it signifies?

// But then how it's represented?


// Not really about storing the data in memory or transmitting it.
//   But saying it's 24 bit color is kind of about its representation.
//   Still that's what it's called.

// Type_Signifier seems better. Now it's called that.

// Wider signification than just JS.


// Type_Signifier_Component ????

// Type_Signifier perhaps. Signifier_Type???

class Type_Signifier {
    // Name
    constructor(spec = {}) {

        const name = spec.name;

        // And use fields / quicker way to define these?

        Object.defineProperty(this, 'name', {
            get() {
                return name;
            }
        });

        const parent = spec.parent;

        Object.defineProperty(this, 'parent', {
            get() {
                return parent;
            }
        });

        const map_reserved_property_names = {
            name: true,
            parent: true
        }

        const _ = {};

        each(spec, (value, name) => {
            if (map_reserved_property_names[name]) {

            } else {
                _[name] = value;
            }
        });



        // And other fields too....


    }
    extend(o_extension) {

        const o = {
            parent: this
        }
        Object.assign(o, o_extension);
        const res = new Type_Signifier(o_extension);
        return res;


    }
    //  Other options?
    //  Disambiguiation? Descriptive text?
    //    Or is naming them the main thing there?

    // Color representation
    //   And that is simple, does not go into internal representation.

}




// A representation for what is signified.
//   This way if the programmer gets stuck about 'the' representation to make, they can make a decent representation, make it default,
//     and move on for the moment.


// Can be multiple allowed representations for a type.
//   Binary data, JSON
//   Compressed, uncompressed, maybe encrypted too.


// Probably don't need subclasses for string or binary representations.
//  Make this able to deal with both.
//  String (kind of) is binary but likely uses UTF-8.

class Type_Representation {
    // Name
    //  Other options?
    //  Disambiguiation? Descriptive text?
    //    Or is naming them the main thing there?

    // Color representation
    //   And that is simple, does not go into internal representation.

    // This should be able to represent types and lang features not available to JS.
    //   Names may be optional? May be autogenerated and quite long?



    constructor(spec = {}) {

        // May be used on a lower level where the most suitable representation is selected.

        // Generally:
        //  string incl json
        //  binary

        // bridge the gap between numeric and binary.
        //   make this ta-friendly and aware.

        // represent components within a typed array? closely packed data structure?
        

        const name = spec.name;
        Object.defineProperty(this, 'name', {
            get() {
                return name;
            }
        });

        const parent = spec.parent;
        Object.defineProperty(this, 'parent', {
            get() {
                return parent;
            }
        });

        // Then the other fields?
        //  Could have named fields.
        //  Could have ordered fields?

        const _ = {};

        const map_reserved_property_names = {
            'name': true
        };

        //  Even the number of bits being in here...?

        each(spec, (value, name) => {
            if (map_reserved_property_names[name]) {

            } else {
                _[name] = value;

                // Could define the property here.
                //  Read only (for the moment)

                Object.defineProperty(this, name, {
                    get() {
                        return _[name];
                    },
                    enumerable: true
                });


            }
        });
        // Then a proxy to get other properties?
    }
    extend(o_extension) {

        const o = {
            parent: this
        }
        Object.assign(o, o_extension);
        const res = new Type_Representation(o_extension);
        return res;


    }

}

// Will spell out some things in a quite verbose vanilla-js way here.
//   Some higher level code will use types and other lang functionality to be less verbose and closer to English / the direct concepts.

// Joins together 1 signifier and multiple representations.
//   Name of item will be the signifier's name.

class Signifier_Representations_Type {
    constructor(spec = {}) {
        // 2 params in constructor? (signifier, arr_reps)???
        //  could check for that.

        if (spec.signifier && spec.representations) {

            let signifier, arr_representations;

            //if (spec.signifier) {
            if (spec.signifier instanceof Type_Signifier) {
                signifier = spec.signifier;
            } else {
                throw 'expected spec.signifier to be a Type_Signifier instance';
            }
            //}

            if (tof(spec.representations) === 'array') {
                let pass = true;
                each(spec.representations, (representation, idx, stop) => {
                    if (!(representation instanceof Type_Representation)) {
                        pass = false;
                        stop();
                    }
                })
                if (pass) {
                    arr_representations = spec.representations;
                } else {
                    throw 'Expected spec.representations to be an array of Type_Representation instances.';
                }
            }





        } else {
            throw 'Expected spec.signifier and spec.representations'
        }

        



    }
}






// And could be subclasses of signification types...???

// ui8 type signification?
//   OK to signify that type, could indeed be represented with different actual values.
//    such as as a string of decimal or hex digits.


// Will have some basic / core types within lang-mini.
//   Will not have a large amount of code.


// Thematic types perhaps....
//   seems like there could be overlap as well, eg image and document, text and document
//   color, date/time, image, video, text, document, font, number, integer, floating point, string
//     Type signifier could have theme property instead of or as well as name?
//       Then representation of one thing as another. Represent a color as a number.

// One advantage of putting in its own module is possible smaller file size.
//   Though could possibly use lang-mini functionality as a platform for signifier and representer types.
//   Type_Representer perhaps, not Type_Representation???
//     Representation is probably the more accurate / better reading word.




const st_color = new Type_Signifier({'name': 'color'});

// Signify an image. Signify a JPEG image. Etc.

// then make a new one that extends st_color
//   as in, a subtype.
const st_24bit_color = st_color.extend({'bits': 24});
// Other types of 3 component color?

//const st_24bit_rgb_color = st_24bit_color.extend({'components': ['red', 'green', 'blue']});
const st_24bit_rgb_color = st_24bit_color.extend({'components': ['red byte', 'green byte', 'blue byte']});
//  or it already knows that these are bytes, when its 3 components in 24 bits.

// st_24bit_rgb_color is only a signifier of 24 bit rgb color.
//  Then there can be an implementation of it.
//  Or a type (or class etc) could indicate it can handle it.

// Type representation index could help.
//   Query by name could return multiple items....
//     Could have a property for the default representation with the name being searched for.






// And have info about the properties by which it is represented?

const tr_string = new Type_Representation({'name': 'string'});
const tr_binary = new Type_Representation({'name': 'binary'}); // And could include number....
// Numbers maybe extend binary.

// And tr_ui8 even perhaps....




// represent it as a binary sequence.
//   Then could use more application specific tools like a Buffer or Typed Array.

// Or extend the string type representation?

// = tr_binary.extend();
// trep maybe. and tsig or tsign.

// Will make / finish some lower level components that interact with some specifically typed data.
//   May well be worth doing more under 'grammar', getting type signifiers and type representations into the system.
//     So far, types have been type representations. Now, they can be a signifier along with multiple representations.
// A 'tags' type system of properties could help. Make it easy to specify / set up types.

// Representation = Implementation (kind of)
//   Or an interface.

// Could use a Representation as an interface, in some cases.
//   Inner representations as well
//   Eg single color channel has a representation
//     Would have a color name.
//       Could even have a wavelength measurement for the color.

// color channel 8 bit
//   could use some language interpretation even. Some language processing could have the system 'understand' simple phrases describing
//   type representations.

// Actually using struct syntax for C++ or rust would be really good.
//   Rust structs don't require fixed length strings in definition.

// A struct being a Type_Representation, or Representational_Type.
//   Dates can and do operate on different calendars.
//     Same thing being signified, but with a different representation.
// Diffent ways of representing strings and text. Now emojis too, they are part of unicode, and they keep getting updated.

// Text characters are images that represent a letter or something else.
//   They are symbols.


















const rt_bin_24bit_rgb_color = new Type_Representation({
    // A binary type representation.
    'signifier': st_24bit_rgb_color,
    'bytes': [
        [0, 'red', 'ui8'],
        [1, 'green', 'ui8'],
        [2, 'blue', 'ui8']
    ]
});

// Maybe do some work on a concise format for defining these types.
// Maybe worth using or allowing the exact same syntax as C++ and/or rust for these stucts.
//  Possibly some kind of syntax import. An example of how the same type of information can have different representations.




// And an editor control could use a representation in terms of how it represents the data being edited to the user.

// Binary type representation
const rt_hex_24bit_rgb_color = new Type_Representation({
    // Likely some kind of string template.
    //  Or a function?
    //  Best to keep this function free here.
    //  Or maybe make a few quite standard ones.
    'signifier': st_24bit_rgb_color,

    // Or could just have the sequence / template literal even.

    'bytes': [
        [0, '#', 'char'],
        [1, 'hex(red)', 'string(2)'],
        [3, 'hex(green)', 'string(2)'],
        [5, 'hex(blue)', 'string(2)']
    ]
});

// Year could be negative.
const st_date = new Type_Signifier({'name': 'date', 'components': ['day uint', 'month uint', 'year int']});
// And datetime signification.

// Approximate date ie date +- x years.


// Just the date.



//  or don't have the component types here?

// String representation type.
//  String_Type_Representation

// Lots of different ways to represent a type.

// Or say that they are numeric strings as well....

// But a string char possibly takes more than 1 byte! Maybe not as defined here.
//  String of int?
//  Go into more details about how dates are represented?

// Could consider JPEG to be a representation of Image.
//   May want / need to think in terms of segments or blocks...
//    segment_name = 'block' even. So it at least knows the right technical term.
//   JPEG can have different versions, or subrepresentations.
//     Type representations can have a supertype. That can be used with JPEG and then their versions are subtypes.
//       A bit like the super-JPEG is a type representation of its own - except its got the details of the syntax.
//     Want to make the overall system flexible in terms of what it represesnts, a fairly simple base structure.


// Maybe make sections that define the representations just after the signifiers.
//   Could have a fair few basic things defined.

// Type Signifiers and Type Representations
//   Think it could become an interesting book / programming topic.
//   Could have implementations in a few languages too. Maybe suggestions for future languages and versions of them.

// Make it its own module even?
//   Could work better at a lower level.

// srtypes module perhaps, or just srtype.
// Coding with the distinction between signified and represented types could be really useful.
//   Be able to handle serialization and deserialization (or format changes in some cases) 'for free', that is once the definitions
//     have been made, the system will be able to convert between them (maybe requires some conversion functions to be written)
//   System will have decent default type conversions.

// Probably worth having set of 'standard' type definitions.
//   System needs to be flexible so that they can be amended.












const rt_string_date_uk_ddmmyy = new Type_Representation({
    'signifier': st_date,
    'bytes': [
        [0, '#', 'char'],
        [1, 'day', 'string(2)'],
        [3, '/', 'char'],
        [4, 'month', 'string(2)'],
        [6, '/', 'char'],
        [7, 'year', 'string(2)']
    ]
});

// Extra rules or restrictions? Defaults eg year 38 is 2038 etc...


// A types registry could help.
//  Registry of signified types
//  Registry of type representations.
//   Meaning 1 'type' in this system can be represented in multiple different ways.

// Then the infrastructure within control declaration...
//   Though likely will use the .model and .view mixins for this.
//   Views (or controls?) will be made so that the model is a specific representation of a signified type.
//     Or one a a few supported representations.
//     Eg a color palette working for monochrome (8bit color depth).
//       Or a color palette could allow selection of multiple colors.

// Color_Chooser perhaps being simpler?
//   Color_Palette seems like it should be able to deal with a bunch of different ways in which the data could be represented
//     either in the app as the user interacts with it, in app memory, in transmission, in storage.










// There could be quite a lot of these type representations.



// Can have plenty of ways of representing a date. Fewer ways of signifying one.


// To signify something is in some ways less than to represent it.
//   Signification is only about saying that it is there.

// Maybe have a nice UI app to set up the signifier / representer links.





// A moderate amount of data type representation info would help get JSGUI controls working nicely on the specific types
//   of data they are supposed to interact with.

// Ways of getting the data in and out of typed arrays
//   Typed array (or buffer?) access for these data types?

// Could make some nice GUI components (controls) for selecing / editing dates and colors.
//   Can do it in a way that avoids code repetition.
//   Make it so that the controls are able to represent the type on the screen.





 
// These types seem most useful for the types that the user interacts with and putting the type knowledge into the GUI.

// Type registry makes sense too.
//  jsgui.types perhaps / lang.types
//   An index of types? Collection of them?

// Also registry of controls that are set up for dealing with specific types?
//   Being able to identify and use variety of representations.

// May integrate this into image format work - or make this good so that image format work can use this as a platform.









// and then day, month, year components




// day, month year



// or 'hexdigit(2)' maybe.

// And the Control could conveniently show and allow editing of values using different representations.
//   Such as a hex representation, or hex representations for comonents.

// A Control could be aware of, and use both representations of a Data_Type.
//   Color Palette seems like the right place to use that more advanced and general purpose functionality.
//     Will work well for some imaging tools as well too.


// More functional composition of controls could be cool....
//   But let's make / improve the color palette.
//     Moving the data outside it could work too.
//     Consts directory. Or basis. Basics.



// Have a class / instance of one that tracks ie is a DB for the type representations and significations.











// Then put that within an array? 32 bit number used as 24 bit?


// Though it may be most/least significant in some cases.




// Then create a representation of 24 bit rgb color where it's the 3 components as bytes.
//   Could be deduced from what we have already. May be easy enough to get from the Type_Signifier to this.
//     However, will then have representations of the individual components too....
//     Perhaps represent the whole thing as a string. eg #RRGGBB color for HTML. Or as items in an array.
//       Even representing them as items within a typed array.


// Allowing multiple representations of the same things.
//   Representation sets - so we know which representations as (almost? totally?) interchangable.
//   Can choose different default representations depending on performance.

// Or implementation sets? Prefer representation here to describe how the types are represented rather than other connotations
//   such as code for operators.

//console.log('st_color', st_color);

lang.Type_Signifier = Type_Signifier;
lang.Type_Representation = Type_Representation;




// Let's make something a little simpler and focused on representing the types of data in Data_Model classes.
//   Control is such a class through inheritance, it extends Data_Object.

// nfdt new functional data type function....?







// The representation type is a way to represent something
//   What is being represented? That is all within a signifier type.

// Or Implementation_Type? As in that is concrete in terms of how it is represented.
// Representation_Implementation_Type???







module.exports = lang;
},{"./lang-mini":46}],48:[function(require,module,exports){
//const {
//    prop,
//    field
//} = require('obext');

var jsgui = require('../html-core/html-core');
const { prop, field, Control } = jsgui;

// Want to make modal windows with this.

// Different to the virtual frame. That could be used to cover a control too.
//  suspended frame suspended_frame

// Will also have overlays available too.
//  coverable works differently.


let coverable = (ctrl, opts) => {
    let select_toggle = false;

    // select only...
    let select_multi = false;
    if (!opts) {

    }

    if (opts) {

    }
    let ctrl_cover;

    // Respond to the covered property changing by adding or removing a cover control.
    ctrl.cover = (content) => {
        /// cover control will need to be absolutely positioned on top of this...
        //   or within this...

        ctrl_cover = new Control({
            context: ctrl.context,
            class: 'cover'
        });
        // then the cover has a background

        let ctrl_cover_bg = new Control({
            context: ctrl.context,
            class: 'background'
        });

        let ctrl_cover_fg = new Control({
            context: ctrl.context,
            class: 'foreground'
        });
        
        content.remove();
        ctrl_cover.add(ctrl_cover_bg);
        ctrl_cover.add(ctrl_cover_fg);
        ctrl_cover_fg.add(content);
        ctrl.add(ctrl_cover);

        // and return an uncover function.
        //  a reference to the cover would be easier
        return ctrl_cover;

    }

    ctrl.uncover = () => {
        ctrl_cover.remove();
        ctrl_cover = null;
    }


    //if (!old_selectable) {
    field(ctrl, 'covered');
    //field(ctrl, 'coverable');
    //field(ctrl, 'select_unique');

    //};
    /*
    if (true) {
        // but it won't be defined.
        if (old_coveravle !== undefined) {
            ctrl.coverable = old_coveravle;
        }
    }
    */
}

module.exports = coverable;
},{"../html-core/html-core":149}],49:[function(require,module,exports){
// Other notifications within the framework?

// Kind of seems like both model and view.
//  Can be deleted from view... and when that happens maybe it will get deleted from the model as well.


// Data_Object could be upgraded to be like this???
//  The Control is based on Data_Object anyway.
//   Kind of as though it is the model (and view) all in one.
// May be best to iterate to make these data models work...

// Making a simple API may be the best....
//  a validate function
//  a data_transform_in function
//   being able to accept different types of data.

// Representing a color or a date in a really simple way.
// ['red', 'ui8']
// ['day_of_month', 'num (1 to 31)']





let deletable = (ctrl) => {
    // Respond to touch events.

    // generally want a 'press' event too.
    //  Could be a click, or a touch press.

    // Could raise a press or click event.
    //  Press could cover click and touch.
    //  Click could specifically be a mouse event to make least confusion / ambiguity long term.

    // Could have an emulate_clicks option.

    // Setting deletable to true or false...

    

    //console.log('ctrl.delete', ctrl.delete);

    ctrl.delete = () => {

        // remove it from the DOM
        ctrl.remove();

        // raise a delete event
        
        ctrl.raise('delete');
        // Delete corresponding objects too.

    }
}

module.exports = deletable;
},{}],50:[function(require,module,exports){

// just display mixin perhaps?
//  so a text box could display as a small box with intro text and '...', then expand when pressed.

// Just use display.js ???? May be a more user-friendly and simple name.
//  Much of that is about modes and categories of modes.


let display_modes = (ctrl, opts = {}) => {


    // setup display modes on the control
    //  could set up some intelligent default sizes...
    //   eg 'icon' size is 32x32.
    
    // May get given info about the wanted shapes for the display modes (where possible).

    // preferred_ratio perhaps?
    // preferred_shape.ratio perhaps?
    // preferred_shape.width = 100% perhaps?
    // perferred_shape.available_width = true perhaps.


    // Could have this set up display modes with default options to start with.

    // Want it to be easy to call on and use display mode functionality.
    //  May want nice (CSS) transitions between display modes.

    // ctrl.display_mode = 'small' for example.
    // ctrl.popup_active property?
    // ctrl.display.popup ???

    // .display property?
    // .display.mode property perhaps?

    // ctrl.display seems like it could make sense for handling higher level display properties.
    //  above the CSS and DOM attributes.











}

module.exports = display_modes;
},{}],51:[function(require,module,exports){

// just display mixin perhaps?
//  so a text box could display as a small box with intro text and '...', then expand when pressed.

// to become 'view'.
//  Likely won't be used in this form?


// Or it is view.display
//  Display is a property of view.

// See about putting other Contol functionality within .view?
//   That would be more comprehensive than just having .view on top of the existing control.

// See about programming it both ways for the moment???

// Both the .model and .view properties seem important...
//  But creating a .view object maybe is not so easy.
//   Could make current control functions more mixin-like?

//   .content goes inside .view?
//     could keep .view as a relatively simple object for the moment?
//       could make HTML_Control_View which includes rendering.

// want to solve view modes, and get a good standard for the more complicated controls that can appear in different ways.
















// will also have 'model' mixin

// more advanced controls will use both the 'model' and 'view' mixins.
//  within the view section, they will specify / refer to views that are specifically for a data type as specified in the model.

//  controls not themselves specifying the model?
//    but the control is only handling the view.
//      data model could be defined just above the control though.

// .model and .view:
//   Could have a Ctrl_Html_Element_View for example.
//   Would be a possible abstraction where it did not need to be rendered to HTML (as an element) specifically.
//     For example, could be rendered into a canvas or similar.






// ctrl.display property.


// Calendar seems like the perfect control and type of control to make use of this.
// Could be full screen and interactive, or it could be a very simple component
//  displaying events over upcoming days. Could be a date picker, possibly. Possibly abstract together the similar code.

// Seems somewhat heavyweight, not sure it's right for many of the simpler controls.
//  However may help coordination... small components of a control acting in coordination with the rest? Though that should prob be top-down?

// Maybe I am creating too many classes that will be made for individual controls.

// Possibly display modes can keep functions which then get executed according to which display mode option is selected.
//  ie the composition functions still get called within their normal place and scope.

// Seems like quite a large and complicated mixin...
//  Also seems like a 'major version' feature.

// This seems a lot like branching - conveniently arranging the branching for how a Control gets displayed.

// Let's make this by making some examples work....
//  May be better to have server as a dev dependency? Though it gets tricky if part of that breaks. Could help develop UI components.

// Maybe jsgui3-html-core would help?
//  Then a module such as jsgui3-html-controls? Both loaded into jsgui3-html?
//  jsgui3-html-core-controls? jsgui3-html-mixins?

// For the moment let's keep it simpler as one lib.


// Load mx display onto the control.
//  Access the .display property and its subproperties.
//   displaye.size could be / return a Control_Display_Size object.
//    could be quite specialised. Could also be simple to use.
//  .display will link things together, and have the functionality provided in the mixin.
//   or at least the structure of the functionality in the mixin.
//   

//  model, view and controller mixins may make sense here.
//   view.context possibly???










let lang = require('lang-tools');


// and fnl code too?
const {Evented_Class, tof, each} = lang;

// Rendering-time checks?
//  Or will it be that items actually added to / removed from Controls?
//   Probably best to integrate simply and safely with HTML rendering.
//   Different rendering depending on options.
//   Don't want to introduce low level changes if not important / greatly beneficial.
//    Would be easy enough to make skip rendering flags.
//    Or multiple collections of controls.

// Composition-time checks
//  And would have recomposition when necessary.

// so the compose function would check the display mode
// maybe the activate function would
//  though it could check what is available.?
//   better to make the content controls depending on the display mode.
//   want to make them quick to specify / describe.







// ctrl.display.color could be solved too.
//  may reasonably assume it refers to the background color.


// And a Ctrl_Display_Mode class perhaps.

// Ctrl_Display_Modes
//   Makes sense for storing these modes.

// Size modes
// Other presentation modes (may influence size??)
//  eg whether its in editing mode or not.


// Any need for a Ctrl_Display_Mode class?
//  Maybe it would need to store / be a place to hook some more advanced functionality.

// eg a Ctrl_Display_Mode object called 'small'.



// Ctrl_Display_Mode_Category
//  Like interactivity or interactions, or size.
//  Or color / colors.

// display.colors.a_part_with_a_name

// display.modes.colors (light and dark modes)
// display.modes.languages possibly
//  makes a lot of sense to have that kind of breakdown of display modes.

// Could create a category object for each of them?

// Want only a moderate amount of effort / boilerplate code needed in the controls.
// Want it to be very easy to call upon the functionality when using the controls.



class Ctrl_Display_Mode_Category extends Evented_Class {
    constructor(spec = {}) {

        super(spec);

        // spec.name should exist.

        let name;
        if (spec.name) {
            name = spec.name;
        } else {
            throw 'Ctrl_Display_Mode_Category requires a name property';
        }
    }
}


class Ctrl_Display_Modes_Categories extends Evented_Class {
    constructor(spec = {}) {
        
        super(spec);

        // spec.names for example.
        const map_categories = {}, arr_categories = [];

        if (spec.names) {
            if (tof(spec.names) === 'array') {
                each(spec.names, name => {
                    const cat = new Ctrl_Display_Mode_Category({name: name});
                    map_categories[name] = cat;
                    arr_categories.push(cat);
                })
            } else {
                throw 'NYI';
            }
        }
        // then use proxy to get by index???

        // What to do with them though?



        // should probably have size, colors, interactivity, (other styling) / presentation.
    }
}



class Ctrl_Display_Modes extends Evented_Class {
    constructor(spec = {}) {
        super(spec);
        // the Ctrl? Maybe dont need it :)
        // small, medium, large for example.
        // Would have multiple display mode categories.

        // Layout or formatting.
        //  Some layout options would be unavailable with really small sizes.
        //  Then there may be only really basic layouts, such as image and text caption.
        //   Want to make the same Control able to render relatively differently and have that easy to express in code.

        // Such as in the constructor, putting the control together, easy programmatic definition.

        // Also 2022 now that it all (lower level) basically works, can more more onto syntactic sugar.

        const arr_category_names = ['size', 'layout', 'colors', 'interactivity'];
        // theme as well? could be within colors too.
        //  these will have control over lower level CSS properties.

        // then create Ctrl_Display_Modes_Category object...
        //  or a Categories object to handle them all?

        const categories = new Ctrl_Display_Modes_Categories({names: arr_category_names});

        Object.defineProperty(ctrl, 'categories', {
            get() {
                return categories;
            },
            set(value) {
                throw 'NYI';
            }
        });

        // .colors
        // .

        /*
            {size: [['small', {}]]}

        */


        // size modes
        // functionality modes (eg editable or not)


        // And will raise events upon change.
        //  May need to update control.

    }
}



class Ctrl_Display extends Evented_Class {
    // so it can have on change events.

    constructor(spec = {}) {
        super(spec);
        let ctrl;
        if (spec.ctrl) ctrl = spec.ctrl;

        // .modes seems to make sense as an object.
        //   but then there can be different mode categories

        // Setting this up with some reasonable defaults for the moment....



        const modes = new Ctrl_Display_Modes({});

        Object.defineProperty(this, 'modes', {
            get() {
                return modes;
            },
            set(value) {

                // determine the type of the value

                // ctrl_display.mode = ...

                //  a string - is it one word? does it match a name of the defined or default display types.

                // eg .display = 'mini', sets the display mode.

                throw 'NYI';
            }
        });





        // Which modes are supported?
        //  Not all modes would need to be supported. Probably never want a full screen checkbox, though maybe want a fullscreen control
        //  with a very prominent checkbox.


        // Could get the preferred aspect ratio or shape through here.

        // display.size property
        //  more to do with size mode?

        // mode properties for different things.

        // display.mode.size makes sense for some things.
        //  perhaps display size could shortcut to it.





        // May make sense to set up the various default display modes.
        //  Then could set them differently or intelligently calculate them for different controls.

        // tinyicon 12x12
        // icon 32x32
        // small 128x128
        // mid 512x512
        // large 1024x768
        // full ???


        // are some display modes (only?) available as popups?
        //  or would they be available through a 'details' section?

        // Want to allow for flexibility, and the default case creating easy flexibility.







    }

}


// display.size = ...
//  named preset, or [w, h].
//  or even z 3d if we want shaped with 3d rendering.
//   would be cool to render polygons within the dom.
//   treat DOM as flat planes in z-index order.


let display = (ctrl, opts = {}) => {

    // And send the control display options through?

    // Should set up the modes here too?
    //  mx display makes a lot of sense for the name of the functionality.

    if (ctrl.display) {
        throw 'ctrl already has .display property';
    } else {
        const ctrl_display = new Ctrl_Display({
            ctrl: ctrl
        });
        Object.defineProperty(ctrl, 'display', {
            get() {
                return ctrl_display;
            },
            set(value) {

                // determine the type of the value

                // ctrl_display.mode = ...

                //  a string - is it one word? does it match a name of the defined or default display types.

                // eg .display = 'mini', sets the display mode.

                throw 'NYI';
            }
        });


    }




    // setup display modes on the control
    //  could set up some intelligent default sizes...
    //   eg 'icon' size is 32x32.
    
    // May get given info about the wanted shapes for the display modes (where possible).

    // preferred_ratio perhaps?
    // preferred_shape.ratio perhaps?
    // preferred_shape.width = 100% perhaps?
    // perferred_shape.available_width = true perhaps.


    // Could have this set up display modes with default options to start with.

    // Want it to be easy to call on and use display mode functionality.
    //  May want nice (CSS) transitions between display modes.

    // ctrl.display_mode = 'small' for example.
    // ctrl.popup_active property?
    // ctrl.display.popup ???

    // .display property?
    // .display.mode property perhaps?

    // ctrl.display seems like it could make sense for handling higher level display properties.
    //  above the CSS and DOM attributes.

}

module.exports = display;
},{"lang-tools":186}],52:[function(require,module,exports){
const {
	prop,
	field
} = require('obext');

const {
	each,
	tof
} = require('lang-tools');

/*
	Handling mouseup outside of the document.
        Is quite important.
        'Virtual' mouseup events? Have it on by default.
        It's working, but making it an option may work better still.

	Should have a mousemove handler (while dragging) to check to see if the button in question has been released.
	Maybe only applies with the mouse drag?

	On mousemove, no buttons down means def not dragging???

	But getting clarity on which mouse buttons are down would help at the beginning.
	A class that models the mouse may help.

	Though let's focus on getting some specific and basic GUI things working.






*/


// control_helpers too perhaps.

// A positioning helper.
// A positioning info helper perhaps.

// Positions will need to get dealt with in all sorts of different ways.
//   To some extent it's worth modelling the CSS rules.

// Want to specify what adjustments to make in some cases, though having them made automatically and well is the ideal.
//   Automatically and out-of sync would be one of the worst behavioiurs.

// Though may be worth doing a bit of specific code here for draggable behaviours --- though having code that specifically
//   helps with all sorts of position calculations could work well here.

// Maybe some more classes could help too, eg Position_Confiner
//   And would apply to a Position object of some sort.

// Position_Confiner perhaps even, if using it would make the code at the higher level very clear.

// For the moment, see about handling variety of cases in the code here, see what is needed.

// Things like calculating the expected clearance between the edges and the bounds before moving.

// Ctrl_Pair_Positioning_Relationship_Info may be a useful class for some things.
//   Could be a good API for dealing with a variety of positioning issues in different parts of the codebase.

// May want to be specific about which positioning relationship info classes for for which overall setups.
//   Eg only for an absolutely positioned control within a relative one.
//     Would make sense for Ctrl_Pair_Positioning_Relationship_Info to have and use info on what CSS does.

// However, want to get some simpler cases involving bounds working here.

// A variety of very specific classes could help client-side, so long as the top level(s) of API are simple.

















// Want to make it simpler to create more specific behaviours like drag to grid position.
//  Drop targets could be one way to do that.

// Dynamic_Size could be an interesting one.
//  Uses the space available or the space it's given as a property.

// Maybe need drag-events mixin?
// Or drag-within?
//  the click-and-drag could be used for different things in different situations.
//  eg box select too.
// Want some kinds of specific handling, or mid-specificity handling.
//  Meaning on the higher level there is not much code to write in order to use the functionality.
//  Maybe it's a grid upgrade?
//   Such as dragging on a grid?
//   Or part of press-events?

// Somewhat complex mixin, seems to work well with the transform-xy drag mode.
//   Should make this a bit more general purpose, but where possible write idiomatic code.






// Get working with ghost drag too?
//  Want to get features demo working soon.
//  Probably separate pages will help to keep it simpler to begin with.
//  Maybe CMS should be finished to power it.

// disables console logging in this module.
//const console = {log: () => {}};


// Maybe a class may work better...?
// Could be easier to make variations and subclasses.


// Seems like we need a 'handle_to' ctrl option.
//   So dragging the hansdle drags the control it's the handle to.

// So here can specify a ctrl to use as the handle.


// Also be able to specify controls which don't start the drag.
//   Perhaps automatically make some kinds of controls, such as Buttons, not begin a drag or act as a drag handle.


// Seems like there is still a problem identifying parent nodes upon activation.
//   Looks like pre-activate needs to properly assign the parents.
//     Maybe / probably needs to assign / add the children into the parents contents.
//       maybe could shortcut that and assign .content._arr = [...]

// Could make some of the more complex / unwieldy activation code clearer in purposes.

const drag_like_events = (ctrl, opts = {}) => {

	let {
		
		//condition
	} = opts;
	// bounds could be a control.

    let start_action;

    if (!ctrl.__using_drag_like_events) {
        start_action = start_action || ['touchstart', 'mousedown'];
        if (tof(start_action) === 'string') start_action = [start_action];

        //console.log('ctrl.parent', ctrl.parent);
        //console.log('bounds', bounds);

        // Maybe have Window bounded within its parent by default.

        

        let pos_md, pos_mm, pos_mu, pos_md_within_ctrl;

        // pos_md_within_ctrl

        //console.log('ctrl.context.body', ctrl.context.body);

        let ctrl_body = ctrl.context.body();




        let dragging = false;
        let drag_offset_distance = opts.start_distance || 6;



        let movement_offset;
        let item_start_pos;

        //let bounds_size;
        //let bounds_offset;
        let half_item_width, item_width, initial_bcr;



        const el = ctrl.dom.el;


        
        let initial_ctrl_translate;


        // No actual drag taking place.
        //   Basically want to return the offsets.

        // will be a bit wordy for the moment.

        // .on('begin-drag-like-action')


        const begin_drag = (pos) => {



            //console.log('begin_drag like action', pos);

            // initial_bcr
            // initial_bounds_bcr
            initial_bcr = ctrl.bcr();
            dragging = true;
            //console.log('initial_bcr', initial_bcr);

            // These should help with the calculaton to keep it within the bounds, with different drag modes.

            // initial ctrl bcr offset from initial bounds bcr.

            const old_bounds_handling_code = () => {
                if (bounds) {
                    if (typeof bounds.bcr === 'function') {
                        initial_bounds_bcr = bounds.bcr();
                        //console.log('initial_bounds_bcr', initial_bounds_bcr);

                        // and the initial client translate x and y that are applied?

                        // And will have an estimated / computed new bcr when dragging???


                        // easy way to do the subtraction???

                        // pos offset from bcr???

                        // Maybe not needed...

                        // But a detailed / advanced Control_Positioning module or class could help.
                        // Control_Positioning_Helper.

                        // Helper almost being a mixin? Helper must have all functionality called from that helper.




                        initial_bcr_offset_from_bounds = [
                            [initial_bcr[0][0] - initial_bounds_bcr[0][0], initial_bcr[0][1] - initial_bounds_bcr[0][1]],
                            [initial_bcr[1][0] - initial_bounds_bcr[1][0], initial_bcr[1][1] - initial_bounds_bcr[1][1]],
                            [initial_bcr[2][0] - initial_bounds_bcr[2][0], initial_bcr[2][1] - initial_bounds_bcr[2][1]]
                        ]

                        //console.log('initial_bcr_offset_from_bounds', initial_bcr_offset_from_bounds);


                        //initial_bcr_offset_from_bounds = [[initial_bounds_bcr[]], [], []]

                    }
                }
            }
    


            ctrl.raise('drag-like-action-start');
        }



        const move_drag = (pos) => {
            //let ctrl_size = ctrl.bcr()[2];
            //let ctrl_size = [ctrl.dom.el.offsetWidth, ctrl.dom.el.offsetHeight];

            //console.log('bounds_size', bounds_size);
            //console.log('ctrl_size', ctrl_size);

            //console.log('move_drag pos', pos);

            // No such thing as drag_mode.

            ctrl.raise('drag-like-action-move', {
                offset: movement_offset
            });

            

        }

        const body_mm = e_mm => {
            // So for mouse move....
            //.  Detect if no button is down.

            let touch_count = 0;

            // The number of buttons though?
            //. No buttons, touch_count of 0?

            //console.log('e_mm.button', e_mm.button);
            //console.log('e_mm.buttons', e_mm.buttons);


            

            if (e_mm.touches) touch_count = e_mm.touches.length;
            if (e_mm.buttons === 0 && touch_count === 0) {

                // The virtual mouseup or touch end.
                body_mu();

            } else {


                if (e_mm.touches) {
                    pos_mm = [e_mm.pageX || e_mm.touches[0].pageX, e_mm.pageY || e_mm.touches[0].pageY];
                } else {
                    pos_mm = [e_mm.pageX, e_mm.pageY];
                }

                

                // could store a variable that tracks the last event.

                //console.log('movement_offset', movement_offset);
                //console.log('item_start_pos', item_start_pos);
                //console.log('pos_md', pos_md);
                //console.log('pos_mm', pos_mm);


                if (touch_count === 0 || touch_count === 1) {

                    if (e_mm.pageX || e_mm.touches) {

                        let pos_mm;

                        if (e_mm.touches) {
                            pos_mm = [e_mm.pageX || e_mm.touches[0].pageX, e_mm.pageY || e_mm.touches[0].pageY];
                        } else {
                            pos_mm = [e_mm.pageX, e_mm.pageY];
                        }

                        if (pos_mm[0] !== undefined && pos_mm[1] !== undefined) {
                            movement_offset = [pos_mm[0] - pos_md[0], pos_mm[1] - pos_md[1]];
                            if (!dragging) {
                                //movement_offset = [(offset_mm[0]), Math.abs(offset_mm[1])];
                                let abs_offset = [Math.abs(movement_offset[0]), Math.abs(movement_offset[1])];
                                let abs_offset_dist = Math.sqrt(Math.pow(abs_offset[0], 2) + Math.pow(abs_offset[1], 2));

                                //console.log('drag_offset_distance', drag_offset_distance);

                                //console.log('abs_offset_dist', abs_offset_dist);
                                if (abs_offset_dist >= drag_offset_distance) {
                                    begin_drag(pos_mm);
                                }
                            } else {
                                move_drag(pos_mm);
                            }
                        }

                        
                        
                    }


                }

            }

            // 

            
            // Looks like they are passive now by default.
            //e_mm.preventDefault();
        }

        const end_drag = e_mu => {
            // depending on if it is touch or mouse

            ctrl_body.off('mousemove', body_mm);
            ctrl_body.off('mouseup', body_mu);

            ctrl_body.off('touchmove', body_mm);
            ctrl_body.off('touchend', body_mu);

            if (dragging) {
                dragging = false;
                //console.log('end_drag', end_drag);
                //console.trace();
                // Also end drag attempt...
                //  Want it switched off on mouseup.
                //console.log('pre raise drag complete');
                //console.log('movement_offset', movement_offset);

                //ctrl.raise();
                ctrl.raise('drag-like-action-end', {
                    offset: movement_offset
                });
            }
        }

        const body_mu = e_mu => {
            // release
            //console.log('body_mu', e_mu);
            //console.trace();
            end_drag(e_mu);
        }



        const h_md = (e_md) => {
            //console.log('dragable e_md', e_md);

            //console.log('e_md.pageX', e_md.pageX);

            // Strange...
            if (e_md.pageX) {
                pos_md_within_ctrl = [e_md.offsetX, e_md.offsetX];
            } else {
                pos_md_within_ctrl = [0, 0];
            }
            dragging = false;

            //pos_md_within_ctrl = [e_mm.pageX || e_mm.touches[0].pageX, e_mm.pageY || e_mm.touches[0].pageY];

            //if (drag_mode === 'x') {
            //pos_md = [e_md.layerX, e_md.layerY];

            // Cancel move if there are multiple touches?
            //  Want to recognise pinch / 2 finger rotate events.

            pos_md = [e_md.pageX || e_md.touches[0].pageX, e_md.pageY || e_md.touches[0].pageY];

            //console.log('pos_md', pos_md);

            // get the 3d translation value...
            //  possibly using the system of dims to set the translate value will help too.

            // .t3d typed array
            //  and can listen to changes in these values in between frames.





            // need to mm pos like this too...

            //} else {
            //pos_md = [e_md.pageX || e_md.touches[0].pageX, e_md.pageY || e_md.touches[0].pageY];
            //}
            ctrl_body.on('mousemove', body_mm);
            ctrl_body.on('mouseup', body_mu);
            ctrl_body.on('touchmove', body_mm);
            ctrl_body.on('touchend', body_mu);

            //e_md.stopPropagation();
            //e_md.preventDefault();
        }

        field(ctrl, 'drag_like_events');
        //field(ctrl, 'select_unique');
        //let id = ctrl._id();
        ctrl.on('change', e_change => {
            //console.log('e_change', e_change);


            let n = e_change.name,
                value = e_change.value;

            // Maybe make an abstraction for switching mixins on and off (attaching and unattaching event handlers)



            if (n === 'drag_like_events') {
                if (value === true) {
                    // ctrl.deselect();
                    //console.trace();

                    if (typeof document === 'undefined') {} else {
                        // on activation of control.

                        let apply_start_handlers = (start_action) => {

                            // handle is the ctrl itself???

                            //console.log('apply_start_handlers handle', handle);
                            //console.trace();

                            

                            if (!ctrl.has_drag_like_md_handler) {
                                ctrl.has_drag_like_md_handler = true;
                                each(start_action, sa => {
                                    ctrl.on(sa, h_md);
                                });
                                //handle.on('touchstart', h_md);
                                //handle.on('mousedown', h_md);
                            }
                            
                        }
                        //console.log('handle.has_drag_md_handler', handle.has_drag_md_handler);
                        ctrl.once_active(() => {
                            //console.log('dragable once_active');
                            apply_start_handlers(start_action);
                        });
                    }
                } else {
                    if (typeof document === 'undefined') {} else {

                        
                        (start_action => {
                            each(start_action, sa => {
                                ctrl.off(sa, h_md);
                            });
                        })(start_action);
                        


                        /*
                        handle.off('touchstart', h_md);
                        handle.off('mousedown', h_md);
                        */
                        ctrl.has_drag_md_handler = false;


                    }
                }
            }
        })

        ctrl.__using_drag_like_events = true;
    }

	//control

	// And maybe same / similar for the resize handle.
	//   Maybe make the resize handle dragable???
	//     Prob don't need to in most cases, use more specific programming for it.





 

}

module.exports = drag_like_events;
},{"lang-tools":186,"obext":382}],53:[function(require,module,exports){
const {
	prop,
	field
} = require('obext');
const {
	each,
	tof
} = require('lang-tools');
let dragable = (ctrl, opts = {}) => {
	let {
		bounds,
		handle,
		mode,
		start_action,
		condition
	} = opts;
	start_action = start_action || ['touchstart', 'mousedown'];
	if (tof(start_action) === 'string') start_action = [start_action];
	let bounds_pos;
	let bounds_is_parent = bounds && bounds === ctrl.parent;
	if (bounds === 'parent') {
		bounds = ctrl.parent;
		bounds_is_parent = true;
	}
	if (bounds) {
		bounds_pos = bounds.pos || [bounds.dom.el.offsetLeft, bounds.dom.el.offsetTop];
	}
	handle = handle || ctrl;
	const old_dragable = ctrl.dragable;

	if (old_dragable) {
		console.trace();
		throw 'NYI / Deprecated';
	}

	let drag_mode = opts.drag_mode || opts.mode || 'translate';
	if (bounds_is_parent) {
	}
	let pos_md, pos_mm, pos_mu, pos_md_within_ctrl;


	const setup_isomorphic = () => {
        const old_silent = ctrl.view.data.model.mixins.silent;
        ctrl.view.data.model.mixins.silent = true;
        ctrl.view.data.model.mixins.push({
            name: 'dragable'
        });
        ctrl.view.data.model.mixins.silent = old_silent;
        field(ctrl, 'dragable');
    }
    setup_isomorphic();

    if (typeof document === 'undefined') {
        ctrl.on('server-pre-render', e => {
            //console.log('selectable server-pre-render');

            if (ctrl.dragable === true) {
                ctrl._fields = ctrl._fields || {};
                //ctrl._fields.selected = ctrl.selected;

                ctrl._fields.dragable = true;

            }

        })
    }

	if (ctrl.dom.el) {
		let ctrl_body = ctrl.context.body();
		let dragging = false;
		let drag_offset_distance = opts.start_distance || 6;
		let movement_offset;
		let item_start_pos;
		let bounds_size;
		let bounds_offset;
		let half_item_width, item_width;
		let initial_bounds_bcr, initial_bcr;
		let initial_bcr_offset_from_bounds;
		const el = ctrl.dom.el;
		let ctrl_translation3d = new Float32Array(3);   
		let initial_ctrl_translation3d;
		let initial_ctrl_translate;
		const begin_drag = (pos) => {
			initial_bcr = ctrl.bcr();
			if (bounds) {
				if (typeof bounds.bcr === 'function') {
					initial_bounds_bcr = bounds.bcr();
					initial_bcr_offset_from_bounds = [
						[initial_bcr[0][0] - initial_bounds_bcr[0][0], initial_bcr[0][1] - initial_bounds_bcr[0][1]],
						[initial_bcr[1][0] - initial_bounds_bcr[1][0], initial_bcr[1][1] - initial_bounds_bcr[1][1]],
						[initial_bcr[2][0] - initial_bounds_bcr[2][0], initial_bcr[2][1] - initial_bounds_bcr[2][1]]
					]
				}
			}
			if (drag_mode === 'within-parent') {
				dragging = true;
				item_start_pos = ctrl.pos;
				const ctrl_pos_to_be = [item_start_pos[0] - movement_offset[0], item_start_pos[1] - movement_offset[1]];
				ctrl.pos = ctrl_pos_to_be;
			} else if (drag_mode === 'translate') {
				initial_ctrl_translate = ctrl.ta.slice(6, 8);
				dragging = true;
			} else {
				if (drag_mode === 'x') {
					dragging = true;
					item_start_pos = ctrl.pos || [ctrl.dom.el.offsetLeft, ctrl.dom.el.offsetTop];
					half_item_width = Math.round(ctrl.dom.el.offsetWidth / 2);
					item_width = (ctrl.dom.el.offsetWidth);
					bounds_offset = [bounds.dom.el.offsetLeft, bounds.dom.el.offsetTop];
					ctrl.pos = [item_start_pos[0] + movement_offset[0], item_start_pos[1]];
				} else {
					console.log('drag_mode', drag_mode);
					throw 'NYI';
				}
			}
			ctrl.raise('dragstart');
		}
		const move_drag = (pos) => {
			let ctrl_size = [ctrl.dom.el.offsetWidth, ctrl.dom.el.offsetHeight];
			if (drag_mode === 'translate') {
				let tr_x = movement_offset[0] + initial_ctrl_translate[0];
				let tr_y = movement_offset[1] + initial_ctrl_translate[1];
				if (bounds) {
					const min_x_movement_offset = -1 * (initial_bcr_offset_from_bounds[0][0] - initial_ctrl_translate[0]);
					if (tr_x < min_x_movement_offset) tr_x = min_x_movement_offset;
					const max_x_movement_offset = -1 * (initial_bcr_offset_from_bounds[1][0] - initial_ctrl_translate[0]);
					if (tr_x > max_x_movement_offset) tr_x = max_x_movement_offset;
					const min_y_movement_offset = -1 * (initial_bcr_offset_from_bounds[0][1] - initial_ctrl_translate[1]);
					if (tr_y < min_y_movement_offset) tr_y = min_y_movement_offset;
					const max_y_movement_offset = -1 * (initial_bcr_offset_from_bounds[1][1] - initial_ctrl_translate[1]);
					if (tr_y > max_y_movement_offset) tr_y = max_y_movement_offset;
				}
				ctrl.ta[6] = tr_x;
				ctrl.ta[7] = tr_y;
			} else if (drag_mode === 'within-parent') {
				bounds = bounds || ctrl.parent;
				bounds_size = bounds.bcr()[2];
				let new_pos = [item_start_pos[0] + movement_offset[0], item_start_pos[1] + movement_offset[1]];
				if (new_pos[0] < 0) new_pos[0] = 0;
				if (new_pos[1] < 0) new_pos[1] = 0;
				if (new_pos[0] > bounds_size[0] - ctrl_size[0]) new_pos[0] = bounds_size[0] - ctrl_size[0];
				if (new_pos[1] > bounds_size[1] - ctrl_size[1]) new_pos[1] = bounds_size[1] - ctrl_size[1];
				ctrl.pos = new_pos;
			} else if (drag_mode === 'x') {
				bounds_size = [bounds.dom.el.offsetWidth, bounds.dom.el.offsetHeight];
				let new_pos = [item_start_pos[0] + movement_offset[0], item_start_pos[1]];
				if (new_pos[0] < bounds_pos[0] - half_item_width) new_pos[0] = bounds_pos[0] - half_item_width;
				if (new_pos[0] > bounds_size[0] - ctrl_size[0] + bounds_offset[0] + half_item_width) new_pos[0] = bounds_size[0] - ctrl_size[0] + bounds_offset[0] + half_item_width;
				ctrl.pos = new_pos;
			}
		}
		const body_mm = e_mm => {
			let touch_count = 0;
			if (e_mm.touches) touch_count = e_mm.touches.length;
			if (e_mm.touches) {
				pos_mm = [e_mm.pageX || e_mm.touches[0].pageX, e_mm.pageY || e_mm.touches[0].pageY];
			} else {
				pos_mm = [e_mm.pageX, e_mm.pageY];
			}
			if (touch_count === 0 || touch_count === 1) {
				if (e_mm.buttons === 0) {
					body_mu();
				} else {
					if (e_mm.pageX || e_mm.touches) {
						let pos_mm;
						if (e_mm.touches) {
							pos_mm = [e_mm.pageX || e_mm.touches[0].pageX, e_mm.pageY || e_mm.touches[0].pageY];
						} else {
							pos_mm = [e_mm.pageX, e_mm.pageY];
						}
						if (pos_mm[0] !== undefined && pos_mm[1] !== undefined) {
							movement_offset = [pos_mm[0] - pos_md[0], pos_mm[1] - pos_md[1]];
							if (!dragging) {
								let abs_offset = [Math.abs(movement_offset[0]), Math.abs(movement_offset[1])];
								let abs_offset_dist = Math.sqrt(Math.pow(abs_offset[0], 2) + Math.pow(abs_offset[1], 2));
								if (abs_offset_dist >= drag_offset_distance) {
									begin_drag(pos_mm);
								}
							} else {
								move_drag(pos_mm);
							}
						}
					}
				}
			}
		}
		const end_drag = e_mu => {
			ctrl_body.off('mousemove', body_mm);
			ctrl_body.off('mouseup', body_mu);
			ctrl_body.off('touchmove', body_mm);
			ctrl_body.off('touchend', body_mu);
			if (dragging) {
				dragging = false;
				ctrl.raise('dragend', {
					movement_offset: movement_offset
				});
			}
		}
		const body_mu = e_mu => {
			end_drag(e_mu);
		}
		const h_md = (e_md) => {
			if (!condition || condition()) {
				if (e_md.pageX) {
					pos_md_within_ctrl = [e_md.offsetX, e_md.offsetX];
				} else {
					pos_md_within_ctrl = [0, 0];
				}
				dragging = false;
				pos_md = [e_md.pageX || e_md.touches[0].pageX, e_md.pageY || e_md.touches[0].pageY];
				ctrl_body.on('mousemove', body_mm);
				ctrl_body.on('mouseup', body_mu);
				ctrl_body.on('touchmove', body_mm);
				ctrl_body.on('touchend', body_mu);
			}
		}
		ctrl.on('change', e_change => {
			let n = e_change.name,
				value = e_change.value;
			if (n === 'dragable') {
				if (value === true) {
					if (typeof document === 'undefined') {} else {
						let apply_start_handlers = (start_action) => {
							if (!handle.has_drag_md_handler) {
								handle.has_drag_md_handler = true;
								each(start_action, sa => {
									handle.on(sa, h_md);
								});
							}
						}
						ctrl.once_active(() => {
							apply_start_handlers(start_action);
						});
					}
				} else {
					if (typeof document === 'undefined') {} else {
						(start_action => {
							each(start_action, sa => {
								handle.off(sa, h_md);
							});
						})(start_action);
						handle.has_drag_md_handler = false;
					}
				}
			}
		})
	}

	
	if (!old_dragable) {
		
		
	}
	//if (old_dragable !== undefined) {
	//	ctrl.dragable = old_dragable;
	//}
}
module.exports = dragable;
},{"lang-tools":186,"obext":382}],54:[function(require,module,exports){
let fast_touch_click = (ctrl) => {

    // Respond to touch events.

    // generally want a 'press' event too.
    //  Could be a click, or a touch press.

    // Could raise a press or click event.
    //  Press could cover click and touch.
    //  Click could specifically be a mouse event to make least confusion / ambiguity long term.

    // Could have an emulate_clicks option.

    let has_moved_away = false;
    ctrl.on('touchstart', ets => {
        //console.log('ets', ets);
        // Then cancel the event.
        //console.log('Object.keys(ets)', Object.keys(ets));
        // Returning false from such a DOM event should cancel the event propagation.
        ets.preventDefault();
        //return false;
    })
    ctrl.on('touchend', ete => {
        //console.log('ete', ete);
        if (!has_moved_away) {
            ctrl.raise('click', ete);
        }
        has_moved_away = false;
    })
    ctrl.on('touchmove', etm => {
        has_moved_away = true;
        //console.log('etm', etm);
    })
}

module.exports = fast_touch_click;
},{}],55:[function(require,module,exports){
const {
    tof,
    each,
    Data_Model,
    Data_Value,
    Immutable_Data_Model,
    Immutable_Data_Value,
    Collection
} = require('lang-tools');
const Control_Data = require('../html-core/Control_Data');
const Control_View = require('../html-core/Control_View');
const Control_Validation = require('../html-core/Control_Validation');

// Want to handle server to client persistance here too. Maybe not in this function - possibly control.view.data.model
//   handle that.

// pfield function for a persistant field?
//  or a persistant field mixin?

// A 'pre-server-render' event would help with persisting some things.
//   Would persist them as ._fields or ._.






const model_data_view_compositional_representation = (ctrl, options = {}) => {
    const {data} = options;
    ctrl.using_model_data_view_compositional_representation = true;
    const verify_ctrl_conditions = (ctrl) => {
        if (ctrl.data !== undefined) return false;
        if (ctrl.view !== undefined) return false;
        if (ctrl.validation !== undefined) return false;
        return true;
    }
    const can_proceed = verify_ctrl_conditions(ctrl);
    if (can_proceed) {
        const {context} = ctrl;
        const o_cd = {
            context
        }
        if (data) {
            if (data.model) {
                o_cd.model = data.model;
            }
        }
        ctrl.data = new Control_Data(o_cd);
        ctrl.validation = new Control_Validation();
        ctrl.view = new Control_View({
            context
        });
        ctrl.view.data.model.mixins = ctrl.view.data.model.mixins || new Collection();
        ctrl.view.data.model.mixins.on('change', e_change => {
            const {name, value} = e_change;
            if (name === 'insert') {
                const o_mxs = {};
                ctrl.view.data.model.mixins.each(mx => {
                    o_mxs[mx.name] = mx;
                    if (ctrl.context.mixins) {
                        const my_mx = ctrl.context.mixins[mx.name];
                        my_mx(ctrl);
                    }
                });
            }
        });
    } else {
        console.trace();
        console.log('ctrl', ctrl);
        throw 'model_data_view_compositional_representation(ctrl) - ctrl must not have .data or .view properties';
    }
}
module.exports = model_data_view_compositional_representation;
},{"../html-core/Control_Data":130,"../html-core/Control_Validation":131,"../html-core/Control_View":135,"lang-tools":186}],56:[function(require,module,exports){
// More directory features here?
//  Be able to mix in multiple at once?



const mx = {
    coverable: require('./coverable'),
    date: require('./typed_data/date'),
    display: require('./display'),
    display_modes: require('./display-modes'),
    fast_touch_click: require('./fast-touch-click'),
    model_data_view_compositional_representation: require('./model_data_view_compositional_representation'),
    popup: require('./popup'),
    resizable: require('./resizable'),
    selectable: require('./selectable'),
    selected_deletable: require('./selected-deletable'),
    selected_resizable: require('./selected-resizable'),
    selection_box_host: require('./selection-box-host'),
    dragable: require('./dragable'),
    drag_like_events: require('./drag_like_events'),
    press_events: require('./press-events'),
    press_outside: require('./press-outside'),
    pressed_state: require('./pressed-state')
}

module.exports = mx;
},{"./coverable":48,"./display":51,"./display-modes":50,"./drag_like_events":52,"./dragable":53,"./fast-touch-click":54,"./model_data_view_compositional_representation":55,"./popup":57,"./press-events":58,"./press-outside":59,"./pressed-state":60,"./resizable":61,"./selectable":62,"./selected-deletable":63,"./selected-resizable":64,"./selection-box-host":65,"./typed_data/date":66}],57:[function(require,module,exports){
/*
    Makes a control appear in place, but with absolute position, at the top of the DOM.
    Outside the overflow of what was its container.

    Measure current position
    Offset / position within document
        Move it to that location with absolute positioning.

    Be able to return it to its original position.

    // .popped_up = true
    // Properties on init, not on activation.
    // .popup
    // Some content will be hidden until it shows through popup.

    // 

    Interaction with Display / display.mode as well?
    Some display modes will be in a popup?

*/

// The page context could give a floating layer if asked.

const jsgui = require('../html-core/html-core');
const stringify = jsgui.stringify,
    each = jsgui.each,
    tof = jsgui.tof;
const Control = jsgui.Control;

const context_ensure_popup_layer = (context) => {
    let ctrl_document = context.ctrl_document;
    // then body...
    // .child_controls
    // .content.length
    // Can get the popup layer from the context now.

    // context.overlay property

    //console.log('ctrl_document', ctrl_document);

    let body = context.map_controls['body_0'];

    // May use overlay from the context.

    if (!body.popup_layer) {
        body.popup_layer = new Control({
            'context': context,
            '__type_name': 'popup_layer'
        });
        body.popup_layer.add_class('popup-layer');
        //body.popup_layer.dom.attributes.style.position = 'absolute';

        body.add(body.popup_layer);
    }
    return body.popup_layer;
}


const popup = (ctrl) => {
    let context = ctrl.context;
    // ctrl_document
    ctrl.popup = () => {
        let popup_layer = context_ensure_popup_layer(context);
        let parent, placeholder;
        setTimeout(() => {

            // make it transparent rather than see-through
            // put a placeholder control in its original location.
            // move the control over to the body.
            //  the body could have a popup layer.
            //  just a div ctrl where all / most of the popups go.

            // ensure the page context's popup layer
            // swap it in its current position with a placeholder, move the ctrl to the popup layer.

            // ctrl measure.
            // getBoundingClientRect
           

            

            // Need to pay attention to moving content from one place to another.

            // control.add(ctrl)
            //  what if ctrl already has a parent
            //  already is in the DOM.
            //   need to remove the control from its previous parent.
            //    (no dom update)
            

            placeholder = new Control({
                'context': context,
                '__type_name': 'placeholder'
            });

            parent = ctrl.parent;

            let absolute_container = new Control({
                'context': context
            })

            popup_layer.add(absolute_container);
            absolute_container.add(placeholder);

            parent.content.swap(ctrl, placeholder);
            //ctrl.remove_class('hidden');
            //ctrl.add_class('invisible');

            let bcr = placeholder.dom.el.getBoundingClientRect();

            
            //console.log('bcr', bcr);
            


            // ctrl could have an absolute-container.
            //  then the control can display (more) normally.

            absolute_container.dom.attrs.style.position = 'absolute';
            absolute_container.dom.attrs.style.left = bcr.left + 'px';
            absolute_container.dom.attrs.style.top = bcr.top + 'px';

            //setTimeout(() => {
            //    ctrl.remove_class('hidden');
            //}, 1000);

            ctrl.remove_class('hidden');
            
            

        }, 0);

        // controls won't have 2 parents.

        // moving but keeping a placeholder...
        //  could change the reference in the parent element.

        const replace = () => {
            ctrl.add_class('hidden');
            parent.content.swap(placeholder, ctrl);
        }
        return replace;
    }

}

module.exports = popup;
},{"../html-core/html-core":149}],58:[function(require,module,exports){
const {get_truth_map_from_arr, each} = require('lang-tools');
let press_events = (ctrl, options = {}) => {


    //console.log('running press-events mixin');

    ctrl.__mx = ctrl.__mx || {};
    ctrl.__mx.press_events = true;
    const press_event_names = ['press-start', 'press-move', 'press-end', 'press-hold', 'press-drag-start'];
    const map_press_event_names = get_truth_map_from_arr(press_event_names);



    const setup_isomorphic = () => {
        const old_silent = ctrl.view.data.model.mixins.silent;
        ctrl.view.data.model.mixins.silent = true;
        ctrl.view.data.model.mixins.push({
            name: 'press-events'
        });
        ctrl.view.data.model.mixins.silent = old_silent;
        //field(ctrl, 'dragable');
    }
    setup_isomorphic();

    if (ctrl.dom.el) {

        ctrl.once_active(() => {


            //console.log('once-active press-events');

            //apply_start_handlers(start_action);
            const body = ctrl.context.body();

            //console.log('body', body);
            const {css} = options;
            let handling_is_setup = false;
            let pos_start;
            let movement_offsets;
            let pos_move;
            let movement_offset;
            let timeout_hold;
            let drag_started = false;
            let el;
            const hold_movement_threshold = 4;
            let move_mag;
            const ms_short = 500;
            const ts = e => {
                if (e.touches.length === 1) {
                    e.pos = [e.pageX = e.touches[0].pageX, e.pageY = e.touches[0].pageY];
                    el = e.el = e.touches[0].target;
                    return ps(e);
                }
            }
            const md = e => {
                let path = e.path || e.composedPath();
                el = e.el = path[0];
                return ps(e);
            }
            const mm = e => {
                e.pos = [e.pageX = e.pageX, e.pageY = e.pageY];
                return pm(e);
            }
            const tm = e => {
                e.pos = [e.pageX = e.touches[0].pageX, e.pageY = e.touches[0].pageY];
                return pm(e);
            }
            const pm = e => {
                pos_move = e.pos;
                e.movement_offset = movement_offset = [e.pos[0] - pos_start[0], e.pos[1] - pos_start[1]];
                movement_offsets.push(movement_offset);
                e.movement_offsets = movement_offsets;
                e.move_mag = move_mag = Math.sqrt(Math.pow(movement_offset[0], 2) + Math.pow(movement_offset[1], 2));
                e.ctrl = ctrl;
                ctrl.raise('press-move', e);
                if (move_mag >= 4 && !drag_started) {
                    ctrl.raise('press-drag-start', e);
                    drag_started = true;
                }
            }
            const pe = e => {
                e.movement_offsets = movement_offsets;
                e.move_mag = move_mag;
                e.ctrl = ctrl;
                e.el = el;
                if (timeout_hold) clearTimeout(timeout_hold);
                body.off({
                    touchend: te,
                    touchmove: tm,
                    mouseup: mu,
                    mousemove: mm
                });
                ctrl.raise('press-end', e);
            }
            const mu = e => {
                body.off({
                    mouseup: mu,
                    mousemove: mm
                });
                e.pos = [e.pageX, e.pageY];
                return pe(e);
            }
            const te = e => {
                body.off({
                    touchend: te,
                    touchmove: tm
                });
                e.pos = pos_move || pos_start;
                return pe(e);
            }
            const ps = e => {
                movement_offsets = [];
                move_mag = 0;
                drag_started = false;
                let is_touch_event = !!e.touches;
                e.is_touch_event = is_touch_event;
                pos_start = [e.pageX, e.pageY];
                if (is_touch_event) {
                    body.on({
                        touchend: te,
                        touchmove: tm
                    });
                } else {
                    body.on({
                        mouseup: mu,
                        mousemove: mm
                    });
                }
                e.ctrl = ctrl;
                ctrl.raise('press-start', e);
                timeout_hold = setTimeout(() => {
                    if (move_mag <= hold_movement_threshold) {
                        ctrl.raise('press-hold', e);
                    }
                }, ms_short);
            }
            const setup = () => {
                //console.log('press-events setup (inner)');
                ctrl.on({
                    'touchstart': ts,
                    'mousedown': md
                });
                handling_is_setup = true;
            }
            const unsetup = () => {
                //console.log('press-events unsetup');
                //console.log('--------------------');
                ctrl.off({
                    'touchstart': ts,
                    'mousedown': md
                });
                handling_is_setup = false;
            }
            const outer_setup = () => {
                //console.log('press-events outer_setup');

                // Seems a bit strange - having to listen here for the adding of an event listener.
                //   What if the event listener is added before this mixin is added?

                ctrl.event_events = true;

                const relying_on_recognising_adding_of_event_listeners = () => {
                    ctrl.on('add-event-listener', e => {
                        const {name} = e;
                        if (map_press_event_names[name]) {
                            if (!handling_is_setup) {
                                setup();
                            }
                        }
                    });
                    ctrl.on('remove-event-listener', e => {
                        const {name} = e;
                        if (map_press_event_names[name]) {
                            console.log('ctrl remove-event-listener', name);
                            const bnec = ctrl.bound_named_event_counts;
                            console.log('bound_named_event_counts bnec', bnec);
                            console.log('name', name);
                            let count_bound_press_events = 0;
                            each(bnec, (count, event_name) => {
                                if (map_press_event_names[event_name]) count_bound_press_events += count;
                            })
                            if (count_bound_press_events === 0) {
                                unsetup();
                            }
                        }
                    })
                }

                const just_do_it = () => {
                    if (!handling_is_setup) {
                        setup();
                    }
                }
                just_do_it();


                


            }
            outer_setup();
        });


        
    }

    // emit 'press-outside' when press ends outside the control
    if (typeof window !== 'undefined' && ctrl.dom && ctrl.dom.el) {
        ctrl.on('press-start', e_ps => {
            const outsideHandler = e_pe => {
                if (!ctrl.dom.el.contains(e_pe.target)) {
                    ctrl.raise('press-outside', e_pe);
                }
                window.removeEventListener('mouseup', outsideHandler);
                window.removeEventListener('touchend', outsideHandler);
            };
            window.addEventListener('mouseup', outsideHandler);
            window.addEventListener('touchend', outsideHandler);
        });
    }
    
}
module.exports = press_events;
},{"lang-tools":186}],59:[function(require,module,exports){
/*
    For detecting press events outside of a control.
    Listens to the body, detects if the control is or is an ancestor of what was pressed.

    Adds press-outside capability.
    Probably only worth checking for it if there are any event listeners for it.


    So, can we listen for listeners being added anywhere?
      Could be a new feature of Evented_Class?
    //  self events to do with add_event_listener? listener-added?
    //   would add more flexibility for higher levels to provide higher performance / more fine-grained control.

*/
const press_events = require('./press-events');

const press_outside = (ctrl, options = {}) => {
    let once = options.one || options.once || false;
    console.log('press_outside');

    ctrl.__mx = ctrl.__mx || {};

    if (!ctrl.__mx || !ctrl.__mx.press_events) {
        press_events(ctrl);
    }
    ctrl.__mx.press_outside = true;

    const body = ctrl.context.body();
    if (!body.__mx || !body.__mx.press_events) {
        press_events(body);
    }
    ctrl.event_events = true;

    const body_press = e => {
        console.log('press_outside body press e', e);
        //const {ctrl} = e;
        //const press_ctrl = e.ctrl;

        const {ctrl_target} = e;
        /*
            // is the 'search' amongst the ancestors?
	        'ancestor'(search) {
        */
        //const is_ancestor = ctrl.ancestor(ctrl_target);
        //const match = ctrl_target === ctrl || is_ancestor;
            
        // No, need to check if the ctrl is an ancestor of the target.
        //console.log('');
        //console.log('ctrl_target', ctrl_target);
        //console.log('ctrl', ctrl);
        const match = ctrl_target === ctrl || ctrl_target.ancestor(ctrl);
        //console.log('match', match);

        if (!match) {
            // was pressed outside.
            ctrl.raise('press-outside', e);
        }

        // is the target an ancestor of the ctrl in question?

        // target_ctrl???
        //  The event should have the corresponding control to the target element.

        // could look up that target control?
        //  .target_ctrl or .ctrl_target would make a lot of sense.

        // the target_ctrl would be a useful thing to have incorporated into the event - whether press ovent, click event, or other.

        // ctrl_target being more standard (Hungarian prefix style).
    }

    const setup_body_press = () => {
        //console.log('press_outside setup_body_press');
        body.on('press-end', body_press);
    }
    const remove_body_press = () => {
        //console.log('remove_body_press');
        //console.trace();
        body.off('press-end', body_press);
        // Then that should switch off a bunch of things.
    }

    // or 'on' event???
    //console.log('pre on add-event-listener');
    ctrl.on('add-event-listener', e => {
        //console.log('press_outside ctrl add-event-listener', e);
        // if it's the press-outside event...
        const {name} = e;
        if (name === 'press-outside') {
            //console.log('added press-outside event');
            // Need to now listen for it in the document body.
            //body_press();
            setup_body_press();
        }
    });

    // remove events listener not working???
    //  not for dom events?
    ctrl.on('remove-event-listener', e => {
        //console.log('press_outside ctrl remove-event-listener', e);
        //console.trace();

        const {name} = e;
        if (name === 'press-outside') {
            remove_body_press();
        }
        // remove the body press event listener.
    });

}

module.exports = press_outside;
},{"./press-events":58}],60:[function(require,module,exports){
/*
    For detecting press events outside of a control.
    Listens to the body, detects if the control is or is an ancestor of what was pressed.

    Adds press-outside capability.
    Probably only worth checking for it if there are any event listeners for it.


    So, can we listen for listeners being added anywhere?
      Could be a new feature of Evented_Class?
    //  self events to do with add_event_listener? listener-added?
    //   would add more flexibility for higher levels to provide higher performance / more fine-grained control.

*/

const {
    field,
    prop
} = require('obext');

const press_events = require('./press-events');

// a state / states mixin???

const pressed_state = (ctrl, options = {}) => {
    //let once = options.one || options.once || false;
    //console.log('press_outside');
    //console.log('running pressed-state mixin');

    ctrl.__mx = ctrl.__mx || {};

    if (!ctrl.__mx || !ctrl.__mx.press_events) {
        press_events(ctrl);
    }
    ctrl.__mx.pressed_state = true;

    const setup_isomorphic = () => {
        const old_silent = ctrl.view.data.model.mixins.silent;
        ctrl.view.data.model.mixins.silent = true;
        ctrl.view.data.model.mixins.push({
            name: 'pressed-state'
        });
        ctrl.view.data.model.mixins.silent = old_silent;
        //field(ctrl, 'dragable');
    }
    setup_isomorphic();

    // begin and end presses.
    //   have a 'pressed' state in the control as well.
    //     Want to get the specifics working well on a low level.
    //       Then make them easier to use on a high level.

    // define 'state' field for pressed-state
    field(ctrl.view.data.model, 'state');

    // handle press-start and press-end events
    ctrl.on('press-start', () => { ctrl.view.data.model.state = 'pressed'; });
    ctrl.on('press-end',   () => { ctrl.view.data.model.state = 'not-pressed'; });

    // toggle 'pressed' CSS class based on view state changes
    ctrl.view.data.model.on('change', e => {
        const { name, value } = e;
        if (name === 'state') {
            if (value === 'pressed') ctrl.add_class('pressed');
            else                        ctrl.remove_class('pressed');
        }
    });


    //const body = ctrl.context.body();
    //if (!body.__mx || !body.__mx.press_events) {
    //    press_events(body);
    //}
    //ctrl.event_events = true;

    

}

module.exports = pressed_state;
},{"./press-events":58,"obext":382}],61:[function(require,module,exports){


/*


1. That it can be resized
2. How it can be resized

There may be a resizable type interface or set of expectations and functionality, but then different UIs to do the resizing.


autosizing perhaps
smart-size?
size-options?
size?
sizes?
display-modes? and sizes?
navigation modes too?
  eg popup-explore interface
need to separate the abstractions of the content itself and the structure its displayed in
  eg could show a tree as a tree component of through navigation of (virtual) pages.

maybe should have size-binding?
bind-size mixin.

bind mixin?
  binds one control to another
  so the size can depend on the amount of space it has available.
  defining the amount of size available or finding it in some cases 
    change those cases so the size gets bound rather than set just once.

bind-dimensions?

UI to enable the user to resize it, by integrating handles?
// Will use dimension and overlays in various ways to facilitate this.
//  Maybe work on this a bit later.

ui-resizable? or assumed.

Want really easy (top level) syntax for resizing and use of resize handles.

Movement of the resize handle (drag-like operation) causes window to resize, resize handle does not need to move explicitly through code if
it's positioned in the correct part of the window with existing CSS (or other position binding).

Keep this code relativel simple if possible.

Could have mode specifically for a BR fixed in the right place (part of / relative to the window) and respond to events on it.

Maybe a drag_like_events mixin???
Seems worth getting really explicit about what is being done and what is needed, where code can be common to various mixins
and pieces of functionality.

Drag_Like_Events or something like that drag_like_events mixin could provide the basis.
Handles mouse downs and gives the offset(s) from starting positions.

Does seem best to solve and use general case code for things like this.
Going by offset with the mousedown position seems like the right approach to take.

Maybe Drag_Offset_Events???
Really we want to know the offsets.

// want easy use of drag_like_events
//   does not need to be actually dragging (moving) something, could use drag_like_events to power resize handles.











*/

// Seem like quite a lot of different potential ways to do UI for resize.
//  This would be the place for them.

// This will take some cues from dragable, which is fairly comprehensive, while also providing a really simple API
//   to use it.

const Control = require('../html-core/control');

const drag_like_events = require('./drag_like_events');

const {tof} = require('lang-tools');


// Will also allow resizing with a 'frame' surrounding it.

const resizable = (ctrl, options = {resize_mode: 'br_handle'}) => {


  const extra_margin = options.extra_margin !== undefined ? options.extra_margin : 2;
  // And specify a minimum size here?
  //  Or size bounds? Could just specify lower size bounds.

  // Bounds as array? Bounds as a ctrl?


  // Size bounds as well as extent bounds.


  const {bounds} = options;
  const extent_bounds = options.extent_bounds || options.extent;

  const t_extent_bounds = tof(extent_bounds);

  // Default lower bounds of window size will help.


  let min_bound, max_bound;

  if (bounds) {
    [min_bound, max_bound] = bounds;
  }



  // And secondary bounds too...?
  // Such as not resizing so that it would extend (down or right or wherever) outside the bounds of a ctrl.
  //   Probably its container control

  // That is more like 'extent bounds' rather than size bounds.

  // Extend bounds being the a control.




  // if (extent_bounds instanceOf Control)....

  // ???

  // tof would be more foolproof for typing.
  

  // resize_method?
  // method?

  // resize_mode?
  //   br_handle may be one of the simplest to get working.
  //   may be all we need for Window right now.


  // borders-all-directions perhaps?
  //   maybe better with thicker borders, or accept 1, 2 or 3 pixels more, inside the borders?

  const {resize_mode} = options;


  const start_action = ['touchstart', 'mousedown'];

  let initial_size, initial_measured_pos_within_ctrl_bounds;

  // will disable css transitions for the duration of the drag_like_action



  if (resize_mode === 'br_handle') {

    if (ctrl.ctrl_relative) {




      // Check if it's already installed???

      if (ctrl.ctrl_br_resize_handle) {
        console.log('ctrl.ctrl_br_resize_handle already detected');
      } else {
        const ctrl_br_resize_handle = new Control({
          context: ctrl.context
        })
        ctrl_br_resize_handle.add_class('bottom-right');
        ctrl_br_resize_handle.add_class('resize-handle');
        ctrl_br_resize_handle.add('◢');

        // But does it have one already???
        ctrl.ctrl_relative.add(ctrl_br_resize_handle);
        ctrl_br_resize_handle.pre_activate();
        ctrl_br_resize_handle.activate();

        ctrl.ctrl_br_resize_handle = ctrl_br_resize_handle;

        drag_like_events(ctrl_br_resize_handle);
        ctrl_br_resize_handle.drag_like_events = true;

        let css_transition;

        ctrl_br_resize_handle.on('drag-like-action-start', () => {

          

          //console.log('e_drag_like_action_move', e_drag_like_action_move);
          //initial_size = ctrl.size;
          //css_transition = ctrl.dom.attributes.style.transition;

          // Looks like we need to bug fix this... not getting the transition style properly.
          //   Likely we want finer grain control over transitions.


          //console.log('1) css_transition', css_transition);

          // Would be worth setting the size bounds here...?

          //   Doubt it would be a significant perf hit to measure and calculate it on move...?
          //     Though that could be an option.

          //console.log('t_extent_bounds', t_extent_bounds);
          initial_size = ctrl.bcr()[2];

          // initial_ctrl_bounds_size ???
          // initial_measured_pos_within_ctrl_bounds perhaps....?




          if (t_extent_bounds === 'control') {
            // Determine what size the window is starting at....

            const ctrl_bcr = ctrl.bcr();
            const extent_bounds_ctrl_bcr = extent_bounds.bcr();

            const pos_offset = [ctrl_bcr[0][0] - extent_bounds_ctrl_bcr[0][0], ctrl_bcr[0][1] - extent_bounds_ctrl_bcr[0][1]];
            //console.log('pos_offset', pos_offset);

            // Then will need to work out how much remaining size is available....?

            //const ctrl_measured_size = ctrl_bcr[2];
            const extent_bounds_ctrl_measured_size = extent_bounds_ctrl_bcr[2];

            // work out amount of space remaining within the extent_bounds_ctrl

            //console.log('ctrl_measured_size', ctrl_measured_size);
            //console.log('extent_bounds_ctrl_measured_size', extent_bounds_ctrl_measured_size);

            

            const bounded_max_size = [extent_bounds_ctrl_measured_size[0] - pos_offset[0] - extra_margin, extent_bounds_ctrl_measured_size[1] - pos_offset[1] - extra_margin];

            //console.log('bounded_max_size', bounded_max_size);

            max_bound = bounded_max_size;


          }



          
          ctrl.add_class('no-transitions');

          // Strangely does not work.
          //.  Possibly was not connected properly to the dom element.
          //console.log('ctrl_br_resize_handle.dom.el', ctrl_br_resize_handle.dom.el);

          ctrl_br_resize_handle.add_class('resizing');
          //ctrl.dom.attributes.style.transition = 'none';

          // Improving the size property would help.
          //   Maybe could have and make use of a Control_Position_And_Size_Info_Helper ?




          //console.log('initial_size', initial_size);




        })


        ctrl_br_resize_handle.on('drag-like-action-move', e_drag_like_action_move => {
          //console.log('e_drag_like_action_move', e_drag_like_action_move);

          const {offset} = e_drag_like_action_move;

          // Then adjust the size....
          const new_size = [initial_size[0] + offset[0], initial_size[1] + offset[1]];
          //console.log('new_size', new_size);

          if (min_bound) {
            if (new_size[0] < min_bound[0]) new_size[0] = min_bound[0];
            if (new_size[1] < min_bound[1]) new_size[1] = min_bound[1];
          }
          if (max_bound) {
            if (new_size[0] > max_bound[0]) new_size[0] = max_bound[0];
            if (new_size[1] > max_bound[1]) new_size[1] = max_bound[1];
          }

          //if (t_extent_bounds === 'control') {
            // Check it's not extending past the extent_bounds bcr.
            //   Need to take translation into account too???




            
          //}

          ctrl.size = new_size;



        })

        ctrl_br_resize_handle.on('drag-like-action-end', e_drag_like_action_end => {
          //console.log('e_drag_like_action_move', e_drag_like_action_move);
          //ctrl.dom.attributes.style.transition = css_transition;
          ctrl_br_resize_handle.remove_class('resizing');
          ctrl.remove_class('no-transitions');

          //console.log('2) css_transition', css_transition);
          /*

          

          const {offset} = e_drag_like_action_move;

          // Then adjust the size....
          const new_size = [initial_size[0] + offset[0], initial_size[1] + offset[1]];
          //console.log('new_size', new_size);
          ctrl.size = new_size;

          */





        })

        

      }


      // Create a new resize handle control in there.

      



    } else {
      console.trace();
      throw 'NYI';
    }

  }







    // Respond to touch events.

    // generally want a 'press' event too.
    //  Could be a click, or a touch press.

    // Could raise a press or click event.
    //  Press could cover click and touch.
    //  Click could specifically be a mouse event to make least confusion / ambiguity long term.
    // Could have an emulate_clicks option.
    // Setting deletable to true or false...
    
    /*
    console.log('ctrl.delete', ctrl.delete);

    ctrl.delete = () => {

        // remove it from the DOM
        ctrl.remove();

        // raise a delete event
        
        ctrl.raise('delete');
        // Delete corresponding objects too.

    }
    */

    // Controls already have resize functionaliy
    //  Possibly move resizing here.

    // Should do more setting other controls as resize handles.

    
}

module.exports = resizable;
},{"../html-core/control":148,"./drag_like_events":52,"lang-tools":186}],62:[function(require,module,exports){
const {
    prop,
    field
} = require('obext');
const {each, is_array, is_def} = require('lang-mini');

// Listening to a pre-server-side-render or pre-ssr event would help with persisting some things.
// Maybe want some more specific view data model persistance.

// server-pre-render event I think.

// Being able to say a grid is selectable or has selectableness, ie the grid cells can be selected.

const selectable = (ctrl, ctrl_handle, opts) => {
    const setup_isomorphic = () => {
        const old_silent = ctrl.view.data.model.mixins.silent;
        ctrl.view.data.model.mixins.silent = true;
        ctrl.view.data.model.mixins.push({
            name: 'selectable'
        });
        ctrl.view.data.model.mixins.silent = old_silent;
        ctrl.on('change', e_change => {
            let {
                name,
                value
            } = e_change;
            if (name === 'selected') {
                if (value) {
                    ctrl.add_class('selected');
                } else {
                    ctrl.remove_class('selected');
                }
            };
            return true;
        });
    }
    setup_isomorphic();

    if (typeof document === 'undefined') {
        ctrl.on('server-pre-render', e => {
            //console.log('selectable server-pre-render');

            if (ctrl.selectable === true) {
                ctrl._fields = ctrl._fields || {};
                //ctrl._fields.selected = ctrl.selected;

                ctrl._fields.selectable = true;

                if (ctrl.selected === true) {
                    ctrl._fields.selected = true;
                }

            }

        })
    }

    if (ctrl.dom.el) {
        let select_toggle = false;
        let select_multi = false;
        let condition;
        let preventDefault = true;
        let selection_action = ['mousedown', 'touchstart'];

        const old_selectable = ctrl.selectable;


        if (old_selectable) {
            console.trace();
            throw 'NYI / Deprecated';
        } else {
            if (!opts) {
                if (ctrl_handle) {
                    if (!ctrl_handle.activate) {
                        opts = ctrl_handle;
                        ctrl_handle = undefined;
                    }
                }
            }
            if (opts) {
                if (opts.handle) {
                    ctrl_handle = opts.handle;
                }
                if (opts.select_toggle || opts.toggle) {
                    select_toggle = true;
                }
                if (opts.select_multi || opts.multi) {
                    select_multi = true;
                }
                if (opts.single) {
                    select_multi = false;
                }
                if (opts.selection_action) {
                    selection_action = opts.selection_action;
                }
                if (opts.condition) {
                    condition = opts.condition;
                }
                if (opts.preventDefault === false) {
                    preventDefault = false;
                }
            }
            ctrl_handle = ctrl_handle || ctrl;
            
            let click_handler = (e) => {
                if (ctrl.selectable && !ctrl.selection_scope && !ctrl.disabled) {
                    if (!condition || condition()) {
                        var ctrl_key = e.ctrlKey;
                        var meta_key = e.metaKey;
                        if (select_multi) {
                            if ((ctrl_key || meta_key)) {
                                ctrl.action_select_toggle();
                            } else {
                                if (select_toggle) {
                                    ctrl.action_select_toggle();
                                } else {
                                    ctrl.action_select_only();
                                }
                            }
                        } else {
                            if (select_toggle) {
                                if (ctrl.selected) {
                                    ctrl.deselect();
                                } else {
                                    ctrl.action_select_only();
                                }
                            } else {
                                ctrl.action_select_only();
                            }
                        }
                        if (preventDefault) {
                            e.preventDefault();
                        }
                    } else {
                        console.log('failed condition check');
                    }
                } else {
                }
            }
            let ss;
            const apply_all = ctrl => {
                let id = ctrl._id();
                ctrl.on('change', e_change => {
                    let n = e_change.name,
                        value = e_change.value;
                    let ss = ctrl.find_selection_scope();
                    if (n === 'selected') {
                        if (value === true) {
                            ctrl.add_class('selected');
                            if (ss) ss.map_selected_controls[id] = ctrl;
                        } else {
                            ctrl.remove_class('selected');
                            if (ss) ss.map_selected_controls[id] = null;
                        }
                    }
                    if (n === 'selectable') {
                        if (value === true) {
                                apply_active_selectable(ctrl);
                        } else {
                            if (typeof document === 'undefined') {
                            } else {
                                if (is_array(selection_action)) {
                                    selection_action.forEach(i => {
                                        ctrl_handle.off(i, click_handler);
                                    })
                                } else {
                                    ctrl_handle.off(selection_action, click_handler);
                                }
                                ctrl_handle.has_selection_click_handler = false;
                            }
                        }
                    }
                });
            }
            const apply_active_selectable = ctrl => {
                ctrl.deselect = ctrl.deselect || (() => {
                    ss = ss || ctrl.find_selection_scope();
                    if (ss) ss.deselect(ctrl);
                    ctrl.raise('deselect');
                });
                ctrl.select = ctrl.select || (() => {
                    ss = ss || ctrl.find_selection_scope();
                    if (ss) ss.select(ctrl);
                    ctrl.raise('select');
                });
                ctrl.action_select_only = ctrl.action_select_only || (() => {
                    ss = ss || ctrl.find_selection_scope();
                    if (ss) {
                        ss.select_only(ctrl);
                    } else {
                        each(ctrl.siblings, sibling => {
                            sibling.selected = false;
                        });
                        ctrl.selected = true
                    }
                });
                ctrl.action_select_toggle = ctrl.action_select_toggle || (() => {
                    ss = ss || ctrl.find_selection_scope();
                    ss.select_toggle(ctrl);
                });
                if (typeof document === 'undefined') {
                } else {
                    ctrl.once_active(() => {
                        if (!ctrl_handle.has_selection_click_handler) {
                            ctrl_handle.has_selection_click_handler = true;
                            if (Array.isArray(selection_action)) {
                                selection_action.forEach(i => {
                                    ctrl_handle.on(i, click_handler);
                                })
                            } else {
                                ctrl_handle.on(selection_action, click_handler);
                            }
                        }
                    });
                }
            }
            //if (!old_selectable) {
                field(ctrl, 'selected');
                field(ctrl, 'selectable');
                apply_all(ctrl);
            //};
            ctrl.on('activate', e => {
                if (ctrl.selectable) apply_all(ctrl);
            })

            //if (old_selectable !== undefined) {
            //    ctrl.selectable = old_selectable;
            //}
        }

        
    }
}
module.exports = selectable;
},{"lang-mini":379,"obext":382}],63:[function(require,module,exports){
const {
    prop,
    field
} = require('obext');

const deletable = require('./deletable');
let selected_deletable = (ctrl) => {
    //let selection_action = 'mousedown';
    // select on mousedown?
    deletable(ctrl);

    let old_selected_deletable = ctrl.selected_deletable;
    let click_handler = (e) => {

    }

    let press_handler = (event) => {
        const keyName = event.key;
        //console.log('event', event);
        // 46

        if (keyName === 'Delete') {
            //return;
            ctrl.delete();
            // 
        }
    }


    // once it's active.

    //ctrl.once_active...



    ctrl.on('change', e_change => {
        let {
            name,
            value
        } = e_change;
        if (name === 'selected') {

            // once it's activated.

            //console.log('selected_deletable selected value', value);

            ctrl.once_active(() => {
                if (value) {
                    //ctrl.add_class('selected');
                    document.addEventListener('keydown', press_handler, false);
                } else {
                    //ctrl.remove_class('selected');
                    document.removeEventListener('keydown', press_handler, false);
                }
            });

        };
        return true;

    });
    //});



    if (true) {
        // but it won't be defined.
        if (old_selected_deletable !== undefined) {
            ctrl.selected_deletable = old_selected_deletable;
        }
    }
}

module.exports = selected_deletable;
},{"./deletable":49,"obext":382}],64:[function(require,module,exports){
const {
    prop,
    field
} = require('obext');

let selected_resizable = (ctrl, ctrl_handle) => {
    //let selection_action = 'mousedown';
    // select on mousedown?

    let old_selected_resizable = ctrl.old_selected_resizable;
    let click_handler = (e) => {

    }

    let press_handler = (event) => {
        const keyName = event.key;
        console.log('event', event);

        // 46

        if (keyName === 'Control') {
            // do not alert when only Control key is pressed.
            return;
        }

        if (event.ctrlKey) {
            // Even though event.key is not 'Control' (e.g., 'a' is pressed),
            // event.ctrlKey may be true if Ctrl key is pressed at the same time.
            //alert(`Combination of ctrlKey + ${keyName}`);
        } else {
            //alert(`Key pressed ${keyName}`);
        }
    }

    ctrl.on('change', e_change => {
        let {
            name,
            value
        } = e_change;
        if (name === 'selected') {
            //console.log('selected value', value);


            ctrl.once_active(() => {
                if (value) {
                    //ctrl.add_class('selected');
                    document.addEventListener('keypress', press_handler, false);
                } else {
                    //ctrl.remove_class('selected');
                    document.removeEventListener('keypress', press_handler, false);
                }
            });


        };
        return true;
    });

    if (true) {
        // but it won't be defined.
        if (old_selectable !== undefined) {
            ctrl.selected_deletable = old_sselected_deletableelectable;
        }
    }
}

module.exports = selected_resizable;
},{"obext":382}],65:[function(require,module,exports){
/*
    Dragging creates a selection box.
*/
const {
    prop,
    field
} = require('obext');

const jsgui = require('../html-core/html-core');


const stringify = jsgui.stringify,
    each = jsgui.each,
    tof = jsgui.tof;
const Control = jsgui.Control;


//const v_subtract = jsgui.util.v_subtract;
//let ofs = e => [e.offsetX, e.offsetY];
/*
const coords_to_lt_wh = (coords_pair) => {
    //if ()
    let l,t,r,b,w,h, min = Math.min, max = Math.max;
    l = min(coords_pair[0][0], coords_pair[0][0]);
    r = max(coords_pair[0][0], coords_pair[0][0]);
    t = min(coords_pair[0][1], coords_pair[0][1]);
    b = max(coords_pair[0][0], coords_pair[0][0]);

    w = r - l;
    h = b - t;

    return [[l,t],[w,h]];
}
*/
const coords_to_lt_wh = coords_pair => {
    //if ()
    let l, t, r, b, w, h, min = Math.min,
        max = Math.max;
    //let h_pair = 
    l = min(coords_pair[0][0], coords_pair[1][0]);
    r = max(coords_pair[0][0], coords_pair[1][0]);
    t = min(coords_pair[0][1], coords_pair[1][1]);
    b = max(coords_pair[0][1], coords_pair[1][1]);

    w = r - l;
    h = b - t;

    return [
        [l, t],
        [w, h]
    ];
}

// a selectable class / control?
let selection_box_host = (ctrl) => {
    //console.log('selection_box_host', ctrl._id());
    //console.log('ctrl.select_unique', ctrl.select_unique);
    //console.trace();
    let click_handler = (e) => {
        //console.log('selectable click e', e);
        if (ctrl.selectable && !ctrl.selection_scope) {
            var ctrl_key = e.ctrlKey;
            var meta_key = e.metaKey;
            //if (ctrl.select_unique && (ctrl_key || meta_key)) {
            if ((ctrl_key || meta_key)) {
                ctrl.action_select_toggle();
            } else {
                ctrl.action_select_only();
            }
        }
        //e.stopPropagation();
    }
    field(ctrl, 'selection_box_host');
    ctrl.selection_box_host = true;
    // ctrl drag events

    // .wrap_activate
    //  finds the old activate function.

    // wraps it with a new one.



    // Or better to respond to activate.




    // wrap the activation function?
    let old_activate = ctrl.activate;
    ctrl.activate = function (spec) {
        if (old_activate) {
            old_activate.call(this, spec);
        }
        // and a selection scope?
        // drag anywhere in the document?
        // create box
        // update box
        // remove box
        let selection_box;
        let md_pos, mm_pos, md_offset_within_ctrl, mm_offset_within_ctrl;
        // selection scope
        //  get control positions...

        let isf;
        // ctrl all subcontrols.
        //let that = this;
        let nsb = this.new_selection_box = (pos) => {
            //console.log('this._id()', this._id());
            //console.log('ctrl', ctrl);
            this.add(selection_box = new Control({
                context: this.context,
                css: {
                    position: 'absolute'
                },
                'class': 'selection-box',
                pos: pos
            }));
            selection_box.activate();
            // need to be able to set coords.
            //  give it the coords, it words out which is the top etc
            // box from coords
            // l,t,w,h box
            // ltwh_from_coords
            // coords_to_lt_wh
            prop(selection_box, 'coords', e_change => {
                //console.log('e_change', e_change);
                let lt_wh = coords_to_lt_wh(e_change[0]);
                //console.log('* lt_wh', lt_wh + '');
                [selection_box.pos, selection_box.size] = lt_wh;
            });
            return selection_box;
        }
        //throw 'stop';
        ctrl.drag_events(md => {
            // md within uncovered control
            // a way to cancel the event too...
            console.log('md', md);
            let main_boxes = ctrl.$('.main-box');
            //console.log('main_boxes', main_boxes);
            //console.log('main_boxes.length', main_boxes.length);
            let do_begin_selection_box = true;

            if (md.target.tagName.toLowerCase() === 'span') {
                do_begin_selection_box = false;
            }

            if (do_begin_selection_box) {
                md_pos = md.pos;
                //console.log('***ctrl', ctrl);
                ctrl.find_selection_scope().deselect_all();

                //console.log('md', md);
                //console.log('md.pos', md.pos);
                //console.log('md.offset', md.offset);
                // offset of ctrl...
                // ctrl pos
                //console.log('ctrl.pos', ctrl.pos);

                // need the scroll position...
                //console.log('ctrl.el.scrollTop', ctrl.dom.el.scrollTop);
                //console.log('ctrl.el.parentNode.scrollTop', ctrl.dom.el.parentNode.scrollTop);
                //console.log('window.scrollY', window.scrollY);
                //console.log('ctrl.bcr()', ctrl.bcr());
                let ctrl_pos = ctrl.bcr()[0];

                // bcr plus window scroll
                // mf pos within control
                //console.log('ctrl_pos', ctrl_pos);
                md_offset_within_ctrl = v_subtract(md.pos, ctrl_pos);
                md_offset_within_ctrl[1] -= window.scrollY;
                md_pos[1] -= window.scrollY;
                //var el = ctrl.dom.el;
                //var elpos2 = [el.offsetLeft, el.offsetTop];

                // Search for the 'main-box' controls
                // dot for the css class

                isf = new jsgui.Intersection_Finder({
                    controls: main_boxes
                });

                isf.on('change', e_change => {
                    //console.log('isf e_change', e_change);
                    if (e_change.name === 'intersections') {
                        let [intersecting, newly_intersecting, previously_intersecting] = e_change.value;
                        each(newly_intersecting, ctrl => {
                            let sel = ctrl.closest(cmatch => {
                                //console.log('cmatch', cmatch);
                                return cmatch.selectable === true;
                            });
                            //console.log('sel', sel);
                            if (sel) sel.selected = true;
                        });
                        each(previously_intersecting, ctrl => {
                            let sel = ctrl.closest(match => match.selectable === true);
                            //console.log('sel', sel);
                            if (sel) sel.selected = false;
                        });
                        //each(previously_intersecting, ctrl => ctrl.selected = false);
                    }
                });
                let selection_box = nsb(md.pos);
                //console.log('selection_box', selection_box);
                if (selection_box) {

                }
                //selection_box.pos()
                // ctrl offset...
            } else {
                return false;
            }

        }, mm => {
            if (selection_box) {
                mm_pos = mm.pos;
                mm_pos[1] -= window.scrollY;
                let ctrl_pos = ctrl.bcr()[0];
                // subtract the scroll position
                // console.log('window.scrollY', window.scrollY);
                //console.log('ctrl_pos', ctrl_pos);
                //ctrl_pos[1] += window.scrollY;
                //console.log('2) window.scrollY', window.scrollY);
                mm_offset_within_ctrl = v_subtract(mm.pos, ctrl_pos);

                //console.log('mm_offset_within_ctrl', mm_offset_within_ctrl);
                //mm_offset_within_ctrl[1] -= window.scrollY;
                //;
                //let intersecting = isf.find_intersections(selection_box.coords = [md_offset_within_ctrl, mm_offset_within_ctrl]);
                //console.log('intersecting', intersecting);
                // could set a scroll offset...
                selection_box.coords = [md_offset_within_ctrl, mm_offset_within_ctrl];
                isf.coords = [md_pos, mm_pos];
            }
        }, mu => {
            //console.log('mu', mu);
            selection_box.remove();
            isf = null;
            //console.log('ofs(mu)', ofs(mu));
        });
    }
}

module.exports = selection_box_host;
},{"../html-core/html-core":149,"obext":382}],66:[function(require,module,exports){

// data_prop_date?
//  This sets up the 'date' property.
//  Very much a 'model' mixin.
//   Possibly will not be used. Will make .model and .view properties, likely through mixins.


// Date properties.


let lang = require('lang-tools');
let is_defined = lang.is_defined;

// obext instead.


// Maybe this is just to do with the data type controlled by the control.

let date = (ctrl, spec) => {

    // Respond to touch events.

    // generally want a 'press' event too.
    //  Could be a click, or a touch press.

    // Could raise a press or click event.
    //  Press could cover click and touch.
    //  Click could specifically be a mouse event to make least confusion / ambiguity long term.

    // Could have an emulate_clicks option.

    let _date, _year, _month, _day;

    let constructor = () => {
        // define the year, month, day properties
        // on activate, will respond to changes in them.

        Object.defineProperty(ctrl, `date`, {
            get() {
                return _date;
            },
            set(value) {
                let old = _date;
                _date = value;
                // Handling the change may be best here though.
                if (typeof document === 'undefined') {
                    ctrl._fields = ctrl._fields || {};
                    ctrl._fields['date'] = value;
                }
                ctrl.raise('change', {
                    'name': 'date',
                    'old': old,
                    //'new': _disabled,
                    'value': _date
                });
            },
            enumerable: true,
            configurable: false
        });

        Object.defineProperty(ctrl, `year`, {
            get() {
                return _year;
            },
            set(value) {
                let old = _year;
                _year = value;
                // Handling the change may be best here though.
                if (typeof document === 'undefined') {
                    ctrl._fields = ctrl._fields || {};
                    ctrl._fields['year'] = value;
                }
                ctrl.raise('change', {
                    'name': 'year',
                    'old': old,
                    //'new': _disabled,
                    'value': _year
                });
            },
            enumerable: true,
            configurable: false
        });

        Object.defineProperty(ctrl, `month`, {
            get() {
                return _month;
            },
            set(value) {
                let old = _month;
                _month = value;
                // Handling the change may be best here though.
                if (typeof document === 'undefined') {
                    ctrl._fields = ctrl._fields || {};
                    ctrl._fields['month'] = value;
                }
                ctrl.raise('change', {
                    'name': 'month',
                    'old': old,
                    //'new': _disabled,
                    'value': _month
                });
            },
            enumerable: true,
            configurable: false
        });

        Object.defineProperty(ctrl, `day`, {
            get() {
                return _day;
            },
            set(value) {
                let old = _day;
                _day = value;
                // Handling the change may be best here though.
                if (typeof document === 'undefined') {
                    ctrl._fields = ctrl._fields || {};
                    ctrl._fields['day'] = value;
                }
                ctrl.raise('change', {
                    'name': 'day',
                    'old': old,
                    //'new': _disabled,
                    'value': _day
                });
            },
            enumerable: true,
            configurable: false
        });


        if (is_defined(spec.year) && is_defined(spec.month)) {
            //console.log('are defined');
            ctrl.month = spec.month; // 0 indexed
            ctrl.year = spec.year;
        } else {
            let now = new Date();
            //console.log('now', now);
            ctrl.month = now.getMonth(); // 0 indexed
            ctrl.year = now.getFullYear();
        }

        Object.assign(ctrl, {
            next_month: () => {
                if (ctrl.month === 11) {
                    ctrl.month = 0;
                    ctrl.year = ctrl.year + 1;
                } else {
                    ctrl.month = ctrl.month + 1;
                }
                ctrl.refresh_month_view();
            },
            previous_month: () => {
                if (ctrl.month === 0) {
                    ctrl.month = 11;
                    ctrl.year = ctrl.year - 1;
                } else {
                    ctrl.month = ctrl.month - 1;
                }
                ctrl.refresh_month_view();
            },
            next_year: () => {
                ctrl.year = ctrl.year + 1;
                ctrl.refresh_month_view();
            },
            previous_year: () => {
                ctrl.year = ctrl.year - 1;
                ctrl.refresh_month_view();
            }
        });

    }

    let activate = () => {

    }

    if (spec) {
        constructor();
    } else {
        activate();
    }

}

module.exports = date;
},{"lang-tools":186}],67:[function(require,module,exports){




const controls = {
    Active_HTML_Document: require('./organised/1-standard/5-ui/Active_HTML_Document'),
    Arrow_Button: require('./organised/0-core/1-advanced/vector/arrow-button'),
    //Audio_Player: require('./audio-player'),
    Audio_Volume: require('./organised/1-standard/5-ui/audio-volume'),
    Button: require('./organised/0-core/0-basic/0-native-compositional/button'),
    Cell: require('./organised/0-core/0-basic/1-compositional/Cell'),
    // Maybe more advanced?
    Context_Menu: require('./organised/0-core/0-basic/1-compositional/context-menu'),
    //Control: 
    Color_Grid: require('./organised/0-core/0-basic/1-compositional/color-palette'),
    Color_Palette: require('./organised/0-core/0-basic/1-compositional/color-palette'),
    Checkbox: require('./organised/0-core/0-basic/0-native-compositional/checkbox'),
    Combo_Box: require('./organised/0-core/0-basic/1-compositional/combo-box'),
    Dropdown_Menu: require('./organised/0-core/0-basic/1-compositional/Dropdown_Menu'),
    // Not using (data-)connected controls.
    //Data_Grid: require('./connected/data-grid'),
    File_Upload: require('./organised/0-core/0-basic/0-native-compositional/file-upload'),
    // maybe 0-basic/0-layout?
    //  A layout control may be / need to be displayed a little differently.
    Grid: require('./organised/0-core/0-basic/1-compositional/grid'),
    Grid_Cell: require('./organised/0-core/0-basic/1-compositional/grid').Cell,
    Horizontal_Menu: require('./organised/1-standard/5-ui/horizontal-menu'),
    Horizontal_Slider: require('./organised/1-standard/5-ui/horizontal-slider'),
    //Data_Item: require('./data-item'),
    Data_Row: require('./organised/1-standard/4-data/data-row'),
    Date_Picker: require('./organised/0-core/0-basic/0-native-compositional/date-picker'),
    Dropdown_List: require('./organised/0-core/0-basic/0-native-compositional/dropdown-list'),
    // Exclude the connected ones for the moment. Moment passed.
    // May not need to actually be 'connected'?
    //  Or other controls may get data connections too.
    File_Tree: require('./organised/1-standard/5-ui/file-tree'),
    File_Tree_Node: require('./organised/1-standard/5-ui/file-tree-node'),
    Icon: require('./organised/0-core/0-basic/0-native-compositional/icon'),
    Item: require('./organised/0-core/0-basic/1-compositional/item'),
    Item_Selector: require('./organised/0-core/0-basic/1-compositional/item-selector'),
    //Item_View: require('./old/item-view'),
    Left_Right_Arrows_Selector: require('./organised/1-standard/2-misc/left-right-arrows-selector'),
    //Vector: require('./vector'),
    Line_Chart: require('./organised/1-standard/5-ui/line-chart'),
    List: require('./organised/0-core/0-basic/1-compositional/list'),
    // could be in forms / standard forms.
    Login: require('./organised/0-core/1-advanced/login'),
    //Media_Scrubber: require('./media-scrubber'),
    Menu_Node: require('./organised/0-core/0-basic/1-compositional/menu-node'),
    Modal: require('./organised/1-standard/6-layout/modal'),
    Month_View: require('./organised/0-core/0-basic/1-compositional/month-view'),
    //Multi_Document_Interface: require('./multi-document-interface'),
    Multi_Layout_Mode: require('./organised/1-standard/6-layout/app/multi-layout-mode'),
    //Object_Editor: require('./editor/object'),
    Panel: require('./organised/1-standard/6-layout/panel'),
    Plus_Minus_Toggle_Button: require('./organised/0-core/0-basic/1-compositional/plus-minus-toggle-button'),
    // More advanced functionality - may require more work to keep it with the right APIs.
    Popup_Menu_Button: require('./organised/0-core/1-advanced/popup-menu-button'),
    Radio_Button: require('./organised/0-core/0-basic/0-native-compositional/radio-button'),
    Radio_Button_Group: require('./organised/0-core/0-basic/1-compositional/radio-button-group'),
    //Resize_Handle: require('./organised/0-core/0-basic/_resize-handle'),
    Scroll_View: require('./organised/0-core/0-basic/1-compositional/scroll-view'),
    Scrollbar: require('./organised/0-core/0-basic/1-compositional/scrollbar'),
    Search_Bar: require('./organised/1-standard/5-ui/search-bar'),
    Select_Options: require('./organised/0-core/0-basic/0-native-compositional/Select_Options'),
    Single_Line: require('./organised/1-standard/6-layout/single-line'),
    Standard_Web_Page: require('./organised/1-standard/3-page/standard-web-page'),
    Start_Stop_Toggle_Button: require('./organised/1-standard/5-ui/start-stop-toggle-button'),
    String_Span: require('./organised/0-core/1-advanced/string-span'),
    Tabbed_Panel: require('./organised/1-standard/6-layout/tabbed-panel'),
    Text_Field: require('./organised/0-core/0-basic/1-compositional/Text_Field'),
    Text_Item: require('./organised/0-core/0-basic/1-compositional/text-item'),
    Text_Input: require('./organised/0-core/0-basic/0-native-compositional/Text_Input'),
    Tile_Slider: require('./organised/1-standard/6-layout/tile-slide'),
    // May be moved to vector?
    Timespan_Selector: require('./organised/0-core/0-basic/1-compositional/timespan-selector'),
    Title_Bar: require('./organised/1-standard/6-layout//title-bar'),
    Titled_Panel: require('./organised/1-standard/6-layout/titled-panel'),
    Toggle_Button: require('./organised/0-core/0-basic/1-compositional/toggle-button'),
    Toolbox: require('./organised/1-standard/5-ui/toolbox'),
    Tree: require('./organised/1-standard/5-ui/tree'),
    Tree_Node: require('./organised/1-standard/5-ui/tree-node'),
    Vertical_Expander: require('./organised/1-standard/6-layout/vertical-expander'),
    Window: require('./organised/1-standard/6-layout/window'),//,
    //mx: require('../control_mixins/mx')
    Indicator: require('./organised/0-core/0-basic/1-compositional/Indicator'),
    Status_Indicator: require('./organised/0-core/0-basic/1-compositional/Status_Indicator'),
    Validation_Status_Indicator: require('./organised/0-core/0-basic/1-compositional/Validation_Status_Indicator')
}

// a show_validation_status mixin perhaps???
// though having a place in the control where it can display the validation status would be nice too.
//   The validation status of the view.model
//     view.model.validate perhaps ....?

// Though having the view model copy the data model, including data type and validation function.

//   Maybe do more applying validation status to Text_Input too?
//   Maybe make a control that contains both the DMVM Control as well as a validation status indicator.

// Being able to get a validation status indicator there for a control with as little top level code as possible will help.

// Could definitely do with improved html / xhtml like control parsing and composition.
//  Done the basics of it, may need to improve it to cover more cases.
//  Can use this to cut down on composition code.

// compose, render, activate, modify

module.exports = controls;
},{"./organised/0-core/0-basic/0-native-compositional/Select_Options":68,"./organised/0-core/0-basic/0-native-compositional/Text_Input":69,"./organised/0-core/0-basic/0-native-compositional/button":70,"./organised/0-core/0-basic/0-native-compositional/checkbox":71,"./organised/0-core/0-basic/0-native-compositional/date-picker":72,"./organised/0-core/0-basic/0-native-compositional/dropdown-list":73,"./organised/0-core/0-basic/0-native-compositional/file-upload":74,"./organised/0-core/0-basic/0-native-compositional/icon":75,"./organised/0-core/0-basic/0-native-compositional/radio-button":76,"./organised/0-core/0-basic/1-compositional/Cell":77,"./organised/0-core/0-basic/1-compositional/Dropdown_Menu":78,"./organised/0-core/0-basic/1-compositional/Indicator":79,"./organised/0-core/0-basic/1-compositional/Status_Indicator":80,"./organised/0-core/0-basic/1-compositional/Text_Field":81,"./organised/0-core/0-basic/1-compositional/Validation_Status_Indicator":82,"./organised/0-core/0-basic/1-compositional/color-palette":84,"./organised/0-core/0-basic/1-compositional/combo-box":85,"./organised/0-core/0-basic/1-compositional/context-menu":86,"./organised/0-core/0-basic/1-compositional/grid":87,"./organised/0-core/0-basic/1-compositional/item":89,"./organised/0-core/0-basic/1-compositional/item-selector":88,"./organised/0-core/0-basic/1-compositional/list":90,"./organised/0-core/0-basic/1-compositional/menu-node":91,"./organised/0-core/0-basic/1-compositional/month-view":92,"./organised/0-core/0-basic/1-compositional/plus-minus-toggle-button":93,"./organised/0-core/0-basic/1-compositional/radio-button-group":94,"./organised/0-core/0-basic/1-compositional/scroll-view":95,"./organised/0-core/0-basic/1-compositional/scrollbar":96,"./organised/0-core/0-basic/1-compositional/text-item":97,"./organised/0-core/0-basic/1-compositional/timespan-selector":98,"./organised/0-core/0-basic/1-compositional/toggle-button":99,"./organised/0-core/1-advanced/login":100,"./organised/0-core/1-advanced/popup-menu-button":101,"./organised/0-core/1-advanced/string-span":102,"./organised/0-core/1-advanced/vector/arrow-button":103,"./organised/1-standard/2-misc/left-right-arrows-selector":104,"./organised/1-standard/3-page/standard-web-page":105,"./organised/1-standard/4-data/data-row":107,"./organised/1-standard/5-ui/Active_HTML_Document":108,"./organised/1-standard/5-ui/audio-volume":109,"./organised/1-standard/5-ui/file-tree":111,"./organised/1-standard/5-ui/file-tree-node":110,"./organised/1-standard/5-ui/horizontal-menu":112,"./organised/1-standard/5-ui/horizontal-slider":113,"./organised/1-standard/5-ui/line-chart":114,"./organised/1-standard/5-ui/search-bar":115,"./organised/1-standard/5-ui/start-stop-toggle-button":116,"./organised/1-standard/5-ui/toolbox":117,"./organised/1-standard/5-ui/tree":119,"./organised/1-standard/5-ui/tree-node":118,"./organised/1-standard/6-layout//title-bar":126,"./organised/1-standard/6-layout/app/multi-layout-mode":120,"./organised/1-standard/6-layout/modal":121,"./organised/1-standard/6-layout/panel":122,"./organised/1-standard/6-layout/single-line":123,"./organised/1-standard/6-layout/tabbed-panel":124,"./organised/1-standard/6-layout/tile-slide":125,"./organised/1-standard/6-layout/titled-panel":127,"./organised/1-standard/6-layout/vertical-expander":128,"./organised/1-standard/6-layout/window":129}],68:[function(require,module,exports){
const jsgui = require('../../../../../html-core/html-core');
const {Control, Control_Data, Control_View, Data_Object, is_array, is_arr_of_strs, each} = jsgui;
const {field} = require('obext');
class Select_Options extends Control {
    constructor(spec) {
        spec.__type_name = spec.__type_name || 'select_options';
        spec.tag_name = 'select';
        super(spec);
        const {context} = this;
        const construct_synchronised_data_and_view_models = () => {
            this.data = new Control_Data({context})
            if (spec.data && spec.data.model) {
                this.data.model = spec.data.model;
            } else {
                this.data.model = new Data_Object({context});
                field(this.data.model, 'value');
                field(this.data.model, 'options');
            }
            this.view = new Control_View({context})
            if (spec.view && spec.view.data.model) {
                this.view.data.model = spec.view.data.model;
            } else {
                this.view.data.model = new Data_Object({context});
                field(this.view.data.model, 'value');
                field(this.view.data.model, 'options');
            }
            this.data.model.on('change', e => {
                const {name, value, old} = e;
                if (name === 'value') {
                    if (value !== old) {
                        this.view.data.model.value = value;
                    }
                } else if (name === 'options') {
                    if (value !== old) {
                        this.view.data.model.options = value;
                    }
                }
            });
            this.view.data.model.on('change', e => {
                const {name, value, old} = e;
                if (name === 'value') {
                    if (value !== old) {
                        this.data.model.value = value;
                        if (this.dom.el) {
                            this.dom.el.value = value;
                        }
                    }
                } else if (name === 'options') {
                    if (value !== old) {
                        this.data.model.options = value;
                    }
                }
            });
        }
        construct_synchronised_data_and_view_models();
        if (spec.options) {
            this.data.model.options = spec.options;
        }
        if (!spec.el) {
            this.compose();
        }
    }
    activate() {
        if (!this.__active) {
            super.activate();
            const {dom} = this;
            const activate_view_model_to_dom_model_sync = () => {
                this.add_dom_event_listener('change', e => {
                    console.log('dom.el.value', dom.el.value);
                    this.view.data.model.value = dom.el.value;
                });
            }
            activate_view_model_to_dom_model_sync();
		}
	}
    compose() {

        // The options may really be within the view.ui object????
        

        const {context} = this;
        const dm_options = this.data.model.options;
        //console.log('Select_Options compose dm_options:', dm_options);
        if (is_array(dm_options)) {
            if (is_arr_of_strs(dm_options)) {
                console.log('dm_options is an array of strings');
                each(dm_options, str_option => {
                    const ctrl_option = new jsgui.option({
                        context
                    });
                    ctrl_option.dom.attributes.value = str_option;
                    ctrl_option.add(str_option);
                    this.add(ctrl_option);
                })
            }
        }
    }
}
module.exports = Select_Options;
},{"../../../../../html-core/html-core":149,"obext":382}],69:[function(require,module,exports){
const jsgui = require('../../../../../html-core/html-core');
var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof;
const {Control, Control_Data, Control_View, Data_Object, Data_Model, Data_Value} = jsgui;
const {prop, field} = require('obext');

// Late 2023 - not so much code.
//   Do want to make use of view.data.model syntax.
//     Separate to for example view.data.ui.options.model
//   Be really explicit with what it's about, but allow for shortened syntax when it's clear(er) what it's doing.

// May see about making this a Data_Model_View_Model_Control (later), but this is quite concise right now without the comments and
//   empty lines.

// Will also make a new version of Text_Input.
//   Want some kind of specification of what data it models / represents.
//   Maybe just say String somewhere.
// ctrl.data.type = String perhaps.
//  data_type: String possibly.


// Then some means to sync this data with the value in the DOM.

// view.ll.model???


//   Maybe just make it the view model for the moment???
//   Does seem worth being able to have (at least) 2 levels of view.data.model




// And Text_Item too...
//   Seems a bit like Text_Input but possibly more flexible.




// Need to do more basic work on Data_Value of data_type String
//   and then could make some easy system / API for specifying maxLength. It could be implemented using a more complex
//   constraint though.


// data_value.constraint(s)

// data_value.constraints.add(new Constraint())
// data_value constraints being separate to the data type.


// Definitely has a View_Model.
// Possibly has a separate Data_Model.

// The syncing code is not actually all that complex on this level.
//   May make some functions to get it working with much less code, but later on once patterns are clear.


class Text_Input extends Control {
    constructor(spec) {


        spec.__type_name = spec.__type_name || 'text_input';
        spec.class = 'text-input';


        super(spec);
        const {context} = this;

        if (spec.placeholder) this.placeholder = spec.placeholder;
        if (!spec.el) {
            //this.compose_text_input();
        }


        // Likely to need improved client-side data coherence.
        //   Worth approaching it step-by-step.



        // But actually want to set up syncing between the view model and the dom element value.

        //console.log('this.view.data', this.view.data);


        //console.log('this.view.data.model', this.view.data.model);


        // not so sure about .ui.ll.data.model.

        // a ui ll dm could make sense.
        //console.log('this.view.ll.data.model', this.view.ll.data.model);

        //console.log('this.view.ll.data.model', this.view.ll.data.model);

        // 3 models, multi-sync.... - Maybe that could be added in somehow.
        //   Maybe need 3 models only in some cases.
        //   Maybe need 0 in some cases?
        //   For the moment, see what can be done with the 2 models system, making it standard in some ways, better supported.

        // Maybe the view model of the parent control gets synced with the data model of the subcontrol.
        //   








        const view_data_model_change_handler = e => {
            const {name, value, old} = e;

            //console.log('Text_Input view data model change e:', e);

            //console.log('Text_Input view_data_model_change_handler [old, value]', [old, value]);

            if (name === 'value') {
                //console.log('Text_Input pre set dom attributes value to:', value);
                //console.log('tof(value)', tof(value));


                //this.dom.attributes.value = value;

                //console.log('!!this.dom.el', this.dom.el);

                if (this.dom.el) {
                    //this.dom.el.setAttribute('value', value + '');
                    this.dom.el.value = value + '';
                }


                //this.view.ll.data.model.value = value;

                this.data.model.value = value;

                // and update the view.ui.ll.data.model....

            }

        };

        //console.log('this.view.data', this.view.data);
        this.view.data.model.on('change', view_data_model_change_handler);

        this.view.data.on('change', e => {
            const {name, value, old} = e;
            if (name === 'model') {
                if (old instanceof Data_Model) {
                    old.off('change', view_data_model_change_handler);
                }
                value.on('change', view_data_model_change_handler);
            }
        });



        /*

        const view_ui_ll_data_model_change_handler = e => {
            const {name, value, old} = e;

            //console.log('Text_Input view data model change e:', e);

            //console.log('Text_Input view_data_model_change_handler [old, value]', [old, value]);

            if (name === 'value') {
                //this.dom.attributes.value = value;
                this.dom.attributes.value = value;
                this.view.data.model.value = value;
                

                // and update the view.ui.ll.data.model....



            }
        }

        this.view.ui.ll.data.model.on('change', view_ui_ll_data_model_change_handler);
        this.view.ui.ll.data.on('change', e => {
            const {name, value, old} = e;
            if (name === 'model') {
                if (old instanceof Data_Model) {
                    old.off('change', view_ui_ll_data_model_change_handler);
                }
                value.on('change', view_ui_ll_data_model_change_handler);
            }
        });
        */

        /*
        const view_ll_data_model_change_handler = e => {
            const {name, value, old} = e;

            //console.log('Text_Input view data model change e:', e);

            //console.log('Text_Input view_data_model_change_handler [old, value]', [old, value]);

            if (name === 'value') {
                //this.dom.attributes.value = value;

                // can it accept that new value???

                //console.log('view_ll_data_model_change_handler [old, value]', [old, value]);

                const change_attempt = this.view.data.model.attempt_set_value(value);
                

                console.log('change_attempt', change_attempt);

                if (change_attempt.success === true) {
                    //this.view.data.model.value = value;
                    this.dom.attributes.value = value;



                } else {


                    //this.view.ll.data.model.value = old;
                    //  not sure this has been set to a value of the right type (str or int).

                    //this.dom.attributes.value = old;

                    // or directly set the dom el???
                    //this.dom.el.value = old;





                    // Set it back to the old value....



                    // undo it....

                    //console.trace();
                    console.log('need to change back to the old value');
                    console.log('[name, value, old]', [name, value, old]);
                    throw 'NYI';
                }


                

                
                

                // and update the view.ui.ll.data.model....



            }
        }

        this.view.ll.data.model.on('change', view_ll_data_model_change_handler);
        this.view.ll.data.on('change', e => {
            const {name, value, old} = e;
            console.log('this.view.ll.data change e:', e);
            if (name === 'model') {
                if (old instanceof Data_Model) {
                    old.off('change', view_ll_data_model_change_handler);
                }
                value.on('change', view_ll_data_model_change_handler);
            }
        });
        */



        const data_model_change_handler = e => {
            const {name, value, old} = e;
            //console.log('Text_Input data_model_change_handler e:', e);
            if (name === 'value') {
                //this.dom.attributes.value = value;
                this.view.data.model.value = value;
            }

        };

        this.data.model.on('change', data_model_change_handler);

        // Maybe have this already automatically from the mixin.

        const setup_handle_data_model_itself_changing = () => {
            this.data.on('change', e => {
                const {name, value, old} = e;
                //console.log('Text_Input .data change e:', e);
                if (name === 'model') {



                    if (old instanceof Data_Model) {
                        old.off('change', data_model_change_handler);
                    }

                    if (value instanceof Data_Model) {
                        value.on('change', data_model_change_handler);
                    }

                    
                }
            })
        }
        setup_handle_data_model_itself_changing();

        //console.log('Text_Input constructor this.data.model.value', this.data.model.value);

        if (this.data.model.value !== undefined) {
            this.view.data.model.value = this.data.model.value;
        }

        if (spec.value) {
            // Sets the .data.model.value, which in turn sets the .view.data.model.value, which in turn sets the dom.attributes,
            //   which then sets it in the live element if active on the client, or in the rendering.

            // .value will be a shortcut.



            //this.value = spec.value;

            this.data.model.value = spec.value; // more explicit here.



            // Will need to also work with the view ui ll data model.
            //   Maybe only have an optional view data model or stack of them.


        }

        this.dom.tagName = 'input';
        this.dom.attributes.type = 'input';
        //this.dom.attributes.value = this.value;

        //console.log('Text_Input end of constructor this.view.ui.ll.data.model:', this.view.ui.ll.data.model);
        //console.log('Text_Input end of constructor this.view.data.model:', this.view.data.model);
        //console.log('this.view.ll.data.model.value', this.view.ll.data.model.value);

    }


    get value() {

        return this.data.model.value;
    }
    set value(v) {


        this.data.model.value = v;
    }

    /*
    compose_text_input() {

        // More like the DOM settings rather than composition.

        

        // And it's placeholder text
        //   That's not part of the data model.
        //   Maybe it's the presentation data model? Presentation model?



        // ui.data.model perhaps....
        // ui.model perhaps???
        //   want some kind of consistency to calling things data models.


        //   And would define types there.
        


        // ui is the presentation basically.





        if (this.placeholder) this.dom.attributes.placeholder = this.placeholder;


    }
    */

    // A ll getter for the string value???

    // ll_value???
    // ll_value_type???


    activate() {
        if (!this.__active) {
            super.activate();
            const {dom} = this;




            // Maybe set the view.ui.ll.data.model.value instead....



            // sync_dom_changes_to_view_data_model....???

            // Later will have some lower level code to set these things up better.

            //console.log('dom.el.value', dom.el.value);

            //console.log('this.view.data.model', this.view.data.model);
            //console.log('this.view.data.model.value', this.view.data.model.value);

            this.view.data.model.value = dom.el.value;

            //console.log('this.view.data.model.value', this.view.data.model.value);


            const activate_sync_dom_to_view_ui_ll_data_model = () => {
                const dm = this.view.ui.ll.data.model;

                this.add_dom_event_listener('change', e => {
                    dm.value = dom.el.value;
                });
                this.add_dom_event_listener('keypress', e_keypress => {
                    dm.value = dom.el.value;
                });
                this.add_dom_event_listener('keyup', e_keyup => {
                    dm.value = dom.el.value;
                });
                this.add_dom_event_listener('keydown', e_keydown => {
                    dm.value = dom.el.value;
                });
            }
            //activate_sync_dom_to_view_ui_ll_data_model();

            const handle_change_event = e => {

                //console.log('Text_Input DOM handle_change_event');

                //console.log('dom.el.value', dom.el.value);
                this.view.data.model.value = dom.el.value;
            }

            const activate_sync_dom_to_view_ll_data_model = () => {
                //console.log('activate_sync_dom_to_view_ll_data_model');
                //const dm = this.view.ll.data.model;

                this.add_dom_event_listener('change', e => {
                    handle_change_event(e);
                });
                this.add_dom_event_listener('keypress', e => {
                    handle_change_event(e);
                });
                this.add_dom_event_listener('keyup', e => {
                    handle_change_event(e);
                });
                this.add_dom_event_listener('keydown', e => {
                    handle_change_event(e);
                });
            }
            activate_sync_dom_to_view_ll_data_model();
        }
    }
}
module.exports = Text_Input;

},{"../../../../../html-core/html-core":149,"obext":382}],70:[function(require,module,exports){
const jsgui = require('../../../../../html-core/html-core');

// This may be a simple one to include .view.model but no .data.model (perhaps???)

// It does not really deal with / interact with data in a model itself, though it itself could do with a .view.ui.data.model.

// no view.data.model though....

// view.ui.data.model would be a decent place to hold an abstraction about what kind of presentation options the control has.

// view.ui.data.model.size for example.
//    could even be a string like 'x-small', 'micro', 'normal', 'compact', 'large', 'fully-expanded'???, 'very-large'.
//      or an enumeration of strings / values like that.
// That would be a level further abstracted from the DOM.
//   Would want to listen to that property change to sync with other parts of the (inner control) system.

// .view.ui.data.model.icon ????
//    By putting things behind these various objects, can be as clear as possible about them, if it's found there is too much typing,
//      could even make a higher level interface on top of this, could simplify access to it.

// Eg setting ctrl.size automatically sets ctrl.view.ui.data.model.size.



var Control = jsgui.Control;

class Button extends Control {
    constructor(spec = {}, add, make) {
        spec.__type_name = spec.__type_name || 'button';
        spec.tag_name = 'button';
        super(spec);
        this.add_class('button');
        if (spec.text || spec.label) {
            this.text = spec.text || spec.label;
        }
        if (!spec.el) {
            this.compose_button();
        }
    }
    'compose_button'() {
        if (this.text) {
            this.add(this.text);
        }
    }
    'activate'() {
        super.activate();
    }
}
module.exports = Button;

if (require.main === module) {
    class London_Button extends Button {
        constructor(spec = {}, add, make) {
            // Call the superclass constructor with the spec, add, and make arguments.
            spec.text = "London, England";
            super(spec, add, make);
    
            // Set the text property of the London_Button to "London, England".
            //this.text = "London, England";
        }
    }
    const lbtn = new London_Button();
    console.log(lbtn.all_html_render());
}
},{"../../../../../html-core/html-core":149}],71:[function(require,module,exports){
/**
 * Created by James on 04/08/2014.
 */

const jsgui = require('../../../../../html-core/html-core');
//var Horizontal_Menu = require('./horizontal-menu');

var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof, is_defined = jsgui.is_defined;
var Control = jsgui.Control;
var group = jsgui.group;


var fields = {
    'name': String,
    'text': String,
    'value': String,
    'checked': Boolean
};
// Want better way(s) to hook up fields like this in controls / data objects.

// Data objects should probably be able to handle fields.
//   Though rendering should also render these fields as their own specific attribute data-jsgui-fields



class Checkbox extends Control {
    constructor(spec, add, make) {

        super(spec);
        this.__type_name = 'checkbox';

        this.add_class('checkbox');
        const context = this.context;

        if (!spec.abstract && !spec.el) {
            const name = this.name;

            // Will need to render its ID in the DOM.

            const html_check = new Control({
                'context': context
            });

            html_check.dom.tagName = 'input';
            html_check.dom.attributes.type = 'checkbox';
            html_check.dom.attributes.name = name;
            html_check.dom.attributes.id = html_check._id();

            //html_check.set('dom.tagName', 'input');
            //html_check.set('dom.attributes.type', 'checkbox');
            //html_check.set('dom.attributes.name', name);
            //html_check.set('dom.attributes.id', html_radio._id());

            var html_label = new Control({
                'context': context,
                
            });
            html_label.dom.tagName = 'label';

            if (is_defined(spec.text)) {
                html_label.add(spec.text);
            } else {
                if (is_defined(spec.label?.text)) html_label.add(spec.label.text);
            }
            

            //html_label.set('dom.tagName', 'label');
            //console.log('that._', that._);


            //var text_value = this.get('text').value();

            
            html_label.dom.attributes.for = html_check._id();
            //html_label.set('dom.attributes.for', html_check._id());

            this.add(html_check);
            this.add(html_label);



            //this.set('check', html_check);
            //this.set('label', html_label);


            //html_radio.set('dom.attributes.type', 'radio');

            this._ctrl_fields = this._ctrl_fields || {};

			this._ctrl_fields.check = html_check;
            this._ctrl_fields.label = html_label;

            // ._fields perhaps....
            
            /*
            this.set('dom.attributes.data-jsgui-fields', stringify({
                'value': this.value
            }).replace(/"/g, "[DBL_QT]").replace(/'/g, "[SNG_QT]"));

            */ 

            this._fields = this._fields || {};

			if (is_defined(this.value)) this._fields.value = this.value;


        }

    }
    //'resizable': function() {
    //},
    'activate'() {

        if (!this.__active) {
            super.activate();

            var html_check = this.check;
            var el_checkbox = html_check.dom.el;//???
            var label = this.label;
            //var that = this;

            //var el = this.dom.el;
            //

            // No, refer specifically to the radio button element's control.

            // Changes upon becoming checked?
            html_check.on('change', e_change => {
                console.log('el_radio.checked', el_radio.checked);

                // Track the old values here? Could help the 'change' event.

                //if (el_radio.checked) {
                    this.raise('change', {
                        name: 'checked',
                        value: el_checkbox.checked
                    });
                //}

                // But have it updated in the data model...?

                // Specification of the data model and the view model as a pair and have the system work out how to sync them properly.
                //   Define the data, define how the data model can vary, define how those variations can be displayed.
                //     Then use that to create the view model, use that to create the view.

            });

            // Need to listen for DOM change events. That will chage the value.
            //  The checked value true or false.

        }
        //

    }
};

Checkbox.css = `
.checkbox input + label {
    margin-left: 6px;
}
`

module.exports = Checkbox;
},{"../../../../../html-core/html-core":149}],72:[function(require,module,exports){
const jsgui = require('../../../../../html-core/html-core');
//const stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof;
const {Control, Control_Data, Control_View, Data_Object} = jsgui;
const {field} = require('obext');

// 2023 - Initial support for the data.model and view.model system. Compact code, but want to make it more compact and idiomatic.

// So it's view.data.model for the moment.
//   There could be other view models too, such as view.ui.model ????
//     As in the scroll position?
//     view.ui.data.model even ???
//      for the moment, use more nested and longwinded syntax.
//      Will allow more future flexibility, and clarity when describing / writing the app(s).

// Incorporate more options / settings into these.
//   Like for a Window control, view.ui.data.model could help.
//     Meaning data such as it's position, height, width.
//       Could then use similar mechanisms for persisting and sharing that data, when needed.

// A more complex underlying system for representing data representations would help.







class Date_Picker extends Control {
    constructor(spec) {
        spec.__type_name = spec.__type_name || 'date_picker';
        super(spec);
        this.add_class('date-picker');
        this.dom.tagName = 'input';
        this.dom.attributes.type = 'date';
        const {context} = this;
        if (!spec.el) {
            this.compose_date_picker();
        }

        // Could be part of a mixin???
        //   Not quite yet though...

        // May want the 'draggable' mixin to work on the level of ctrl.view.ui.options.data.model.draggable = true??
        //   A ui options model could be useful.
        //   or just view.ui.model rather than view.data.model. ctrl.view.options ....???

        // Do make them deeply nested so that they can be for very specific things.

        // Maybe work on integrating .view.ui.data.model into classes at a lower level, for controlling some presentation things,
        //   such as ctrl.view.ui.data.model.background....

        // And could make (common / general purpose) shortcuts to them.
        //   Could make it clearer about how to write code (functions) to deal with the changes and syncronisation.



        const construct_synchronised_data_and_view_models = () => {
            this.data = new Control_Data({context})
            if (spec.data && spec.data.model) {
                this.data.model = spec.data.model;
            } else {
                this.data.model = new Data_Object({context});
                field(this.data.model, 'value');
            }
            this.view = new Control_View({context})
            if (spec.view && spec.view.data.model) {
                this.view.data.model = spec.view.data.model;
            } else {
                this.view.data.model = new Data_Object({context});
                field(this.view.data.model, 'value');
            }
            this.data.model.on('change', e => {
                const {name, value, old} = e;
                if (name === 'value') {
                    if (value !== old) {
                        this.view.data.model.value = value;
                    }
                }
            });
            this.view.data.model.on('change', e => {
                const {name, value, old} = e;
                if (name === 'value') {
                    if (value !== old) {
                        this.data.model.value = value;
                        if (this.dom.el) {
                            this.dom.el.value = value;
                        }
                    }
                }
            });
        }
        construct_synchronised_data_and_view_models();
        this.assign_data_model_value_change_handler();
    }
    assign_data_model_value_change_handler() {
        if (this.data && this.data.model) {
            this.data.model.on('change', e => {
                const {name, value, old} = e;
                if (name === 'value') {
                    if (value !== old) {
                        this.view.data.model.value = value;
                    }
                }
            });
        }
	}
    compose_date_picker() {
    }
    activate() {
        if (!this.__active) {
            super.activate();
            const {dom} = this;
            const activate_view_model_to_dom_model_sync = () => {
                this.add_dom_event_listener('change', e => {
                    this.view.data.model.value = dom.el.value;
                });
                this.add_dom_event_listener('keypress', e_keypress => {
                    this.view.data.model.value = dom.el.value;
                });
                this.add_dom_event_listener('keyup', e_keyup => {
                    this.view.data.model.value = dom.el.value;
                });
                this.add_dom_event_listener('keydown', e_keydown => {
                    this.view.data.model.value = dom.el.value;
                });
            }
            activate_view_model_to_dom_model_sync();
        }
    }
}
module.exports = Date_Picker;
},{"../../../../../html-core/html-core":149,"obext":382}],73:[function(require,module,exports){
/*
    Basically an 'select' element with options, rendering would be swappable though.


*/

// A Select_Options control could help more first....
//   And could progressively enhance that too.
//   So falling back on the non-enhanced control by default will help, it brings the app further towards
//     not requiring client-side JS.






const jsgui = require('../../../../../html-core/html-core');
const each = jsgui.each;
const tof = jsgui.tof;
const Control = jsgui.Control;
//const Tree_Node = require('./tree-node');

// Then use a swap to change the controls when it's in place.

/*
    <select> <option value="American">American flamingo</option> <option value="Andean">Andean flamingo</option> <option value="Chilean">Chilean flamingo</option> <option value="Greater">Greater flamingo</option> <option value="James's">James's flamingo</option> <option value="Lesser">Lesser flamingo</option> </select>

    Read more: https://html.com/tags/select/#ixzz5NXFlnCLS
*/

// Different states - open, closed


// This will do more than just wrap the HTML control(s)
//  Maybe work on the combo-box control.

// Likely could be enhanced a lot, removed, or replaced.
//  Does minimal wrapping of html options list (it seems).
//  Could do with popup iplementation.


// Maybe could make good use of the mx_display_modes.


// Could render as a select / options box by default.
//   Though could use progressive enhancement to replace it.
//     Could even do some CSS hack(s) to make open/closed state not require client-side JS.

// Basically select option control.
//   Maybe retire this for the moment.
//     Or make it with a dropdown mixin and a list.


// Worth making the control that encapsulates the bare HTML input option select.
//   The 'select' and 'option' elements system.

// Just make jsgui.select perhaps????
//   Some enhancement around that?

// Select_Options ?????

// Select_Options_Dropdown_List perhaps???

// Then an Options_List could do more progressive enhancement.
//   See about making better idioms for 'progressively enhanced' versions.
//     So have the basic control there, have code for it, that code would support client-side things, but it gets swapped for
//       a more advanced control???

// Want to be able to easily express both the basic HTML, as well as the enchanced versions.


// Grid does seem like it needs more work when it comes to separating the data and the presentation.
//   Want it to be powerful and flexible in this regard.

// Perhaps this could use a select options and replace it upon activation using JS?



//  Different types of controls / control modes.
//    HTML Native, JSGUI Composed.
//    So a dropdown menu could use the HTML select element, or could be composed of other controls.
//    Maybe just 'native' and 'composed'.
//      Or 'complex'? 'built'?

// Native controls could still have other native controls within them - like options in a select.

// And controls operating in either native or composed mode?
//   Not right now.



// Make this into a compositional type control?
// Dropdown_Menu for now?


class Dropdown_List extends Control {
    constructor(spec) {
        super(spec);

        console.trace();
        throw 'Deprtecating this control for the moment. Try Select_Options or Dropdown_Menu instead.';

        // and the options...
        //  an array of options.
        this.options = spec.options;
        // Compose functions look like they would be helpful again.

        // if it was called through activation?

        if (!spec.skip_compose) this.compose();
    }
    compose() {
        const context = this.context;

        // Make this more versitile, while also supporting a very intuitive high-level API.
        //   Such as being able to provide it options from a model or part of one to select from.
        



        each(this.options, option => {
            // Option could just be a string, a number or [number, string]

            let t = tof(option);
            let ctrl_option = new jsgui.option({
                context
            });
            if (t === 'string') {
                ctrl_option.dom.attributes.value = option;
                ctrl_option.add(new jsgui.textNode('option'));
            }

        });
    }
}

module.exports = Dropdown_List;
},{"../../../../../html-core/html-core":149}],74:[function(require,module,exports){

/*

if (typeof define !== 'function') { var define = require('amdefine')(module) }

define(["../../jsgui-html", "./text-field"],
function(jsgui, Text_Field) {
*/

const jsgui = require('../../../../../html-core/html-core');
var Text_Field = require('../1-compositional/Text_Field');
var Button = require('./button');

var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof;
var Control = jsgui.Control;

// Another type of control? - composite or basic-composite?
//  That would be an unenhanced Login control. Made up of basic controls, will render and
//   be useful on very limited platforms.

// Since this is now an advanced control...

/*
 'fields': {
 'action': String
 },
 */

class File_Upload extends Control {

    // Maybe should put this into a form, so that it does a form post.
    //  That could possibly be disabled.

    constructor(spec) {
        super(spec);
        var make = this.make;

        // 0 icon / mini mode
        // 1 compact mode
        // 2 normal mode
        // 3 large mode

        var autosubmit = spec.autosubmit || false;

        var mode = 'medium';
        if (spec.mode) mode = spec.mode;
        if (mode == 'icon' || mode == 'mini' || mode == 'compact') autosubmit = true;

        //var url_path = spec.url_path;
        // but we want that property to go to the client and be activated there too.
        // will use ctrl fields too.
        //this.add_class('file-upload ' + mode);
        this.__type_name = 'file_upload';
        // and use a form control, set it's dom attributes.
        //  will use relative login url.

        // We can get the cookies from the context.
        var req = this.context.req;
        //var headers = req.headers;
        //console.log('headers ' + stringify(headers));
        var frm = new jsgui.form({
            'context': this.context
        })
        // action, method
        // Could have a default action, or the action could be a field of this.
        //  Then when it arrives on the server, need to handle its post request
        //  Could possibly respond with a long polled / stream that says how much of it has uploaded. Could keep writing the percentage, possibly estimated
        //  time remaining, speed.

        //var action;
        /*
        if (spec.action) {
            this.action = spec.action;

        } else {
            this.action = '/upload/';
        }
        */

        this.action = spec.action || '/upload/';
        //this.set('action', action);

        //var action = this.get('action') || '/upload/';
        //if (action.value) action = action.value();

        //frm.set('dom.attributes.action', action);
        var da = this.dom.attrs;
        da.action = this.action;
        da.method = 'POST';
        da.enctype = 'multipart/form-data';

        //frm.set('dom.attributes.action', '/login');
        //frm.set('dom.attributes.method', 'POST');
        //frm.set('dom.attributes.enctype', 'multipart/form-data');

        this.add(frm);

        var input_file = new jsgui.input({
            //'type': 'file',
            'context': this.context

        });
        input_file.set('dom.attributes.type', 'file');
        input_file.set('dom.attributes.name', 'file');

        frm.add(input_file);

        if (mode === 'normal' || mode === 'large') {
            var btn = new Button({
                'context': this.context

            })
            var bda = btn.dom.attrs;
            bda.type = 'submit';
            bda.value = 'submit';
            bda.class = 'upload';

            //btn.set('dom.attributes.type', 'submit');
            //btn.set('dom.attributes.value', 'submit');
            //btn.set('dom.attributes.class', 'upload');
            btn.add('Upload');
            frm.add(btn);
        }

        var ctrl_fields = {
            'input_file': input_file._id(),
            'form': frm._id()
        }

        /*
        this.set('dom.attributes.data-jsgui-ctrl-fields', stringify(ctrl_fields).replace(/"/g, "'"));

        // and the fields...
        this.set('dom.attributes.data-jsgui-fields', stringify({
            'autosubmit': autosubmit,
            'mode': mode
        }).replace(/"/g, "'"));
        */

        //throw 'stop';
    }
    'activate'() {
        super.activate();
        console.log('activate File_Upload');
        var mode = this.mode;
        // .val
        //  could get a control, but if it's a non-control Data_Object it would get its value.
        var autosubmit = this.autosubmit;
        var input_file = this.input_file;
        var form = this.form;

        //console.log('autosubmit', autosubmit);
        //console.log('form', form);

        if (autosubmit) {
            //console.log('autosubmit', autosubmit);
            //console.log('input_file', input_file);
            input_file.add_event_listener('change', function (e_change) {
                console.log('e_change', e_change);
                form.dom.el.submit();
            })
        }
    }
}
module.exports = File_Upload;

},{"../../../../../html-core/html-core":149,"../1-compositional/Text_Field":81,"./button":70}],75:[function(require,module,exports){
const jsgui = require('../../../../../html-core/html-core');
const {
    Control,
    parse_mount,
    parse,
    field
} = jsgui;

// Nice to make this flexible - make use of resources, svg, jsgui3-gfx....
//   Would be better to have this make use of other (lower level) functionality and to provide a nice API here.

// Would be nice to have low and medium level image features available to various controls, will be easy to put icons where they need to be
//   though this Icon control should make it easier in some ways.


class Icon extends Control {



    constructor(spec) {
        spec.__type_name = spec.__type_name || 'icon';
        let size = spec.size = spec.size || [64, 64];
        super(spec);
        const {
            context
        } = this;
        this.add_class('icon');
        field(this, 'key', spec.icon_key || spec.key);
        const compose = () => {
            const {
                key
            } = this;
            const imgurl = '/img/icons/' + key;
            const img = new jsgui.img({
                context: context,
                size: [64, 64]
            });
            img.dom.attributes.src = imgurl;
            this.add(img);
            this._ctrl_fields = this._ctrl_fields || {};
            this._ctrl_fields.img = img;
        }
        if (!spec.el) {
            compose();
        }
    }
    activate() {
        if (!this.__active) {
            super.activate();
            const {
                img
            } = this;
            this.on('change', ({
                name,
                value
            }) => {
                if (name === 'key') {
                    const imgurl = '/img/icons/' + value;
                    img.dom.attributes.src = imgurl;
                }
            })
        }
    }
}
module.exports = Icon;
},{"../../../../../html-core/html-core":149}],76:[function(require,module,exports){
/**
 * Created by James on 04/08/2014.
 */

/*

 if (typeof define !== 'function') { var define = require('amdefine')(module) }


 // Also want to make an MDI window system (Multiple Document Interface)

 define(["../../jsgui-html", "./horizontal-menu"],
 function(jsgui, Horizontal_Menu) {
 */

const jsgui = require('../../../../../html-core/html-core');
//var Horizontal_Menu = require('./horizontal-menu');

var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof, is_defined = jsgui.is_defined;
var Control = jsgui.Control;

var group = jsgui.group;

// And the tab buttons act as radio buttons.
//  Having a JSGUI radio button replacement would be nice.
//   Could choose whether to render as a radio button and progressively enhance on the client...
//    Client-side enhancement of semantic HTML.

//   Or render as it appears on the client?
//    Being able to handle both would be nicest.
//    Possibly radio buttons could have good styling on modern clients anyway?
//    May want them to look very different to normal radio buttons though, eg using them for tabs.


// RadioButtonGroup could be a useful Control as well.
//  May provide an easier interface that abstracts away from having to directly make some of the controls.











var fields = {
    'name': String,
    'text': String,
    'value': String,
    'checked': Boolean
};

class Radio_Button extends Control {
    // panel name?

    // could have a title field.

    // Items field could be an array.

    // maybe add before make would be better. add will probably be used more.
    constructor(spec, add, make) {


        super(spec);

        // Will have set up some fields.
        //  However, will not be directly using a Field_Collection.
        //   Though perhaps that would help with keeping the ordering of the fields.
        //   Currently we are just treating ._ as holding all fields.
        //    Though not everything in there need be considered a field or set up as one.




        this.__type_name = 'radio_button';

        this.add_class('radio-button');
        var context = this.context;
        //var that = this;

        // A different way of raising change events?
        //  .on('change') often translates to the dom el's onchange.

        // Want a way to refer to the event for the Control itself, not adding a DOM listener.
        //  (..., false) seems OK.



        if (spec.group_name) this.group_name = spec.group_name;

        //console.log('spec.el', spec.el);

        // No, make this contain an input element and a label element

        if (!spec.abstract && !spec.el) {

            var name = this.group_name;

            // Will need to render its ID in the DOM.

            var html_radio = new Control({
                context
            });
            {
                const {dom} = html_radio;
                dom.tagName = 'input';
                const {attributes} = dom;
                attributes.type = 'radio';

                attributes.name = name;


                attributes.id = html_radio._id();

            }
            /*
            html_radio.set('dom.tagName', 'input');
            html_radio.set('dom.attributes.type', 'radio');
            html_radio.set('dom.attributes.name', name);
            html_radio.set('dom.attributes.id', html_radio._id());
            */




            var html_label = new Control({
                'context': context
            });

            //html_label.set('dom.tagName', 'label');
            html_label.dom.tagName = 'label';
            //console.log('that._', that._);

            var text_value = this.text + '';

            //console.log('spec.text', spec.text);

            // Value should have been set during the initialization.


            //console.log('text_value', text_value);
            //console.log('tof text_value', tof(text_value));
            //console.log('that._.text', that._.text);
            //console.log('tof(that._.text)', tof(that._.text));
            //console.log('tof(that._.text._)', tof(that._.text._));

            // So it seems as though the text field has not been assigned.
            //  It should have been, as its specified as a field.

            // However, there is a Data_Value for the text field, but it has not been set.

            // The field should have been set during initialization.



            //throw 'stop';

            if (is_defined(text_value)) {
                html_label.add(text_value);
            }

            // The text is a field.
            //  Should be automatically assigned from the spec.


            // Needs to have a context for the text that gets added.
            //  Text is not an element in of itself, so will not need a context.



            //html_label.set('dom.attributes.for', html_radio._id());
            html_label.dom.attributes.for = html_radio._id();

            this.add(html_radio);
            this.add(html_label);
            
            //this.set('radio', html_radio);
            //this.set('label', html_label);
            //html_radio.set('dom.attributes.type', 'radio');


            /*
            this.set('dom.attributes.data-jsgui-fields', stringify({
                'value': this.get('value')
            }).replace(/"/g, "[DBL_QT]").replace(/'/g, "[SNG_QT]"));

            */

            // Look at the items.




            /*
             var ctrl_fields = {
             'ctrl_relative': div_relative._id(),
             'title_bar': title_bar._id()
             }


             this.set('dom.attributes.data-jsgui-ctrl-fields', stringify(ctrl_fields).replace(/"/g, "'"));
             */


        }

    }
    //'resizable': function() {
    //},
    'activate'() {
        // May need to register Flexiboard in some way on the client.


        if (!this.__active) {
            super.activate();

            var radio = this.radio;
            //var el_radio = radio.dom.el;//???
            var label = this.label;
            //var that = this;

            //var el = this.dom.el;
            //

            // No, refer specifically to the radio button element's control.

            // Changes upon becoming checked?

            /*
            radio.on('change', e_change => {
                //console.log('el_radio.checked', el_radio.checked);

                //if (el_radio.checked) {
                    this.raise('change', {
                        name: 'checked',
                        value: el_radio.checked
                    });
                //}
            });
            */

            // Need to listen for DOM change events. That will chage the value.
            //  The checked value true or false.



        }



        //

    }
};

module.exports = Radio_Button;
/*
 return Panel;
 }
 );
 */

},{"../../../../../html-core/html-core":149}],77:[function(require,module,exports){


// Also see about more low / mid level support for compositional models modes.
//   Supporting a wordy API (explicit but not rediculous), but with shortcuts, will be helpful.

const jsgui = require('../../../../../html-core/html-core');
//var Horizontal_Menu = require('./horizontal-menu');

var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof, is_defined = jsgui.is_defined;


const mx_selectable = require('../../../../../control_mixins/selectable');
const {field} = require('obext');
var Control = jsgui.Control;

// Possible archetypes for control. Ie declarative definitions of what the control is and does. So a cell would have a similar
//   archetype to text input, and would also be expected to be or likely to be within a grid.

// Will separate out the view data model aspects of it.


class Cell extends Control {
    constructor(spec) {
        (spec = spec || {}).__type_name = 'cell';
        super(spec);
        this.add_class('cell');
        field(this, 'x', spec.x);
        field(this, 'y', spec.y);
        field(this, 'data', spec.data);
        if (!spec.el) {
            this.compose_grid_cell();
        }
        mx_selectable(this);
    }
    compose_grid_cell() {
        let o = {
            context: this.context
        };
        if (this.data) o.text = this.data;
        this.add(this.span = new jsgui.span(o));
        this._ctrl_fields = this._ctrl_fields || {};
        this._ctrl_fields.span = this.span;
    }
    activate() {
        if (!this.__active) {
            super.activate();
            //mx_selectable(this);
        }
    }
}

module.exports = Cell;

// And also want to integrate with data sources.
// Possibly a Data_Grid subclass of Data_Model could help most with this.
//   Especially with the data updating, and representing that on a grid.

// Also, the Grid control was the control that was proving most difficult when it came to the .size property.
//  Ambiguity over if it's the dimensions of the data, or the size in pixels in the UI.

// .view.size may be a useful way to express it clearly.
// .data.size or .data.model.value.size even....

// Do want the unambiguous short(er) ways of expressing it.

// .view.ui.data.model.size even???

// a ui model or ui data model???
// .view.ui.data.copy()
// view.ui.data.toUInt8Array() ???

// having .data be more general, then data.model being the data_model instance makes sense in terms of a flexible API.
//   Writing this should be fairly concise because some high level code can use the very specific mid level code to do things that would
//   otherwise take a few lines or be more complex than it otherwise would without the very specific mid level code.








},{"../../../../../control_mixins/selectable":62,"../../../../../html-core/html-core":149,"obext":382}],78:[function(require,module,exports){
const jsgui = require('../../../../../html-core/html-core');
var stringify = jsgui.stringify,
    each = jsgui.each,
    tof = jsgui.tof,
    is_defined = jsgui.is_defined;

const {is_array, is_arr_of_strs} = jsgui;

var Control = jsgui.Control;
const {
    field,
    prop
} = require('obext');

// Seems worth using mixins, improving them to cover a variety of features that will be used in many controls.

// Menu items being selectable individually.
//   So when one gets selected, the control has its state changed to closed.

// Also, consider state transitions in the state system.
//   Could take a 1/2s or something to change between open and closed.

// Pressed view state mixin?
//   view ui data model or something like that.





const {press_events, pressed_state, selectable} = require('../../../../../control_mixins/mx');


class Dropdown_Menu extends Control {
    constructor(spec) {
        spec = spec || {};
        spec.__type_name = spec.__type_name || 'dropdown_menu';
        super(spec);
        this.add_class('dropdown-menu');

        field(this.view.data.model, 'state');
        field(this.view.data.model, 'options');

        this.view.data.model.on('change', e_change => {
            //console.log('this.view.data.model.on change e_change', e_change);
            const {name, value} = e_change;

            if (name === 'state') {
                if (value === 'open') {
                    this.remove_class('closed');
                    this.add_class('open');
                } else if (value === 'closed') {
                    this.remove_class('open');
                    this.add_class('closed');
                }
            } else {
                //console.log('this.view.data.model.on change e_change', e_change);
            }

            // and on changing the options...
            //   do some specific composition I suppose?

        });

        this.view.data.model.state = 'closed';

        if (spec.options) {
            this.view.data.model.options = spec.options;
        }

        if (!spec.abstract && !spec.el) {
            //this.compose_color_palette_grid();
            this.compose_dropdown_menu();
        }

        /*
        this.on('resize', (e_resize) => {
            if (this.grid) {
                var _2_padding = 12;
                var new_grid_size = v_subtract(e_resize.value, [_2_padding, _2_padding]);
                this.grid.size = new_grid_size;
            }
        });
        */

        // View states of inner composed controls?

    }
    
    compose_dropdown_menu() {

        const {context} = this;

        // Popup can be modal or not.

        // Have the initial / closed state item.
        //   Show the current value, have the dropdown icon.

        // Selected item, null item / no item selected.

        const ctrl_closed_top = new Control({ context });
        ctrl_closed_top.add_class('closed-top');


        const ctrl_closed_top_item_itself = new Control({ context });
        ctrl_closed_top_item_itself.add_class('item-itself');
        ctrl_closed_top.add(ctrl_closed_top_item_itself);


        // Can we make the system transfer state changes to do with 'pressed'?
        const ctrl_dropdown_icon = new Control({ context });
        ctrl_dropdown_icon.add_class('dropdown-icon');
        ctrl_dropdown_icon.add('▼');
        ctrl_closed_top.add(ctrl_dropdown_icon);

        this.add(ctrl_closed_top);

        const ctrl_open_items = new Control({ context });
        ctrl_open_items.add_class('open-items');
        this.add(ctrl_open_items);

        
        const dm_options = this.view.data.model.options;
        //console.log('Select_Options compose dm_options:', dm_options);
        if (is_array(dm_options)) {
            if (is_arr_of_strs(dm_options)) {
                //console.log('dm_options is an array of strings');
                each(dm_options, str_option => {
                    const ctrl_option = new Control({
                        context
                    });
                    ctrl_option.add_class('item');
                    //ctrl_option.dom.attributes.value = str_option;
                    ctrl_option.add(str_option);
                    ctrl_open_items.add(ctrl_option);

                    // Can we make these selectable here?
                    //   So it would need to persist to the client, be automatically set up on the client.

                    // Auto setting up mixins on client-side activation.

                    //   Could see about further server to client persistnce of properties / features.
                    //     Auto client-side mixin activation would help a lot when expressing various features in the
                    //     composition (server and client-side) code.

                    // Setting up selection scopes?
                    //   Mixin initialisation being sent as data-jsgui properties of some sort?#
                    //     data-jsgui-mixins property...
                    //       would be able to bring accross JSON properties for client-side use.
                    //         also would need to work properly with references to the various controls.


                    // Selectable children - where they are all within the selection scope of this control.

                    

                    


                })
            }
        }



        this._ctrl_fields = this._ctrl_fields || {};
		this._ctrl_fields.ctrl_dropdown_icon = ctrl_dropdown_icon;


    }

    activate() {
        if (!this.__active) {
            super.activate();
            const {ctrl_dropdown_icon} = this;
            //console.log('activating Dropdown_Menu this.ctrl_dropdown_icon', this.ctrl_dropdown_icon);

            // Want to listen for clicks on the dropdown icon.
            //  Will change the state of the dropdown menu.

            pressed_state(ctrl_dropdown_icon);

            // Though could have that control bound to the open/closed view state.
            
            ctrl_dropdown_icon.on('click', e_click => {
                //console.log('ctrl_dropdown_icon e_click', e_click);
                //console.log('this.view.data.model.state', this.view.data.model.state);

                if (this.view.data.model.state === 'closed') {
                    this.view.data.model.state = 'open';
                } else {
                    this.view.data.model.state = 'closed';
                }

            });

            // Want hover and press states for that button too.
            //   May want to implement / use mixins.


            
        }
    }

}


Dropdown_Menu.css = `
.dropdown-menu {
    height: 64px;
    width: 384px;
    background-color: #FFFFFF;
    border-radius: 4px;
    border: 2px solid #CCCCCC;
    padding: 2px;
}

.dropdown-menu .closed-top {
    height: 56px;
    width: 376px;
    background-color: #EEEEEE;
    border-radius: 4px;
    border: 2px solid #CCCCCC;
    padding: 2px;
    display: flex;
    flex-direction: row;
}

.dropdown-menu .closed-top .item-itself {
    height: 53px;
    width: 320px;
    background-color: #FFFFFF;
    border-radius: 4px;
    border: 2px solid #CCCCCC;
}

.dropdown-menu .closed-top .dropdown-icon {
    height: 53px;
    width: 53px;
    background-color: #FFFFFF;
    border-radius: 4px;
    border: 2px solid #CCCCCC;
    margin-left: 2px;
    font-size: 53px;
    line-height: 53px;
    color: #888888;
}

.dropdown-menu .closed-top .dropdown-icon.pressed {
    background-color: #F0F0F0;
}

.dropdown-menu .open-items {
    width: 376px;
    height: 414px;
    background-color: #EEEEEE;
    border-radius: 4px;
    border: 2px solid #CCCCCC;
    padding: 2px;
}

.dropdown-menu.closed .open-items {
    display: none;
}

.dropdown-menu .open-items .item {
    width: 373px;
    height: 64px;
    background-color: #FFFFFF;
    border-radius: 4px;
    border: 2px solid #CCCCCC;
    text-indent: 12px;
    font-size: 52px;
    line-height: 56px;
}

.dropdown-menu .open-items .item:not(:first-child) {
    margin-top: 2px;
}



`

if (require.main === module) {
    //console.log('pal_crayola.length', pal_crayola.length);


    // Could make a new doc / context etc without the server.

    const ddm = new Dropdown_Menu();
    console.log(ddm.all_html_render());

} else {
}
module.exports = Dropdown_Menu;
},{"../../../../../control_mixins/mx":56,"../../../../../html-core/html-core":149,"obext":382}],79:[function(require,module,exports){
const jsgui = require('../../../../../html-core/html-core');
const {
    Control,
    parse_mount,
    parse,
    field
} = jsgui;

// Nice to make this flexible - make use of resources, svg, jsgui3-gfx....
//   Would be better to have this make use of other (lower level) functionality and to provide a nice API here.

// Would be nice to have low and medium level image features available to various controls, will be easy to put icons where they need to be
//   though this Icon control should make it easier in some ways.


class Indicator extends Control {



    constructor(spec) {
        spec.__type_name = spec.__type_name || 'indicator';
        //let size = spec.size = spec.size || [64, 64];
        super(spec);
        const {
            context
        } = this;
        this.add_class('indicator');
        
        if (!spec.el) {
            //compose();
        }
    }
    activate() {
        if (!this.__active) {
            super.activate();

            
        }
    }
}
module.exports = Indicator;
},{"../../../../../html-core/html-core":149}],80:[function(require,module,exports){


const Indicator = require('./Indicator');

// Could link to a property or even a .status property by default.
//   listen for on change status of a Data_Model or control.

// 

// 'View Data Model' sounds like a data model that ius used to describe the view, possibly in terms of other data models.



// This is a good one to work on for view model abstraction. It's both simple and could be made complex.
//   On or off, or some more complex status.

// So there could be multiple view models. Create multiple view model specs, or have a system where multiple can
//   be handled within a single spec.


class Status_Indicator extends Indicator {
    constructor(spec) {
        super(spec);

        // on status change?

        // bind some status words with css classes even.
        //     

        this.on('change', e => {
            const { name, value } = e;
            //if (name === 'status') {
            //    this.update_status(value);
            //}
            console.log('status indicator change', name, value);
        });
        this.data.on('change', e => {
            const { name, value } = e;
            //if (name === 'status') {
            //    this.update_status(value);
            //}
            console.log('status indicator .data change', name, value);
        });
        this.data.model.on('change', e => {
            const { name, value } = e;
            //if (name === 'status') {
            //    this.update_status(value);
            //}
            console.log('status indicator .data.model change', name, value);
        });
    }

    // bind this to a data value?
    //   simple function, could deal with lower level stuff where necessary.

    
}

// listen for status changes in something its linked to or its own data model.

Status_Indicator.css = `
.indicator {
    display: inline-block;
    width: 1em;
    height: 1em;
    border-radius: 50%;
    background-color: var(--status-indicator-color, gray);
}       
.indicator.on {
    background-color: green;
}       
.indicator.off {
    background-color: red;
}
.indicator.yes {
    background-color: blue;
}
.indicator.no {
    background-color: orange;
}   
.indicator.unknown {
    background-color: gray;
}   
`;

module.exports = Status_Indicator;

// then yes or no statuses. or on and off?


},{"./Indicator":79}],81:[function(require,module,exports){
// Maybe just change to Field control
// Then Field_Group control would avoid confusion with an HTML form.

// This will be more about text or string editor in the future.

const jsgui = require('../../../../../html-core/html-core');
const Text_Input = require('../0-native-compositional/Text_Input');
const Text_Item = require('./text-item');
/*
var stringify = jsgui.stringify,
	each = jsgui.each,
	tof = jsgui.tof;
	*/
const {Control, Control_Data, Control_View, Data_Object, Data_Value, Data_Model} = jsgui;

const {field} = require('lang-tools');

const Data_Model_View_Model_Control = require('../../../../../html-core/Data_Model_View_Model_Control');


const Validation_Status_Indicator = require('./Validation_Status_Indicator');
const { model_data_view_compositional_representation } = require('../../../../../control_mixins/mx');


// fields could have default values too.

// May well be worth improving and extending this.
//   Put code to set up specific features in their own functions.
//     May later want to optimise (make more concise) the code here using more patterns.


// Late 2023 - Currently works, but could do with extra options, finesse, and making the code more compact and idiomatic,
//   making use of (new) lower level features to support it.



// 

// Will set the fields up (slightly?) differently in the future?
//   Or passing it along as 2nd param could be OK???


// Maybe an is_editable mixin???
//   Or have that integrated with the various view and model systems.
//     so if there is an 'editable' ui property, its value will have some kind of synced mapping to other parts of the system.

// Simplify things from a lower level too.



const fields = [
	['text', String],
	['name', String],
	//['value', String],
	['type', String],
	['editable', Boolean, true],
	['show_text', Boolean, true]
];

// Could use validation status and validation status indicator.

// Could see if updates to the Data_Model (from the View_Model) validate correctly.
//   See if the View_Model (.data.model) validates properly.
//     Assigning validation rules to the view.data.model too....




// Could maybe use a status indicator mixin???

// Or the status indicator only has a view.model ???



//  status_indicator.data.model = ....



// Text_Field


// Value has got to be dynamic!!!!

// When activated, respond to the property changes...
//   Or even not only when activated.


// Proper dom / view / model referencing and clarity seems important.

// ctrl.model.on(change)???


// Could seem the most explicit MVC or CVM type pattern.
// ctrl.view.model.on()


// .label.text perhaps....



// extends Data_Model_View_Model_Control perhaps.

// Making effective ll functionality to support this would help a lot.

// For the moment should focus on implementing the interface here???
//   No, separate the concerns now, so that can be general purpose.


// Maybe should use a Data_Value by default.

// Perhaps Data_Value could have a .name property as well.
//   The name of the value. Synonymous with .key I suppose.

// Could display the data_value name (perhaps???)

// Maybe bound to the name and the value?

// Data_Model.clone() could help.
//   So set the view.data.model = data.model.clone()

// See about some work on the .view.ui.model here.

//   Being able to specify it nicely will help.

//   More view.ui.options or similar....
//     .ui.options makes sense....
//     





// Could also make Text_Input extend Data_Model_View_Model_Control.


// No, should be made from a normal control but which has the model_data_view_compositional_representation mixin in use.

// 



// Seems worth making a new version which uses the new (high-level? mid-level?) API that sets up and makes use of data and view models etc.
//   Need some sort of DOM data binding too.

// defining how a view.data.model syncs with the dom.el.value or something.

// Mid-level code to get all of it working concisely on a high level.

// view.ui.inner.compositional.model for example.
//   maybe most controls won't support it???
//   the Window Control should support it, some others too....


// This does seem essential when representing some data.
//   Let's also have a validation indicator in an example.


// Need very clear and idiomatic data model / value sync and validation code and APIs.
//   A view.data.model.validation.state
//

// 

// this.validation.status change etc....
// The validation between the view and the data model.







class Text_Field extends Control {
	// fields... text, value, type?
	//  type could specify some kind of validation, or also 'password'.

	//  and can have other fields possibly.
	constructor(spec) {

		super(spec, fields);
		//super(spec);
		this.editable = true; // for now.

		this.__type_name = 'text_field';
		this.add_class('text-field');

		//if (spec.type) this.type = spec.type;
		// could be 'password' for example...???


		if (spec.placeholder) this.placeholder = spec.placeholder;

		// Binding 'value' to the model data???


		const {context} = this;

		const data_model_change_handler = e => {
            console.log('Text_Field data_model_change_handler e', e);

			// Should change it in the view model....???

			const {name, old, value} = e;
			if (name === 'value') {

				this.view.data.model.value = value;
			}

        };

        this.data.model.on('change', data_model_change_handler);

        this.data.on('change', e => {
            const {name, value, old} = e;
			console.log('Text_Field data change e:', e);
            if (name === 'model') {
                if (old instanceof Data_Model) {
                    old.off('change', data_model_change_handler);
                }
                value.on('change', data_model_change_handler);
            }
        });



		const view_data_model_change_handler = e => {
            //console.log('Text_Field view_data_model_change_handler e', e);

			// Should change it in the view model....???

			const {name, old, value} = e;
			if (name === 'value') {
				this.data.model.value = value;

				// Needs to update the UI!!!!

				// The equivalent being the data model of the internal text_input

				//console.log('!!this.text_input', !!this.text_input);

				if (this.text_input) {
					this.text_input.data.model.value = value;
				}
			}

        };

        this.view.data.model.on('change', view_data_model_change_handler);

        this.view.data.on('change', e => {
            const {name, value, old} = e;
            if (name === 'model') {
                if (old instanceof Data_Model) {
                    old.off('change', view_data_model_change_handler);
                }
                value.on('change', view_data_model_change_handler);
            }
        });

		const old_setup_data_and_view = () => {

			this.data = new Control_Data({context});

			// even see about putting that data_model in the spec when reconstructing the controls?
			//   does seem like a better (but increasing complexity) answer for it on a lower level.

			// This could be within Data_Model_View_Model_Control.
			//   Probably should be.
			//     See about some lower level improvements to assigning / specifying fields.
			//       Will be using the field function that's new to lang-mini - though the function had been used in 
			//       obext for quite a while. The field function is proving useful and versitile, moreso for the moment
			//       than the slightly similar in purpose prop function also in obext.
			//     




			if (spec.data && spec.data.model) {
				this.data.model = spec.data.model;
			} else {
				// The Control_Data will have its own model object.

				this.data.model = new Data_Value({context});
				//field(this.data.model, 'value');
			}

			this.view = new Control_View({context})
			if (spec.view && spec.view.data.model) {
				// set the view model????
				this.view.data.model = spec.view.data.model;
			} else {


				this.view.data.model = new Data_Value({context});
				//field(this.view.data.model, 'value');
			}


			// Then on data value change - see about changing it in the data model....


			// Better to make a new setup_models_change_handlers ???
			//


			//this.setup_models_change_handlers();

			// Or this is fine in the constructor because it does not have to do with internal controls???
			//   Or at least does not need to listen to their DOM events???
			//     Will be worth trying patterns that get this to work easily, as well as provide a nice / simple API
			//       when used.

			// Does seem OK here....

			//this.assign_data_model_value_change_handler();

			

			

			// And the view model changing --- would be nice to know if the change has been initiated by the DOM???
			//   Or the comparison will prevent feedback, and be simpler??


			this.view.data.model.on('change', e => {
				const {name, value, old} = e;

				//console.log('text_field view model change', e);

				if (name === 'value') {

					// Maybe want a more versitile equals function. Or even relying on tostring coersion with ==?

					if (value !== old) {
						// change it in the view model...

						// Though check if the data model can change to that?
						//   can_change_data_model
						this.data.model.value = value;

						// Kind of activated???
						//   Does seem fine within the constructor though.
						//     May try this kind of code more.

						this.text_input.data.model.value = value;
						//if (this.dom.el) {
							//this.dom.el.value = value;
						//}

					}
				}

				// And possibly? update it in the DOM (.value property of the html element) here.



				//
			});

		}
		// old_setup_data_and_view();
		

		if (!spec.el) {
			this.compose_text_field();

			// Not so sure this should be needed....
			//this.setup_child_controls_listeners();
			// And better to call an 

		}

		if (spec.value !== undefined) {
			this.data.model.value = value;
		}

		
	}

	setup_inner_control_events() {
		const {text_input} = this;


		//this.view.data.model = this.text_input.data.model;

		//this.text_input.data.model = this.view.data.model;

		// And validation states???

		this.view.data.model.on('change', e => {
			const {name, old, value} = e;
			if (name === 'value') {
				text_input.data.model.value = value;
			}
		})

		text_input.data.model.on('change', e => {
			const {name, old, value} = e;
			if (name === 'value') {
				this.view.data.model.value = value;
			}
		})

	}

	activate() {
        if (!this.__active) {
            super.activate();
            const {dom, text_input} = this;

			//this.setup_child_controls_listeners();
			this.setup_inner_control_events();





		}
	}



	compose_text_field() {
		
		// Could set the view.ui.compositional.model.
		//   Though may want 'name' values too, as strings???
		//    And it would set them all up as this._ctrl_fields too.
		//      Or only some of them???
		//      Seems worth setting all the named ones up as ctrl fields.

		const old_composition_code = () => {

			var left = new jsgui.div({
				'context': this.context
			});
			left.add_class('left');

			var right = new jsgui.div({
				'context': this.context
			});
			right.add_class('right');
			// adding should set the context properly.

			this.add(left);
			this.add(right);

			var clearall = new jsgui.div({
				'context': this.context
			});
			clearall.add_class('clearall');
			this.add(clearall);

			if (this.show_text) {
				var label = new jsgui.label({
					'context': this.context
				});
				//var text = this.get('text');
				//console.log('this.text ' + this.text);
				//console.log('tof text ' + tof(text));
				label.add(this.text);
				left.add(label);
			}

			const _ctrl_fields = this._ctrl_fields = this._ctrl_fields || {};

			// Needs to work differently.
			//  Define two modes, it will swap between modes based on editable property and changes to it.
			if (this.editable) {

				let o_spec = {
					'context': this.context,
					'value': this.value
				}

				if (this.placeholder) o_spec.placeholder = this.placeholder;

				var text_input = new Text_Input(o_spec);
				var tiid = text_input._id();

				// da(ctrl, str attr name, attr value)
				// da([arr of ctrl dom attr changes])

				text_input.dom.attributes.id = tiid;
				text_input.dom.attributes.name = this.name;
				label.dom.attributes.for = tiid;

				// and the type... it could be a password.
				//  that's a DOM attribute.
				text_input.dom.attributes.type = this.type;
				right.add(text_input);

				_ctrl_fields.text_input = text_input;
				this.text_input = this.text_input = text_input;
			} else {
				// Text_Item.
				var text_item = new Text_Item({
					'context': this.context,
					'value': this.value
				});
				right.add(text_item);

				_ctrl_fields.text_item = text_item;
				this.text_item = text_item;
			}

		}

		// For now, have both the text label and the text input.

		const using_compositional_model = () => {

			//console.log('using_compositional_model');

			this.view.ui.compositional.model = [

				// (string, function || constructor) handling needed for the composition system.
				// (string, function || constructor, object)

				['left_part', Control, {class: 'left', comp: [['label', jsgui.label]]}],
				['right_part', Control, {class: 'right', comp: [['text_input', Text_Input, {'value': this.value}]]}]

			];

			// But then need to localise the inner named items too.

			// see about (auto) extracting names and references from the composition once it's been made according to that model.

			const label = this._ctrl_fields.left_part.content._arr[0];
			const text_input = this._ctrl_fields.right_part.content._arr[0];

			//text_input.data.model = this.view.data.model;

			//console.log('!!label', !!label);
			//console.log('!!text_input', !!text_input);

			//console.log('this.text', this.text);

			if (this.text) {
				//label.text = this.text;
				label.add(this.text);
			}

			this._ctrl_fields = this._ctrl_fields || {};
			this._ctrl_fields.label = label;
			this._ctrl_fields.text_input = text_input;

			this.label = label;
			this.text_input = text_input;
		}

		using_compositional_model();
		// text_input
	}

}
module.exports = Text_Field;
},{"../../../../../control_mixins/mx":56,"../../../../../html-core/Data_Model_View_Model_Control":143,"../../../../../html-core/html-core":149,"../0-native-compositional/Text_Input":69,"./Validation_Status_Indicator":82,"./text-item":97,"lang-tools":186}],82:[function(require,module,exports){
const Status_Indicator = require('./Status_Indicator');

const Control_Validation = require('../../../../../html-core/Control_Validation');

// Control_Validation.

// Control View Validation???
//   etc can use in a few different ways.


// Seems like piece-by-piece implementation of client-side data model recoherence will be the way.
//   Seems like the controls would need to be constructed without the correct data_models, and then they get changed later on.

// Perhaps though, the Data_Model could be set up completely independant of controls (to start with at least).
//   Though having it so that all the logic is within client-side controls could make sense.
//   It does for now at least, but consider other ways.
//     Recoherence (and recoherence testing?) may be the best way forward for now, and work on making it as simple as possible
//     on a high level.

// Possibly need more low/mid level code to coordinate validations.
//   Specifically how one data model gets validated against another data model.

// Make the status indicator get the status after it gets activated?
//   Before it gets activated?

// Reloading / reconstructing / recohering a data_model on the client-side....
//   Need to carefully consider the steps.
//   Probably best to implement on high-level for the moment, move to lower level when the principles are clearer.



// this.validate.by perhaps???
// this.validation.data.model does make sense.
//   At least when it comes to a validation status indicator.
//   Though having more of the work done by Validation_Status would make sense.

// Do need to be a bit clearer about what will validate what.

// Maybe see about using some concise pieces of code....

// Or looking at validation statuses thoroughly on different levels.




class Validation_Status_Indicator extends Status_Indicator {

    // Likely will need some client-side recoherence with whatever model(s).

    // vsi.data.model.value being the status value itself?
    // vsi.data.model.validation.state perhaps?????

    //   

    constructor(spec = {}) {
        spec.__type_name = spec.__type_name || 'validation_status_indicator';
        super(spec);
        this.add_class('validation-status')

        const {context} = this;

        // .validation.data.model ....

        //  Should look at lower level coherence systems so that the data_model gets transmitted best to the client.
        // does the spec have a validation data model???

        // Is it connected to the data to validate?

        // Some kinds of 'statuses' model / list?
        //   

        // .validation.status.valid = true / false
        // or .data.model.validation.state ????

        // Data_Model_Validation_State



        const create_control_validation_but_maybe_we_dont_need_it = () => {

            const o_validation = {context};

            if (spec.validation) {
                if (spec.validation.data) {
                    if (spec.validation.data.model) {
                        o_validation.data = {
                            model: spec.validation.data.model
                        }
                    }
                }
            }
            // 




            this.validation = new Control_Validation(o_validation);
            this.validation.state.on('change', e => {
                const {name, old, value} = e;

                //console.log('Validation_Status_Indicator validation.state change e:', e);

                if (name === 'valid') {
                    // update the appearance (class)

                    if (value === true) {
                        this.remove_class('is-not-valid');
                        this.add_class('is-valid');
                    } else if (value === false) {
                        this.remove_class('is-valid');
                        this.add_class('is-not-valid');
                    }
                }
            })

        }

        // 
        this.data.on('change', e => {

            console.log('V_S_I change e:', e);

            const {name, old, value} = e;
            if (name === 'model') {
                // May need to move handlers.
                //   The validation status change handler.


                console.log('vsi data model change e', e);

            }
        })

        this.data.model.validation.state.on('change', e => {
            console.log('Validation_Status_Indicator .data.model.validation.state change e:', e);
        })


        // this.data.model.validation.status.on('change' 'valid')


        // this.validation.on('change' valid)....


        // A Validation State is an important thing to have as well.
        //   It is worth putting a load of logic into the names and purposes of classes.

        // this.validation.state.on('change'....)

    }

    activate() {

        // Definitely would be better to put some kinds of validation / data model recoherence in the lower level code that
        //   gets run automatically.

        // Want both the controls and the usage of them to have simple code.
        //   Will need to focus on implementing particularly mid-level code to get all these things working smoothly.

        // Looking again at ctrl and ctrl-enh may help with recohering the data on the client-side.

        // Also want to get into a view.ui.presentation data model....
        //   Maybe also see about coherance / reconstruction of that.

        // It seems very worth focusing for the moment on the mid-level code that will get everything working more smoothly.
        //   Plus Data_Value where needed.
        //   Maybe see about refactoring it.


        // Context seems like the best place to keep some data model coherence.
        //   

        // Recoherence of data_model(s) within the Page_Context?



        // Any kind of recoherence that would help here???


        const log_some_things = () => {
            console.log('Validation_Status_Indicator activate');

            console.log('this.validation', this.validation);

            console.log('this.validation.state', this.validation.state);

            console.log('this.validation.data.model', this.validation.data.model);

            console.log('this.data.model', this.data.model);

            console.log('this.data.model.value', this.data.model.value);
        }

        


    }

    // And activation????
    //   Would nice to have less needing to be done in activate functions.



}

Validation_Status_Indicator.css = `
    .validation-status.indicator {
        width: 24px;
        height: 24px;
        box-sizing: border-box;
        -moz-box-sizing: border-box;
        -webkit-box-sizing: border-box;
        border: 1px solid #333333;
        border-radius: 3px;
    }
    .validation-status.indicator.is-valid {
        background-color: '#66DD66'
    }
    .validation-status.indicator.is-not-valid {
        background-color: '#DD6666'
    }
`

module.exports = Validation_Status_Indicator;
},{"../../../../../html-core/Control_Validation":131,"./Status_Indicator":80}],83:[function(require,module,exports){
const jsgui = require('../../../../../html-core/html-core');
var Grid = require('./grid');
var stringify = jsgui.stringify,
    each = jsgui.each,
    tof = jsgui.tof,
    is_defined = jsgui.is_defined;
var Control = jsgui.Control;
var v_subtract = jsgui.util.v_subtract;
const {
    field,
    prop
} = require('obext');
class Color_Grid extends Grid {
    constructor(spec) {
        spec = spec || {};
        spec.__type_name = spec.__type_name || 'color_grid';
        super(spec);
        this.add_class('color-grid');
        this.internal_relative_div = true;

        // Will mainly be the 'view' model.

        prop(this, 'palette', spec.palette);
        //prop(this, 'grid_size', spec.grid_size || [12, 12]);


        if (!spec.abstract && !spec.el) {
            this.compose_color_palette_grid();
        }
        this.on('resize', (e_resize) => {
            if (this.grid) {
                var _2_padding = 12;
                var new_grid_size = v_subtract(e_resize.value, [_2_padding, _2_padding]);
                this.grid.size = new_grid_size;
            }
        });
    }
    activate() {
        if (!this.activate.__active) {
            super.activate();
            this.grid.selection_scope.on('change', e => {
                const {
                    name,
                    value
                } = e;
                if (name === 'selected') {
                    const selected_ctrl = value;
                    if (selected_ctrl) {
                        let color = selected_ctrl._color;
                        this.raise('choose-color', {
                            value: color
                        });
                    }
                }
            });
            const old_make_grid_cells_selectable = () => {
                this.grid.each_cell(cell => {
                })
            }
        }
    }
    each_cell(cb) {
        return this.grid.each_cell(cb);
    }
    add_grid_cells() {
        if (this.palette) {
            let c = 0;
            this.grid.each_cell((cell) => {
                var item = this.palette[c++];
                if (item) {
                    if (item.hex) {
                        cell.color = item.hex;
                    } else {
                        if (typeof item === 'string') {
                            cell.color = item;
                        }
                    }
                }
            });
        }
    }
    compose_color_palette_grid() {
        var padding = 6;
        const grid = this.grid = new Grid({
            'context': this.context,
            'grid_size': this.grid_size,
            'size': this.size,
            'cell_selection': 'single'
        });
        grid.each_cell((cell, [x, y]) => {
        });
        this.add(grid);
        this.add_grid_cells();
        this._ctrl_fields = this._ctrl_fields || {};
		this._ctrl_fields.grid = grid;
    }
}
if (require.main === module) {
    console.log('pal_crayola.length', pal_crayola.length);
} else {
}
module.exports = Color_Grid;
},{"../../../../../html-core/html-core":149,"./grid":87,"obext":382}],84:[function(require,module,exports){
const jsgui = require('../../../../../html-core/html-core');
const Color_Grid = require('./color-grid');
const {v_subtract} = jsgui;
var Control = jsgui.Control;
const {
    field,
    prop
} = require('obext');
const pal_crayola = require('../../../../../html-core/arr_colors');
class Color_Palette extends Control {
    constructor(spec) {
        spec = spec || {};
        spec.__type_name = spec.__type_name || 'color_palette';
        super(spec);
        this.add_class('color-palette');
        prop(this, 'palette', spec.palette || pal_crayola);


        // Have this within the 'view model'.
        //   The color palette itself would be in the data model, probably.


        prop(this, 'grid_size', spec.grid_size || [12, 12]);
        if (!spec.abstract && !spec.el) {
            this.compose_color_grid();
        }
        this.on('resize', (e_resize) => {
        });
    }
    activate() {
        if (!this.activate.__active) {
            super.activate();
            const attach_on_change_named_property_handler = (obj, property_name, fn_handler) => {
                obj.on('change', e => {
                    if (property_name === e.name) {
                        fn_handler(e);
                    }
                })
            }
            attach_on_change_named_property_handler(this, 'selected', e => {
                const selected_ctrl = e.value;
                if (selected_ctrl) {
                    let color = selected_ctrl._color;
                    this.raise('choose-color', {
                        value: color
                    });
                }
            })
            const old_make_grid_cells_selectable = () => {
                this.grid.each_cell(cell => {
                })
            }
        }
    }
    compose_color_grid() {
        console.log('compose_color_grid');
        var padding = 6;
        const fg_bg_color_grid = new Color_Grid({
            'context': this.context,
            'grid_size': [2, 1],
            'size': [80, 40]
        });
        this.add(fg_bg_color_grid);
        const color_grid_pxsize = v_subtract(this.size, [0, 46]);
        const color_grid = this.grid = new Color_Grid({
            'context': this.context,
            'grid_size': this.grid_size,
            'palette': this.palette,
            'size': color_grid_pxsize,
            'cell_selection': 'single'
        });
        this.add(color_grid);
        this._ctrl_fields = this._ctrl_fields || {};
		this._ctrl_fields.color_grid = color_grid;
        this._ctrl_fields.fg_bg_color_grid = fg_bg_color_grid;
    }
}
if (require.main === module) {
    console.log('pal_crayola.length', pal_crayola.length);
} else {
}
module.exports = Color_Palette;
},{"../../../../../html-core/arr_colors":145,"../../../../../html-core/html-core":149,"./color-grid":83,"obext":382}],85:[function(require,module,exports){
/**
 * Created by james on 18/12/2016.
 */

// Could accept only some specific types of data eg numeric.
//  May well want nicer / custom scrollbars.

// It will be a text box but the selection list appears below.
//  So we will use List with its own scrollbar.

// Should be made out of component JSGUI controls as necessary. both option control as well as text box.

// text-input
//  drop-down-list (menu)

// Have a need for combo box
//  Choosing a month
//  Clicking on the box should bring up the full range of options
//   Could involve scrolling
//    In this situation, we want something totally HTML styled.
//    Not making use of native Options.
//     Keep native scrollbars for the moment. More work on jsgui scrollbars would help though.


// Hold a list of items
//  Data rendered as controls
//  

// Interested in data coming in from the side

// Item_Selector could be a good alternative.
//  More varied than Combo_Box. Not a problem having non-combo-box functionality.
const jsgui = require('../../../../../html-core/html-core');

//var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof, is_defined = jsgui.is_defined;
var Control = jsgui.Control;



// Basic but then could be swapped.


// Allow searching / choosing with text.


// This should also allow flexibility in terms of how the items are displayed???


// Just allow a single icon next to the items?

// A text input part
// A list part

// A control suite would make sense
//  But maybe as another module.

// This in its default form uses a kind of popup-resizing.
//  There would need to be room for it to be displayed. Possibly in a popup overlay layer.



// Needs more work. Would be nice to make really simple implementation that does what is needed, while allowing extensions.

// May need to see about server-side autocomplete.
//   Maybe use a data resource or an autocomplete data (provider) resource on the client.
//     Could implement such a data provider on the client with an array.

// Websockets would probably be the fastest way to transfer the autocomplete suggestions data.
//   Could even have that on a different server / in a different process.
//     For the moment though, want to be able to easily hook up server-side data to client-side resources.

// await get_suggestions(str)
//   could access the server quite easily with things set up right on the client.
//     Maybe want to assign the data source on the server, then the control on the client makes a request to the client-server resource
//       access component, gets that to request the answer from the server, sends it to the client.

// Though setting it up with a property could be nicer.
//   It may automatically create the server-side resource that holds that data / responds to (authenticated and authorised?) client side
//     requests with it.
//   Generating a random 256 bit token to send to the client, then for the client to send back with every request could help.
//     It would be a key that allows access to that resource.
//       And the server-side resource publisher would need the key from the client to access the resource.

// Do need to consider specific resources for specific clients.
//   User-based.

// Including user-based security into jsgui3 could be useful.



// A countries selector could be a good example, both for server and client side implementations.


// Maybe is worth focusing more of text fields?
// Number Fields?
// Integer Fields?
// Typed Text Fields? eg integer?
// Have TextBox Text_Box elsewhere?

// Also want popup menus.
//   They would help the UIs of some demos too.
//   Menu bars (for the top generally?) 
//     see https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.toolstripitem.mergeaction?view=windowsdesktop-8.0

// A Menu_Bar could help.
//   Maybe assume horizontal?








// Autocomplete???




class Combo_Box extends Control {
    constructor(spec) {
        spec.__type_name = spec.__type_name || 'combo_box';
        super(spec);

        // Has various items.
        // At the top is a control that either shows the item selected, or search text.

        // spec.items

        // create Item control from the spec items
        //  They will be displayed in a vertical list
        //  



        //  
        //  Could use Items_Container mixin.
        //  Open_Closed mixin

        // Run-time mixins for the moment.



        // Maybe contain a single main area and a drop-down box

    }

}

module.exports = Combo_Box;
},{"../../../../../html-core/html-core":149}],86:[function(require,module,exports){
const jsgui = require('../../../../../html-core/html-core');
var Menu_Node = require('./menu-node');

var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof, is_defined = jsgui.is_defined;
var Control = jsgui.Control;

// More advanced, but still comes as standard, basic in that way.

// May benefit from some kind of model overlay over the main part of the doc.

// ctrl.context_menu?
// ctrl.context.menu(ctrl) ???
//   later, work on easy specification of the context menu.


class Context_Menu extends Control {
	constructor(spec, add, make) {
		super(spec);

		this.__type_name = 'context_menu';
		//this.add_class('context menu');
		this.add_class('context menu');

		//console.log('Context_Menu init spec.el', spec.el);
		if (!spec.abstract) {
			const obj = spec.value;

			//console.log('menu obj', obj);

			// Create the menu nodes from it.
			//var that = this;

			const tobj = tof(obj);
			//console.log('tobj', tobj);
			if (tobj === 'object') {
				each(obj, (v, key) => {
					const menu_node = make(Menu_Node({
						'text': key,
						'value': v,
						'menu': this
					}))
					this.add(menu_node);
				})
			}

			// typed each
			//  would be useful with if statements and an item sig
			//  then also with mfp typed each!!! :)

			if (tobj === 'array') {
				each(obj, (v, index) => {
					//const tv = tof(v);
					//console.log('tv', tv);
					// then if it's string and function...

					var vsig = jsgui.get_item_sig(v, 1);
					//console.log('vsig', vsig);

					if (vsig == '[s,f]') {
						var text = v[0];
						var item_callback = v[1];

						var menu_node = make(Menu_Node({
							'text': text,
							'value': text,
							'menu': this
						}))
						this.add(menu_node);
					}
				})
			}
		}

		this._features = this._features || []; // an array is cool but map is better for testing for specific ones.
        each(['menu'], this._features.push);

	}
	'activate'() {
		//console.log('pre super this._.content._arr.length ' + this._.content._arr.length);
		// So it seems the problem lies within the activate function.
		super.activate();
		//var body = this.context.body;
		//var that = this;
		//var nodes = this.descendents('menu_node');

	}
	'close_all'() {
		console.log('menu close_all');
		// need to do this recursively I think.
		//  could call this recursively on all nodes.

		this.content.each(function (v, i) {
			v.close_all();
		});
	}
}

module.exports = Context_Menu;
},{"../../../../../html-core/html-core":149,"./menu-node":91}],87:[function(require,module,exports){
const jsgui = require('../../../../../html-core/html-core');
const {
    stringify,
    each,
    tof,
    def,
    Control
} = jsgui;
const mx_selectable = require('../../../../../control_mixins/selectable');
const {
    prop,
    field
} = require('obext');
const Cell = require('./Cell');
const Grid_Cell = Cell;

// Some kind of compositional spec being part of the view (data) model.
// view.data.model.composition = ...




class Grid extends Control {
    constructor(spec, add, make) {
        spec = spec || {};
        spec.__type_name = spec.__type_name || 'grid';
        super(spec);
        if (spec.cell_selection) {
            this.cell_selection = spec.cell_selection;
        }
        this.add_class('grid');
        var spec_data = spec.data;
        this._arr_rows = [];
        field(this, 'composition_mode');
        if (spec.composition_mode) {
            this.composition_mode = spec.composition_mode
        } else {
            this.composition_mode = 'divs'
        }

        prop(this, 'grid_size', spec.grid_size || [12, 12]);

        /*
        let _grid_size;
        Object.defineProperty(this, 'grid_size', {
            get() {
                return _grid_size;
            },
            set(value) {
                if (Array.isArray(value) && value.length === 2) {
                    let old = _grid_size
                    _grid_size = value;
                    console.log('set _grid_size', value);
                    this.raise('change', {
                        'name': 'grid_size',
                        'old': old,
                        'value': value
                    });
                } else {
                    throw 'Invalid grid_size. Expected [x, y]';
                }
            }
        });
        if (spec.grid_size) _grid_size = spec.grid_size;
        */
        field(this, 'cell_size');
        if (spec.cell_size) this.cell_size = spec.cell_size;
        field(this, 'column_headers', false);
        field(this, 'row_headers', false);
        prop(this, 'data', false);
        this.map_cells = {};
        this.arr_cells = {};
        if (spec.data) {
            let t_data = tof(spec.data);
            if (t_data === 'array') {
                let max_x = -1;
                let y, x, ly, lx, arr = spec.data,
                    arr_row;
                ly = arr.length; 
                for (y = 0; y < ly; y++) {
                    arr_row = arr[y];
                    lx = arr_row.length;
                    if (lx > max_x) max_x = lx;
                    for (x = 0; x < lx; x++) {
                    }
                }
                _grid_size = [max_x, ly];
            }
        }
        if (!spec.el) {
            var data;
            this.full_compose_as_divs();
            this._fields = this._fields || {};
            Object.assign(this._fields, {
                'composition_mode': this.composition_mode,
                'grid_size': this.grid_size
            });
            if (this.cell_size) {
                this._fields.cell_size = this.cell_size;
            }
        }
        this.changes({
            grid_size: v => {
                if (!spec.el) {
                    this.clear();
                    this.full_compose_as_divs();
                }
            }
        });
    }

    //  Have the size system set up within the 'view model'.


    'refresh_size'() {
        if (this.composition_mode === 'divs') {
            let [num_columns, num_rows] = this.grid_size;
            var cell_border_thickness = 1;
            var _2_cell_border_thickness = cell_border_thickness * 2;
            if (this.size) {
                var cell_size = this.cell_size || [Math.floor(this.size[0] / num_columns) - _2_cell_border_thickness, Math.floor(this.size[1] / num_rows) - _2_cell_border_thickness];
                var cell_v_border_thickness = 2;
                this.each_row((row) => {
                    row.size = [this.size[0], cell_size[1] + cell_v_border_thickness];
                });
                this.each_cell((cell) => {
                    cell.size = cell_size;
                });
            } else {
                console.log('.size was not available');
            }
        }
    }
    'each_row'(cb_row) {
        each(this._arr_rows, cb_row);
    }
    'each_cell'(cb_cell) {
        each(this._arr_rows, (row, i_row) => {
            row.content.each((cell, i_cell) => {
                cb_cell(cell, [i_cell, i_row]);
            });
        });
    }
    'get_cell'(x, y) {
        console.trace();
        throw 'NYI';
    }
    'add_cell'(content) {
        var cell = new Grid_Cell({
            context: this.context
        });
        if (this.cell_selection) {
            cell.selectable = true;
        } else {
        }
        if (content) {
            cell.add(content);
        }
        cell.active();
        this.main.add(cell);
        return cell;
    }
    'full_compose_as_divs'() {
        let main = this.main = new Control({
            context: this.context,
            class: 'main'
        });
        this.add(main);
        let rows = this.main = new Control({
            context: this.context,
            class: 'rows'
        });
        main.add(rows);
        let map_cells = this.map_cells,
            arr_cells = this.arr_cells;
        if (this.grid_size) {
            let [num_columns, num_rows] = this.grid_size;
            var cell_border_thickness = 0;
            var _2_cell_border_thickness = cell_border_thickness * 2;
            let cell_size;
            if (this.size) {
                cell_size = this.cell_size || [Math.floor(this.size[0] / num_columns) - _2_cell_border_thickness, Math.floor(this.size[1] / num_rows) - _2_cell_border_thickness];
            } else {
                cell_size = this.cell_size;
            }
            let row_width, row_height;
            let row_header_width;
            if (this.cell_size) {
                if (this.row_headers) {
                    row_header_width = this.row_headers.width || row_header_width;
                    row_width = this.cell_size[0] * num_columns + row_header_width;
                } else {
                    row_width = this.cell_size[0] * num_columns;
                }
                row_height = this.cell_size[1];
            } else {
                if (this.size) row_height = Math.floor(this.size[1] / num_rows);
            }
            const data = this.data;
            var x, y;
            if (this.column_headers) {
                let header_row = new Control({
                    context: this.context 
                });
                header_row.add_class('header');
                header_row.add_class('row');
                if (row_height) {
                    header_row.style('height', row_height);
                }
                if (row_width) {
                    header_row.style('width', row_width);
                }
                rows.add(header_row);
                if (this.row_headers) {
                    var cell = new Control({
                        context: this.context,
                        __type_name: 'grid_cell', 
                    });
                    cell.add_class('grid-header');
                    cell.add_class('cell');
                    if (row_header_width) {
                        cell.size = [row_header_width, cell_size[1]];
                    } else {
                        cell.size = cell_size;
                    }
                    header_row.add(cell);
                }
                for (x = 0; x < num_columns; x++) {
                    var cell = new Control({
                        context: this.context,
                        __type_name: 'grid_cell', 
                    });
                    cell.add_class('column-header');
                    cell.add_class('cell');
                    cell.size = cell_size;
                    header_row.add(cell);
                }
            }
            for (y = 0; y < num_rows; y++) {
                var row_container = new Control({
                    context: this.context 
                });
                if (row_height) {
                    row_container.style('height', row_height);
                }
                if (row_width) {
                    row_container.style('width', row_width);
                }
                row_container.add_class('row');
                this._arr_rows.push(row_container);
                rows.add(row_container);
                if (this.row_headers) {
                    var cell = new Control({
                        context: this.context,
                        __type_name: 'grid_cell', 
                    });
                    cell.add_class('row-header');
                    cell.add_class('cell');
                    if (row_header_width) {
                        cell.size = [row_header_width, cell_size[1]];
                    } else {
                        cell.size = cell_size;
                    }
                    row_container.add(cell);
                }
                for (x = 0; x < num_columns; x++) {
                    let o = {
                        context: this.context,
                        x: x,
                        y: y
                    }
                    if (data) {
                        o.data = data[y][x];
                    }
                    var cell = new Grid_Cell(o);
                    cell.selectable = true;

                    // saying the cells are selectable within this scope...?

                    if (cell_size) cell.size = cell_size;
                    row_container.add(cell);
                    arr_cells[x] = arr_cells[x] || [];
                    arr_cells[x][y] = cell;
                    map_cells['[' + x + ',' + y + ']'] = cell;
                }
            }
        }
        this._ctrl_fields = this._ctrl_fields || {};
        this._ctrl_fields.main = main;
        this._ctrl_fields.rows = rows;
    }
    'full_compose_as_table'() {
        this.dom.tagName = table;
        var data = this.data;
        var range = data.range;
        var value;
        if (tof(data) === 'data_grid') {
            var x, y, max_x = range[0],
                max_y = range[1];
            var ctrl_cell, ctrl_row;
            var size = this.size().value();
            var tbody_params = {
                'context': this.context,
                'tagName': 'tbody'
            }
            if (size) {
                tbody_params.size = [size[0][0], size[1][0]];
            }
            var tbody = new Control(tbody_params);
            this.add(tbody);
            for (y = 0; y <= max_y; y++) {
                ctrl_row = new jsgui.tr({
                    'context': this.context
                });
                tbody.add(ctrl_row);
                for (x = 0; x <= max_x; x++) {
                    ctrl_cell = new jsgui.td({
                        'context': this.context
                    });
                    ctrl_row.add(ctrl_cell);
                    value = data.get(x, y);
                    ctrl_cell.add_text(value);
                }
            }
        } else {
            throw 'Unexpected data type. Expected data_grid, got ' + tof(data);
        }
    }
    'activate'() {
        if (!this.__active) {
            super.activate();
            this.selection_scope = this.selection_scope || this.context.new_selection_scope(this);
            var load_rows = () => {
                var _arr_rows = this._arr_rows = [];
                this.rows.content._arr.forEach((v) => {
                    _arr_rows.push(v);
                });
            }
            load_rows();
            var load_cells = () => {
                each(this._arr_rows, (row) => {
                    each(row.content._arr, (cell) => {
                    });
                });
            };

            /*
            this.each_cell(cell => {
                cell.activate();
            });
            */


        }
    }
}
Grid.css = `
table.grid {
    background-color: #eceff1;
    border: 1px solid #546e7a;
    padding: 2px;
    cursor: default;
}
table.grid tbody {
    overflow: hidden;
    display: block;
}
table.grid td {
    padding: 1px;
}
.data-row .data-item {
    display: inline;
    margin-left: 2px;
    padding: 2px;
}
.mid-width {
    width: 450px;
}
div.grid {
    user-select: none;
    clear: both;
}
div.grid .header.row .cell {
    text-align: center
}
div.grid .row {
    clear: both;
}
div.grid .header.row .cell span {
    position: relative;
    top: 4px;
    left: 0px;
    font-size: 11pt;
}
div.grid .row .cell {
    float: left;
    box-sizing: border-box;
    border-right: 1px solid #AAAAAA;
    border-bottom: 1px solid #999999;
}
div.grid .row .cell.selected {
    float: left;
    box-sizing: border-box;
    border: 2px solid #2046df;
    border-radius: 4px;
}
div.grid .row .cell.selected span {
    position: relative;
    left: 3px;
    top: -1px;
    font-size: 16pt;
}
div.grid .row .cell span {
    position: relative;
    left: 5px;
    top: 1px;
    font-size: 16pt;
}
`;
Grid.Cell = Grid.Grid_Cell = Grid_Cell;
module.exports = Grid;
},{"../../../../../control_mixins/selectable":62,"../../../../../html-core/html-core":149,"./Cell":77,"obext":382}],88:[function(require,module,exports){
/*
    May wind up as superclass of Combo_Box
    Maybe will have a massive amount of options and modes.

    For the moment, want this to handle a relatively small array of items.
*/

const jsgui = require('../../../../../html-core/html-core');

//function(jsgui, Plus_Minus_Toggle_Button, Vertical_Expander) {

var stringify = jsgui.stringify,
    each = jsgui.each,
    tof = jsgui.tof;
var Control = jsgui.Control;
const def = jsgui.is_defined;


const Item_View = require('./item');
const List = require('./list');

const mx_popup = require('../../../../../control_mixins/popup');

// Post construct compose and activate
//  Want to be able to run same code on client and server.
//  Want code to respond to list changes

// Definitely want a post compose and activate function.
//  Maybe would need to call it from the constructor.

// .setup?
//  .finalize?
//  .finish

// Respond to control changes...
//  Don't just want this on activation, as they are not DOM events, though many would originate there.

// May be like a list.

// 2022 - May be unnecessary. Could make better use of mixins such as list and selectable.

// Does seem worth making some relatively simple examples - though may need jsgui server?
//   Or do more about client-side activation more like jQuery is done...?



class Item_Selector extends Control {
    constructor(spec) {
        spec.__type_name = spec.__type_name || 'item_selector';
        super(spec);
        this.add_class('item-selector');
        // selected_index
        // Could have Object assignproperies done here
        //  use local variables as true private variables.
        if (spec.items) {
            this.items = spec.items
        } else {
            this.items = [];
        }
        if (spec.loop) this.loop = spec.loop;
        //console.log('spec.item_index', spec.item_index);
        if (def(spec.item_index)) {
            this.item_index = spec.item_index;
        } else {
            // Don't want to overwrite the item_index if we have set it up already.
            //  May need this pattern more.
            //  Maybe write more setting code.

            // this.copy_from(spec);
            if (!def(this.item_index)) {
                this.item_index = 0;
            }
        }
        // A loop option.
        if (!spec.el) {
            this.compose_item_selector();
            this.finish_item_selector();
        }


    }
    finish_item_selector() {
        this.item_list.on('change', e_change => {
            //console.log('item_list e_change', e_change);
            if (e_change.name === 'selection') {
                let selected_index = e_change.value;
                this.item_index = selected_index;
                this.current_item_view.item = this.items[selected_index];

                this.raise('change', {
                    'name': 'value',
                    'value': this.items[selected_index],
                    'index': selected_index
                });

                this.value = this.items[selected_index];



                setTimeout(() => {
                    this.item_list.hide();
                }, 120);
            }
        });
    }
    compose_item_selector() {
        // In combo mode normally.
        // current_item
        // item_list

        let current_item_view = this.current_item_view = new Item_View({
            context: this.context,
            item: this.items[this.item_index]
        });
        this.add(current_item_view);

        //console.log('compose_item_selector this.items', this.items);

        let item_list = this.item_list = new List({
            context: this.context,
            items: this.items
        });
        item_list.hide();
        item_list.add_class('item-selector'); // So styling works right in the popup layer.
        mx_popup(item_list);

        this.add(item_list);

        // Render all of the items in a list.
        //  Grid of some kind depending on if horizontal or vertical
        //  

        // Items hidden in a list, the rest of the items in the list hidden?
        //  Specific copy of the item that gets shown, also be able to show item list.

        // Just show it in a list anyway.

        // Go for both single item with neighbours on tiles.
        //  Also all items rendered in a list / sequence.

        // Item_List with direction: horizontal would work well.

        // Item_View
        //  And Tile_Slide processed item view.

        // Want a very simple Item_View that renders the string item as a span, in an item view control marked with classes in the DOM.
        //  Want Item_View with no expand/contract.
        // Depending on the type of items...?
        this._fields = this._fields || {};
        this._fields.item_index = this.item_index;
        this._fields.items = this.items;
        if (this.loop) this._fields.loop = this.loop;
        this._ctrl_fields = this._ctrl_fields || {};
        this._ctrl_fields.current_item_view = current_item_view;
        this._ctrl_fields.item_list = item_list;
    }
    previous(raise_event = true) {
        //console.log('this.item_index', this.item_index);
        let o_change;
        if (this.item_index > 0) {
            this.item_index--;
            this.current_item_view.item = this.items[this.item_index];
            if (raise_event) {
                o_change = {
                    value: this.items[this.item_index],
                    index: this.item_index,
                    size: -1
                }
            }
        } else {
            if (this.loop) {
                this.item_index = this.items.length - 1;
                this.current_item_view.item = this.items[this.item_index];
                if (raise_event) {
                    this.raise('loop', -1);
                    o_change = {
                        value: this.items[this.item_index],
                        loop: -1,
                        index: this.item_index,
                        size: -1
                    }
                }

            }
        }
        if (o_change) {
            if (this.item_index === 0) {
                o_change.first = true;
            }
            if (this.item_index === this.items.length - 1) {
                o_change.last = true;
            }
            this.raise('change', o_change);
        }
    }
    next(raise_event = true) {
        //console.log('this.item_index', this.item_index);
        let old_index = this.item_index;
        let old = this.items[this.item_index];
        let o_change;
        if (this.item_index < this.items.length - 1) {
            this.item_index++;
            this.current_item_view.item = this.items[this.item_index];
            if (raise_event) {
                o_change = {
                    value: this.items[this.item_index],
                    index: this.item_index,
                    size: 1
                };
            }
        } else {
            if (this.loop) {
                this.item_index = 0;
                this.current_item_view.item = this.items[this.item_index];
                if (raise_event) {
                    this.raise('loop', 1);
                    o_change = {
                        value: this.items[this.item_index],
                        loop: 1,
                        index: this.item_index,
                        size: 1
                    };
                    //if (this.item_index === this.items.length - 1) {
                    //    o_change.first = true;
                    //}
                }
            }
        }
        if (o_change) {
            if (this.item_index === 0) {
                o_change.first = true;
            }
            if (this.item_index === this.items.length - 1) {
                o_change.last = true;
            }
            this.raise('change', o_change);
        }
        //console.log('this.items', this.items);
        // Then the item view needs to respond to the item change.
    }
    activate() {
        let ctrl = this;
        if (!this.__active) {
            super.activate();

            let item_list = this.item_list;
            mx_popup(item_list);
            // touchstart - bring up the list

            let has_moved_away = false;
            let t = false;

            /*
            this.item_list.on('change', e_change => {
                console.log('item_list e_change', e_change);
            })
            */

            this.on('touchstart', ets => {
                //console.log('ets', ets);
                // Then cancel the event.
                t = true;

                item_list.popup();

                //console.log('Object.keys(ets)', Object.keys(ets));
                // Returning false from such a DOM event should cancel the event propagation.

                ets.preventDefault();
                //return false;
            })
            this.on('touchend', ete => {
                //console.log('ete', ete);

                if (!has_moved_away) {
                    //this.raise('click', ete);
                }
                has_moved_away = false;
                item_list.hide();
            })
            this.on('touchmove', etm => {
                has_moved_away = true;
                //console.log('etm', etm);
            });
            this.on('click', ec => {
                //item_list.show();

                if (!t) {
                    let replace = item_list.popup();
                    // Event propagation has stopped? :(

                    // then click elsewhere...

                    // best done with body event (delegation)

                    let body = this.context.map_controls['body_0'];

                    let body_click_handler = (e_click) => {
                        //console.log('e_click', e_click);

                        let target_ctrl = this.context.map_controls[e_click.target.getAttribute('data-jsgui-id')];
                        //console.log('target_ctrl', target_ctrl);

                        //let anc = item_list.ancestor(e_click.ctrl);
                        let anc = target_ctrl.ancestor(item_list);
                        //console.log('anc', anc);

                        if (anc) {
                            // Select that item.


                        } else {
                            body.off('click', body_click_handler);
                            replace();
                        }
                    }
                    setTimeout(() => {
                        body.on('click', body_click_handler);
                    }, 0);
                }
            });
            this.finish_item_selector();
        }
    }
}

module.exports = Item_Selector;
},{"../../../../../control_mixins/popup":57,"../../../../../html-core/html-core":149,"./item":89,"./list":90}],89:[function(require,module,exports){
const jsgui = require('../../../../../html-core/html-core');
const {Control, controls, tf, are_equal, each} = jsgui;
const {span} = controls;
const {prop, field} = require('obext');

// Use some mixins here...
//  Expandable
//  Inner space?

const Icon = require('../0-native-compositional/icon');

// May move the left_right creator function elsewhere.
// Control and multi-control creation functions.

// cfn seems like the right abbreviation.


// Always needs the context?
//  Hard to create controls without it.
//  context always as first property.

const c_left_right = (context, l_content, r_content) => {
    // Will retutn an array of 2 ctrls.

    const left = new Control({
        context: context,
        class: 'left'
    })
    left.add(l_content);
    const right = new Control({
        context: context,
        class: 'right'
    })
    right.add(r_content);
    const res = [left, right];
    return res;
}


// Integrated css / sass would be quite useful.
//  Can get the CSS generated from jsgui controls.

// Will be able to put css together from the (prototypes? classes ie constructors?) within jsgui.controls.

// item.css
// item.sass


// Would definitely be easier / neater (and like React) to define the CSS within the Control js file.
// Post browserify, pre babel...
//  That would be a decent time to remove these statements.

// What mode is it being displayed in?

// display_mode property could be useful.

// Item should just be a div for the moment.
//   May be useful naming, more significant in terms of what it is application and logic wise, abstracts from HTML.


// Very vague.

class Item extends Control {

    constructor(spec) {
        spec.__type_name = spec.__type_name || 'item';
        super(spec);
        this.add_class('item');

        // item can be given in the spec.
        //  then look at that object.

        /*

        const item = this.item = spec.item;
        const {context} = this;
        const compose = () => {
            const tfitem = tf(item);
            //console.log('tfitem', tfitem);

            if (tfitem === 'o') {
                // see what keys there are...
                //  use mfp?

                const item_keys = Object.keys(item).sort();
                //console.log('item_keys', item_keys);

                // icon and text?

                // Would be split into 2 parts.
                //  Icon, then the rest (text).

                if (item_keys.length === 2) {
                    if (are_equal(item_keys, ['icon', 'text'])) {
                        //console.log('item with icon and text');
                        
                        // then compose it this way.
                        //  probably want a left part and a right part.

                        //  a function to generate them?
                        // control / controls generator functions...

                        // Then a div / span with the text.
                        //  Div and p? p?

                        const main_content = new span({
                            context: context
                        });
                        main_content.add(item.text);

                        const lr = c_left_right(context, new Icon({
                            context: context,
                            key: item.icon,
                            size: [64, 64]
                        }), main_content);

                        console.log('lr');

                        // adding an array of content... should work!
                        //  TODO: Try it later.
                        each(lr, ctrl => {
                            this.add(ctrl);
                        })

                        // Multi-control creation functions
                        //  Saves encapsulating within a single control.


                        //left_right(new icon, div with text);
                        // would create two controls that cover left and right.
                        //  may be a useful way of creating and wrapping content.

                    }
                }
            }
        }
        if (!spec.el) {
            compose();
        }
        */
    }
}

// CSS as JSON...?
// Could have css as css text.

// Compiling all the CSS together would make a lot of sense.
//  Rather than using basic.css so much. Styling is too separate and hard to find in there.

// The css resource can provide this.
//  Could even be inline within the main HTML file - may be better performance?

// overriding specific CSS properties?
//  maybe requires some kind of decent (simple?) model of css and its properties. would deal with a lot of strings.
//   use the same way that React builds the CSS?

// https://github.com/streamich/nano-css

// Maybe it can just join all the CSS together...
//  And in the right order, it could work quite well.

// It could just put together all of the css strings that get defined.
//  Even include it at the end of basic css?
//   or put it in controls.css
//    That would make sense. All css for all controls compiled into that.

// Item.sass|scss = ...


// Definitely seems like including CSS in the controls will get the whole thing to work better.
//  What about sending / not sending those defs to the client?
//   Some way to remove them in Babel / Browserify / Webpack?

// Would like them in the files, but not in the versions compiled and sent to the client.
//  A Babel transformer could recompile these files to remove the CSS definitions.
//   The CSS would be sent to the client as normal CSS anyway.

// Could create a copy of the whole directory structure pre-babel with the code removed?
//  Maybe look more into babel / typescript code removal options.
//  Or could remove all of this post-babel...
//   Would be able to find those pieces of code.
//   Closure compiler?
//    Gets much smaller js size than Uglify it seems.

// Removing the Class.css assignment statements from compiled js wouldnt be so hard I think.
//  But adds more complexity in the process. Makes programming it easier and less complex though.


// Making it so the CSS only applies within the object itsel - just use class names properly.

// putting it into controls.css makes sense.
// Could check all statements against the statements we have extracted to compile the CSS.

// Lets try this CSS file for the moment.
//  Seems like an easy way to set up the css that applies to the classes specified in the controls.

/*
Item.css = `
.item .icon {
    width: 64px;
    height: 64px;
}
`; // Semicolon seems necessary. `;
*/


module.exports = Item;
},{"../../../../../html-core/html-core":149,"../0-native-compositional/icon":75,"obext":382}],90:[function(require,module,exports){
/*
 if (typeof define !== 'function') { var define = require('amdefine')(module) }

 define(["../../jsgui-html", "./item"],
 function(jsgui, Item) {
 */

const jsgui = require('../../../../../html-core/html-core');
//var Item = require('./old/item');

const Item = require('./item');


// Maybe integrate obext into lang-tools? Or some of it into lang-mini (eventually).

const {each} = jsgui;

const {prop} = require('lang-tools');

var Control = jsgui.Control;
var Collection = jsgui.Collection;

// Could be folded. Could show all items.
//  Could show just a view of a range of items in the list.

// will have a context menu by default

// Swaps will be useful here.

const mx_selectable = require('../../../../../control_mixins/selectable');

// could use a mixin for active-data
//  it would call an add function.

// or raise an event called 'next'.
//  .listen(obs)
//  .observe(obs)

// Do more programming for UI components observing observables.

// SSR will still produce nice looking lists even when not activated. Unlike Date_Picker when it comes to progressive enhancement?
//   Or even with a full Date_Picker when there is no client-side JS, it could fully render the proper Date_Picker on the server,
//     and then send it back to the client having processed a click.
//   So it could run like old-fashioned websites did with no client-side JS, still have a fancy/specifically styled UI date picker.
//     Could have some system where there are various attributes in the querystring or request body so that the server knows params from the client
//       Like ASP.NET was, slightly.








// This needs to be flexible.
//  May be useful to have a .subscribe or .observe function to listen to an observable.
//   Then create items out of the data that gets produced.
//   Would need to focus on client-side observables.
// Want to be able to give it an array or observable, or object, it renders it.
//  But needs to work with resources and objects that interact with server data.

// May be worth being able to use this in a Radio_Button_Group....
//   Different possible internal implementations of controls such as List.
//   By default will use the HTML ul, could use ol


// Likely to want different ways that lists can be rendered.

// Needs to be able to respond to the list changing from outside of the Control.
// Could be a list of controls. Possibly using the List class will help make some things clearer, like a list of items on a menu.

// 




class List extends Control {

    // Items collection as a field?
    //  This would have control content items.
    //  It would / may also have a Collection of items.
    //  It would get given its items as JSON / a JS object / array, and then would create the content Controls.

    // Want it to be easy to create a list, give it the data or the data source.

    /*
     'fields': [
     //['text', String]
     ['toggle_button', Control],
     ['inner_control', Control],
     ['expander', Control]
     ],
     */

    constructor(spec, add, make) {
        // Wont fields have been set?
        //console.log('init list');
        super(spec);
        var that = this;
        // Can take an image
        // Can take some text.
        //  That's all I'll have in the tree node for now.
        this.__type_name = 'list';
        //this.dom.attributes.class', 'list');

        // 'ordered' property. Want it to have change events raised.
        //   probably using 'prop'

        prop(this, 'ordered', spec.ordered || false);


        if (this.ordered) {
            this.dom.tagName = 'ol';
        } else {
            this.dom.tagName = 'ul';
        }

        
        this.add_class('list');

        // Should render as a ul.
        //   Could have some code that puts a 'li' around anything added that is not a 'li' (dom.tagName === 'li').


        // a Collection of items.
        // Collection not needing a Context?
        //  Having all Data_Objects and Collections require a context seems too much.
        //  Context seems important in the case of Controls.

        //this.items = new Collection();

        //this.set('items', coll_items);
        //console.log('spec.items', spec.items);
        //throw 'stop';

        // Could have items property and listen for item change events.
        //   Preferably that will work server-side too, adding and removing controls as necessary, and then on the client
        //     side those updates will then be updated in the DOM.



        prop(this, 'items', spec.items);
        /*

        if (spec.items) {
            // is the type a Collection? An Array?

            //this.items.set(spec.items);
            this.items = spec.items;
        } else {
            this.items = new Collection();
        }
        */

        // The list spec could also take info about how to display the items.

        // And create a new item control for each item.
        //  I think an 'item' control could be quite useful. Shows some data.
        //   Won't be too big, but will be flexible in what it can do.

        // Will take some JSON, and render it using sensible defaults.
        //  Eg name first and in bold.
        //  Maybe key
        //

        // A general purpose item control will be quite useful.
        //  Item will be fairly general purpose, and much of the purpose of using it is to show intent rather than because of
        //  an 'item' doing particular things. It just is. It will be like a control, except it's generally used for rendering some particular data.
        // Want the Item and the List to be convenient UI components. They need to make it simple to represent some data.
        //  Items and Lists could potentially use templates to quickly render data.

        // Any need to send the list as a jsgui field?
        // listen for changes to the list. represent those changes in the UI controls. Then these get automatically changed in the DOM by other code.
        // This is where a Collection could help a lot.
        /*

        this.items.on('change', (evt_change) => {
            //console.log('evt_change', evt_change);
            if (evt_change.type === 'insert') {
                var ctrl_item = new Item({
                    'context': this.context,
                    'value': evt_change.item
                });

                this.add(ctrl_item);
            }
        });
        */
        // A system to share objects sent to the client by reference.
        //  Could tag an object to send to the client, assign it an id, and then only need to send it once.
        // A system of objects-to-client
        if (!spec.el) {
            //let ss = this.context.new_selection_scope(this);
            //console.log('ss', ss);
            this.compose_list();
        }
        // the selection scope could just be a number on the server.
    }

    'compose_list' () {


        each(this.items, (item, index) => {
            //console.log('item', item);


            // Make it a List_Item....?


            // Make it a 'li'.
            //  Maybe want more flexibility?
            //    Or take existing item specs, and add the context.

            // Being able to make controls without specifying the context will help.
            //   Have the context get set as soon as they are added inside another control which has a context.
            //     Can not rely on the IDs of the controls before they have a context.
            //       Maybe could / would need to tighten up some other code so it does not assume or need a context at some points.
            


            // Maybe a list-item control will be best.
            //   And could be very basic HTML.
            // May want a simple and quick to write way of specifying the inner controls.
            //   Could make it work specifically on controls that only have one inner section.

            




            var ctrl_item = new Item({
                'context': this.context,
                'value': item
            });

            ctrl_item._fields = ctrl_item._fields || {};
            ctrl_item._fields.index = index;
            
            //console.log('ctrl_item.selectable', ctrl_item.selectable);
            mx_selectable(ctrl_item);
            ctrl_item.selectable = true;

            this.add(ctrl_item);
        });
    }

    'activate' () {
        //console.log('');
        //console.log('activate list');
        if (!this.__active) {
            super.activate();

            each(this.$('item'), item => {
                item.selectable = true;
            })
            let ss = this.find_selection_scope();
            if (ss && ss.on) {
                //console.log('ss', ss);

                ss.on('change', e_change => {
                    //console.log('1) list ss e_change', e_change);

                    let item = e_change.value;
                    //console.log('item', item);

                    this.selected_index = item.index;

                    this.raise('change', {
                        'name': 'selection',
                        'value': item.index
                    })
                })
            }
        }

        // Could use delegated click events.
        //  Would save having to wire up each item.

        // The items themselves could be selectable.


        // put the context menu in place.
        //throw 'stop';

        // Not all lists need context menus.

        /*

        this.context_menu({
            'Delete': function() {
                console.log('context_menu Delete');

                // need to actually delete it if possible?

            },
            'Edit': function() {
                console.log('context_menu Edit');
                // need to actually delete it if possible?
            }
        });
        */

        // Need to listen for new items being added.
        //  (Changes being made)



    }
}
module.exports = List;
},{"../../../../../control_mixins/selectable":62,"../../../../../html-core/html-core":149,"./item":89,"lang-tools":186}],91:[function(require,module,exports){

const jsgui = require('../../../../../html-core/html-core');

const {stringify, each, tof, Control} = jsgui;
//var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof;
//var Control = jsgui.Control;

// Maybe we can just use 'item'.


// Could make this API the same as tree node where possible.

class Menu_Node extends Control {
    // fields... text, value, type?
    //  type could specify some kind of validation, or also 'password'.

    // single field?

    // Actually having a different content?
    //  Or use inner_content.

    // Menu node having expanded and contracted states.

    // Menu Node has an image and some text, and a contrainer control for othe Menu nodes.
    //  Can be collapsed so that the internal items don't show

    //'fields': [
    //['text', String]


    //],

    //'fields': {
    //	'img_src': 'string',
    //	'text': 'string'
    //},

    //  and can have other fields possibly.


    constructor(spec, add, make) {
        // Wont fields have been set?

        super(spec);

        // Can take an image
        // Can take some text.
        //  That's all I'll have in the Menu node for now.
        this.__type_name = 'menu_node';
        //var that = this;
        if (!this._abstract) {
            if (!spec.el) {
                this.add_class('menu-node');
                var spec_state = spec.state, state;

                var main_control = make(Control({ 'class': 'main' }));
                this.add(main_control);
                //console.log('**** spec.img_src', spec.img_src);
                if (spec.img_src) {
                    //var img_src = this.get('img_src');
                }
                if (spec.text) {
                    //this.set('text', spec.text);
                    this.text = spec.text;

                    var span = make(jsgui.span({}));

                    //var text = this.get('text');
                    //console.log('text', text);
                    //console.log('tof text', tof(text));

                    span.add(spec.text);
                    main_control.add(span);
                }
                var menu = spec.menu;
                if (menu) {
                    this.set('menu', menu);
                }

                var inner_control = this.inner_control = make(Control({ 'class': 'inner hidden' }));
                this.add(inner_control);

                // Inner may not just be the title.

                //this.set('inner_control', inner_control);

                //inner_control.hide();

                //var inner_control_content = inner_control.content;
                // reference to a menu control.
                // maybe take 'value' here
                if (spec.value) {
                    // depending on the type of obj, work differently.
                    //  array of strings, just make those menu items.

                    var obj_menu = spec.value;
                    var t_obj_menu = tof(obj_menu);
                    console.log('t_obj_menu', t_obj_menu);

                    if (t_obj_menu == 'array') {
                        each(obj_menu, function(v) {
                            // make a new menu node with that as the value?

                            var tv = tof(v);
                            if (tv == 'string') {
                                // new node with text, no inner nodes.

                                var nested_menu_node = make(Menu_Node({
                                    'text': v,
                                    'menu': menu
                                }));
                                inner_control.add(nested_menu_node);
                            }
                        })
                    }
                }

                var ctrl_fields = {
                    'inner_control': inner_control._id(),
                    'main_control': main_control._id(),
                    'menu': spec.menu._id()
                }

                // use different quotes...

                this.set('dom.attributes.data-jsgui-ctrl-fields', stringify(ctrl_fields).replace(/"/g, "'"));

                if (spec_state) {

                    // open and closed
                    if (spec_state == 'open' || spec_state == 'closed') {
                        state = this.set('state', spec_state);
                    } else {
                        throw 'spec.state expects "open" or "closed".';
                    }
                } else {
                    state = this.set('state', 'open');
                }
            }
        }
    }
    'activate'() {

        if (!this.__active) {
            super.activate();

            var inner_control = this.inner_control;
            var main_control = this.main_control;
            var menu = this.menu;

            var that = this;

        }
    }
    'close_all'() {
        console.log('menu-node close_all');

        // need to do this recursively I think.
        //  could call this recursively on all nodes.
        //

        var inner_control = this.inner_control;

        inner_control.content.each(function(v, i) {
            //console.log('i', i);
            //console.log('v', v);
            var tn = v.__type_name;
            //console.log('tn', tn);
            if (tn == 'menu_node') {
                v.close_all();
            }
            //v.close_all();
        });

        inner_control.hide();
        // this.silent?
        this.set('state', 'closed', true); // silent

    }
    'close'() {
        var inner_control = this.inner_control;
        inner_control.hide();
        this.set('state', 'closed', true);
    }
    'open'() {
        var inner_control = this.inner_control;
        inner_control.show();
        this.set('state', 'open', true);
    }


}
module.exports = Menu_Node;

},{"../../../../../html-core/html-core":149}],92:[function(require,module,exports){
const jsgui = require('../../../../../html-core/html-core');
const clone = jsgui.clone;
const each = jsgui.each, is_defined = jsgui.is_defined;
const Grid = require('./grid');
const Tile_Slider = require('../../../1-standard/6-layout/tile-slide');
let days = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'];
let bgc_disabled = '#DDDDDD';
let bgc_enabled = 'inherit';
const mx_date = require(`../../../../../control_mixins/typed_data/date`);
class Month_View extends Grid {
    constructor(spec) {
        spec.grid_size = [7,7]; spec.size = spec.size || [360,200]; spec.__type_name = 'month_view';
        super(spec); mx_date(this, spec);
        if (!spec.el) { this.compose_month_view(); }
        this.context.new_selection_scope(this);
    }
    activate() {
        super.activate();
        let cells = this.$('grid_cell');
        each(cells, cell => {
            //cell.selectable = true;
            cell.on('change', e_change => {
                if(e_change.name==='selected' && e_change.value && is_defined(cell.value)) { this.day = cell.value; }
            });
        });
    }
    compose_month_view() {
        this.refresh_month_view(); this.add_class('month-view');
        let days_row = this._arr_rows[0]; 
        days_row.add_class('days'); days_row.add_class('header');
        // Insert day name abbreviations using cell.span.add():
        each(days_row.content._arr, (cell, i) => { if(cell.span) { cell.span.add(days[i]); } });
        let cell_pos = [0,1], ctrl_row = this._arr_rows[cell_pos[1]];
        let advance_cell = () => {
            if(cell_pos[0] === ctrl_row.content._arr.length - 1) {
                if(cell_pos[1] < this._arr_rows.length - 1) { cell_pos[0] = 0; cell_pos[1]++; ctrl_row = this._arr_rows[cell_pos[1]]; }
                else return false;
            } else { cell_pos[0]++; }
            return true;
        };
        let d = new Date(this.year, this.month, 1);
        let got_day = d.getDay() - 1; if(got_day < 0) got_day = 6;
        while(cell_pos[0] < got_day) {
            let cell = ctrl_row.content._arr[cell_pos[0]++];
            cell.selectable = false; cell.select_unique = true; cell.background.color = bgc_disabled;
        }
        let did_advance = true;
        while(did_advance) {
            let cell = ctrl_row.content._arr[cell_pos[0]];
            cell.selectable = true; cell.select_unique = true; cell.value = d.getDate();
            cell._fields = cell._fields || {}; cell._fields.value = cell.value;
            d.setDate(d.getDate() + 1);
            did_advance = advance_cell() && d.getDate() !== 1;
        }
        while(cell_pos[0] <= 6) {
            let cell = ctrl_row.content._arr[cell_pos[0]++];
            cell.selectable = false; cell.select_unique = true; cell.background.color = bgc_disabled;
        }
        if(cell_pos[1] < 6) {
            cell_pos = [0, 6]; ctrl_row = this._arr_rows[cell_pos[1]];
            while(cell_pos[0] <= 6) {
                let cell = ctrl_row.content._arr[cell_pos[0]++];
                cell.selectable = false; cell.select_unique = true; cell.background.color = bgc_disabled;
            }
        }
    }
    refresh_month_view() {
        let d = new Date(this.year, this.month, 1), m = d.getMonth();
        let got_day = d.getDay() - 1; if(got_day < 0) got_day = 6;
        let day = this.day;
        this.each_cell((cell, cell_pos) => {
            let [x, y] = cell_pos;
            if(y > 0) {
                if(y === 1) {
                    if(x < got_day) {
                        cell.background.color = bgc_disabled; cell.selectable = false;
                        if(cell.deselect) cell.deselect(); cell.value = null;
                        cell.iterate_this_and_subcontrols(ctrl => { if(ctrl.dom.tagName === 'span') ctrl.text = ''; });
                    } else {
                        cell.background.color = bgc_enabled; cell.selectable = true;
                        cell.span.add(d.getDate() + ''); d.setDate(d.getDate() + 1);
                    }
                } else {
                    let dm = d.getMonth();
                    if(dm === m) {
                        cell.background.color = bgc_enabled; cell.selectable = true;
                        cell.span.add(d.getDate() + ''); d.setDate(d.getDate() + 1);
                    } else {
                        cell.background.color = bgc_disabled; cell.selectable = false;
                        if(cell.deselect) cell.deselect(); cell.value = null;
                    }
                }
            }
        });
    }
}
Month_View.Tiled = Tile_Slider.wrap(Month_View, spec => {
    spec = clone(spec);
    if(!is_defined(spec.month)) {
        let now = new Date();
        spec.month = now.getMonth(); spec.year = now.getFullYear();
    }
    spec.month = spec.month - 1; if(spec.month < 0) { spec.month = 11; spec.year = spec.year - 1; }
    return spec;
}, spec => {
    spec = clone(spec);
    if(!is_defined(spec.month)) {
        let now = new Date();
        spec.month = now.getMonth(); spec.year = now.getFullYear();
    }
    spec.month = spec.month + 1; if(spec.month > 11) { spec.month = 0; spec.year = spec.year + 1; }
    return spec;
});
module.exports = Month_View;
},{"../../../../../control_mixins/typed_data/date":66,"../../../../../html-core/html-core":149,"../../../1-standard/6-layout/tile-slide":125,"./grid":87}],93:[function(require,module,exports){


const jsgui = require('../../../../../html-core/html-core');
var Toggle_Button = require('./toggle-button');
//if (typeof define !== 'function') { var define = require('amdefine')(module) }

//define(["../../jsgui-html", "./toggle-button"],
//function(jsgui, Toggle_Button) {

var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof;
var Control = jsgui.Control;

class Plus_Minus_Toggle_Button extends Toggle_Button {

    //  and can have other fields possibly.

    constructor(spec, add, make) {

        // Set it so it only has two states
        //  '+' and '-'
        spec.__type_name = 'plus_minus_toggle_button';
        spec.states = ['+', '-'];
        spec.state = spec.state || '-';

        //console.log('spec.context', spec.context);

        super(spec);
        let state = this.state = spec.state;

    }
};
//return Plus_Minus_Toggle_Button;

//return jsgui;


//});

module.exports = Plus_Minus_Toggle_Button;

},{"../../../../../html-core/html-core":149,"./toggle-button":99}],94:[function(require,module,exports){
/**
 * Created by James on 04/08/2014.
 */


const jsgui = require('../../../../../html-core/html-core');
var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof, is_defined = jsgui.is_defined;
var Control = jsgui.Control;
var group = jsgui.group;
var Radio_Button = require('../0-native-compositional/radio-button');
// And the tab buttons act as radio buttons.
//  Having a JSGUI radio button replacement would be nice.
//   Could choose whether to render as a radio button and progressively enhance on the client...
//    Client-side enhancement of semantic HTML.

//   Or render as it appears on the client?
//    Being able to handle both would be nicest.
//    Possibly radio buttons could have good styling on modern clients anyway?
//    May want them to look very different to normal radio buttons though, eg using them for tabs.

// RadioButtonGroup could be a useful Control as well.
//  May provide an easier interface that abstracts away from having to directly make some of the controls.

// And have a selected and selected value API.
//   Make the API common with other things, interoperable nicely.

class Radio_Button_Group extends Control {
    // panel name?

    // Should not need to give a group name...

    //'fields': {
    //    'items': Array
    //},

    // maybe add before make would be better. add will probably be used more.
    constructor(spec, add, make) {
        super(spec);

        this.__type_name = 'radio_button_group';

        this.add_class('radio-button-group');

        //console.log('spec.el', spec.el);

        var context = this.context;
        //var that = this;


        if (!spec.abstract && !spec.el) {
            var id = this._id();

            //
            var items = this.get('items').value();
            //console.log('items', items);
            //throw 'stop';

            each(items, (v, i) => {

                // jsgui advanced Radio Buttons will also be able to have a text label next to them.
                //  May render itself as an item inside a div, with the value next to it.
                //  Would be interesting to have a control that is 0 depth container...
                //   Like a div, but does not exist.

                // So a control could have contents, but could have no DOM node of its own.
                //  Or it has got more than one top level DOM node?
                // Do not want to have to put everything inside a DIV.
                //  An HTML radio button with its label next to it looks just like the kind of thing that could work as a 2 element control.
                //   Make it have an array of elements as its .el?
                //    or .els?
                //  Seems like it would add more complexity to the branching.
                //   Brings up more edge cases, makes rules more complex.

                // Could get on with this and override the rendering mechanism?
                //  Or have an option not to render the control itself?

                // .content_only property?
                //  Does not render the control itself, only its content.
                //   Then the content can include the HTML radio button control itself.

                // But then sending the control that has not HTML element to the client?
                //  Details of that control could be included in the next level down that does get shown.

                // Should put them in a Div for the moment, the find a way to remove that DIV from the markup.
                //  Avoid more hacks + complexity for now. Just get the tabs etc working smoothly.



                var radio_button = new Radio_Button({
                    'context': context,
                    'name': id,
                    'text': v,
                    'value': v
                });

                this.add(radio_button);
            });



            /*
             var ctrl_fields = {
             'ctrl_relative': div_relative._id(),
             'title_bar': title_bar._id()
             }


             this.set('dom.attributes.data-jsgui-ctrl-fields', stringify(ctrl_fields).replace(/"/g, "'"));
             */


        }

    }
    //'resizable': function() {
    //},
    'activate'() {
        //console.log('1) Activate radio_button_group');
        if (!this.__active) {
            var that = this;
            super.activate();

            var ctrl_checked;
            //console.log('2) Activate radio_button_group');
            this.content.each(function(ctrl, i) {

                ctrl.on('change', false, function(e_change) {
                    //console.log('rbg e_change', e_change);

                    ctrl_checked = ctrl;

                    that.raise('change', {
                        'checked': ctrl_checked
                    })
                })
            })
        }
    }
}

module.exports = Radio_Button_Group;
},{"../../../../../html-core/html-core":149,"../0-native-compositional/radio-button":76}],95:[function(require,module,exports){
/**
 * Created by James on 29/02/2016.
 */

const jsgui = require('../../../../../html-core/html-core');
var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof;
var Control = jsgui.Control;
var Scrollbar = require('./scrollbar');
var H_Scrollbar = Scrollbar.H, V_Scrollbar = Scrollbar.V;

// Scroll_View
//  Being a Control that has both scrollbars optionally
//   Also left for RTL languages?
//   Also possibility of scrollbar on top?
//    Never used that way.

class Scroll_View extends Control {

    // Though maybe tell it to be an array and it should be an array rather than a collection?
    //  Or a Data_Value that holds an array?

    //'fields': [
    //    ['text', String],
    //    ['state', String],
    //    ['states', Array]
    //],
    //  and can have other fields possibly.

    constructor(spec, add, make) {

        super(spec);
        this.__type_name = 'toggle_button';
        this.add_class('scrollbar');

        // Always active?

        if (!spec.abstract && !spec.el) {

            // Compose the different sections.
            //  Grid9 would be a useful abstraction here.
            //  Will not use it right now. Grid_9 currently makes DOM interactions and it would be better if it used the right JSGUI abstractions.


            // So, in composition we need to know which scrollbars are showing.

            // show_h_scrollbar, show_v_scrollbar

            // Need to have up to three components rendered
            //  2 scrollbars, inner view


            // For the moment we will have thw tro scrollbars rendered not optionally.

            // Need to be aware of the widths of the various scrollbars.

            var inner_view = new Control({
                'context': this.context
            });
            var h_scrollbar = new H_Scrollbar({
                'context': this.context
            });
            var v_scrollbar = new V_Scrollbar({
                'context': this.context
            });

            this.add(inner_view);
            this.add(h_scrollbar);
            this.add(v_scrollbar);
            this.active();
        }
        var that = this;
    }
    'activate'() {
        if (!this.__active) {
            super.activate();
            var that = this;
        }
    }
}

module.exports = Scroll_View;

},{"../../../../../html-core/html-core":149,"./scrollbar":96}],96:[function(require,module,exports){
/**
 * Created by James on 28/02/2016.
 */


const jsgui = require('../../../../../html-core/html-core');
var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof;
var Control = jsgui.Control;
var Button = require('../0-native-compositional/button');

// Seems a good candidate to be a 'core' control.
//  Possibly code will be promoted / sunk to the core.

// Scroll_View
//  Being a Control that has both scrollbars optionally
//   Also left for RTL languages?
//   Also possibility of scrollbar on top?
//    Never used that way.

// __direction being part of Display_Modes options properties?

class Scrollbar extends Control {

    // Though maybe tell it to be an array and it should be an array rather than a collection?
    //  Or a Data_Value that holds an array?

    //'fields': [
    //    ['text', String],
    //    ['state', String],
    //    ['states', Array]
    //],
    //  and can have other fields possibly.

    constructor(spec, add, make) {

        super(spec);
        this.__type_name = 'scrollbar';

        // Always active?

        this.active();
        var that = this;
        var context = this.context;

        if (!spec.abstract && !spec.el) {
            this.add_class('scrollbar');
            var btn_negitive = new Button({
                'context': context
            });
            var scroll_area = new Control({
                'context': context
            });
            var dragable_scroller = new Control({
                'context': context
            });
            var btn_positive = new Button({
                'context': context
            });
            this.add(btn_negitive);
            scroll_area.add(dragable_scroller);
            this.add(scroll_area);
            this.add(btn_positive);
        }

    }
    'activate'() {

        if (!this.__active) {
            super.activate();
            var that = this;

        }
    }
}

class Horizontal_Scrollbar extends Scrollbar {
    constructor(spec) {
        super(spec);
        this.__direction = 'horizontal';
        
    }
}

class Vertical_Scrollbar extends Scrollbar {
    constructor(spec) {
        super(spec);
        this.__direction = 'vertical';
        
    }
}

Scrollbar.H = Scrollbar.Horizontal = Horizontal_Scrollbar;
Scrollbar.V = Scrollbar.Vertical = Vertical_Scrollbar;

module.exports = Scrollbar;

},{"../../../../../html-core/html-core":149,"../0-native-compositional/button":70}],97:[function(require,module,exports){

const jsgui = require('../../../../../html-core/html-core');
var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof;
var Control = jsgui.Control;

// The basic controls should not do too much on top of normal HTML, but make it easier to do a few things
//  there.

const textNode = require('../../../../../html-core/text-node');
// more work on fields? or use obext fields for now?
var fields = [
    ['value', String, '']

];

// Maybe not much need for this?

// A div containing a text node.
//   Possibly enable better control over inner text / html of both spans and divs.

// Being able to use .view.data.model.value to hold the text, as well as .data.model.value.
//   and then also just .value shortcutting to .data.model.value.





class Text_Item extends Control {
    // is an Input element.
    //  type of either text or password.
    // could possibly specify some of the starting field values in this part.

    constructor(spec) {
        //this._super(spec, fields);
        super(spec, fields);
        this.__type_name = 'text_item';
        this.add_class('item');

        // composition function instead...

        this.add(new textNode({
            text: this.value,
            context: this.context
        }))
    }
}
module.exports = Text_Item;

},{"../../../../../html-core/html-core":149,"../../../../../html-core/text-node":153}],98:[function(require,module,exports){
var jsgui = require('../../../../../html-core/html-core');
var stringify = jsgui.stringify,
    each = jsgui.each,
    tof = jsgui.tof;
var Control = jsgui.Control;
const Date_Picker = jsgui.Date_Picker;

// Extending, with field values being set?
//  Setting field values in definitions may be a useful thing.

// Date_Time_Selector
//  Not a calendar itself. Just used to select a Date value. Shows it on a calendar (fairly small).
//  Could use a Calendar control though, with specific config not to show other things.
//   Though could mark dates there too.

// Date_Picker
//  Maybe that will just have the date option.

// Starting / default values.

// From, to.
// .span




// text alias being title?
class Timespan_Selector extends Control {
    // fields... text, value, type?
    //  type could specify some kind of validation, or also 'password'.
    // single field?
    //  and can have other fields possibly.
    constructor(spec) {
        spec = spec || {};
        spec.__type_name = spec.__type_name || 'timespan_selector';

        super(spec);

        if (spec.span) {
            this.span = spec.span;

        } else {
            //
            this.span = [];
        }

        if (!spec.skip_compose) {
            this.compose();
        }

    }
    compose() {
        let context = this.context;
        let date_from = this.span[0] || new Date('2018-06-20T11:00:00');
        let date_to = this.span[0] || new Date('2018-08-20T11:00:00');
        
        let picker_from = new Date_Picker({
            context: this.context,
            date: date_from
            
        });
        this.add(picker_from);

        let picker_to = new Date_Picker({
            context: this.context,
            date: date_to
            
        });
        this.add(picker_to);
        
    }
};
module.exports = Timespan_Selector;
},{"../../../../../html-core/html-core":149}],99:[function(require,module,exports){
/*
if (typeof define !== 'function') { var define = require('amdefine')(module) }

define(["../../jsgui-html-enh"],
 function(jsgui) {
*/

// Should have a toggle button group to allow selection / activation of individual buttons.
//  Will have an event for when the button selection changes.
//  Perhaps this could be done with a selection group, like a radio group.
// For the moment, I think a Toggle_Button_Group is the right way to go.

// Maybe we really want a 'select_button'.
//  Don't want clicking it again to unselect it.
//  Perhaps we just want to say a button is 'selectable'.

const jsgui = require('../../../../../html-core/html-core');

//var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof;
//var Control = jsgui.Control;

const {stringify, each, tof, def, Control} = jsgui;
// Can the button contain an image?
//  Would be useful for a start/stop button.
//  Toggle button toggling between two images.

// Nice of obext did a bit in terms of object.grammar.
//  Defining the grammar of objects and functions seems very useful.
//   In some cases, it could be used to make more concise and declarative code.

// Look at using mixin state management and display modes.
//   Have the code in the controls more declarative and concise.


const { prop, field } = require('obext');

class Toggle_Button extends Control {

    constructor(spec, add, make) {
        spec = spec || {};
        spec.__type_name = spec.__type_name || 'toggle_button';
        super(spec);
        this.add_class('toggle-button');
        field(this, 'states', spec.states || '');
        field(this, 'state', spec.state || '');
        if (!spec.abstract && !spec.el) {
            const _compose = () => {
                var span_state = this.span_state = new jsgui.span({ 'context': this.context, text: this.state });
                this.add(span_state);
            }
            const compose = () => jsgui.parse_mount(`<span name='span_state'>${this.state}</span>`, this, jsgui.controls);
            compose();
        }
        this.on('change', e_change => {
            //console.log('Toggle_Button change', e_change);
            if (this.span_state) this.span_state.text = e_change.value;
        });
        if (typeof document === 'undefined') {
            //this.dom.attributes['data-jsgui-fields'] = stringify(active_fields).replace(/"/g, "'");
            this.dom.attributes['data-jsgui-ctrl-fields'] = stringify({
                'span_state': this.span_state._id()
            }).replace(/"/g, "'");
            //this.set('dom.attributes.data-jsgui-fields', stringify(active_fields).replace(/"/g, "'"));
        }
    }

    'activate'() {
        if (!this.__active) {
            super.activate();
            this.on('click', e_click => {
                var state = this.state;
                var states = this.states;
                var i_current_state;
                if (tof(states) === 'array') {
                    each(states, (i_state, i) => {
                        if (i_state === state) {
                            i_current_state = i;
                        }
                    })
                    var i_next_state = i_current_state + 1;
                    if (i_next_state === states.length) i_next_state = 0;
                    var str_next_state = states[i_next_state];
                    this.raise('toggle', {
                        'state': str_next_state
                    });
                    this.state = str_next_state;
                } else {
                    throw 'stop'
                }
            })
        }
    }
}
module.exports = Toggle_Button;
},{"../../../../../html-core/html-core":149,"obext":382}],100:[function(require,module,exports){
/*
 if (typeof define !== 'function') { var define = require('amdefine')(module) }

 define(["../../jsgui-html", "./text-field"],
 function(jsgui, Text_Field) {
 */

var jsgui = require('./../../../../html-core/html-core'), Text_Field = require('../0-basic/1-compositional/Text_Field');

var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof;
var Control = jsgui.Control;

// Another type of control? - composite or basic-composite?
//  That would be an unenhanced Login control. Made up of basic controls, will render and
//   be useful on very limited platforms.

// Since this is now an advanced control...

// relatively advanced.
//  maybe a 'platform' or 'web-platform' control.
//  jsgui3-html-controls-web-platform.
//   dont like it, too long.




class Login extends Control {

	// Maybe should put this into a form, so that it does a form post.
	//  That could possibly be disabled.


	constructor(spec) {
		super(spec);
		var make = this.make;
		//this.add_class('login-control');
		this.add_class('login-control');

		// and use a form control, set it's dom attributes.
		//  will use relative login url.

		// We can get the cookies from the context.

		var req = this.context.req;

		console.log('--- Within Login Control ---');

		var headers = req.headers;
		console.log('headers ' + stringify(headers));

		// If logged in, show a welcome message and logout button rather than the form.
		//  However, the application should have authenticated at an earlier stage.
		//   Perhaps it would also come up with the permissions for that user, but there could be many specific permissions
		//    for different objects.



		//console.log('this.context ' + stringify(this.context));
		var auth = this.context.auth;
		console.log('auth ' + stringify(auth));

		if (auth && auth.verified) {
			var div_logged_in = new jsgui.div({
				'context': this.context
			});
			//div_logged_in.add('Logged in as ' + )

			var span_logged_in = new jsgui.span({
				'context': this.context
			})

			span_logged_in.add('Logged in as: ' + auth.username);

			div_logged_in.add(span_logged_in);

			// And a button to log out.
			//  This will carry out an action, like the login, but without a form.
			var frm = new jsgui.form({
				'context': this.context
			})
			// action, method


			frm.dom.attrs.set({
				'action': '/logout/?returnurl=%2F',
				'method': 'POST'
			});
			//frm.set('dom.attributes.action', '/logout/?returnurl=%2F');
			//frm.set('dom.attributes.method', 'POST');

			div_logged_in.add(frm);

			var btn = new jsgui.button({
				'context': this.context

			})
			btn.dom.attrs.set({
				'type': 'submit',
				'value': 'submit',
				'class': 'logout'
			});

			btn.add('Logout');
			frm.add(btn);

			this.add(div_logged_in);

		} else {
			var frm = new jsgui.form({
				'context': this.context
			})
			// action, method

			//frm.set('dom.attributes.action', '/login/?returnurl=%2F');
			//frm.set('dom.attributes.action', '/login');
			//frm.set('dom.attributes.method', 'POST');

			frm.dom.attrs.set({
				'action': '/logout/?returnurl=%2F',
				'method': 'POST'
			});

			this.add(frm);
			// and composed of two text fields...

			var tf_username = new Text_Field({
				'text': 'Username',
				'name': 'username',
				'value': '',
				'type': 'text',
				'context': this.context

			})

			frm.add(tf_username);

			// This is a factory function that calls the constructor,
			//  with this context as the context.
			//make(Text_Field({}));

			var tf_password = new Text_Field({
				// a name field as well?
				//  a name for the form

				'text': 'Password',
				'name': 'password',
				'value': '',
				'type': 'password',
				'context': this.context

			})

			frm.add(tf_password);

			// <BUTTON name="submit" value="submit" type="submit">
			var btn = new jsgui.button({
				'context': this.context

			})
			btn.dom.attrs.set({
				'type': 'submit',
				'value': 'submit',
				'class': 'login'
			});

			btn.add('Login');

			frm.add(btn);
		}
		//throw 'stop';
	}
}

module.exports = Login;

},{"../0-basic/1-compositional/Text_Field":81,"./../../../../html-core/html-core":149}],101:[function(require,module,exports){

var jsgui = require('./../../../../html-core/html-core');
//var Horizontal_Menu = require('./horizontal-menu');

var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof, is_defined = jsgui.is_defined;
//var Control = jsgui.Control;

var Button = require('../0-basic/0-native-compositional/button');
var Item = require('../0-basic/1-compositional/item');
var Collection = jsgui.Collection;
var Data_Value = jsgui.Data_Value;

// Titled_Panel would be useful.
//  Would extend the panel, and also show it's name or title.

// Want to keep panel simple. Could have Titled_Panel, maybe Resizable_Panel.
//  If we want a panel with a lot of functionality, it would be the Flexi_Panel.


// A 'platform' control.
//  Not basic. Will still have its own file for the moment.


// limited states feature.
//  can oble be one of a few.
//  may as well give as an array or list in many cases.


class Popup_Menu_Button extends Button {
    // panel name?

    // could have a title field.
    //'fields': {
    //    'name': String
    //}
    // maybe add before make would be better. add will probably be used more.
    constructor(spec, add, make) {
        spec.no_compose = true;
        spec['class'] = 'popup-menu-button';
        super(spec);
        this.__type_name = 'popup_menu_button';
        //this.add_class('panel');
        //console.log('pre add class');
        //console.log('1) this.dom.attrs', this.dom.attrs);
        //this.add_class('popup-menu-button');
        //console.log('2) this.dom.attrs', this.dom.attrs);
        // Should set the class in the DOM if its not set already.

        var context = this.context;
        // that = this;
        // With name as a field, that field should get sent to the client...

        // Then will have the hidden menu that appears when the popup menu button is clicked.

        // Has a list/collection of items.

        // Use Stateful mixin?

        // Mixins may be a bit tricky in terms of adding both composition and activation stages.
        //  Mixins would need to be loaded in order, and applied with care.
        //  ._mixin_compose
        //  ._mixin_activate
        //  ._arr_mixin_names

        //  These two would also need to be made as properties of the Control, so that they can be added to by the mixins.
        //  ._active_fields
        //  ._ctrl_fields


        

        var setup_mixins = function () {
            this.mixin(
                ['open_closed', 'closed'],
                ['item_container']
            )
        }


        // Update this!
        this.states = ['closed', 'open'];
        this.state = new Data_Value('closed');
        this.i_state = 0;

        var active_fields = this.active_fields = {};
        active_fields.states = this.states;
        active_fields.state = this.state;
        active_fields.i_state = this.i_state;

        var compose = () => {
            this.text = spec.text || spec.label || '';
            var root_menu_item = new Item({
                'context': context,
                'item': this.text
            });
            root_menu_item.add_class('popup-menu');

            this.add(root_menu_item);
            root_menu_item.inner.add_class('popup-menu');
            this.root_menu_item = root_menu_item;

            // Then the inner part / the part that is hidden within the root node.
            // Show / hide the hidden area based on click or hover.

            if (spec.items) {
                //console.log('spec.items', spec.items);
                let items = this.items = new Collection(spec.items);
                //console.log('this.items', this.items);
                each(items, item => {
                    //console.log('item', item);

                    var menu_item = new Item({
                        'context': context,
                        'item': item
                    });
                    menu_item.add_class('popup-menu');
                    root_menu_item.inner.add(menu_item);

                    // Then add a callback event, if we have that.
                    //  Post-activation I suppose.

                });
            };

            var ctrl_fields = {
                'root_menu_item': root_menu_item._id()
            }

            //this.set('dom.attributes.data-jsgui-ctrl-fields', stringify(ctrl_fields).replace(/"/g, "'"));
            this.dom.attrs['data-jsgui-fields'] = stringify(active_fields).replace(/"/g, "'");
            this.dom.attrs['data-jsgui-ctrl-fields'] = stringify(ctrl_fields).replace(/"/g, "'");
        }

        if (!spec.abstract && !spec.el) {
            // Render the menu itself as a bunch of items / an item tree.
            // Create the top level menu item.
            compose();
        }

        if (spec.el) {
            // A different type of constructor usage. Most likely client-side / within a web browser.
            // The element could be empty.
            //  If so, we need to carry out the compose stage.
            compose();
            // Needs to reflect changes within itself to the DOM.
            //  Possibly this is where react could come in.

            // It does not have a rendering phase at the moment when it's not being rendered on the server.
            //  Want small and to-the-point client-side rendering.

        }
    }
    //'resizable': function() {
    //},
    'activate'() {
        if (!this.__active) {
            super.activate();

            // Activating should set the CSS class of the node if necessary.

            var root_menu_item = this.root_menu_item;

            //console.log('root_menu_item.inner', root_menu_item.inner);

            //console.log('Popup_Menu_Button activate');
            // Need references?
            //var that = this;

            //console.log('this.root_menu_item', this.root_menu_item);

            // Respond to clicks / selects of the inner menu items.
            // All the descendent items need to have events.
            //  Want to have it so that the event handler can be called directly when that item is clicked.

            // Want to set up the onclicks in the construction / composition.



            //console.log('root_menu_item', root_menu_item);

            // And pop out of body too?
            //  Could leave a placeholder / comment in place of where the element used to be.
            //  Then swap them to go back.

            this.state.on('change', (e_change) => {
                //console.log('Popup_Menu_Button state change', e_change);

                // Change it in the UI at this point.
                var val = e_change.value;
                //console.log('val', val);

                //if (val == 'closed') {
                //ui_close();
                //    root_menu_item.close();
                //}

                //if (val == 'open') {
                //ui_open();
                //    root_menu_item.open();
                //}

                if (val === 'open') {
                    //ui_open();
                    //root_menu_item.open();
                    root_menu_item.inner.pop_into_body();

                    // Elsewhere could take account for menu being put into the body?

                    this.one_mousedown_elsewhere((e_mousedown_elsewhere) => {
                        console.log('e_mousedown_elsewhere', e_mousedown_elsewhere);
                        /*
                        window.requestAnimationFrame(function () {
                            //resolve(func.apply(null, args));
                            that.i_state = 0;
                            that.state.set('closed'); // closed
                        });
                        */
                        setTimeout(function () {
                            //resolve(func.apply(null, args));
                            this.i_state = 0;
                            this.state.set('closed'); // closed
                        }, 300);
                        // close it.
                        //console.log('pre close');

                    })
                };

                // The root menu item needs to pup up into the DOM.

                root_menu_item.state.set(val);
            });


            root_menu_item.on('click', (e_click) => {
                //console.log('root_menu_item clicked e_click', e_click);

                // have a control target?
                // Find out if that control is part of this control directly, not part of any other control?

                //if (e_click.target === root_menu_item.dom.el) {
                //console.log('that.state', that.state);
                //console.log('that.i_state', that.i_state);
                //console.log('that.states', that.states);

                //console.log('tof that.state', tof(that.state));

                var new_i_state = that.i_state + 1;
                if (new_i_state === that.states.length) {
                    new_i_state = 0;
                }

                this.i_state = new_i_state;
                this.state.set(that.states[new_i_state]);
                //}

            });
            // When it's disconnected from the DOM, the events from inner controls don't reach above.

            // Need to go through the internal menu items...
            // prototype.description.
            //  description function to set it up.
            //  .api?
            //   info on the API?

            // prototype.api?
            //  seems useful info there.





            //console.log('root_menu_item.inner.content', root_menu_item.inner.content);
            root_menu_item.inner.content.each((inner_menu_item) => {
                //console.log('inner_menu_item', inner_menu_item);
                inner_menu_item.on('click', (e_click) => {
                    //console.log('root_menu_item clicked e_click', e_click);

                    // have a control target?
                    // Find out if that control is part of this control directly, not part of any other control?

                    //if (e_click.target === root_menu_item.dom.el) {
                    //console.log('that.state', that.state);
                    //console.log('that.i_state', that.i_state);
                    //console.log('that.states', that.states);

                    //console.log('tof that.state', tof(that.state));

                    root_menu_item.state.set('closed');
                    this.i_state = 0;
                    //}
                });
            })

            // Listen for the various changes on inner buttons.
            //  Want an easy way to iterate them.
            //console.log('pre iterate_sub_items');

            // Could attach the events earlier.
            //  Want to try that.
            /*
            root_menu_item.iterate_sub_items((item, str_path) => {
                //console.log('item', item);
                item.on('click', (e_click) => {

                    console.log('sub item click', e_click);
                    console.log('sub item: ', item);
                })
            });

            */
        }
    }
}
module.exports = Popup_Menu_Button;

},{"../0-basic/0-native-compositional/button":70,"../0-basic/1-compositional/item":89,"./../../../../html-core/html-core":149}],102:[function(require,module,exports){
/*
    Interchangable with a span (in many cases), allows editing of a single string.

    // (no styling)


    // Text property / field.

*/

// tag name span
// highlight on mouseover.
// edit on click

// no support for sub-spans.

const jsgui = require('./../../../../html-core/html-core');

// could inherit span control?

const {controls, parse, each, are_equal} = jsgui;
const {Control, Text_Node} = controls;

const Button = require('../0-basic/0-native-compositional/button');

const {field, prop} = require('obext');
const press_events = require('./../../../../control_mixins/press-events');

// Likely to better use layout / popup / display mixins.
//   swap-to-edit? maybe not with this control anyway.

// Should extend span control?

// Editable
// Editing

// Click-to-edit mixin?

// or make the mixin / plugin-like functionality outside the class for easier movement elsewhere.

// More functional programming using controls would be useful. Maybe move (back) away from ES6 classes.


// And respond to presses, not just clicks.

// press-events

// Automatic activation would make a lot of sense when it's put into an active document / active part of the document.
//  Or always...

// The context could maybe respond to a control being added into the DOM.


// a 'frame' mixin piece of functionality would help too.
//  Be able to add controls to the frame of a control...

// suspended_frame
//  the virtual frame made up by the position of the object in the DOM.

// Maybe could use 'before' and 'after' css?

// Really would be best to be able to add items to the virtual frame around the control.

// suspended_virtual_frame
//  suspended in the body.

// will be able to position and place (new) controls within that frame.
//  access the controls (as collection?) within the frame?

// will be useful for positioning popups / adjustment buttons.
//  an abstraction to handle it where it occurrs.

// Definitely seems useful for the various buttons (popup menu? too) that will show in some cases.
//  Will help with doing this around a span control.


// virtual_suspended_frame...
//  won't itself have / be a control to display its stuff.

// Putting things into a background layer behind everything else?
//  Don't want to cover on top of the frame we actually want.
//  Do want to provide easy access through an abstraction to a space / spaces around a ctrl.
//   Want to provide bindings to it.

// Want an abstraction that makes it very simple to access and use the space (suspended) around a ctrl.

// Will want to add a variety of controls / objects to the suspended_frame.

// or use this right now to get the positions?
//  will want centering of controls around suspended_frame points.



// will create controls.
//  add them to positions in a suspended_frame.


// watch_redimension to avoid ambiguity?
const watch_resize = (ctrl) => {

    // watch reposition?
    // and moving too.
    // will use request animation frame.

    // also bcr.

    // A typed array bcr system would be nicer.

    let last_size = ctrl.bcr();


    const inner = () => {
        requestAnimationFrame(timestamp => {


            const current_size = ctrl.bcr();
            const same_size = are_equal(last_size, current_size);
            //console.log('same_size', same_size);

            if (same_size) {

            } else {
                ctrl.raise('resize');
                last_size = current_size;
            }

            inner();

        })
    }
    inner();


}

// Likely to move this elswhere, ie mixins.

const suspended_frame = (ctrl, opts = {
    offset: 0
}) => {


    const {context} = ctrl;
    const body = context.body();
    //console.log('body', body);

    let arr_ctrls = [];
    let arr_ctrls_with_poss = [];


    // controls by position map...
    //  only one control in each position?

    // or make an adjust control position function?
    //  sync control position.




    const {offset} = opts;



    // Will do resize watching on the ctrl.
    //  Then will accordingly adjust positions.










    // Suspended frame for the control...

    // Want to get a suspended frame object back.
    // Place ctrl.
    //  Place ctrl into the body in a position specified by the frame.

    // Listen out for the control resizing / moving too...
    //  The suspended frame will have to move.

    // add to position...
    // be able to get the positions...
    // tl, br etc

    // The suspended controls will be put into the document body.
    //  Maybe a suspended layer div within the body?

    // Get the variety of positions...

    // tl, tm, tr
    // ml, mm, mr
    // bl, mm, br

    // and then adjustments in pixels to make.

    // Needs to have its own layout engine using absolute positioning.

    // Or could relative positioned inline divs be included before and after a span?
    // Jsgui ctrl way doing before and after, not just with CSS...?

    // For the moment, will make this suspended_frame.

    // Need to be able to add a ctrl (to a position)
    //  Bind it to that position relative to the ctrl as well.

    const measure_ctrl = () => {

        // Measurements in the DOM for the ctrl.

        // Bounding client rect? Anything faster?
        //  getBoundingClientRect()
        //   its relative to viewport so need to account for scroll position.

        // bcr function but adjusted for scroll positions?
        //  would be worth planning for the future.

        const bcr = ctrl.bcr();
        console.log('bcr', bcr);


        // Calculate positions where various things can go.
        //  Can't put some controls inside the a span or some other controls.
        //  The virtual suspended frame makes a lot of sense for framing an object with other controls.
        //   Can also style it with a border.
        //    It would be outside of the boundaries of the ctrl.

        // return the bcr?


        return bcr;


    }

    const clear = () => {
        
        each(arr_ctrls, ctrl => {
            ctrl.remove();
        });
        arr_ctrls = [];
        arr_ctrls_with_poss = [];

    }

    // Best not to have to remeasure self when getting ctrl position?



    // self-measurement position...
    const get_suspended_ctrl_doc_pos = (suspended_ctrl, pos) => {

        const m = measure_ctrl();


        //console.log('m', m);

        const [tl, br, size] = m;

        // And the size of the control to add...
        //  Sizes could do with work on types and grammar.

        //console.log('[tl, br, size]', [tl, br, size]);
        // get the size of the ctrl_to_add
        //console.log('ctrl_to_add.size', ctrl_to_add.size);
        // work out / have various corner positions...
        //  we basically have them already.


        // And the size of the control to add.
        //  That should be centered.

        // work out offset positions from points.

        // get the doc position from the pos given.

        //console.log('pos', pos);

        // tl = top left.
        //  could have a lookup function for them

        // take account of the offset too.
        //  could make offset edges / positions objects?

        const map_pos_fns = {
            'tl': () => [tl[0] - offset, tl[1] - offset],
            'tm': () => [t1[0] + (1/2 * size[0]), t1[1] - offset],
            'tr': () => [br[0] + offset, tl[1] - offset]
        }

        if (map_pos_fns[pos]) {

            const retrieved_pos = map_pos_fns[pos]();
            //console.log('retrieved_pos', retrieved_pos);

            if (retrieved_pos) {
                if (suspended_ctrl.size) {
                    const half_size = [suspended_ctrl.size[0] / 2, suspended_ctrl.size[1] / 2];
                    //console.log('half_size', half_size);
                    // set the control to add to be absolute.
                    const docpos = [retrieved_pos[0] - half_size[0], retrieved_pos[1] - half_size[1]];
                    return docpos;
                } else {
                    return retrieved_pos;
                }
            }
        }


    }


    const add = (ctrl_to_add, pos) => {
        // and poly with the pos with mfp? eventually maybe. grammar and interpretation. at least that part of the system exists and functions somewhat.

        // Then offsets based on the control to add's size.

        // Sync / set the control's position...
        /// Some / all of this can be used to sync / reset the pos.

        const docpos = get_suspended_ctrl_doc_pos(ctrl_to_add, pos);
        console.log('docpos', docpos);

        ctrl_to_add.style({
            'position': 'absolute',
            'left': docpos[0] + 'px',
            'top': docpos[1] + 'px'
        });

        // rendering the 'off' property in 'style'?
        //  seems like a problem there.
        //   not so sure why its being set either.

        //console.log('body', body);
        //console.log('body.__active', body.__active);
        //console.log('pre add to body');

        body.add(ctrl_to_add);
        arr_ctrls.push(ctrl_to_add);
        arr_ctrls_with_poss.push([ctrl_to_add, pos]);


        // Consistent and reliable auto-activate would help a lot.
        ctrl_to_add.activate();

    }

    const sync_dimensions = () => {
        // go through all items by layout position...

        //const docpos = get_suspended_ctrl_doc_pos(ctrl_to_add, pos);
        //console.log('docpos', docpos);

        // sync the dimensions within the suspended frame.

        each(arr_ctrls_with_poss, cwp => {
            const [ctrl, pos] = cwp;
            const docpos = get_suspended_ctrl_doc_pos(ctrl, pos);
            //console.log('docpos', docpos);

            // Not sure why its not setting the style....

            //console.log('ctrl.__active', ctrl.__active);

            ctrl.style({
                'left': docpos[0] + 'px',
                'top': docpos[1] + 'px'
            });

        });

    }
    watch_resize(ctrl);

    ctrl.on('resize', e_resize => {
        //console.log('suspended_frame e_resize', e_resize);
        sync_dimensions();
    });


    const res = {
        add: add,
        clear: clear
    };

    return res;

}




// Edit mode mixin?
//   Yes, edit mode mixin would definitely make sense.
//   Possibly for many controls. Will focus on editing and editable data for the moment - but not all data will be editable (or edited) at all times.
//     Much of the time data would just be viewed. Not all data could be edited anyway.

// Make cancel and OK buttons quicker and easier to make....




const editable = (ctrl) => {
    field(ctrl, 'editable', true);
    field(ctrl, 'editing', false);

    const {context} = ctrl;
    // then when the control is clicked, if it's not editing, set it to editing mode.

    ctrl.on('activate', e => {
        console.log('new mini mixin editable ctrl on activate');

        let initial_text = ctrl.dom.el.textContent;

        press_events(ctrl);

        // suspended_frame

        // Maybe do this as async, so the parsing works?
        //  Parsing only works with a callback for the moment.

        // And an offset distance from the ctrl...
        //  Extra spacing around the contorol would stop buttons getting in the way.

        const sframe = suspended_frame(ctrl, {
            offset: 8
        });

        // Create the utility buttons that get hidden around the suspended frame.
        //  Or they only get created when needed?

        // And include buttons in the suspended frame.

        // Create two button controls.
        //  A parse but dont mount function would be of use too.
        //   Would be easier to define and create a button.
        
        // create a cancel and ok button for the suspended frame.

        // can use parse, not parse_mount.

        // size and color
        //  or that's in the CSS?
        //   then would need to measure its size?
        //   put it in as transparent, then measure its size???


        // cancel button, cancel logo
        //  put the size in at 16,16?
        //  reading of size properties could be better. Using grammar?

        // just putting in a fairly simple button here would help.
        //  Not so sure about size property, especially through parse.


        //  size property here should be easy enough.
        //  also sizes from themes / size calculation system would help.

        // parse is now async :(
        //  maybe a sync parse could be made.
        //  parsing doesnt have to be async, technically.


        //const btn_cancel = 

        //console.log('btn_cancel', btn_cancel);

        // add that button to the suspended frame.

        // parse(`<Button name="cancel" class="cancel" size="[16,16]"></Button>`, context, controls);

        // Worth creating the button the old-fashioned way for the moment.

        // and set its size here?
        //  maybe not the most flexible way.
        //console.log('!!Button', !!Button);

        // Size function not working right?
        //  style function?

        // Want to easily set up the icons.
        //  Later will support sprites.
        //  For the moment, want to easily serve images.

        // Or unicode?

        // &#x2BA8
        //  makes sense for the moment.

        // ⮌
        // ✓

        // set the line-height too?
        //  set (inline) style properties too?

        const btn_cancel = new Button({
            context: context,
            class: 'cancel button',
            size: [24, 24],
            text: '⮌'
        });
        btn_cancel.style({
            'line-height': '18px',
            'color': '#8B0000',
            'font-weight': 'bold'
        });

        // 8B0000
        //press_events(btn_cancel);

        const btn_ok = new Button({
            context: context,
            class: 'ok button',
            size: [24, 24],
            text: '✓'
        });
        btn_ok.style({
            'line-height': '18px',
            'color': '#228B22',   // forest green
            'font-weight': 'bold'
        });
        //press_events(btn_ok);

        // ok button too.

        const cancel_editing = () => {
            console.log('cancel_editing');

            // clear the suspended controls...
            sframe.clear();
            ctrl.remove_class('editing');
            ctrl.editing = false;
            ctrl.dom.attributes.contenteditable = false;

            ctrl.dom.el.textContent = initial_text;

        }

        const save_editing = () => {
            console.log('save_editing');

            // get the text content...

            //  inner html?
            // textContent 

            const new_text = ctrl.dom.el.textContent;
            console.log('new_text', new_text);

            sframe.clear();
            ctrl.remove_class('editing');
            ctrl.editing = false;
            ctrl.dom.attributes.contenteditable = false;

            // silent update of the text field?

            


            // raise a change event?
            //  other part of app will listen for change events.

            // edit-complete event would be nicely specific.

            ctrl.raise('edit-complete', {
                old: initial_text,
                value: new_text
            });

        }

        // these will be hidden when not in editing mode.
        //  or possibly not added to the DOM then?

        let has_events = false;

        const start_editing = () => {
            ctrl.editing = true;
            initial_text = ctrl.dom.el.textContent;
            ctrl.add_class('editing');

            //console.log('btn_cancel', btn_cancel);
            sframe.add(btn_cancel, 'tl');
            sframe.add(btn_ok, 'tr');

            if (!has_events) {
                btn_cancel.on('click', e => {
                    cancel_editing();
                })
                btn_ok.on('click', e => {
                    save_editing();
                })
                has_events = true;
            }

            // possible to focus on the point where it was clicked?
            ctrl.dom.attributes.contenteditable = true;
            // request animation frames to detect size changes?
            //  or careful just to trigger resize events with that?
            
            // Possibly the suspended_frame should cover that.
            //  RAF_Size_Monitor?
            //  Resize_Watcher?
            //   Seems like another mixin would help.
            //  Self_Resize_Event?
            //   Listening for size changes with requestanimationframe seems like it would do the job in many cases.
            //    Won't be ideal for very many of them I expect.

            //resize_watch(ctrl);
            //  The frame will handle this.

            




            










            // Also need to keep the suspended frame item positions in sync.





            // responde to keypresses etc?
            //  or only change the content once the OK button is clicked?



            // make contenteditable.
            



            // Not so sure about the problem here.
            //  Auto-activating when placed in active doc looks like the best way.

            /*

            setTimeout(() => {
                btn_cancel.activate();
                btn_ok.activate();
            }, 0);
            */

            



            // A popup 'done' button.
            // A popup 'cancel' button.

            // suspended_frame.show();
            //  shows the item within the suspended_frame.

            // then these button presses...

            /*
            btn_cancel.on('press-end', e => {
                cancel_editing();
            })
            btn_ok.on('press-end', e => {
                save_editing();
            })
            */

            
            




        }

        
        ctrl.on({
            'press-end': e_press_end => {
                console.log('e_press_end', e_press_end);

                // if not editing, start editing.


                if (!ctrl.editing) {
                    start_editing();
                }



            }
        })
        /*
        ctrl.on('press-end', e_press_end => {
            console.log('e_press_end', e_press_end);
        });
        */

    });
    
}


// Nice to write the functionality as mixins.
//  Makes it easier to move elsewhere, and makes this code clearer and more concise.




// Looks interesting as a string editor.
//   Could be another view for string editor.
//     



// String_Editor_Span?


class String_Span extends Control {
    constructor(spec) {
        spec.__type_name = spec.__type_name || 'string_span';
        spec.tag_name = 'span';
        spec.class = 'string';
        super(spec);
        // But be able to read the text from what's inside?
        field(this, 'value', spec.value);
        editable(this);

        const {context} = this;

        const compose = () => {
            //console.log('Text_Node', Text_Node);
            let tn = new Text_Node({
                context: context,
                text: spec.value
            })
            this.add(tn);
        }
        if (!spec.el) {
            compose();
        }


        // Were we given a value in the spec?
        //  If so, need to add the inner text node.


        // New client-side lifecycle idea:
        //  reconstruct stage.
        //  reconstructs the control from the rendered HTML.
        //   populating some values where necessary.


        // having a reconstruct function as standard within the ctrl-enh lifecycle could be very useful.












        // Need to respond to text change events.

        // Will sometimes have another text node added within this during construction, rather than using the .value field.




    }

    // listen for edit-complete to update the .text property.
    //  silent update?

    activate() {
        if (!this.__active) {
            super.activate();

            this.on({
                'edit-complete': e => {
                    const {old, value} = e;
                    //console.log('String span edit complete', [old, value]);
                    if (old !== value) {
                        this.value = value;
                    }
                }
            })

        }
    }


    // Popups outside of this?
    //  Will need to position the popup divs within the DOM.
    //  Suspended_Around_Bounding_Rect
    //  Frame



    // Popups around bounding rect (mixin)?
    //  Would be very useful for a variety of things that appear around the frames / borders of controls.








    // how / when does this get activated...?




    // setup for hover....

    // Click to edit

    // Editable behaviour
    //  Click to edit.




    // 
}

module.exports = String_Span;
},{"../0-basic/0-native-compositional/button":70,"./../../../../control_mixins/press-events":58,"./../../../../html-core/html-core":149,"obext":382}],103:[function(require,module,exports){
var jsgui = require('../../../../../html-core/html-core');
var Control = jsgui.Control;
let def = jsgui.is_defined;
const Button = require('../../0-basic/0-native-compositional/button');

class Arrow_Button extends Button {
    constructor(spec, add, make) {
        // Wont fields have been set?
        //spec['class'] = spec['class'] || 'button';


        spec.size = spec.size || [32, 32];

        spec.text = undefined;
        spec.__type_name = spec.__type_name || 'arrow_button';
        super(spec);
        //this.__type_name = 'button';


        /*

        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 350 100">
        <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="7" 
            refX="0" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" />
            </marker>
        </defs>
        <line x1="0" y1="50" x2="250" y2="50" stroke="#000" 
        stroke-width="8" marker-end="url(#arrowhead)" />
        </svg>

        */

        // It's rotation.
        //  .rotation property

        // get and set?

        // Could have an Angle class that handles both degrees, radians, and proportion of full rotation (meaning proportion of 2 pi radians)

        // half radians being a useful angle measurement.
        //  hr

        //console.log('spec.direction', spec.direction);

        let rotation = 0;
        
        Object.defineProperty(this, 'rotation', {
            // Using shorthand method names (ES2015 feature).
            // This is equivalent to:
            // get: function() { return bValue; },
            // set: function(newValue) { bValue = newValue; },
            get() {
                return rotation;
            },
            set(value) {
                rotation = value;
                this.raise('change', {
                    'name': 'rotation',
                    'value': value
                });
            },
            enumerable: true,
            configurable: true
        });


        let direction;

        this.on('change', e => {
            if (e.name === 'rotation') {
                this.line.dom.attributes.transform = 'rotate(' + e.value + ', 50, 50)';
                this.polygon.dom.attributes.transform = 'rotate(' + e.value + ', 50, 50)';
            }
            if (e.name === 'direction') {
                //console.log('e', e);
                //line.dom.attributes.transform = 'rotate(' + e.value + ', 50, 50)';
                if (e.value === 'left') this.rotation = 270;
                if (e.value === 'up') this.rotation = 0;
                if (e.value === 'right') this.rotation = 90;
                if (e.value === 'down') this.rotation = 180;
            }
        });
        
        Object.defineProperty(this, 'direction', {
            // Using shorthand method names (ES2015 feature).
            // This is equivalent to:
            // get: function() { return bValue; },
            // set: function(newValue) { bValue = newValue; },
            get() {
                return direction;
            },
            set(value) {
                direction = value;
                //console.log('pre raise change - direction');
                this.raise('change', {
                    'name': 'direction',
                    'value': value
                });
            },
            enumerable: true,
            configurable: true
        });
        if (def(spec.rotation)) {
            rotation = spec.rotation;
        }

        //  || spec.no_compose === true
        if (!spec.el) {
            this.compose_arrow_button();

        }
        if (def(spec.direction)) {
            //console.log('spec.direction', spec.direction);
            // do want to change it
            this.direction = spec.direction;
            
        }
    }

    'compose_arrow_button' () {
        this.add_class('arrow');
        //this.add_class('button');
        // Want to have a system of accessing icons.
        //  Will be possible to do using a Postgres website db resource
        //   First want it working from disk though.

        // A way not to add the text like this to start with?
        //  Or just don't inherit from a button in some cases when we don't want this?

        // direction...
        //  left, l, r, right, u, ur, ru
        //   possibly express with angles in degrees and radians.

        // An arrow glyph with rotation would be cool.
        //  For the moment, I think SVG rendering would work the best.

        // Could give it an Arrow control as background.
        //  Not ready for background controls yet though.

        let svg = this.svg = new jsgui.svg({
            'context': this.context
        });
        svg.dom.attributes.viewBox = "0 0 100 100";

        // include all in a group



        /*

        let svgdefs = new jsgui.defs({
            'context': this.context
        });
        this.svg.add(svgdefs);

        let marker = new jsgui.marker({
            'context': this.context
        })
        marker.dom.attributes.id = 'arrowhead';
        marker.dom.attributes.markerWidth = 10;
        marker.dom.attributes.markerHeight = 7;
        marker.dom.attributes.refX = 2;
        marker.dom.attributes.refY = 3.5;
        marker.dom.attributes.orient = 'auto';
        svgdefs.add(marker);

        */


        let polygon = this.polygon = new jsgui.polygon({
            context: this.context
        })
        //polygon.dom.attributes.points = '0 0, 3 3.5, 0 7';
        polygon.dom.attributes.points = '50 0, 70 20, 30 20';

        // Polygon fill won't change with css
        //polygon.dom.attributes.fill = '#FF0000';
        //marker.add(polygon);

        let line = this.line = new jsgui.line({
            'context': this.context,

        });

        /*
        line.dom.attributes.x1 = 96;
        line.dom.attributes.y1 = 50;
        line.dom.attributes.x2 = 10;
        line.dom.attributes.y2 = 50;
        */

        // Could work these out based on rotation maths.

        line.dom.attributes.x1 = 50;
        line.dom.attributes.y1 = 96;
        line.dom.attributes.x2 = 50;
        line.dom.attributes.y2 = 10;

        //  transform="rotate(100)"

        // then rotation angle.
        //  could be given as a fraction of 2pi (full rotation radians).

        // A 'rotation' mixin perhaps.

        line.dom.attributes.transform = 'rotate(' + this.rotation + ', 50, 50)';
        polygon.dom.attributes.transform = 'rotate(' + this.rotation + ', 50, 50)';
        



        //line.dom.attributes.stroke = '#000000';
        //line.dom.attributes['marker-end'] = 'url(#arrowhead)';
        line.dom.attributes['stroke-width'] = 8;

        svg.add(line);
        svg.add(polygon);


        this.add(svg);
    }
    'activate' () {
        super.activate();
    }
}
module.exports = Arrow_Button;
},{"../../../../../html-core/html-core":149,"../../0-basic/0-native-compositional/button":70}],104:[function(require,module,exports){
const jsgui = require('../../../../html-core/html-core');
const Control = jsgui.Control;
const def = jsgui.is_defined;
const Arrow_Button = require('../../0-core/1-advanced/vector/arrow-button');


const Item_Selector = require('../../0-core/0-basic/1-compositional/item-selector');
// Maybe give Item_Selector a more specific name, or involk it in terms of more explicit behaviours?

/*

    Encapsulates an array with a range of possible values.
    // Maybe a number of years.

    // Basically just chooses an index within the array, and can get a value for the item in the array too.

    // Could be used for picking a year, or months within a year.

    // Events responding to the UI events and changes there.
    //  Does its internal processing, raises external event when event occurs.

    // Tile_Slide_Panel could be useful here, and with Month_View
    //  With Month_View, would have entire month views rendered already for previous and next months.

    // Possibility of Tile_Slide_Panel being something that would hack into another control?

    // Want it so that a control can be wrapped automatically in a Title_Slide_Panel, so adjacent controls also get constructed.

    // Still want the Month_View to be fairly simple.
    //  Month_View is a place where its worth implementing Tile_Slide or Tile_Slide_Panel.

    // This will be good for choosing months and years.

    // Will be able to operate with tile sliding too.
    //  Tile sliding on mobile especially.


    // Could use Tile_Slider with next and previous.


    // Could tile slide towards a control that shows the month name


    // Having a very nice month selector with arrows
    // Then also a very nice year selector
    
    //  These could be micro Controls.
    //   Worth making into a Control, a grouping of controls.



    //   such as a year picker
    //    all it does is allow picking of a year in a user friendly way. Won't be very obvious, but will be a component of Date_Picker.
    // ./micro-date


    Arrow
    [Box with value] - Something like a Select box
    // 

    Item_Selector
     // Can deal with previous and next
     //  Directional sliding
     //  Choose the direction
     //   Are all items rendered to begin with?
     //    Less than 100 then this would work nicely.
     //   Optional delayed_item_rendering
     //    Those in view
     //     Those that may be brought into the view soon.
     //   Could have a buffer of active / live controls.

     // Possibly Item_Selector could be enabled to set up Tile_Slider based on internal controls, and functional involkation of them

    Arrow


*/

// Item_Selector interface?
//  By passing on Item_Selector 

// An item picker?
//  Abstract away the left and right arrows somehow?

// Indexed_Item_Picker?



class Left_Right_Arrows_Selector extends Control {
    constructor (spec) {

        //console.log('');
        //console.log('Left_Right_Arrows_Selector spec', spec);

        spec.__type_name = spec.__type_name || 'left_right_arrows_selector';
        super(spec);
        this.add_class('left-right');
        this.add_class('arrows-selector');

        if (spec.items) {
            this.items = spec.items;
        }
        if (def(spec.item_index)) {
            this.item_index = spec.item_index;
        }
        if (def(spec.loop)) {
            this.loop = spec.loop;
        }
        if (!spec.el) {
            this.compose_lras();
        }
    }
    compose_lras() {

        // left, item, right
        let context = this.context;
        let left_arrow = new Arrow_Button({
            context: context,
            direction: 'left'
        });

        let is_spec = {
            context: context
        }
        if (this.items) is_spec.items = this.items; 
        if (this.item_index) is_spec.item_index = this.item_index;
        if (this.loop) is_spec.loop = this.loop; 

        // Should be able to parse these from an HTML-like document.

        let item_selector = new Item_Selector(is_spec);

        let right_arrow = new Arrow_Button({
            context: context,
            direction: 'right'
        });

        this.add(left_arrow);
        this.add(item_selector);
        this.add(right_arrow);

        this._fields = this._fields || {};
        if (this.items) this._fields.items = this.items;
        if (def(this.item_index)) this._fields.item_index = this.item_index;
        if (def(this.loop)) this._fields.loop = this.loop;

        this._ctrl_fields = {
            left_arrow: left_arrow,
            item_selector: item_selector,
            right_arrow: right_arrow
        }
    }

    previous(raise_event = true) {
        this.item_selector.previous(raise_event);

    }
    next(raise_event = true) {
        this.item_selector.next(raise_event);
    }
    activate() {
        if (!this.__active) {
            super.activate();
            // Automatically disable arrow if we reach the first while not in loop mode.

            //console.log('Activate Left_Right_Arrows_Selector');
            let {left_arrow, item_selector, right_arrow} = this;


            // on({subcontrol names, event names})
            //  a different mechanism for 'on'?


            left_arrow.on('click', e_click => {
                //console.log('left_arrow e_click',e_click);
                this.previous();
            });
            item_selector.on('change', e_change => {
                //console.log('item_selector e_change', e_change);

                if (!this.loop) {
                    if (e_change.first) {
                        left_arrow.disabled = true;
                    } else {
                        left_arrow.disabled = false;
                    }
                    if (e_change.last) {
                        right_arrow.disabled = true;
                    } else {
                        right_arrow.disabled = false;
                    }
                }
                this.raise('change', e_change);
            });
            right_arrow.on('click', e_click => {
                //console.log('right_arrow e_click',e_click);
                this.next();
            });

            if (this.loop) {
                item_selector.on('loop', loop_direction => {
                    //console.log('loop_direction', loop_direction);
                    this.raise('loop', loop_direction);
                })
            }
        }
    }
}


// Needs to select from an array of items.
//  Can loop (optional)

// Internally can use a tile_slide


module.exports = Left_Right_Arrows_Selector;


},{"../../../../html-core/html-core":149,"../../0-core/0-basic/1-compositional/item-selector":88,"../../0-core/1-advanced/vector/arrow-button":103}],105:[function(require,module,exports){

// Header, footer
// Left panel
// Right panel
// Main

var jsgui = require('../../../../html-core/html-core');

//const Active_HTML_Document = require('../../../')
// Is a page control. Ie is an HTML document.

class Standard_Web_Page extends jsgui.Blank_HTML_Document {
    constructor(spec) {
        super(spec);

        // Set its title, an h1, one or more paragraphs of text?

        
    }
}

module.exports = Standard_Web_Page;

},{"../../../../html-core/html-core":149}],106:[function(require,module,exports){
const jsgui = require('./../../../../html-core/html-core');
var stringify = jsgui.stringify,
    each = jsgui.each,
    tof = jsgui.tof;
var Control = jsgui.Control;

// Extending, with field values being set?
//  Setting field values in definitions may be a useful thing.


// A 'Platform' Control.
//  Any other word?
//  Platform control makes sense as it's the platform that jsgui3 is providing.
//  Basic controls are the ones that are simple / simpler abstractions over HTML elements with customization.

// Basic controls
// Platform controls

// 



var fields = [
    ['value', Object]
];
class Data_Item extends Control {
    // fields... text, value, type?
    //  type could specify some kind of validation, or also 'password'.
    // single field?
    //  and can have other fields possibly.


    // this.__type_name = 'text_item';
    constructor(spec) {
        super(spec, fields);
        this.__type_name = 'data_item';
        this.add_class('data-item');
        let context = this.context;

        //console.log('this.value', this.value);

        this.add(new jsgui.textNode({
            text: this.value + '',
            context: this.context
        }));

        // Contains data items
        /*
        if (spec.item || spec.value) {
            let item = this.item = spec.item || spec.value;



        }
        */



        //ctrl_title_bar.set('dom.attributes.class', 'titlebar');
        //this.add(span);
    }
};
module.exports = Data_Item;
},{"./../../../../html-core/html-core":149}],107:[function(require,module,exports){
const jsgui = require('./../../../../html-core/html-core');
var stringify = jsgui.stringify,
    each = jsgui.each,
    tof = jsgui.tof;
var Control = jsgui.Control;

var Data_Item = require('./data-item');
// Extending, with field values being set?
//  Setting field values in definitions may be a useful thing.
/*
var fields = [
    ['text', String]
];
*/

/*
    May be unnecessary with a more flexible core.
*/

class Data_Row extends Control {
    // fields... text, value, type?
    //  type could specify some kind of validation, or also 'password'.
    // single field?
    //  and can have other fields possibly.
    constructor(spec) {
        super(spec);
        this.add_class('data-row');
        let context = this.context;

        // Contains data items

        let items = this.items = [];

        // Or use the inner collection of controls?

        if (spec.items) {
            each(spec.items, item => {
                //console.log('item', item);
                items.push(this.add(new Data_Item({
                    'context': context,
                    'value': item
                })));
            })
        }

        //ctrl_title_bar.set('dom.attributes.class', 'titlebar');
        //this.add(span);
    }
};
module.exports = Data_Row;
},{"./../../../../html-core/html-core":149,"./data-item":106}],108:[function(require,module,exports){
const jsgui = require('../../../../html-core/html-core');

const {Blank_HTML_Document} = jsgui;



class Active_HTML_Document extends Blank_HTML_Document {



    constructor(spec = {}) {
        //console.log('Client_HTML_Document');
        super(spec);
        //spec.context.ctrl_document = this;
        this.active();
    }

    // Seems a bit like 'view features'.

    'include_js'(url) {
        /*
        Add it to the end of the body instead.
        */
        //var head = this.get('head');
        const body = this.get('body');
        var script = new jsgui.script({
            //<script type="text/JavaScript" src="abc.js"></script>
            'context': this.context
        });
        var dom = script.dom;
        var domAttributes = dom.attributes;
        domAttributes.type = 'text/javascript';
        domAttributes.src = url;
        body.add(script);
    }

    'include_css'(url) {
        var head = this.get('head');
        var link = new jsgui.link({
            //<script type="text/JavaScript" src="abc.js"></script>
            'context': this.context
        })
        // <script data-main="scripts/main" src="scripts/require.js"></script>
        var dom = link.dom;
        var domAttributes = dom.attributes;
        domAttributes['rel'] = 'stylesheet';
        domAttributes['type'] = 'text/css';
        //domAttributes.set('src', '/js/require.js');
        domAttributes['href'] = url;
        head.content.add(link);
    }

    'include_jsgui_client'(js_file_require_data_main) {
        js_file_require_data_main = js_file_require_data_main || '/js/web/jsgui-html-client';
        var head = this.head;
        var body = this.body;
        var script = new jsgui.script({
            //<script type="text/JavaScript" src="abc.js"></script>
            'context': this.context
        })
        var domAttributes = script.dom.attributes;
        domAttributes.set({
            'type': 'text/javascript',
            'src': '/js/web/require.js',
            'data-main': js_file_require_data_main
        });
        body.add(script);
    }
    'include_client_css'() {
        var head = this.get('head');
        var link = new jsgui.link({
            //<script type="text/JavaScript" src="abc.js"></script>
            'context': this.context
        });
        var domAttributes = link.dom.attributes;
        domAttributes.rel = 'stylesheet';
        domAttributes.type = 'text/css';
        domAttributes.href = '/css/basic.css';
        head.content.add(link);
        // <link rel="stylesheet" type="text/css" href="theme.css">
    }
    // also need to include jsgui client css
}

module.exports = Active_HTML_Document;
},{"../../../../html-core/html-core":149}],109:[function(require,module,exports){
// Vertical_Expander
const jsgui = require('./../../../../html-core/html-core');


var Horizontal_Slider = require('./horizontal-slider');
var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof;
var Control = jsgui.Control;
var v_subtract = jsgui.v_subtract;

// Extending, with field values being set?
//  Setting field values in definitions may be a useful thing.
class Audio_Volume extends Control {
	// fields... text, value, type?
	//  type could specify some kind of validation, or also 'password'.

	// single field?
	//'fields': [
	//	['text', String]
	//],
	//  and can have other fields possibly.

	constructor(spec, add, make) {
		super(spec);
		this.__type_name = 'audio_volume';

		if (!spec.abstract && !spec.el) {

			this.add_class('audio-volume');
			// the bar at the top.

			// It's going to act as a drag handle for this.
			//  The drag system will integrate with various bands / window positions.
			// Maybe a property to say that it's dockable.

			//var top_bar = new Control({
			//	'context': this.context
			//})
			//top_bar.set('dom.attributes.class', 'title bar');
			//this.add(top_bar);

			var h_slider = add(Horizontal_Slider({
				'min': 0,
				'max': 100,
				'value': 100
			}));

			var ctrl_fields = {
				'h_slider': h_slider._id()
			}

			//this.set('dom.attributes.data-jsgui-ctrl-fields', stringify(ctrl_fields).replace(/"/g, "'"));
			this.active();
		}
	}
	'activate'() {
		super.activate();
		console.log('Audio Volume activate');

		var h_slider = this.h_slider;
	}
}

module.exports = Audio_Volume;
},{"./../../../../html-core/html-core":149,"./horizontal-slider":113}],110:[function(require,module,exports){
const jsgui = require('./../../../../html-core/html-core');
const Tree_Node = require('./tree-node');

//const mx_selection_box_host = require('../control_mixins/selection-box-host');

class File_Tree_Node extends Tree_Node {
    constructor(spec) {
        /*
        if (spec.camera) {
            spec.text = spec.camera.name;
        }
        */
        // Could be a directory too?
        if (spec.file) {
            let file = spec.file;
            let filename = file.name;
            spec.text = file.name;
            
        }
        spec.__type_name = 'file_tree_node';
        spec.expandable = false;

        super(spec);
        this.add_class('file');
        
        
        // Camera could be a camera object that can provide data.
        //  On the client should go through a data service.
        //this.camera = spec.camera;

        //console.log('File_Tree_Node spec', spec);

        if (!spec.el) {
            //let tn;
            /*
            this.add(tn = new Tree_Node({
                context: this.context,
                text: 'Info'
            }));
            tn.active();
            //console.log('tn.dom.el', tn.dom.el);
            //tn.activate(tn.dom.el);
            let tn_videos;
            this.add(tn_videos = new Tree_Node({
                context: this.context,
                text: 'Videos',
                state: 'contracted'
            }));
            tn_videos.on('expand', e_expand => {
                // if there are 0 nodes then add them...
                (async () => {
                    console.log('e_expand', e_expand);
                    console.log('this.context.cameras', this.context.cameras);
                    console.log('Object.keys(this.context.cameras)', Object.keys(this.context.cameras));
                    let url_files = spec.camera.name + '/files.json';
                    console.log('url_files', url_files);
                    let corner_files = await this.context.cameras.get(url_files);
                    console.log('corner_files', corner_files);
                })();
            });
            // then all the videos for the camera
            console.log('this.camera', this.camera);
            // can get data back through the camera data service.
            // asyncronously load the camera videos data.
            tn.active();
            */
        }
    }
}

module.exports = File_Tree_Node;
},{"./../../../../html-core/html-core":149,"./tree-node":118}],111:[function(require,module,exports){
const jsgui = require('./../../../../html-core/html-core');
const Tree = require('./../../1-standard/5-ui/tree');

// This may need to be connected with a resource.
//  Specified with an API.
//   Possibly move to a 'data' or 'connected' dir.
//    or resource? As in it will need access to a resource to work.
//   That resource will be available on the client-side.

// Possibly some controls will only work in a connected mode.



class File_Tree extends Tree {
    constructor(spec) {

        spec.__type_name = 'file_tree';

        // Could be a directory too?
        /*
        if (spec.file) {
            let file = spec.file;
            let filename = file.name;
            spec.text = file.name;
            
        }
        */

        // FS_Resource is an obvious data source.

        //spec.expandable = false;

        super(spec);
        this.add_class('file tree file-tree');

        const context = this.context;

        // Make the published resources available?



        let fs_resource = spec.fs || spec.fs_resource;
        if (fs_resource) {
            this.fs_resource = fs_resource;
        } else {
            let resources = context.resources;

            // The website resource.
            //  That's critical to many servers.
            //  Don't want to assume it's the only / main resource in all configs though.

            // Or a control's context should be set to the webserver.
            //  That makes more sense.
            //   The webserver (resource) can be encapsulated in a more general server.

            // The FS resource will / may only be published within the website resource
            //  Can have the website resource provide some access code.



            console.log('File_Tree context resources', resources);
            console.log('File_Tree context.resource_pool', context.resource_pool);
            console.log('Object.keys(context)', Object.keys(context));

            // Maybe should assume the website context in some cases, rather than the server context.
            //  Want easier way of accessing the web page context.

            // .page_context ?
            //   get that from the context?
            
            // 

            // find the 'fs' resource within the context.

            // Want to get the website resource.
            //  Maybe do some more work on collections too. Indexing, storing, retrieving, using the tree kvs feature.


            // context.resource_pool.resources

            // Publishing should add a resource to the pool.
            //  It does now, to the website pool.

            // then get the fs resource from the local pool.
            //  Should work on both the client and the server.




            //throw 'stop';

        }

        // can we get it from the page_context resources?



        // Need to respond to events from the fs_resource.
        //  Client-side, it should automatically wire up requests to the resource.


        // Camera could be a camera object that can provide data.
        //  On the client should go through a data service.
        //this.camera = spec.camera;

        //console.log('File_Tree_Node spec', spec);

        if (!spec.el) {
            //let tn;
            this.compose_file_tree();
        }
    }
    compose_file_tree() {
        // Show it at its root.
        //  Async composition?

        // Seems like async composition is necessary.

        // Could even do parse-mount?






    }
    activate() {
        // Client-side, we need to connect to the resource.
        //  Initialise a new Data_Resource?
        //   Or the Data_Resource would have been initialised?

        // Being able to get a list of available resources would be useful.
        //  context.resources
        //   think that's the client-side resource pool?

        // Need to get access to an equivalent resource on the client-side with the same JS API.






    }
}

module.exports = File_Tree;
},{"./../../../../html-core/html-core":149,"./../../1-standard/5-ui/tree":119}],112:[function(require,module,exports){
// object viewer

/*
 if (typeof define !== 'function') { var define = require('amdefine')(module) }

 // html-enh depending on Context_Menu?



 define(["../../jsgui-html", "./menu-node"],
 function(jsgui, Menu_Node) {

 */

// 2022 - Good candidate for deprecation - use Menu with display mode options.
//   Can choose various things to do with appearance using .view

var jsgui = require('../../../../html-core/html-core');
var Menu_Node = require('../../0-core/0-basic/1-compositional/menu-node');

var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof, is_defined = jsgui.is_defined;
var Control = jsgui.Control;

var group = jsgui.group;

class Horizontal_Menu extends Control {

	// could have a title field.
	//'fields': {
	//	'title': String
	//},

	// maybe add before make would be better. add will probably be used more.
	constructor(spec, add, make) {
		super(spec);
		this.__type_name = 'horizontal_menu';
		this.dom.attrs.class = 'horizontal menu';
		if (!spec.abstract && !spec.el) {
			var obj = spec.value;
			//var that = this;
			var tobj = tof(obj);
			if (tobj == 'object') {
				each(obj, (v, key) => {
					var menu_node = make(Menu_Node({
						'text': key,
						'value': v,
						'menu': this
					}))
					this.add(menu_node);
				})
			}
		}
	}
	'activate'() {
		// May need to register Flexiboard in some way on the client.

		if (!this.__active) {
			super.activate();

			//console.log('activate Horizontal_Menu');
			// While it is open, clicking outside of the menu should close it.
			// Something for opening the menu.
			//  Need to respond to a click on a (root) node.
			// Want a quick way to get all controls of a certain type inside.
			//  eg this.find(':horizontal_menu')
			//  this.children(':horizontal_menu')
			// this.matches_selector(':horizontal_menu');
			// Needs to have various states
			//  Different parts of it can be open, closed.

			// On click, want to see if any of the nodes are open.
			//  I think being able to do some kind of selector / query that gets a group of controls would be very helpful here.

			// this.children(':menu_node[open]')
			//  Some kind of notation like that to find any open menu nodes.
			// The menu items should have 'state' properties
			var last_clicked;
			this.content.each((v, i) => {
				v.on('click', e_click => {
					//console.log('menu item clicked');

					// if it is already open?
					var v_state = v.state;
					//console.log('v_state', v_state);

					// Don't open if we are reclicking on the same menu item?
					//if (last_clicked !== v) {
					v.open();
					// And mousedown anywhere (else) to close.
					//console.log('pre setup one mousedown anywhere');
					// mousedown anywhere else?

					v.one_mousedown_anywhere(function (e_mousedown) {
						//console.log('e_mousedown.within_this ' + e_mousedown.within_this);
						if (!e_mousedown.within_this) {
							v.close();
							//
						} else {

						}
					});
					//}

					//last_clicked = v;

				})

				v.on('mouseup', function (e_mouseup) {
					//setTimeout(function() {
					//	last_clicked = null;
					//}, 0);
				});
			});
		}
		//  could find controls with classes and tag names using css queries.
		//
	}
	'close_all'() {
		console.log('menu close_all');
		// need to do this recursively I think.
		//  could call this recursively on all nodes.
		this.content.each((v, i) => {
			//console.log('i', i);
			//console.log('v', v);
			v.close_all();
		});
	}
}

module.exports = Horizontal_Menu;

},{"../../../../html-core/html-core":149,"../../0-core/0-basic/1-compositional/menu-node":91}],113:[function(require,module,exports){
const jsgui = require('./../../../../html-core/html-core');
var stringify = jsgui.stringify,
	each = jsgui.each,
	tof = jsgui.tof;
var Control = jsgui.Control;

var v_subtract = jsgui.v_subtract;


// Extending, with field values being set?
//  Setting field values in definitions may be a useful thing.

/*
 'fields': [
 ['min', Number],
 ['max', Number],
 ['value', Number],
 ['drag_mode', String]
 ],
 */

const {
	prop,
	field
} = require('obext');

const mx_dragable = require('./../../../../control_mixins/dragable');

class Horizontal_Slider extends Control {
	// fields... text, value, type?
	//  type could specify some kind of validation, or also 'password'.

	// single field?

	//  and can have other fields possibly.

	// This should be customizable in which values it holds.
	//  For the moment, set up the value range on the server, and send that to the client as fields which we get back from the DOM when
	//  the Control gets activated.

	// I think this can take a min, a max, and a value.
	//  Perhaps operating in 'proportion' mode between 0 and 1 is easiest?
	//  Also having it handle time values - could use ms.


	// Basically, this needs to be told its min value, its max value, and its current value.

	// Also, want 'ghost' drag mode so that the handle can be dragged, and only changes position on release
	//  For different scrubber behaviour to what is in the iPod app.

	constructor(spec, add, make) {
		spec.__type_name = spec.__type_name || 'horizontal_slider';
		super(spec);

		// Want a 'ghost' drag mode.
		//console.log('spec.min', spec.min);
		//console.log('spec.max', spec.max);
		//console.trace();

		field(this, 'min', spec.min || 0);
		field(this, 'value', spec.value || 0);
		field(this, 'max', spec.max || 100);

		if (!spec.el) {
			this.compose_horizontal_slider();
		}
	}
	'compose_horizontal_slider'() {
		let h_bar, v_bar;
		const context = this.context;

		let div_relative = this.add(new Control({
			'class': 'relative',
			'context': context
		}));
		this.add_class('horizontal slider');

		// Then we add the bar over the width.
		(h_bar = new Control({
			'class': 'h-bar',
			'context': context
		}));
		(v_bar = new Control({
			'class': 'v-bar',
			'context': context
		}));

		div_relative.add(h_bar);
		div_relative.add(v_bar);

		let ctrl_fields = {
			'div_relative': div_relative,
			'h_bar': h_bar,
			'v_bar': v_bar
		}

		this._ctrl_fields = this._ctrl_fields || {};
		Object.assign(this._ctrl_fields, ctrl_fields);
	}
	'activate'() {

		if (!this.__active) {
			super.activate();
			console.log('Horizontal Slider activate');
			// Also need to deal with touch events.
			//  I think that touch tolerance would do the job.
			//  Need to find the right trick to use for this, if there is one.
			// Could probably work using a lower level touch API
			//  Detect if the touch is near the item we want to drag.
			// Perhaps touch tolerance could be done by using a larger touch overlay, or touch handle.

			//var that = this;

			//var div_relative = this.get('div_relative');
			var h_bar = this.h_bar;
			var v_bar = this.v_bar;

			mx_dragable(v_bar, {
				mode: 'x',
				bounds: h_bar,
				start_distance: 1
			});
			v_bar.dragable = true;

			// drag complete event...
			v_bar.on('dragend', e_complete => {
				//console.log('v_bar e_complete', e_complete);
				//console.trace();

				//console.log('drag-complete');

				let bar_left = v_bar.dom.el.offsetLeft;
				// Then subtract the left of the h bar.
				let h_v_width = Math.round(v_bar.dom.el.offsetWidth / 2);

				//let bar_x = bar_left - (h_bar.dom.el.offsetLeft + h_v_width);
				let bar_x = bar_left - (h_v_width);

				let h_width = h_bar.dom.el.offsetWidth;

				//console.log('bar_x', bar_x);
				//console.log('h_width', h_width);

				let prop = bar_x / h_width;

				//console.log('prop', prop);

				//console.log('[bar_x, prop]', [bar_x, prop]);

				// then work out the value out of the range

				let range_diff = this.max - this.min;
				//console.log('range_diff', range_diff);
				let v = (prop * range_diff) + this.min;
				//console.log('v', v);
				this._.value = v;

				this.raise('choose-value', v);

				//this.value = v;



			});

			this.on('change', (e_change) => {
				var name = e_change.name,
					value = e_change.value;
				//console.log('h slider change', e_change);
				//console.trace();

				if (name === 'value') {
					// h_bar

					this.bar_value = value;
				}
				// 
			});


			this.on('resize', e => {
				// move the var to the point at given value
				//console.log('resize');
				//console.log('this.value', this.value);

				this.bar_value = this._.value;
            });





			//var ghost_v_bar;

			//console.log('h_bar', h_bar);
			//console.log('v_bar', v_bar);
			/*
			var size = this.bcr()[2];
			console.log('Horizontal Slider size', size);

			var size_v_bar = this.v_bar.bcr()[2];


			var w_v_bar = size_v_bar[0];
			var h_w_v_bar = w_v_bar / 2;


			var h_bar_width = this.v_bar.bcr()[2][0];
			*/
			/*

			var h_padding = 5;

			var h_bar_width = size[0] - h_padding * 2;


			this.h_bar.style({
				'width': h_bar_width + 'px'
			});

			*/

			/*

			var ctrl_html_root = this.context.ctrl_document;

			// have lower level drag working on the h_bar?
			//  want some kind of flexible drag, but that could be done while cutting out code.
			//  for the moment, will do the eventhandlers?
			//   generic drag handlers would be useful for touch interfaces as well.

			var pos_down, pos_current, pos_offset;

			var orig_v_bar_l = parseInt(this.v_bar.style('left'), 10);
			var new_v_bar_l;

			//console.log('orig_v_bar_l', orig_v_bar_l);

			var drag_mode;

			var prop;

			var ctrl_ghost_v_bar;
			var context = this.context;

			var v_bar_center_pos;
			var v_bar_center_pos_when_pressed;
			*/

			
		}




	}

	set bar_value(value) {
		//console.log('set bar_value', value);
		const {
			h_bar,
			v_bar
		} = this;
		var min = this.min;
		var max = this.max;



		let prop = (value - min) / (max - min);
		//console.log('prop', prop);
		var size_h_bar = h_bar.size || [h_bar.dom.el.offsetWidth, h_bar.dom.el.offsetHeight];
		let v_bar_center_pos = Math.round((size_h_bar[0] * prop)) + h_bar.dom.el.offsetLeft;
		let v_bar_left_pos = v_bar_center_pos - Math.round(v_bar.dom.el.offsetWidth / 2);

		// then the left pos
		//v_bar.style('left', v_bar_left_pos + 'px');

		// no, work out where the top should go.

		let v_bar_top = v_bar.dom.el.offsetTop;

		//console.log('v_bar.pos', v_bar.pos);
		if (v_bar.pos) {
			

			//console.log('v_bar.pos', v_bar.pos);
			//console.log('v_bar.pos[1]', v_bar.pos[1]);
			v_bar.pos = [v_bar_left_pos, v_bar.pos[1]];
		} else {
			v_bar.dom.attributes.style.left = v_bar_left_pos;
		}

		//

		

		//console.log('set bar_value', value);
		//console.trace();

		this._.value = value;
	}
}
module.exports = Horizontal_Slider;
},{"./../../../../control_mixins/dragable":53,"./../../../../html-core/html-core":149,"obext":382}],114:[function(require,module,exports){
// Copyright James Vickers 2016, james@metabench.com

var jsgui = require('../../../../html-core/html-core');

var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof, extend = jsgui.extend;
var Control = jsgui.Control;
var Collection = jsgui.Collection;


// Could have the range as a field.
//  A 2d range may be a useful type for this.


// Making various things into fields that get sent to the client?

/*
 'fields': {
 //'num_days': Number
 'range': Array,
 'vert_margin': Number,
 'left_margin': Number,
 'right_margin': Number,
 'axis_thickness': Number,
 'x_major_notch_spacing': Number,
 'y_major_notch_spacing': Number,
 'x_minor_notch_spacing': Number,
 'y_minor_notch_spacing': Number,
 'suppress_0_axes_labels': Boolean,

 // For internal use
 'x_origin': Number,
 'y_origin': Number
 },
 */

class Line_Chart extends Control {

    constructor(spec) {
        super(spec);
        this.__type_name = 'line_chart';

        // Specify num_days

        // Will have y axis down the left.
        // Will have x axis down the middle
        if (!spec.abstract && !spec.el) {

            this.add_class('line-chart no-select');

            var vert_margin = 10;
            var left_margin = 80;
            var right_margin = 24;
            var axis_thickness = 2;

            var x_major_notch_spacing = spec.x_major_notch_spacing || spec.major_notch_spacing || 50;
            var y_major_notch_spacing = spec.y_major_notch_spacing || spec.major_notch_spacing || 50;

            var x_minor_notch_spacing = spec.x_minor_notch_spacing || spec.major_minor_spacing || 10;
            var y_minor_notch_spacing = spec.y_minor_notch_spacing || spec.major_minor_spacing || 10;

            var suppress_0_axes_labels = true;

            this.set({
                'vert_margin': vert_margin,
                'left_margin': left_margin,
                'right_margin': right_margin,
                'axis_thickness': axis_thickness,
                'x_major_notch_spacing': x_major_notch_spacing,
                'y_major_notch_spacing': y_major_notch_spacing,
                'x_minor_notch_spacing': x_minor_notch_spacing,
                'y_minor_notch_spacing': y_minor_notch_spacing,
                'suppress_0_axes_labels': suppress_0_axes_labels
            });
            this.add_full_axes();
        }

        // When it's rendered on the server, we don't know quite how much space the chart will need.
        //  Still, server side rendering and client side activation fits the general pattern.




        // number of units on x axis
        // x min y min

        // range could be given as [[0, 0,], [20, 20]];
        //  could assume origin [0, 0] if it's not given.

        var num_days = this.get('num_days');

        if (typeof window == 'undefined') {
            // For sending the fields to the client.

            extend(this._fields = this._fields || {}, {
                'vert_margin': vert_margin,
                'left_margin': left_margin,
                'right_margin': right_margin,
                'axis_thickness': axis_thickness,
                'x_major_notch_spacing': x_major_notch_spacing,
                'y_major_notch_spacing': y_major_notch_spacing,
                'x_minor_notch_spacing': x_minor_notch_spacing,
                'y_minor_notch_spacing': y_minor_notch_spacing,
                'suppress_0_axes_labels': suppress_0_axes_labels,
                'range': this.get('range').value(),
                'x_origin': this.get('x_origin').value(),
                'y_origin': this.get('y_origin').value()
            });
        }
    }

    'add_full_axes'() {

        var vert_margin = this.get('vert_margin');
        var left_margin = this.get('left_margin');
        var right_margin = this.get('right_margin');
        var axis_thickness = this.get('axis_thickness');
        var x_major_notch_spacing = this.get('x_major_notch_spacing');
        var y_major_notch_spacing = this.get('y_major_notch_spacing');
        var x_minor_notch_spacing = this.get('x_minor_notch_spacing');
        var y_minor_notch_spacing = this.get('y_minor_notch_spacing');
        var suppress_0_axes_labels = this.get('suppress_0_axes_labels');




        var size = this.get('size').value();
        //console.log('size', size);


        var w = size[0][0];
        var h = size[1][0];

        var range = this.get('range').value();

        console.log('range', range);

        var y_axis_x, x_axis_y;

        var x_min = range[0][0], y_min = range[0][1], x_max = range[1][0], y_max = range[1][1];

        // Want to show the Y axis at the origin if possible.

        // Is the x point 0 within the grid? if so, show the y axis at that position.

        var x_range = x_max - x_min, y_range = y_max - y_min;
        //console.log('x_min', x_min);
        //console.log('x_max', x_max);


        var y_axis_is_at_origin = x_min <= 0 && x_max >= 0;
        var x_axis_is_at_origin = y_min <= 0 && y_max >= 0;

        // Position of chart_left, position of chart_right

        var x_axis_left = left_margin;
        var x_axis_right = w - right_margin;
        var y_axis_top = vert_margin;
        var y_axis_bottom = h - vert_margin;

        var x_chart_distance = x_axis_right - x_axis_left;
        var y_chart_distance = y_axis_bottom - y_axis_top;

        var x_axis_length = w - left_margin - right_margin;
        var y_axis_length = h - (2 * vert_margin);

        var x_scale = x_range / x_axis_length;
        var y_scale = y_range / y_axis_length;

        // would be good to have the origin position.

        var x_origin, y_origin;


        var values_from_pixel_location = function(px_loc) {
            var vect_from_origin = [px_loc[0] - x_origin, px_loc[1] - y_origin];
            //console.log('vect_from_origin', vect_from_origin);
            // and then the values, obtained by scaling.

            var res = [Math.round(vect_from_origin[0] * x_scale), Math.round(vect_from_origin[1] * y_scale * -1)];
            return res;


        };

        var pixel_location_from_values = function(values) {
            var res = [Math.round(origin[0] + values[0] * 1 / x_scale), Math.round(origin[1] + values[1] * -1 / y_scale)];
            return res;
        };

        var x_location_from_value = function(x_value) {
            return Math.round(x_origin + x_value * 1 / x_scale)
        };
        var y_location_from_value = function(y_value) {
            return Math.round(y_origin + y_value * -1 / y_scale)
        };

        //console.log('tof range', tof(range));
        //console.log('range', range);

        var svg = new Control({
            'context': this.context,
            'tag_name': 'svg'
        });

        svg.set('dom.attributes', {
            'width': w,
            'height': h,
            'viewPort': '0 0 ' + w + ' ' + h,
            'version': '1.1',
            'xmlns': 'http://www.w3.org/2000/svg'
        });

        this.add(svg);
        this.set('svg', svg);

        if (y_axis_is_at_origin) {
            // Proportion to the right of the origin, proportion to the left of the origin.

            //x_range - x_min;
            //onsole.log('x_range + x_min', x_range + x_min);

            var prop_through = (-1 * x_min) / x_range;
            var distance_through = x_chart_distance * prop_through;

            //console.log('pos', prop_through);

            x_origin = x_axis_left + distance_through;


            y_axis_x = x_origin;

        } else {
            // Draw it on the left
            throw 'stop';
        }

        if (x_axis_is_at_origin) {
            // Proportion to the right of the origin, proportion to the left of the origin.

            //x_range - x_min;
            //onsole.log('x_range + x_min', x_range + x_min);

            var prop_through = (-1 * y_min) / y_range;
            //console.log('prop_through', prop_through);
            var distance_through = y_chart_distance * prop_through;
            //console.log('distance_through', distance_through);



            //console.log('pos', prop_through);

            y_origin = y_axis_bottom - distance_through;
            x_axis_y = y_origin;

        } else {
            // Draw it on the left
            throw 'stop';
        }

        this.x_origin = x_origin;
        this.y_origin = y_origin;

        // Not necessarily going from the origin.
        //  Also want to have server-side rendering, client-side activation.

        //var origin = [left_margin - 1, (h - axis_thickness) / 2];

        //console.log('y_axis_x', y_axis_x);

        var y_axis_top = vert_margin;
        var y_axis_bottom = h - vert_margin;

        var add_y_axis_line = function() {

            var y_axis = new Control({
                'context': this.context,
                'tag_name': 'line'
            });

            y_axis.set('dom.attributes', {
                'width': 10,
                'height': h,
                'x1': y_axis_x,
                'y1': y_axis_top,
                'x2': y_axis_x,
                'y2': y_axis_bottom,
                'stroke': '#000000',
                'stroke-width': 2
            });

            svg.add(y_axis);
        };

        var add_x_axis_line = function() {
            var x_axis = new Control({
                'context': this.context,
                'tag_name': 'line'
            });

            x_axis.set('dom.attributes', {
                'width': 10,
                'height': h,
                'x1': x_axis_left,
                'y1': x_axis_y,
                'x2': x_axis_right,
                'y2': x_axis_y,
                'stroke': '#000000',
                'stroke-width': 2
            });

            svg.add(x_axis);
        };

        var add_x_notch_group = function(spacing, height) {
            //console.log('x_min', x_min);
            //console.log('spacing', spacing);
            var num_notches_left_of_origin = Math.floor((x_min * -1) / spacing);
            var num_notches_right_of_origin = Math.floor(x_max / spacing);
            var first_notch_x_value = num_notches_left_of_origin * spacing * -1;
            // then we repeat through the range...
            var notch_x_value = first_notch_x_value;
            // Need functions to convert between logical grid and screen coords.
            while (notch_x_value <= x_max) {

                // then need to get the x pixel value using a function

                var x_notch = new Control({
                    'context': this.context,
                    'tag_name': 'line'
                });

                var x_location = x_location_from_value(notch_x_value);

                // calculate the notch x position.

                x_notch.set('dom.attributes', {
                    'width': 2,
                    'height': height,
                    'x1': x_location,
                    'y1': y_origin,
                    'x2': x_location,
                    'y2': y_origin + height,
                    'stroke': '#AAAAAA',
                    'stroke-width': 2
                    //'xmlns': 'http://www.w3.org/2000/svg',
                    //'version': '1.1'
                });

                svg.add(x_notch);

                notch_x_value += spacing;
            }
        }

        var add_x_label_group = function(spacing) {
            var num_notches_left_of_origin = Math.floor((x_min * -1) / spacing);
            var num_notches_right_of_origin = Math.floor(x_max / spacing);
            var first_notch_x_value = num_notches_left_of_origin * spacing * -1;
            // then we repeat through the range...
            var notch_x_value = first_notch_x_value;
            // Need functions to convert between logical grid and screen coords.

            while (notch_x_value <= x_max) {

                // then need to get the x pixel value using a function

                if (!(suppress_0_axes_labels && notch_x_value === 0)) {
                    var x_location = x_location_from_value(notch_x_value);
                    var x_notch_label = new Control({
                        'context': this.context,
                        'tag_name': 'text'
                    });
                    x_notch_label.set('dom.attributes', {
                        'x': x_location - 4,
                        'y': y_origin + 28,
                        'font-family': 'Verdana',
                        'font-size': 14
                    });
                    x_notch_label.add(notch_x_value + '');
                    svg.add(x_notch_label);
                }
                notch_x_value += spacing;
            }
        }
        var add_y_label_group = function(spacing) {
            var num_notches_below_origin = Math.floor((y_min * -1) / spacing);
            var num_notches_above_origin = Math.floor(y_max / spacing);

            var first_notch_y_value = num_notches_below_origin * spacing * -1;

            // then we repeat through the range...

            var notch_y_value = first_notch_y_value;

            // Need functions to convert between logical grid and screen coords.

            while (notch_y_value <= y_max) {

                // then need to get the x pixel value using a function

                if (!(suppress_0_axes_labels && notch_y_value === 0)) {

                    var y_notch = new Control({
                        'context': this.context,
                        'tag_name': 'line'
                    });

                    var y_location = y_location_from_value(notch_y_value);

                    var y_notch_label = new Control({
                        'context': this.context,
                        'tag_name': 'text'
                    });

                    y_notch_label.set('dom.attributes', {
                        'x': x_origin - 48,
                        'y': y_location + 6,
                        'font-family': 'Verdana',
                        'font-size': 14
                    });
                    y_notch_label.add(notch_y_value + '');

                    svg.add(y_notch_label);
                }
                notch_y_value += spacing;
            }
        }

        var add_y_notch_group = function(spacing, length) {
            //console.log('x_min', x_min);
            //console.log('spacing', spacing);
            var num_notches_below_origin = Math.floor((y_min * -1) / spacing);


            var num_notches_above_origin = Math.floor(y_max / spacing);

            var first_notch_y_value = num_notches_below_origin * spacing * -1;

            // then we repeat through the range...

            var notch_y_value = first_notch_y_value;

            // Need functions to convert between logical grid and screen coords.

            while (notch_y_value <= y_max) {

                // then need to get the x pixel value using a function

                var y_notch = new Control({
                    'context': this.context,
                    'tag_name': 'line'
                });

                var y_location = y_location_from_value(notch_y_value);

                y_notch.set('dom.attributes', {
                    'width': length,
                    'height': 2,
                    'x1': x_origin - length,
                    'y1': y_location,
                    'x2': x_origin,
                    'y2': y_location,
                    'stroke': '#AAAAAA',
                    'stroke-width': 2
                    //'xmlns': 'http://www.w3.org/2000/svg',
                    //'version': '1.1'
                });

                svg.add(y_notch);

                notch_y_value += spacing;
            }
        }


        var add_x_axis_major_notches = function() {
            // x_major_notch_spacing

            // paint notches from origin (if origin is shown)

            // Or paint them from one side, in sync with the origin.

            // Painting both ways from origin makes sense logically.
            //  Partial adding / painting would work.

            // Really is best to work out the range of values, that will go through the origin if necessary.

            //var num_notches_left_of_origin = Math.floor((x_min * -1) / x_major_notch_spacing);
            add_x_notch_group(x_major_notch_spacing, 20);

        }

        var add_x_axis_minor_notches = function() {
            // x_major_notch_spacing

            // paint notches from origin (if origin is shown)

            // Or paint them from one side, in sync with the origin.

            // Painting both ways from origin makes sense logically.
            //  Partial adding / painting would work.

            // Really is best to work out the range of values, that will go through the origin if necessary.

            //var num_notches_left_of_origin = Math.floor((x_min * -1) / x_major_notch_spacing);
            //console.log('x_minor_notch_spacing', x_minor_notch_spacing);
            add_x_notch_group(x_minor_notch_spacing, 10);

        }

        var add_origin_label = function() {
            var origin_label = new Control({
                'context': this.context,
                'tag_name': 'text'
            });

            origin_label.set('dom.attributes', {
                'x': x_origin - 14,
                'y': y_origin + 14,
                'font-family': 'Verdana',
                'font-size': 14//,
                //'xmlns': 'http://www.w3.org/2000/svg',
                //'version': '1.1'
            });

            origin_label.add('0');

            svg.add(origin_label);
        }

        var add_y_axis_major_notches = function() {
            add_y_notch_group(y_major_notch_spacing, 20);
        }

        var add_y_axis_minor_notches = function() {
            console.log('x_minor_notch_spacing', y_minor_notch_spacing);
            add_y_notch_group(y_minor_notch_spacing, 10);

        }

        var add_major_x_axis_labels = function() {
            add_x_label_group(x_major_notch_spacing);
        }
        var add_major_y_axis_labels = function() {
            add_y_label_group(y_major_notch_spacing);
        }

        var add_major_axes_labels = function() {
            add_major_x_axis_labels();
            add_major_y_axis_labels();
        }

        add_x_axis_minor_notches();
        add_x_axis_major_notches();

        add_y_axis_minor_notches();
        add_y_axis_major_notches();

        add_x_axis_line();
        add_y_axis_line();

        add_major_axes_labels();
        add_origin_label();
    }

    'render_axes'() {

    }

    'values_from_pixel_location'(px_loc) {
        var el = this.dom.el;
        var w = el.clientWidth;
        var h = el.clientHeight;
        var x_origin = this.x_origin;
        var y_origin = this.y_origin;
        var vert_margin = this.vert_margin;
        var left_margin = this.left_margin;
        var right_margin = this.right_margin;
        var x_axis_length = w - left_margin - right_margin;
        var y_axis_length = h - (2 * vert_margin);
        var range = this.range;
        var x_min = range[0][0], y_min = range[0][1], x_max = range[1][0], y_max = range[1][1];
        var x_range = x_max - x_min, y_range = y_max - y_min;
        var x_scale = x_range / x_axis_length;
        var y_scale = y_range / y_axis_length;
        var vect_from_origin = [px_loc[0] - x_origin, px_loc[1] - y_origin];
        //console.log('vect_from_origin', vect_from_origin);
        // and then the values, obtained by scaling.

        var res = [Math.round(vect_from_origin[0] * x_scale), Math.round(vect_from_origin[1] * y_scale * -1)];
        return res;
    }
    'pixel_location_from_values'(values) {
        var el = this.dom.el;
        var w, h;
        if (el) {
            w = el.clientWidth;
            h = el.clientHeight;
        } else {
            var size = this.size();
            //console.log('size', size);
            //throw 'stop';
            w = size._[0][0];
            h = size._[1][0];
        }
        // and if we don't have the element?


        var x_origin = this.x_origin;
        var y_origin = this.y_origin;
        var vert_margin = this.vert_margin;
        var left_margin = this.left_margin;
        var right_margin = this.right_margin;
        var x_axis_length = w - left_margin - right_margin;
        var y_axis_length = h - (2 * vert_margin);
        var range = this.range;

        //console.log('vert_margin', vert_margin);
        //console.log('y_axis_length', y_axis_length);

        var x_min = range[0][0], y_min = range[0][1], x_max = range[1][0], y_max = range[1][1];
        var x_range = x_max - x_min, y_range = y_max - y_min;
        var x_scale = x_range / x_axis_length;
        var y_scale = y_range / y_axis_length;

        //console.log('values', values);
        //console.log('y_scale', y_scale);
        //console.log('y_origin', y_origin);
        //console.log('values', values);

        var res = [Math.round(x_origin + values[0] * 1 / x_scale), Math.round(y_origin + values[1] * -1 / y_scale)];
        return res;
    }
    'activate'() {
        if (!this.__active) {
            super.activate();
            var that = this;
            //console.log('this', this);
            //throw 'stop';
            //var retrieved_el = this.dom.el;
            //console.log('!!retrieved_el', !!retrieved_el);
            //console.log('retrieved_el', retrieved_el);
            var el = this.dom.el;
            //throw 'stop';
            // But want a better way to get the size.
            //  Want a standard, encapsulated way.

            var w = el.clientWidth;
            var h = el.clientHeight;
            var size = [w, h];

            // Size could have been sent as a property?
            //  Or it loads it from the inline style.

            var vert_margin = this.vert_margin;
            var left_margin = this.left_margin;
            var right_margin = this.right_margin;
            var axis_thickness = this.axis_thickness;
            var x_major_notch_spacing = this.x_major_notch_spacing;
            var y_major_notch_spacing = this.y_major_notch_spacing;
            var x_minor_notch_spacing = this.x_minor_notch_spacing;
            var y_minor_notch_spacing = this.y_minor_notch_spacing;
            var suppress_0_axes_labels = this.suppress_0_axes_labels;



            var x_origin = this.x_origin;
            var y_origin = this.y_origin;

            var range = this.range;
            var x_min = range[0][0], y_min = range[0][1], x_max = range[1][0], y_max = range[1][1];

            var y_axis_is_at_origin = x_min <= 0 && x_max >= 0;
            var x_axis_is_at_origin = y_min <= 0 && y_max >= 0;

            // Position of chart_left, position of chart_right

            var x_axis_left = left_margin;
            var x_axis_right = w - right_margin;
            var y_axis_top = vert_margin;
            var y_axis_bottom = h - vert_margin;

            //var x_chart_distance = x_axis_right - x_axis_left;
            //var y_chart_distance = y_axis_bottom - y_axis_top;

            var x_axis_length = w - left_margin - right_margin;
            var y_axis_length = h - (2 * vert_margin);

            // Want to show the Y axis at the origin if possible.

            // Is the x point 0 within the grid? if so, show the y axis at that position.

            var x_range = x_max - x_min, y_range = y_max - y_min;
            var x_scale = x_range / x_axis_length;
            var y_scale = y_range / y_axis_length;


            var log_values = function() {
                console.log('x_range', x_range);
                console.log('y_range', y_range);
                console.log('x_scale', x_scale);
                console.log('y_scale', y_scale);

                console.log('left_margin', left_margin);
                console.log('right_margin', right_margin);
                console.log('range', range);
                console.log('tof range', tof(range));
            }

            // They items got are Data_Values.
            var context = this.context;

            var values_from_pixel_location = function(px_loc) {
                var vect_from_origin = [px_loc[0] - x_origin, px_loc[1] - y_origin];
                //console.log('vect_from_origin', vect_from_origin);
                // and then the values, obtained by scaling.

                var res = [Math.round(vect_from_origin[0] * x_scale), Math.round(vect_from_origin[1] * y_scale * -1)];
                return res;


            };

            var pixel_location_from_values = function(values) {
                var res = [Math.round(origin[0] + values[0] * 1 / x_scale), Math.round(origin[1] + values[1] * -1 / y_scale)];
                return res;
            };

            var x_location_from_value = function(x_value) {
                return Math.round(x_origin + x_value * 1 / x_scale)
            };
            var y_location_from_value = function(y_value) {
                return Math.round(y_origin + y_value * -1 / y_scale)
            };


            // Want a mousemove that shows where the bounds will be placed
            //  Will show highlight of bound or bound point the mouse is over.

            var findPos = function(obj) {
                var curleft = curtop = 0;
                if (obj.offsetParent) {
                    do {
                        curleft += obj.offsetLeft;
                        curtop += obj.offsetTop;
                    }  while (obj = obj.offsetParent);
                }
                return [curleft, curtop];
            }
            // Need a way of getting the event to the app with the chart positions.

            // 22/11/2015 - Was considering adding event interceptors to jsgui.
            //  Will not do that, as we can change the event object here, then other event handlers can access new properties.

            this.add_event_listener('mousemove', function(e_mousemove) {
                //console.log('e_mousemove', e_mousemove);
                // See the logical points it corresponds to.
                var pos = findPos(el);
                //var pos = bcr[0];
                var click_x, click_y;
                if (e_mousemove.pageX || e_mousemove.pageY) {
                    click_x = e_mousemove.pageX;
                    click_y = e_mousemove.pageY;
                }
                var click_pos = [click_x, click_y];
                var pos_within_this = jsgui.v_subtract(click_pos, pos);
                //console.log('pos_within_this', pos_within_this);
                var values = values_from_pixel_location(pos_within_this);
                //console.log('values', values);
                e_mousemove.chart_position = values;
                //return false
            });
            this.add_event_listener('click', function(e_click) {
                var pos = findPos(el);
                //var pos = bcr[0];
                var click_x, click_y;
                if (e_click.pageX || e_click.pageY) {
                    click_x = e_click.pageX;
                    click_y = e_click.pageY;
                }
                var click_pos = [click_x, click_y];
                var pos_within_this = jsgui.v_subtract(click_pos, pos);
                var values = values_from_pixel_location(pos_within_this);
                e_click.chart_position = values;
            });
        }
    }
}

module.exports = Line_Chart;

},{"../../../../html-core/html-core":149}],115:[function(require,module,exports){
const jsgui = require('./../../../../html-core/html-core');

// text input?
// search button
//   an icon system would be of great help.
//    references to web resources for icons too.
//    making use of them from local CMS as well. CMS and icons could be integrated well.

const {Control} = jsgui;

//const Button = require('./button');
//const Text_Input = require('./text-input');

// Worth having a 'text' property.
//  Use oext.

const view_model_spec = {
    name: 'search_bar',
    version: '0.0.1',
    type: 'control',
    fields: {
        number_of_lines: 1
    },
    actions: ['search']
}

// Will support rapid lookups.
//  Results will not be part of this right now though.

// Worth having a property or field to represent the 'text'.
//  Possibly Data_Value will be of use.

// or ._ being an evented class that stores properties?
// specific change events for specific properties?

const {prop, field} = require('obext');

// The search bar having toolboxes would make sense.
//  For holding buttons etc.

class Search_Bar extends Control {
    constructor(spec) {
        // Capitalise type names?
        spec.__type_name = spec.__type_name || 'search_bar';
        super(spec);

        // Composed of the button and the text input.
        // Needs to itself raise an event / events from the search button being pressed.
        //  How to do that with parse_mount?
        //   Would get the created items back, and then be able in interact with them.
        this.add_class('search-bar');
        // a prop for the text being enough?
        /*
        prop(this, 'value', (e_change) => {
            console.log('text prop e_change', e_change);
        });
        */
        field(this, 'value');

        if (!spec.el) {
            //this.compose_block_summary();

            // Flexibility with buttons?
            //  A toolbox or two?
            //  jsgui toolbox control?
            //   yes would make sense for some guis such as drawing apps, IDEs.
            //   a bit like a menu. 

            const jsguiml = '<Text_Input name="input"></Text_Input><Button name="btn"></Button>';
            //console.log('Search_Bar constructor pre parse_mount Object.keys(jsgui.controls)', Object.keys(jsgui.controls));

            //console.trace();
            //throw 'stop';
            jsgui.parse_mount(jsguiml, this, jsgui.controls);
        }
    }

    // onkeypress 

    activate() {
        if (!this.__active) {
            super.activate();
            const {input, btn} = this;

            // will need to listen to the keypress event.
            // worth raising a text change event?

            /*
            input.on('keypress', e => {
                console.log('input keypress', e);

                // get the text of the input...

                const input_text = input.text;
                console.log('input_text', input_text);
                this.text = input_text;

            });
            */

            // input on change...

            //  change event overriding dom?
            //   a little ambiguous?

            // nice if this happens on keypress / paste / whatever causes it to change.
            //  don't like how change means losing focus.

            // So text input should raise the 'change' event when its text field / property changes.

            input.on('change', e_change => {
                //console.log('Search_Bar input change', e_change);
                // should happen when the value changes? Change event gets called because of the field?
                // value property - set the value of the search bar.

                const {name, value} = e_change;

                if (name === 'value') {
                    this.value = value;
                }
            });

        }
        
    }
}

Search_Bar.prototype.view_model_spec = view_model_spec;

module.exports = Search_Bar;

},{"./../../../../html-core/html-core":149,"obext":382}],116:[function(require,module,exports){
var jsgui = require('./../../../../html-core/html-core');
var Toggle_Button = require('../../0-core/0-basic/1-compositional/toggle-button');

var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof;
var Control = jsgui.Control;

// Maybe a bit more niche.
//  Could make an extra controls expansion....

// Specifying / having a smaller default control set would help.
//  So would a function for declaring controls.
//   May have some more tricks for keeping things in a closure.




class Start_Stop_Toggle_Button extends Toggle_Button {

	//'fields': [
		//['text', String]
	//],
	//  and can have other fields possibly.

	constructor(spec, add, make) {
		// Set it so it only has two states
		//  '+' and '-'
		spec.states = ['start', 'stop'];
		spec.state = spec.state || 'start';

		super(spec);
		this.__type_name = 'start_stop_toggle_button';

		this.add_class('start-stop toggle-button');

		// set not returning the Data_Value?
		//this.state = spec.state;
		// Want it to have events as well specific to start and stop.
		//  That will make it different to some other toggle buttons.
		// can listen for state change.
		// needs to be client-side event only.
		//  Maybe just on activation.

		// a 'changes' util function.

		this.on('change', (e_change) => {
			//console.log('Start_Stop_Toggle_Button e_change', e_change);
			const {name, value} = e_change;
			if (name === 'state') {
				// the state is just what the button says/will say.
				if (value === 'stop') {
					// start it.
					this.raise('start');
				}
				if (value === 'start') {
					// start it.
					this.raise('stop');
				}
			}
		});
	}
	'activate'() {
		// Need to check it's not active already.
		if (!this.__active) {
			super.activate();
			//console.log('* activate Start_Stop_Toggle_Button');
			//var that = this;
			
		}
	}
}

module.exports = Start_Stop_Toggle_Button;

},{"../../0-core/0-basic/1-compositional/toggle-button":99,"./../../../../html-core/html-core":149}],117:[function(require,module,exports){
const jsgui = require('./../../../../html-core/html-core');
const {Control} = jsgui;
const {prop, field} = require('obext');

class Toolbox extends Control {
    constructor(spec) {
        spec.__type_name = spec.__type_name || 'toolbox';
        super(spec);
        this.add_class('toolbox');
    }
}

module.exports = Toolbox;
},{"./../../../../html-core/html-core":149,"obext":382}],118:[function(require,module,exports){
var jsgui = require('./../../../../html-core/html-core');
var Plus_Minus_Toggle_Button = require('./../../0-core/0-basic/1-compositional/plus-minus-toggle-button');
var Vertical_Expander = require('./../6-layout/vertical-expander');

const mx_selectable = require('./../../../../control_mixins/selectable');
const {
	prop,
	field
} = require('obext');

const {
	stringify,
	each,
	tof,
	def,
	Control
} = jsgui;

/*
var stringify = jsgui.stringify,
	each = jsgui.each,
	tof = jsgui.tof,
	def = jsgui.def;
var Control = jsgui.Control;
*/

var fields = [
	//['text', String]
	['toggle_button', Control],
	['inner_control', Control],
	['expander', Control]
];

class Tree_Node extends Control {
	constructor(spec) {
		// Wont fields have been set?
		spec = spec || {};
		//console.log('1) spec', spec);
		spec.__type_name = spec.__type_name || 'tree_node';
		//spec.expandable = spec.expandable || true;
		if (!def(spec.expandable)) spec.expandable = true;
		super(spec);
		mx_selectable(this);

		field(this, 'depth');
		field(this, 'state', 'open');
		this.expandable = spec.expandable;
		if (def(spec.depth)) this.depth = spec.depth;
		if (spec) {
			var spec_state = spec.state,
				state;
			//this.depth = spec.depth || 0;
			//console.log('spec_state', spec_state);
			if (spec_state === 'open' || spec_state === 'closed') {
				this.state = spec_state;
			} else {
				//this.state = 'closed';
				//throw 'spec.state expects "expanded" or "contracted".';
			}
			if (spec.text) {
				//this.set('text', spec.text);
				this.text = spec.text;
			} else {
				if (spec.name) {
					//this.set('text', spec.text);
					this.text = spec.name;
				}
			}
		} else {
			//state = this.set('state', 'expanded');
			this.state = 'open';
		}

		if (spec.img_src) {
			//this.set('img_src', spec.img_src);
			//var img_src = this.img_src;
			//console.log('img_src', img_src);
			//console.log('this._', this._);
			//throw '1) stop;'
		}
		if (typeof spec.el === 'undefined') {
			//console.log('4) spec', spec);
			//console.log('5) spec2', spec2);
			//console.log('typeof spec2', typeof spec2);
			//console.log('**** spec.img_src', spec.img_src);
			this.compose_tree_node(spec);
			// Tree node name, or text.
			//  Could give it a name
		}
		//this.selectable = true;
		//}

		// need to listen to content change...
		//  how many tree nodes are in the content.

		// inner_control content change

		if (this.inner_control) {
			this.inner_control.content.on('change', e_change => {
				//console.log('tree inner_control content change', e_change);

				let coll = e_change.target;
				// then does the collection contain at least one Tree_Node?

				// can we do has by type?
				//  has an instance of a function constructor.
				let has_tree_node = false;
				each(coll, (v, i, stop) => {
					if (v instanceof Tree_Node) {
						has_tree_node = true;
						stop();
					}
				});

				if (has_tree_node) {
					this.toggle_button.show();
				} else {
					this.toggle_button.hide();
				}
			})
		}
	}

	'compose_tree_node'(spec) {
		//console.log('!!this.context', !!this.context);
		//throw 'stop';
		//let my = p => p.context = this.context;
		let my = (p) => {
			p.context = this.context;
			return p;
		}
		const add = item => this.add(item);
		const make = item => this.make(item);
		// Old way of doing things...
		//  allowed classes to be involked without new, meaning they were in a passive mode and held params describing them.
		var top_line = add(new Control(my({
			'class': 'top-line'
		})));
		let rest_of_top_line;

		// Could try with parse_mount. Maybe it's not the best for loops

		if (def(this.depth)) {
			// add that many depth blocks
			//console.log('this.depth', this.depth);
			for (let c = 0; c < this.depth; c++) {
				let depth_block = new Control(my({
					'class': 'depth-block'
				}))
				top_line.add(depth_block);
			}
		}
		/*
		rest_of_top_line = new Control(my({
			'class': 'rest-of'
		}));
		top_line.add(rest_of_top_line);
		*/
		//var plus_minus = make(new Plus_Minus_Toggle_Button({}));
		//top_line.add(plus_minus);
		let plus_minus, inner_control;
		let spec3 = {};
		if (this.state === 'closed') {
			spec3.state = '+';
		}

		// only if there are other nodes within this node?

		top_line.add(plus_minus = new Plus_Minus_Toggle_Button(my(spec3)));
		this.toggle_button = plus_minus;
		plus_minus.hide();

		// Whenever the collection of nodes changes, if there are 0 nodes, then hide this plus minus button.

		var main_box = top_line.add(new Control(my({
			'class': 'main-box'
		})));

		//plus_minus.hide();
		//var img_src = ;

		if (this.img_src) {
			rest_of_top_line.add(new jsgui.img(my({
				'dom': {
					'attributes': {
						'src': this.img_src
					}
				}
			})));
		}
		//var img = make(new jsgui.img({}));
		//img.dom.attributes.src = img_src;
		// Also add the text to the top line.
		//var span = make(new jsgui.span({}));
		//var text = this.text;
		//console.log('this.text', this.text);
		//span.add(text);
		// inner_box
		main_box.add(new jsgui.span(my({
			text: this.text,
			'class': 'text'
		})));

		/*
		var clearall = add(new Control(my({
			'class': 'clearall'
		})));
		*/
		// expandable by default.
		//  Some won't be.

		let expander;
		//console.log('this.expandable', this.expandable);
		if (this.expandable) {
			expander = add(new Vertical_Expander(my({
				//state: this.state
			})));
			//var inner_control = make(new Control({ 'class': 'inner' }));
			expander.add(inner_control = new Control(my({
				'class': 'inner'
			})));

			/*
			var inner_control_content = inner_control.content;
			inner_control_content.on('change', e_change => {
				//console.log('Tree_Node inner_control_content change', e_change);
				//throw 'stop';
				var l = inner_control_content.length();
				console.log('inner_control_content', l);
				if (l > 0) {
					// so could / should be hidden bydefault anyway.
					plus_minus.show();
				}
				//throw 'stop';
			});
			*/
			
			//console.log('pre set inner_control');
			this.inner_control = inner_control;
			//console.log('post set inner_control');
			this.expander = expander;

			if (spec.nodes) {
				for (let node of spec.nodes) {
					node.context = this.context;
					node.depth = this.depth + 1;
					let tn = new Tree_Node(node);
					this.inner_control.add(tn);
				}
				expander.state = this.state = 'open';
			} else {
				expander.state = this.state = 'closed';
				//plus_minus.hide();
				//expander.close();
			}
		} else {
			//console.log('should hide plus_minus');
			plus_minus.hide();
		}

		var ctrl_fields = this._ctrl_fields = Object.assign(this._ctrl_fields || {}, {
			'toggle_button': plus_minus
		});
		if (expander) {
			ctrl_fields.inner_control = inner_control;
			ctrl_fields.expander = expander;
		}
		this.add_class('tree-node');
		// only active on the server.
		//  on the client, we don't need those extra references?
		this.active();
	}

	// adding a node - need to set up its depth?


	// I think a pre-render function would be useful.
	//  Something that sets data-jsgui DOM attributes.

	// Seems we need a separate 'register' stage, where controls, with their DOM els get registered with the central jsgui system.

	// whenever something is added to the DOM, the nodes need to be registered.
	//  within the page context

	// Want automatic activation of any control that gets added.
	//  Added to an active control.

	// __is_active


	'activate'(el) {
		if (!this.__active) {
			super.activate(el);

			// Maybe shouldn't need this.
			this.rec_desc_ensure_ctrl_el_refs();
			//this.selectable();

			//console.log('activate Tree_Node');
			// ctrl-fields not working?
			// Need to listen to the toggle event of the plus minus toggle button

			// This will be done through the ctrl~_fields system.
			//  Would like an easier way of setting that up.
			var toggle_button = this.toggle_button;
			//console.log('toggle_button', toggle_button);

			var inner_control = this.inner_control;
			var expander = this.expander;
			//console.log('inner_control', inner_control);

			//console.log('expander', expander);
			//console.log('toggle_button', toggle_button);

			if (expander) {
				if (toggle_button) {
					toggle_button.on('toggle', e_toggle => {
						// set the expander state depending on the value.
						// '-' state means open at that time.
						let state = e_toggle.state;
						if (state === '-') {
							expander.open();
							this.raise('expand');
							this.raise('open');
						} else {
							//console.log('expander', expander);
							//console.log('expander.close', expander.close);
							//console.log('Object.keys(expander)', Object.keys(expander));
							expander.close();
							this.raise('contract');
							this.raise('close');
						}
					})

					//console.log('toggle_button.__active', toggle_button.__active);
				}
			}
		}

	}
}
module.exports = Tree_Node;
},{"./../../../../control_mixins/selectable":62,"./../../../../html-core/html-core":149,"./../../0-core/0-basic/1-compositional/plus-minus-toggle-button":93,"./../6-layout/vertical-expander":128,"obext":382}],119:[function(require,module,exports){
// A box that contains a tree.
//  While a tree can be put in a normal Control, will have some more functions / tools / controls for dealing with a tree, such as collapse_all etc.
var jsgui = require('./../../../../html-core/html-core');
/*
var stringify = jsgui.stringify,
    each = jsgui.each,
    tof = jsgui.tof;
var Control = jsgui.Control;
*/
const {stringify, each, tof, def, Control} = jsgui;

// Registration of controls within jsgui.
//  where it adds it to the map of controls.

// jsgui.controls is now the / a map of controls.

// Again, a 'platform' control.
//  Ways to merge in different controls / control sets?
//   That will come. It needs to be convenient.

// Could download the bare minimum.
//  Bare minimum / core controls.

// Could separate out the core controls ie document, div, span, svg, many others.
//  Pay them more attention. Could have plugins.
//   Styling shortcuts.
// Really advanced and flexible core that deals mostly with single controls, but sets the groundwork for 'platform' controls.

// Platform controls - separate from the core controls.
//  eos-live-www just seems to need to show some very basic controls ie have control over some span contents.
//   it has its own controls. then module-view as well.
//    so does not need much in terms of jsgui controls at all at this stage.





//  Then download a control set all at once in another file.








const Panel = require('./../6-layout/panel');
const Title_Bar = require('./../6-layout/title-bar');
const Tree_Node = require('./tree-node');
// Extending, with field values being set?
//  Setting field values in definitions may be a useful thing.
const {prop, field} = require('obext');
//var fields = [
//    ['text', String]
//];
// Could do with a File_Tree that can integrate with an FS_Resource
// text alias being title?
class Tree extends Control {
    // fields... text, value, type?
    //  type could specify some kind of validation, or also 'password'.
    // single field?
    //  and can have other fields possibly.
    constructor(spec, add, make) {
        spec = spec || {};
        spec.__type_name = spec.__type_name || 'tree';
        super(spec);
        this.add_class('tree');
        //this.__type_name = 'tree';
        // Add the title bar and the main container space.
        /*
        this.title_bar = new Title_Bar({
        });
        */
        //if (spec.title) this.title = spec.title;

        field(this, 'title');
        this.title = spec.title;

        //add(Title_Bar({
        //    'text': 'tree'
        //}));

        // don't do this composition on the client.
        //  don't do it when connecting to an existing DOM.

        if (!spec.el) {
        //if (!window) {
            this.compose_tree(spec);
        }

        // one way data binding.
        // this.bind('title', this.title_bar.text);
        // bind(this, 'title', this.title_bar.text)

        this.on('change', e_change => {
            if (e_change.name === 'title') {
                this.title_bar.text = e_change.value;
            };
        }) 
    }
    compose_tree(spec) {
        //console.log('this.title', this.title);

        // Can try the new parse_mount with controls.




        if (this.title !== undefined) {
            this.add(this.title_bar = new Title_Bar({
                context: this.context,
                text: this.title
            }));
        }
        this.add(this.main = new Panel({
            context: this.context
        }));
        //var ctrl_fields = ;
        if (spec.nodes) {
            for (let node of spec.nodes) {
                node.context = this.context;
                node.depth = 0;
                let tn = new Tree_Node(node);
                this.main.add(tn);
            }
        }
        this._ctrl_fields = Object.assign(this._ctrl_fields || {}, {
            //'title_bar': this.title_bar,
            'main': this.main
        });
        if (this.title_bar) {
            this._ctrl_fields.title_bar = this.title_bar;
        }
        //this.dom.attributes['data-jsgui-ctrl-fields'] = stringify(ctrl_fields).replace(/"/g, "'");
    }
    clear() {
        //console.log('this.main', this.main);
        this.main.clear();
    }
    activate() {
        super.activate();
        this.selection_scope = this.context.new_selection_scope();
    }
};
module.exports = Tree;
},{"./../../../../html-core/html-core":149,"./../6-layout/panel":122,"./../6-layout/title-bar":126,"./tree-node":118,"obext":382}],120:[function(require,module,exports){
/**
 * Created by James on 03/08/2014.
 */



/*
    2022 - May change this to use mixins and other more composable ways of doing it.
        Want to start with a Control and then add functionality to it, not changing it to a separate class / subclass where possible.

    eg FlexiSize...?
        Could use flexbox css as well.
        Where inner content takes the size that is available internally (control can be set to a variety of sizes)
        Where it can be displayed / edited at different sizes.
        Would specify different layouts for different sizes available.
            Can certainly use CSS for this as well - showing hiding and maybe even transforming.

        MultiSizable...?
            Eg a component with one piece of text and an icon. Click it to edit it and the popup takes a lot more space.
            View_And_Edit_Mode possibly?

        Different types of modes can apply to the same Control.






if (typeof define !== 'function') { var define = require('amdefine')(module) }
// Also want to make an MDI window system (Multiple Document Interface)
define(["../../jsgui-html", "./panel"],
    function(jsgui, Panel) {
*/

// An app layout / full app layout

var jsgui = require('./../../../../../html-core/html-core');
var Panel = require('../panel');
var Tabbed_Panel = require('../tabbed-panel');

var stringify = jsgui.stringify,
    each = jsgui.each,
    tof = jsgui.tof,
    is_defined = jsgui.is_defined;
var Control = jsgui.Control;

var group = jsgui.group;

// Extensions of inner frames within inner frames...
//  The relative frame container, which has an inner frame. Then if something extends that, it would be good for that
//  to have an inner_control of its own and seamlessly expose that one while using the one above that.

// Relate the inner_control more to that level of the control heirachy.
//	Then make it so that they are navigable in sequence.
//  Not for the moment though.
//  I'll just have the Window control contain a relative div.

//var Relative_Frame = Control.

/*
    Nav and layout like VS code
    A new layout system that more specifically includes the tabs would work better.
    Multiple documents / viewers are available through tabs like in vs code.

    Definitely want to do more with dynamic / parsed user controls.

    leftmost - menu
    topmost - menu, title bar
    left vertical menu - tool group select
    left panel - navigation
    main panel - tabs at top. shows content in main view.

*/

/*
 'fields': {
 'layout_mode': String
 },
 */

/*
 Layout_Inner_Swap may be a better way of handling multiple layouts
 Would work on a different level

*/

var fields = {
    'layout_mode': String
};

// Making this handle tabs in its main area would make it more flexible in a nice way.

// VSC influenced layout... Nav_View?
//  VSC_Layout?
//   IDE layout?
//  IDE_Layout?
//  VSC_Like?
//   Seems best for now.

// This may be a very worthwhile place to use composition parsing and building.
//  parse_mount
//   that seems like a good way to include content.
//   Want to get that right before writing more UI composition code.

// Features ._features feature

// Like Multi layout mode
//  Define a few panels.

// Could base VSC_Layout on this.
//  

// But want to use parse_mount on some HTML-like code.
//  Getting parse_mount etc working fully would be a better focus right now.

// Maybe make this into a mixin so that controls can have their own different layout modes.
//   Or give this a more specific name within a layout library of some sort.




class Multi_Layout_Mode extends Control {

    // could have a title field.
    //'fields': {
    //	'title': String
    //},

    // maybe add before make would be better. add will probably be used more.
    constructor(spec) {
        spec.__type_name = spec.__type_name || 'multi_layout_mode';
        super(spec);

        // Don't register controls on the server?
        this.layout_mode = spec.layout_mode;
        // May be having probs with make
        var make = this.context.make;
        var context = this.context;
        //this.__type_name = 'multi_layout_mode';
        //this.add_class('multi-layout-mode');
        this.add_class('multi-layout-mode');
        if (!spec.el) {
            this.compose_mlm();
        }

        this._features = this._features || []; // an array is cool but map is better for testing for specific ones.

        // map of features may be better for quick checking?



        //each(['app', 'title', 'navigation', 'main', 'misc'], this._features.push);

        // other features could be
        //  editor, viewer, versitile???, responsive-size
        //   try a few where it would help for feature checking.
        //    also would be useful when they are in a library if the features are described as standard.
        //  basic?, layout?, flexi-layout?
        //   once these mean something more we can include them in ._features.
        



    }
    'compose_mlm'() {
        var layout_mode = this.layout_mode;
        let context = this.context;

        if (layout_mode) {
            this.add_class(layout_mode);
        }

        //console.log('layout_mode', layout_mode);
        //console.log('tof layout_mode', tof(layout_mode));
        //  And the main content in the fluid area...
        //   That could be a useful default of fluid-fixed.

        var panel_title = new Panel({
            'context': context,
            'name': 'title',
            'class': 'title'
        })
        //panel_title.add_class('title');
        var panel_navigation = new Panel({
            'context': context,
            'name': 'navigation',
            'class': 'navigation'
        });
        // Make it so the navigation (on the left panel) can be changed to specific tools

        // A tools panel would be quite useful
        //  Could just be tools selection.

        // Tool_Select
        //  Not sure we need this right now.

        //panel_navigation.add_class('navigation');

        // are we using tabs?
        //  .using_tabs
        //  .tabs exists

        // tabs allows swapping between different items that are being viewed.

        var panel_main = new Panel({
            'context': context,
            'name': 'main',
            'class': 'main'
        })

        // Make it so that the main panel can use tabs.
        //  Tabbed main panel looks more useful.

        // panel.tabs?
        //  or use tabbed-panel
        //  could have a tabs mixin?
        //   tabs opens up a variety of internal controls.

        // Tabbed panel looks like it could be useful here.

        //panel_main.add_class('main');
        var panel_misc = new Panel({
            'context': context,
            'name': 'misc',
            'class': 'misc'
        })
        //panel_misc.add_class('misc');
        if (layout_mode == 'fluid-fixed') {
            // make the html like in
            //  http://www.dynamicdrive.com/style/layouts/item/css-liquid-layout-22-fluid-fixed/

            // top
            // left_wrapper
            //  left
            // right
            // bottom
            /*
            var panel_top = new Panel({
                'context': context,
                'name': 'top'
            })
            panel_top.add_class('top');
            */

            var panel_top = new Panel({
                'context': context,
                'name': 'top'
            })
            panel_top.add_class('top');
            var panel_left_wrapper = new Panel({
                'context': context,
                'name': 'left-wrapper'
            })
            panel_left_wrapper.add_class('left-wrapper');
            var panel_left = new Panel({
                'context': context,
                'name': 'left'
            })
            panel_left.add_class('left');
            var panel_right = new Panel({
                'context': context,
                'name': 'right'
            })
            panel_right.add_class('right');
            var panel_bottom = new Panel({
                'context': context,
                'name': 'bottom'
            })
            panel_bottom.add_class('bottom');
            // will expose, top, left, right, bottom
            this.add(panel_top);
            this.add(panel_left_wrapper);
            panel_left_wrapper.add(panel_left);
            this.add(panel_right);
            this.add(panel_bottom);
            panel_top.add(panel_title);
            panel_bottom.add(panel_navigation);
            panel_left.add(panel_main);
            panel_right.add(panel_misc);
            // layout_mode
        } else if (layout_mode === 'tools-at-top') {
            this.add(panel_title);
            this.add(panel_navigation);

            var main_column = new Control({
                'context': context,
                'class': 'main-column'
            })
            this.add(main_column);

            main_column.add(panel_misc);
            main_column.add(panel_main);
        } else {
            this.add(panel_title);
            this.add(panel_navigation);
            this.add(panel_main);
            this.add(panel_misc);
        } 

        this.title = panel_title;
        this.nav = this.navigation = panel_navigation;
        this.main = panel_main;
        this.misc = panel_misc;

        this._ctrl_fields = this._ctrl_fields || {};

        //console.log('pre add ctrl fields');
        
        Object.assign(this._ctrl_fields, {
            'title': panel_title,
            'nav': panel_navigation,
            'main': panel_main,
            'misc': panel_misc
        });
    }
    'activate'() {
        if (!this.__active) {
            super.activate();
        }
        // May need to register Flexiboard in some way on the client.
        
    }


    //,
    // Takes on the menu of the maximized window (for the moment).
    //  Could have its own menu possibly
    //'menu': function(menu_spec) {


    //}
}
module.exports = Multi_Layout_Mode;
},{"../panel":122,"../tabbed-panel":124,"./../../../../../html-core/html-core":149}],121:[function(require,module,exports){
var jsgui = require('./../../../../html-core/html-core');
//var Horizontal_Menu = require('./horizontal-menu');

var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof, def = jsgui.is_defined;
var Control = jsgui.Control;

class Modal extends Control {
    constructor(spec) {
        spec.__type_name = spec.__type_name || 'modal';
        super(spec);
        this.add_class('modal');

    }
}

module.exports = Modal;
},{"./../../../../html-core/html-core":149}],122:[function(require,module,exports){
/**
 * Created by James on 04/08/2014.
 */


var jsgui = require('./../../../../html-core/html-core');
//var Horizontal_Menu = require('./horizontal-menu');

var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof, def = jsgui.is_defined;
var Control = jsgui.Control;

// Titled_Panel would be useful.
//  Would extend the panel, and also show it's name or title.

// Want to keep panel simple. Could have Titled_Panel, maybe Resizable_Panel.
//  If we want a panel with a lot of functionality, it would be the Flexi_Panel.

// Panel_Grid possibly...
//  Can load panels etc...

// May make Showcase version.
//  Or SuperPanel?
//  Or ActivePanel?
//   SmartPanel

// A panel with something like 4 panels inside it...
//  Should be a way of doing application layout.

// Or just use a normal panel with a bunch of mixins?


// Panel could have a text label as part of it (by default, easy to set, easy to move, easy to delete or not use)
//   Though may want to get into making it really easy to add new controls in specific ways, such as binding it to the edge
//     (and also probably reducing the size of the panel itself so that label (or div / span element) fits)




class Panel extends Control {
    // panel name?

    // could have a title field.
    //'fields': {
    //    'name': String
    //}
    // maybe add before make would be better. add will probably be used more.
    constructor(spec, add, make) {
        spec = spec || {};
        spec.__type_name = spec.__type_name || 'panel';
        super(spec);
        //this.__type_name = 'panel';
        //this.add_class('panel');
        this.add_class('panel');

        if (def(spec.name)) {
            this.name = spec.name;
        }



        // With name as a field, that field should get sent to the client...
        if (!spec.abstract && !spec.el) {
            var l = 0;
            //var ctrl_fields = {
            //}

            let n = this.name;
            if (def(n)) {
                let f = this._fields = this._fields || {};
                f.name = n;
            }


            //var name = this.name;
            //if (is_defined(name)) {
                //this._fields = this._fields || {};
                //this._fields['name'] = name;
            //    this.name = name;
            //}
        }
    }
    //'resizable': function() {
    //},

    /*
    'activate'() {
        // May need to register Flexiboard in some way on the client.

        if (!this.__active) {
            super.activate();
            this.content.on('change', e => {
                console.log('e', e);
                console.log('this', this);
            })
        }
        
    }
    */
}
module.exports = Panel;

},{"./../../../../html-core/html-core":149}],123:[function(require,module,exports){

//if (typeof define !== 'function') { var define = require('amdefine')(module) }

//define(["../../jsgui-html"],
//function(jsgui, Text_Input) {

var fields = [
    ['value', Object],
    ['field', String],
    ['meta_field', String]
];

var jsgui = require('./../../../../html-core/html-core');
var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof;
var Control = jsgui.Control;

// Look into more advanced data binding (to client-side objects).


const view_model_spec = {
    name: 'single_line',
    version: '0.0.1',
    type: 'control',
    fields: {
        number_of_lines: 1
    }

}

class Single_Line extends Control {
    // fields... text, value, type?
    //  type could specify some kind of validation, or also 'password'.

    // single field?
    //  and can have other fields possibly.


    constructor(spec) {
        super(spec);

        this.add_class('single-line');
        this.__type_name = 'single_line';

        //if (spec.resource_pool) {
        //	this.set('resource_pool', spec.resource_pool);
        //}

        // we have access to the resource pool through the page context.
        //  that may be disabled in some configurations though.

        //var pool = this.context.pool;
        //console.log('pool', pool);

        // then for each resource in the pool, we have a resource control.
        //  controls for the same kind of item could be in different kinds of display modes, such as list and
        //  edit. Don't want to make loads of modules for different things, so having resources display just with their
        //  name in one configuration, and as an editable / interactive full size object in another configuration.

        //var value = this.get('value');
		var value = this.value;
        //console.log('Single_Line init value ', value);

        var display_value;

        var meta_field = this.get('meta_field');
        //console.log('tof meta_field', tof(meta_field));
        //console.log('meta_field', meta_field);

        if (meta_field) {
            display_value = value.meta.get(meta_field.value());
        }

        //console.log('display_value', display_value);
        //console.log('tof display_value', tof(display_value));

        // and have a span where it shows that value

        var el = this.dom.el;
        if (!el) {
            var span = new jsgui.span({
                'context': this.context//,
                //'content': display_value
            });
            if (display_value) {
                span.add(display_value);
            }



            this.add(span);

            this.set('span', span);
        }




        // Maybe won't get the field directly.
        //  May be getting a meta field.

    }
    'activate'() {
        super.activate();

        // Not sure it will have activated / got the subcontrols as content yet...


        // also do some scraping.
        //  want to get the value.
        //  as data_value or string?

        // get the child span control...
        var content = this.content;
        //console.log('Single_Line content', content);

        // need to read the value from that.
        var span = content.get(0);
        //console.log('span', span);


        var val = span.dom.el.innerHTML;

        //this.set('value', val);
		this.value = val;

		/*
		 var span = this.content.get(0);
		 console.log('span', span);

		 var span_content = span.content;
		 console.log('span_content', span_content);
		 */
        //var span_content_item = span.content.get(0);
        //console.log('span_content_item', span_content_item);

    }


};
module.exports = Single_Line;

},{"./../../../../html-core/html-core":149}],124:[function(require,module,exports){
const jsgui = require('./../../../../html-core/html-core');
const Control = jsgui.Control;
const mx_selectable = require('./../../../../control_mixins/selectable');
const { each, is_array, tof } = jsgui;
const Panel = require('./panel');
const List = require('../../0-core/0-basic/1-compositional/list');
const Radio_Button_Group = require('../../0-core/0-basic/1-compositional/radio-button-group');
const Radio_Button = require('../../0-core/0-basic/0-native-compositional/radio-button');

class Tab extends Control {
    constructor(spec) {
        spec.__type_name = spec.__type_name || 'tab';
        super(spec);
        let _group_name;
        Object.defineProperty(this, 'group_name', {
            get() { return _group_name; },
            set(value) {
                let old = _group_name;
                _group_name = value;
                this.raise('change', { 'name': 'group_name', 'old': old, 'value': value });
            }
        });
        _group_name = spec.group_name;

        let _name;
        Object.defineProperty(this, 'name', {
            get() { return _name; },
            set(value) {
                let old = _name;
                _name = value;
                this.raise('change', { 'name': 'name', 'old': old, 'value': value });
            }
        });
        _name = spec.name;

        this.add_class('tab');
        mx_selectable(this);
        this.selectable = true;
        if (!spec.el) { this.construct_tab(); }
    }
    construct_tab() {
        const { context } = this;
        const radio_button = new Radio_Button({
            context,
            group_name: this.group_name,
            text: this.name
        });
        this.add(radio_button);
        this._ctrl_fields = this._ctrl_fields || {};
        this._ctrl_fields.radio_button = radio_button;
        (this._fields = this._fields || {}).name = this.name;
    }
}
Tab.css = `
.tab { }
`;

class Tab_Group extends List {
    constructor(spec) {
        spec.__type_name = spec.__type_name || 'tab_group';
        super(spec);
        this.add_class('tab-group');
        this.tab_names = spec.tab_names || spec.tabs;
        if (!spec.el) { this.compose_tab_group(); }
    }
    compose_tab_group() {
        each(this.tab_names, tab_name => {
            this.add(new Tab({
                context: this.context,
                name: tab_name,
                group_name: this.__id
            }));
        });
    }
}
Tab_Group.css = `
.tab-group {
    display: flex;
    column-gap: 6px;
}
`;

class Tabbed_Panel extends Panel {
    constructor(spec) {
        spec.__type_name = spec.__type_name || 'tabbed_panel';
        super(spec);
        this.add_class('tab-container');
        this.tabs = spec.tabs;
        if (!spec.el) { this.compose_tabbed_panel(spec.tabs); }
    }
    compose_tabbed_panel(tabs_def) {
        const { context } = this;
        this.tab_pages = [];

        const add_tab = (name, group_name) => {
            var html_radio = new Control({ context });
            {
                const { dom } = html_radio;
                dom.tagName = 'input';
                const { attributes } = dom;
                attributes.type = 'radio';
                attributes.name = group_name;
            }
            html_radio.add_class('tab-input');
            this.add(html_radio);
            html_radio.dom.attributes.id = html_radio.__id;

            const label = new jsgui.controls.label({ context });
            label.dom.attributes.for = html_radio.dom.attributes.id;
            label.add_class('tab-label');
            label.add(name);
            this.add(label);

            const tab_page = new Control({ context });
            tab_page.add_class('tab-page');
            this.tab_pages.push(tab_page);
            this.add(tab_page);
            return tab_page;
        };

        let i_tab = 0;
        each(this.tabs, tab => {
            const group_name = this._id();
            const t = tof(tab);
            if (t === 'string') {
                add_tab(tab, group_name);
                i_tab++;
            } else {

                if (t === 'array') {

                    const tab_label_text = tab[0];
                    const tab_content = tab[1];
                    const tab_page = add_tab(tab_label_text, group_name);
                    tab_page.add(tab_content);

                } else {
                    console.log('tab', tab);
                    console.log('t', t);
                    throw 'NYI';
                }
                
                

            }
        });

        const ctrl_break = new Control({ context });
        ctrl_break.add_class('break');
        this.add(ctrl_break);

        this._ctrl_fields = this._ctrl_fields || {};
    }
    activate() {
        if (!this.__active) {
            this.__active = true;
            const tab_pages = [];
            each(this.content._arr, ctrl => {
                if (ctrl.has_class('tab-page')) { tab_pages.push(ctrl); }
            });
            this.tab_pages = tab_pages;
            console.log('tab_pages.length', tab_pages.length);
        }
    }
}
Tabbed_Panel.css = `
.tab-container {
    display: flex;
    flex-wrap: wrap;
    flex-direction: row; /* Change to 'row' for top or bottom tabs */
    width: 300px; /* Adjust width as needed */
    position: relative;
    height: 300px;
}
.break {
    flex-basis: 100%;
    height: 0;
}
.tab-input {
    display: none;
}
.tab-label {
    height: 22px;
    background-color: #ccc;
    padding: 4px;
    margin: 2px;
    cursor: pointer;
}
.tab-input:checked + .tab-label {
    background-color: #DDFFDD;
}
.tab-input:checked + .tab-label + .tab-page {
    display: block;
}
.tab-page {
    display: none;
    


    /*
    order: 100;
    left: 4px;
    right: 4px;
    top: 32px;
    */


    /* height: calc(100% - 32px); */

    height: 300px;
    width: 300px;
    background-color: #FFFFFF;
    border: 1px solid #CCCCCC;
}
`;
module.exports = Tabbed_Panel;
},{"../../0-core/0-basic/0-native-compositional/radio-button":76,"../../0-core/0-basic/1-compositional/list":90,"../../0-core/0-basic/1-compositional/radio-button-group":94,"./../../../../control_mixins/selectable":62,"./../../../../html-core/html-core":149,"./panel":122}],125:[function(require,module,exports){
// This is a Control Transformer
//  A function

// Could work well as a mixin too.

var jsgui = require('./../../../../html-core/html-core');
var stringify = jsgui.stringify,
    each = jsgui.each,
    tof = jsgui.tof;
var Control = jsgui.Control;

const fnl = require('fnl');
const prom_or_cb = fnl.prom_or_cb;

class Tile_Slider extends Control {
    constructor(spec) {
        spec = spec || {};
        spec.__type_name = 'tile_slider';
        super(spec);

        // Could use a larger grid9 control, but with its central piece positioned in view.

        // Only concerned with central (normally full in view), left, above, right, below.

        // Has 5 controls.
        //  

        if (!spec.el) {
            this.compose_tile_slider();
        }

    }
    compose_tile_slider() {

        // May need to know / measure the size of the central div.
        //  Nice if we already have the info


        // And the sizes of these containers.

        // Good candidate for parse_mount.
        //  Along with date editors / pickers / viewers / calendars.
        //  Could treat it as building up a composition string.


        const context = this.context;
        let above = new Control({
            'contect': context
        });
        above.add_class('above');
        this.add(above);
        let left = new Control({
            'contect': context
        });
        left.add_class('left');
        this.add(left);

        let right = new Control({
            'contect': context
        });
        right.add_class('right');
        this.add(right);
        let below = new Control({
            'contect': context
        });
        below.add_class('below');
        this.add(below);


        let central = new Control({
            'contect': context
        });
        central.add_class('central');
        this.add(central);
        // Central last, other are positioned absolutely (from beginning).


        this.above = above;
        this.left = left;
        this.central = central;
        this.right = right;
        this.below = below;

        // .cf or cf function?
        //  or use parse_mount / pm for this?

        this._ctrl_fields = {
            'above': above,
            'left': left,
            'central': central,
            'right': right,
            'below': below
        }

        this._fields = {
            'size': this.size
        }
    }

    // Need repositioning after sliding.

    // So the central slide is now the current one.
    //  Could be worth keeping these cached?
    //  For the moment, just want 1 further in each direction.

    // Just the sliding.

    // previous, next

    // previous_major
    // next_major
    //  used for changing years

    // previous_year = previous_major

    // prev2

    // Transitions of the non-framed version would be cool.


    // move_previous

    // does the slide to the left / right
    //  rearrange / arrange things so that the next operation is ready.



    slide_to_left() {
        // This exposes the element to the right.
        //console.log('slide_to_left');
        //console.log('this.size', this.size);

        //console.log('this.central.dom.attributes', this.central.dom.attributes);

        return prom_or_cb((resolve, reject) => {
            let ms = 333;
            let s = ms / 1000;

            this.central.dom.attributes.style.transition = 'transform ' + s + 's';
            this.central.dom.attributes.style.transform = 'translate(' + -1 * this.size[0] + 'px, 0px)';

            this.right.dom.attributes.style.transition = 'transform ' + s + 's';
            this.right.dom.attributes.style.transform = 'translate(' + -1 * this.size[0] + 'px, 0px)';

            this.right.one('transitionend', e_end => {
                //console.log('e_end', e_end);
                resolve();
            });
        }, callback);


        /*

        setTimeout(() => {
            console.log('transition (should be) done');
        }, ms);

        */

        // do it on the el?

        //transitionend
        

        /*

        var fnTransitionEnd = (e_end) => {
            console.log('fnTransitionEnd');
            //el.style.overflow = 'visible';
            this.right.dom.el.removeEventListener('transitionend', fnTransitionEnd)
        }

        this.right.dom.el.addEventListener('transitionend', fnTransitionEnd, false);
        */



    }
    slide_to_right(callback) {

        return prom_or_cb((resolve, reject) => {
            this.central.dom.attributes.style.transition = 'transform 0.33s';
            this.central.dom.attributes.style.transform = 'translate(' + this.size[0] + 'px, 0px)';

            this.left.dom.attributes.style.transition = 'transform 0.33s';
            this.left.dom.attributes.style.transform = 'translate(' + this.size[0] + 'px, 0px)';

            this.left.one('transitionend', e_end => {
                //console.log('e_end', e_end);
                resolve();
            });
        }, callback);
        // This exposes the element to the right.
        //console.log('slide_to_left');
        //console.log('this.size', this.size);

        //console.log('this.central.dom.attributes', this.central.dom.attributes);



        // do it on the el?

    }

    activate() {
        if (!this.__active) {
            super.activate();

            setTimeout(async () => {
                await this.slide_to_right();
                console.log('awaited slide to right');
            }, 2000);
        }
    }

}

const Tile_Slide = function (Ctrl, fn_prev_spec, fn_next_spec, adjacencies = {
    left: -1,
    right: 1
}) {

    // map of where the prev and next go.



    // Return a new control that extends Tile_Slider and contains necessary instances of the original control.
    // Create both normal instances of the control, and controls with different specs that represent a different position on a larger grid.

    // Tile slide is quite important to a smooth mobile user interface
    //  It also will look fairly good in a desktop browser.
    // Currently this will work in just 2 or 4 directions.
    //  2 would be easiest, fine for a month or day selector.


    class Tile_Sliding_Ctrl extends Tile_Slider {
        constructor(spec) {

            let slider_spec = {
                context: spec.context,
                size: spec.size
            }
            super(slider_spec);

            if (spec.size) {
                slider_spec.size = spec.size;
                this.size = spec.size;
                //console.log('spec.size', spec.size);
            }

            /*
            if (spec.size) {
                this.central.size = spec.size;
                this.dom.attributes.style.overflow = 'hidden';
                this.dom.attributes.style.position = 'absolute';
                
            }
            */
            //if (spec.size) {
            //slider_spec.size = spec.size;
            //}


            //console.log('spec', spec);
            //console.log('spec.size', spec.size);
            //this.size = spec.size;
            // 

            this.spec = spec;

            //console.log('prev_spec', prev_spec);
            //console.log('spec', spec);


            if (!spec.el) {
                this.compose_tile_sliding_ctrl();
            }

            if (spec.size) {
                //this.central.size = spec.size;


            }

            // then make versions with modified specs and put them adjacent.

            // Moving to the right will mean swiping to the left.




        }
        compose_tile_sliding_ctrl() {
            let prev_spec = fn_prev_spec(this.spec);
            let next_spec = fn_next_spec(this.spec);

            //console.log('this.spec.size', this.spec.size);

            if (this.spec.size) {
                this.central.size = this.spec.size;

                // .das? .s? .st?
                //  ds? da.s?
            
                // .s accesses style directly.
                //   maybe that would be a (little) layer about dom styling.

                this.dom.attributes.style.overflow = 'hidden';
                this.dom.attributes.style.position = 'relative';

                this.left.dom.attributes.style.position = 'absolute';
                this.left.dom.attributes.style.left = -1 * this.spec.size[0] + 'px';
                this.right.dom.attributes.style.position = 'absolute';
                this.right.dom.attributes.style.left = this.spec.size[0] + 'px';

                this.left.size = this.spec.size;
                this.right.size = this.spec.size;
            }

            if (adjacencies.left === -1) {
                // make a previous version to put left of it.
                //let left_ctrl_prev_spec = fn_prev_spec()
                let left_ctrl_prev = new Ctrl(prev_spec);
                this.left.add(left_ctrl_prev);
                //if (prev_spec.size) {

                //}
            }

            let ctrl = new Ctrl(this.spec);
            this.central.add(ctrl);

            if (adjacencies.right === 1) {
                // make a previous version to put left of it.
                //let left_ctrl_prev_spec = fn_prev_spec()

                let left_ctrl_prev = new Ctrl(next_spec);
                this.right.add(left_ctrl_prev);
                if (next_spec.size) {

                }
            }


        }
    }

    return Tile_Sliding_Ctrl;
}

//Tile_Slider

Tile_Slider.wrap = Tile_Slide;

module.exports = Tile_Slider;
},{"./../../../../html-core/html-core":149,"fnl":6}],126:[function(require,module,exports){
var jsgui = require('./../../../../html-core/html-core');

const {stringify, each, tof, def, Control} = jsgui;

var fields = [
    ['text', String]
];


// describe available actions for the control's view model.
const view_model_spec = {
    name: 'title_bar',
    version: '0.0.1',
    type: 'control',
    fields: {
        number_of_lines: 1
    },
    actions: ['close', 'minimize', 'maximize', 'restore']

}

class Title_Bar extends Control {
    constructor(spec) {
        spec = spec || {};
        spec.__type_name = spec.__type_name || 'title_bar';

        super(spec, fields);

        if (!spec.el) {
            this.add_class('title-bar title bar');
            var span = new jsgui.span({
                'context': this.context,
                'text': this.text
            })
            this.add(span);
        }
        
    }
};
module.exports = Title_Bar;
},{"./../../../../html-core/html-core":149}],127:[function(require,module,exports){
var jsgui = require('./../../../../html-core/html-core');
//var Horizontal_Menu = require('./horizontal-menu');

var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof, is_defined = jsgui.is_defined;
var Control = jsgui.Control;

var Panel = require('./panel');
// Panel with a titlebar inside

var Title_Bar = require('./title-bar');
var fields = {
    'title': String
}

// Titled could even be some kind of mixin.

// Tabbed panel seems more useful.
// Tab bar is a radio button group (in disguise)

// Tabbed_Panel?
//   Tabbed_Multi_Content_Container???

// The tabbed control would be very helpful for demoing various controls in a single spa / control.
// Could have a window containing a bunch of different demos of different controls.





class Titled_Panel extends Panel {

    constructor(spec) {
        super(spec);
        this.__type_name = 'titled_panel';

        // And in composition, we add the title bar.

        if (!spec.abstract && !spec.el) {
            var title_bar = new Title_Bar({
                'context': this.context,
                'text': this.title
            });
            title_bar.active();
            this.add(title_bar);

            // Then an inner content control.
            var inner_control = new Control({
                'context': this.context
            });
            inner_control.active();
            this.add(inner_control);

            // Then want to set the jsgui control fields so that it knows what these are on the client-side too.
            //  Will change this so it's got better syntax.
            //  But for the moment want to use the pattern as it is, and better spot how to cover the cases.

            //this.set('dom.attributes.data-jsgui-ctrl-fields', stringify({
            //    'title_bar': title_bar._id(),
            //    'inner_control': inner_control._id()
            //}).replace(/"/g, "'"));


            // And want to be able to refer to the title_bar as an object.
            // Also, want it so the inside of this control is where things get added, so there may need to be another content div.
            //  Easier to do that than to keep the title always the first element.


        }
    }
    'activate'() {
        super.activate();

        const {title_bar, inner_control} = this;

        //console.log('title_bar', title_bar);
        //console.log('inner_control', inner_control);

    }
}

module.exports = Titled_Panel;
},{"./../../../../html-core/html-core":149,"./panel":122,"./title-bar":126}],128:[function(require,module,exports){
// Vertical_Expander

// Some of these controls won't be needed.
//   It will definitely help to make simple and complex examples demonstrating them.


//if (typeof define !== 'function') { var define = require('amdefine')(module) }
var jsgui = require('./../../../../html-core/html-core');

//var stringify = jsgui.stringify, each = jsgui.each, tof = jsgui.tof;
var Control = jsgui.Control;

const {prop, field} = require('obext');

// Extending, with field values being set?
//  Setting field values in definitions may be a useful thing.
class Vertical_Expander extends Control {
	// fields... text, value, type?
	//  type could specify some kind of validation, or also 'password'.

	// single field?
	//'fields': [
	//	['text', String]
	//],
	//  and can have other fields possibly.

	constructor(spec) {
		spec.__type_name = 'vertical_expander';
		super(spec);

		this.add_class('vertical expander');
		//

		// starts either open or closed.

		// Would have two possible states - open and closed.
		//  Would move between the two.

		//var state = spec.state || 'open'

		field(this, 'state');
		field(this, 'states');

		//this.set('states', ['open', 'closed']);

		this.state = spec.state;
		this.states = spec.states;


		//let state = spec.state;
		//if (state === 'expanded') state = 'open';
		//if (state === 'contracted') state = 'closed';

		//this.set('state', state || 'open');

		//var span = new jsgui.span({
		//	'context': this.context
		//})
		//span.add(this.get('text').value());
		//ctrl_title_bar.set('dom.attributes.class', 'titlebar');
		//this.add(span);

	}
	
	'activate'() {
		//console.log('Vertical Expander activate');
        super.activate();

		// I think that animation should be handled by Contol, just getting called here.
		//  Will use css transitions where applicable.
		// Listen to the state being changed.
		// Then update the UI based on that
		//var that = this;
		var orig_height;

		var el = this.dom.el;

		if (el) {
			el.style.transition = 'height 0.125s linear';
			var ui_close = () => {
				var h = el.childNodes[0].offsetHeight;
				//console.log('h', h);
				orig_height = h;
				el.style.height = orig_height + 'px';
				
				// transition: width 3s linear;
				//el.style.transition = 'height 0.08s linear';
				
				//el.style['webkit-transition-property'] = 'height';
				//el.style['webkit-transition-duration'] = '1s';
				//el.style['webkit-transition-timing-function'] = 'linear';
				//el.style['transition-delay'] = '2s';
				// And to listen to the animation ending as well.
				setTimeout(function() {
					//console.log('should hide overflow');
					//
					el.style.overflow = 'hidden';
					el.style.height = '0px';
				}, 0);
				// Better control over styles will help.
				//  Need the inline css layer.
				//  Then have the JSGUI style layer on top of that.
			}

			var ui_open = () => {

				var fnTransitionEnd = function(e_end) {
					//console.log('e_end', e_end);
					//console.log('fnTransitionEnd');
					//el.style.overflow = 'visible';
					el.removeEventListener('transitionend', fnTransitionEnd)
				}

				el.addEventListener('transitionend', fnTransitionEnd, false);

				// when the transition has completed, make the overflow visible.
				//el.style.overflow = 'visible';
				el.style.height = orig_height + 'px';
			}

			this.on('change', e_change => {
				var val = e_change.value;

				if (val == 'closed') {
					ui_close();
				}

				if (val == 'open') {
					ui_open();
				}
			});
		} else {
			console.log('WARNING: vertical_expander expected el to activate');
			console.trace();
		}

		/*

		var state = this.get('state');
		state.on('change', function(e_change) {
			console.log('Vertical_Expander state change', e_change);

			// Change it in the UI at this point.
			var val = e_change.value;

			if (val == 'closed') {
				ui_close();
			}

			if (val == 'open') {
				ui_open();
			}
		});
		*/

		// Going to be setting the height based on measured height of self / contents
		//  May use css transitions. Possibly 'transit' function.
		// May make animate function take similar syntax to jQuery but use CSS transitions where appropriate.

		// Have the UI respond to changes in the state variable.
	}
	'toggle'() {
		// Will change the state.
		//console.log('vertical-expander toggle');
		//var state = this.state;
		//var v_state = state.value();
		//console.log('state', state);

		//console.log('tof state', tof(state));

		if (this.state == 'open') {
			//this.set('state', 'closed');
			//state.set('closed');
			this.state = 'closed';
		}
		if (this.state == 'closed') {
			//this.set('state', 'open');
			this.state = 'open';
		}
	}
	'open'() {
		//this.state.set('open');
		this.state = 'open';
	}
	'close'() {
		//this.state.set('closed');
		this.state = 'closed';
	}
	// Open, close, expand, contract
	//  Could have a state variable as well.
	//  Will listen to changes in that state variable.

}
module.exports = Vertical_Expander;

},{"./../../../../html-core/html-core":149,"obext":382}],129:[function(require,module,exports){
var jsgui = require('./../../../../html-core/html-core');
var Horizontal_Menu = require('./../../../organised/1-standard/5-ui/horizontal-menu');
const {def, each} = jsgui;
var Control = jsgui.Control;
var fields = {
	'title': String
};
const {dragable, resizable} = require('../../../../control_mixins/mx');
class Window extends Control {
	constructor(spec, add, make) {
		super(spec);
		this.__type_name = 'window';
		this.add_class('window');
		const show_buttons = def(spec.show_buttons) ? spec.show_buttons : true;
		if (!spec.abstract && !spec.el) {
			const {context} = this;
			const div_relative = new Control({
				context
			});
			div_relative.add_class('relative');
			const title_bar = new Control({
				context
			});
			title_bar.add_class('title');
			title_bar.add_class('bar');
			const title_h2 = new jsgui.controls.h2({
				context
			})
			title_bar.add(title_h2);
			if (typeof spec.title === 'string') {
				title_h2.add(spec.title);
			}
			div_relative.add(title_bar);
			let btn_minimize, btn_maximize, btn_close;
			if (show_buttons) {
				const right_button_group = new Control({
					context
				});
				right_button_group.add_class('button-group');
				right_button_group.add_class('right');
				btn_minimize = new jsgui.controls.Button({
					context
				});
				const span = (text) => {
					const res = new jsgui.controls.span({context});
					res.add(text);
					return res;
				}
				btn_minimize.add(span('⊖'));
				right_button_group.add(btn_minimize);
				btn_maximize = new jsgui.controls.Button({
					context
				});
				btn_maximize.add(span('⊕'))
				right_button_group.add(btn_maximize);
				btn_close = new jsgui.controls.Button({
					context
				});
				btn_close.add(span('⊗'))
				right_button_group.add(btn_close);
				title_bar.add(right_button_group);
			}
			const ctrl_inner = new Control({
				context
			})
			ctrl_inner.add_class('inner');
			div_relative.add(ctrl_inner);
			this.add(div_relative);
			this.ctrl_inner = ctrl_inner;
			this.inner = ctrl_inner;
			this.title_bar = title_bar;
			this.ctrl_relative = div_relative;
			this._ctrl_fields = this._ctrl_fields || {};
			this._ctrl_fields.ctrl_inner = ctrl_inner;
			this._ctrl_fields.inner = ctrl_inner;
			this._ctrl_fields.title_bar = title_bar;
			this._ctrl_fields.ctrl_relative = div_relative;
			if (show_buttons) {
				this._ctrl_fields.btn_minimize = btn_minimize;
				this._ctrl_fields.btn_maximize = btn_maximize;
				this._ctrl_fields.btn_close = btn_close;
			}
		}
	}
	bring_to_front_z() {
		let max_z = 0;
		each(this.parent.content, (ctrl) => {
			if (ctrl !== this) {
				const z = parseInt(ctrl.dom.attributes.style['z-index']);
				if (!isNaN(z) && z > max_z) max_z = z;
			}
		});
		this.dom.attributes.style['z-index'] = parseInt(max_z) + 1;
	}
	glide_to_pos(pos) {
		return new Promise((s, j) => {
			const [my_new_left, my_new_top] = pos;
			const x_diff = my_new_left - this.ta[6];
			const y_diff = my_new_top - this.ta[7];
			const ms_total_animation_time = 140;
			let animation_start;
			const start_tx = this.ta[6];
			const start_ty = this.ta[7];
			let i_frame = 0;
			const skip_zeroth_frame = false;
			const process_frame = () => {
				if (skip_zeroth_frame && i_frame === 0) {
					requestAnimationFrame(timestamp => {
						i_frame++;
						process_frame();
					});
				} else {
					requestAnimationFrame(timestamp => {
						if (!animation_start) {
							animation_start = timestamp;
							process_frame();
						} else {
							const time_since = timestamp - animation_start;
							if (time_since < ms_total_animation_time) {
								const proportion_through = time_since / ms_total_animation_time;
								const proportional_x_diff = x_diff * proportion_through;
								const proportional_y_diff = y_diff * proportion_through;
								this.ta[6] = start_tx + proportional_x_diff;
								this.ta[7] = start_ty + proportional_y_diff;
								i_frame++;
								process_frame();
							} else {
								this.ta[6] = start_tx + x_diff;
								this.ta[7] = start_ty + y_diff;
								s();
							}
						}
					})
				}
			}
			process_frame();
		})
	}
	async minimize() {
		if (this.manager) {
			this.manager.minimize(this);
		} else {
			const my_bcr = this.bcr();
			if (!this.has_class('minimized')) {
				const width_to_minimize_to = 280;
				const minimized_height = 31;
				if (this.has_class('maximized')) {
					this.was_maximized_just_before_minimizing = true;
					this.pre_minimized_pos = this.pre_maximized_pos;
					this.pre_minimized_size = this.pre_maximized_size;
					this.remove_class('maximized');
				} else {
					this.was_maximized_just_before_minimizing = false;
					this.pre_minimized_pos = my_bcr[0];
					this.pre_minimized_size = my_bcr[2];
				}
				this.dragable = false;
				const parent_bcr = this.parent.bcr();
				const parent_size = parent_bcr[2];
				setTimeout(() => {
					this.size = [width_to_minimize_to, minimized_height];
				}, 17)
				const determine_pos_to_minimize_to = () => {
					let minimized_sibling_window_bcrs = [];
					each(this.parent.content, (ctrl) => {
						if (ctrl !== this) {
							if (ctrl.has_class('window') && ctrl.has_class('minimized')) {
								const ctrl_bcr = ctrl.bcr();
								minimized_sibling_window_bcrs.push(ctrl_bcr);
							}
						}
					});
					if (minimized_sibling_window_bcrs.length > 0) {
						minimized_sibling_window_bcrs.sort((a, b) => {
							if (a[0][1] === b[0][1]) {
								return a[1][0] - b[1][0];
							} else {
								return b[0][1] - a[0][1];
							}
						});
						const last_bcr = minimized_sibling_window_bcrs.at(-1);
						const last_r = last_bcr[1][0];
						const extra_margin = 2;
						if (parent_size[0] >= last_r + width_to_minimize_to + extra_margin) {
							return [last_bcr[1][0] + extra_margin, last_bcr[0][1]];
						} else {
							return [0, last_bcr[0][1] - extra_margin - minimized_height];
						}
					} else {
						return [0, parent_size[1] - minimized_height];
					}
				}
				const ltpos = [this.dom.attributes.style.left || 0, this.dom.attributes.style.top || 0].map(x => parseInt(x));
				const dest_pos = determine_pos_to_minimize_to();
				dest_pos[0] -= ltpos[0];
				dest_pos[1] -= ltpos[1];
				await this.glide_to_pos(dest_pos);
				this.add_class('minimized');
			} else {
				if (this.was_maximized_just_before_minimizing) {
					await this.maximize();
				} else {
					setTimeout(() => {
						this.size = this.pre_minimized_size;
					}, 17)
					const ltpos = [this.dom.attributes.style.left || 0, this.dom.attributes.style.top || 0].map(x => parseInt(x));
					const dest_pos = [this.pre_minimized_pos[0] - ltpos[0], this.pre_minimized_pos[1] - ltpos[1]];
					await this.glide_to_pos(dest_pos);
					this.remove_class('minimized');
					this.dragable = true;
				}
			}
		}
	}
	async maximize() {
		if (this.manager) {
			this.manager.maximize(this);
		} else {
			if (this.has_class('maximized')) {
				this.remove_class('maximized');
				setTimeout(() => {
					this.size = [this.pre_maximized_size[0] - 2, this.pre_maximized_size[1] - 2];
				}, 17)
				this.dragable = true;
				const ltpos = [this.dom.attributes.style.left || 0, this.dom.attributes.style.top || 0].map(x => parseInt(x));
				const dest_pos = [this.pre_maximized_pos[0] - ltpos[0], this.pre_maximized_pos[1] - ltpos[1]];
				await this.glide_to_pos(dest_pos);
			} else {
				const my_bcr = this.bcr();
				const ltpos = [this.dom.attributes.style.left, this.dom.attributes.style.top].map(x => parseInt(x));
				if (this.has_class('minimized')) {
					this.remove_class('minimized');
					this.pre_maximized_pos = this.pre_minimized_pos;
					this.pre_maximized_size = this.pre_minimized_size;
				} else {
					this.pre_maximized_pos = my_bcr[0];
					this.pre_maximized_size = my_bcr[2];
				}
				this.add_class('maximized');
				this.dragable = false;
				const parent_bcr = this.parent.bcr();
				const parent_size = parent_bcr[2];
				setTimeout(() => {
					this.size = [parent_size[0] - 4, parent_size[1] - 4];
				}, 17)
				const [tx, ty] = [this.ta[6], this.ta[7]];
				const dest_pos = [0 - ltpos[0], 0 - ltpos[1]];
				await this.glide_to_pos(dest_pos);
			}
		}
	}
	close() {
		if (this.manager) {
			this.manager.close(this);
		} else {
			this.remove();
		}
	}
	'activate'() {
		if (!this.__active) {
            super.activate();
			const {title_bar, btn_minimize, btn_maximize, btn_close} = this;
			if (btn_close) {
				btn_close.on('click', () => {
					this.close();
				})
				btn_close.on('press', () => {
					this.close();
				})
			}
			if (btn_maximize) {
				btn_maximize.on('click', () => {
					this.maximize();
				})
				btn_maximize.on('press', () => {
					this.maximize();
				})
			}
			if (btn_minimize) {
				btn_minimize.on('click', () => {
					this.minimize();
				})
				btn_minimize.on('press', () => {
					this.minimize();
				})
			}
			title_bar.on('dblclick', () => {
				this.maximize();
			})
			this.on('mousedown', () => {
				this.bring_to_front_z();
			});
			dragable(this, {
                drag_mode: 'translate',
				handle: this.title_bar,
				bounds: this.parent
            });
            this.dragable = true;
			resizable(this, {
				resize_mode: 'br_handle',
				bounds: [[120, 80], undefined],
				extent_bounds: this.parent
			});
			setInterval(() => {
				if (this.has_class('minimized')) {
					const extended_bcr = this.bcr().extend('left', 80);
					const minimized_siblings = this.siblings.filter(x => x.has_class('minimized'));
					const overlaps = extended_bcr.overlaps(minimized_siblings);
					if (overlaps && overlaps.length > 0) {
						const max_overlap_width = Math.max(...overlaps.map(x => x.w))
						if (max_overlap_width <= 78) {
							const parent_bcr = this.parent.bcr();
							const parent_left = parent_bcr[0][0];
							const my_bcr = this.bcr();
							const my_left = my_bcr[0][0];
							const dist_from_parent_left = my_left - parent_left;
							if (dist_from_parent_left > 2) {
								this.ta[6] = this.ta[6] - 1;
							}
						}
					} else {
						const parent_bcr = this.parent.bcr();
						const parent_left = parent_bcr[0][0];
						const my_bcr = this.bcr();
						const my_left = my_bcr[0][0];
						const dist_from_parent_left = my_left - parent_left;
						if (dist_from_parent_left > 2) {
							if (dist_from_parent_left > 8) {
								this.ta[6] = this.ta[6] - 8;
							} else {
								this.ta[6] = this.ta[6] - dist_from_parent_left;
							}
						}
					}
				}
			}, 18);
		}
	}
}
Window.css = `
.relative {
	position: relative;
}
.window.no-transitions {
	transition: none !important; 
}
:root {
	--rhsqsize: 16px;
}
.resize-handle {
	width: var(--rhsqsize);
	height: var(--rhsqsize);
	color: #CCCCCC;
	opacity: 0.45;
	position: absolute;
	line-height: var(--rhsqsize);
	font-size: var(--rhsqsize);
	user-select: none;
	transition: color 0.14s ease-in-out, opacity 0.14s ease-in-out;
}
.resize-handle:hover {
	color: #EFCF00;
	opacity: 0.5;
}
.resize-handle.resizing {
	color: #FFDF00;
	opacity: 1;
}
.bottom-right.resize-handle {
	right: 0;
	bottom: 0;
	cursor: nwse-resize;
	z-index: 10000001;
}
.window {
    position: absolute;
    border: 1px solid #CCCCCC;
	background-color: #F4F4F4;
	width: 360px;
	height: 360px;
	border-radius: 5px;
	transition: width 0.14s linear, height 0.14s linear; 
	overflow: hidden;
	-webkit-user-select: none;
	user-select: none;
}
.window .relative {
	height: inherit;
	overflow: hidden;
}
.window.minimized {
	height: 31px;
}
.window.minimized .bottom-right.resize-handle {
	display: none;
}
.window.maximized .bottom-right.resize-handle {
	display: none;
}
.window .title.bar {
    height: 31px;
	background-color: #0D4F8B;
	background-image: linear-gradient(to right, #0D4F8B , #3fb0d9);
    color: #FFFFFF;
    font-size: 12px;
    line-height: 32px;
    text-indent: 4px;
    -webkit-box-shadow: inset 0px -2px 2px -2px rgba(0, 0, 0, 0.75);
    -moz-box-shadow: inset 0px -2px 2px -2px rgba(0, 0, 0, 0.75);
    box-shadow: inset 0px -2px 2px -2px rgba(0, 0, 0, 0.75);
	border-radius: 4px;
	-webkit-user-select: none;
	user-select: none;
	overflow: hidden;
	cursor: default;
}
.window .title.bar h2 {
	font-weight: 400;
	margin-left: 42px;
	float: left;
}
.window .title.bar > span {
    vertical-align: middle;
    line-height: 31px;
}
.window .title.bar .button > span {
	transform: scale(2);
    display: inline-block;
	line-height: 13px;
    height: 14px;
}
.window .title.bar .right {
    margin-right: 2px;
    margin-top: 2px;
    position: absolute;
    right: 0;
    top: 0;
	height: 29px;
}
.window .title.bar .button {
    width: 26px;
	height: 26px;
	line-height: 24px;
	font-size: 14px;
}
.window .title.bar .button + .button {
    margin-left: 3px;
}
.window .relative .inner {
	width: 100%;
	height: calc(100% - 31px);
}
`
module.exports = Window;

},{"../../../../control_mixins/mx":56,"./../../../../html-core/html-core":149,"./../../../organised/1-standard/5-ui/horizontal-menu":112}],130:[function(require,module,exports){
// And maybe should have the context too?
//   Not unless necessary.

const {field, Data_Object, Data_Value, Evented_Class} = require('lang-tools');

const Data = require('./Data');

// Probably worth getting deep into making code that uses both view model and data model to run the GUI.
//     View model can include multiple ways to display something.


// The model needs to share context....

// Or extend Data_Object here even???

// The model could possibly be a single value (Data_Value).


// data.model ????
// data.value ????
// data.model.value ????



// Could maybe make non-server examples / tests that just render it to HTML and list info on what events are attached to the
//   dom and control.

// Having further ways to develop and test controls not on the server could help a little.
//   Could help a lot with unit / regression tests.
//   Eg what HTML do they render?

// Is the data coordinated with the data model(s)?

// Make it extend Data

class Control_Data extends Data {
    constructor(spec = {}) {
        super(spec);
        //if (spec.context) this.context = spec.context;

        // set up the .model field....
        //  would help when responding to it being changed.

        //this.model = {};

        //field(this, 'model');

        // .model is a Data_Value???
        // .model.inner_value ????

        // .model.value may be OK???
        // as in value.value would be OK in that situation.

        //console.log('spec.model', spec.model);
        /*
        const model = (() => {
            if (spec.model) {
                return spec.model;
            } else {
                //return new Control_View_Low_Level_Data({context});
            }
        })();
        Object.defineProperty(this, 'model', {get: () => model});
        */

        

        


    }

    

    // but will have a model on change system of some sort(s).
    
    // Reassigning events (change event handlers).
    //   So anything listening for change events on the old model instead listens to change events on the new model.

    // so the Control_Data would raise a 'change' event with name 'model'.
    //   maybe worth being clearer about what kinds of changes there are, ie if something's value changes, or of it gets
    //   replaced with another item.







}

// Maybe this will be 'DMVM' rather than 'MVVM'.
// Data-Model-View-Model.
// Data_Model_View_Model.
// Data_Model_View_Model_View_Data_Model even ???
//   Could generally always support those three model layers (and use them?) but not need to be explicit about them in the high level API.

// The View_Data_Model will be specifically to mirror the Data_Model, while the View_Model would include things like zoom level of the
//   viewer or editor.

// Could look into a nice mid-level API to facilitate model mirroring / syncing.
//   Data_Object syncing.
//     And could have it support async patterns (though may be better to retrofit that a little later)
//   That could help make other code more explicit and compact.





module.exports = Control_Data;
},{"./Data":142,"lang-tools":186}],131:[function(require,module,exports){



const {field, Data_Object, Data_Value, Evented_Class} = require('lang-tools');

const Control_Validation_Data = require('./Control_Validation_Data');
const Validation_State = require('./Validation_State');

// Let's just have it a Validation class????

const Control_Validation_Target = require('./Control_Validation_Target');
const Control_Validation_Validator = require('./Control_Validation_Validator');

// Control_Validation_Validator

// Should not automatically be there for every control...??
//   Or create it when it's accessed the first time???

// Or a mixin that sets up the Control_Validation on the control.


class Control_Validation extends Evented_Class {
    // Or set up validation on data model states?

    // Control validation will be about if the view.data.model.value is valid according to the data.model.valdate_value

    constructor(spec = {}) {
        super(spec);

        // and will have .data too.
        //   that would itself have .data

        // The validation data model is important.
        
        if (spec.data) {
            if (spec.data.model) {
                this.data.model = spec.data.model;
            }
        }

        // validation target too....
        //   a field of some sort.
        //   will need to be able to listen to target change.








        // .validation.state.valid for the moment.
        // .validation.state.valid === true???

        // And need to change that automatically according to what validation needs to be done.

        // Make it so that validation status indicators can be very clear in purpose and accurate in what they show.
        //   Easy to define and use.

        // Should continue working on particularly mid level code that makes the high-level code more succinct.
        //   There is quite a lot of existing low level code that can improve the mid level to make the high level
        //   very capable.


        // ctrl.validation.target = ...
        // ctrl.validation.validator = ...
        // ctrl.validation = {target, validator}

        // ctrl.validation.state.on('change', e => {...})
        //   Does seem like it would be a convenient API for watching state changes.

        // .onchange('valid')

        // ctrl.view.data.validation seems like maybe the best / clearest syntax.
        // ctrl.validation is not as clear / explicit.
        //   it's really about validating the data in the view.
        //   maybe that would be assumed.
        // ctrl.data.validation too ???
        //   that would be about validating the underlying (currently accepted) data rather than the data represented in the view.


        // Maybe best to focus on Control_View_Data_Validation for the moment.
        //   Either would not have a .target, or better its .target is the .view.data.model as read-only.

        





        //





    }

    // and validator too....



    get validator() {
        //console.log('get model');
        //console.log('this._model', this._model);

        if (this._validator === undefined) {

            //if (this.model_constructor) {
            //    this._model = new this.model_constructor({context: this.context});
            //} else {
            //    this._validator = new Data_Value({context: this.context});
            //}

            this._validator = new Control_Validation_Validator({context: this.context});

            
        }
        return this._validator;
    }
    set validator(value) {
        // 

        if (value !== this._validator) {
            const old = this._validator;
            this._validator = value;

            this.raise('change', {
                name: 'validator',
                old,
                value
            })
        }

    }



    get target() {
        //console.log('get model');
        //console.log('this._model', this._model);

        if (this._target === undefined) {

            //if (this.model_constructor) {
            //    this._model = new this.model_constructor({context: this.context});
            //} else {
            //    this._target = new Data_Value({context: this.context});
            //}

            this._target = new Control_Validation_Target({context: this.context});

            
        }
        return this._target;
    }
    set target(value) {
        // 

        if (value !== this._target) {
            const old = this._target;
            this._target = value;

            this.raise('change', {
                name: 'target',
                old,
                value
            })
        }

    }

    get state() {
        if (this._state === undefined) {
            this._state = new Validation_State();
        }
        return this._state;
    }

    // Need both .data and .view.data
    //   It may validate between them...?


    // validation.validator = ....?
    // validation.validatior.data.model = ...???
    //   Does seem logical!!!

    // Control_Validation_Target

    // validation.target.data.model = ....?

    // Control_Validation_Validator even!!!!

    // A very explicit API would help, will be a bit fiddly to code all the parts.


    // Validator and Target would be explicit names, and will be clear when a view data model is being validated according to the (backing) data model






    get data() {
        if (this._data === undefined) {
            this._data = new Control_Validation_Data({context: this.context});
        }
        return this._data;
    }

    // And a view property too.

    // Seems somewhat easy to set up like this....

    // Though it's Control_Validation_View

    // Validation View???

    // ctrl.validation.view.data.model = ctrl.view.data.model



    // Validate view agasint non-view.





    set data(value) {
        if (value !== this._data) {
            const old = this._data;
            this._data = value;
            this.raise('change', {
                name: 'data',
                old,
                value
            })
        }

    }
}

module.exports = Control_Validation;
},{"./Control_Validation_Data":132,"./Control_Validation_Target":133,"./Control_Validation_Validator":134,"./Validation_State":144,"lang-tools":186}],132:[function(require,module,exports){
// And maybe should have the context too?
//   Not unless necessary.

const {field, Data_Object, Data_Value, Evented_Class} = require('lang-tools');

const Data = require('./Data');

class Control_Validation_Data extends Data {
    constructor(spec = {}) {
        super(spec);

    }


}



module.exports = Control_Validation_Data;
},{"./Data":142,"lang-tools":186}],133:[function(require,module,exports){

const {Evented_Class} = require('lang-tools');


class Control_Validation_Target {

    // will target 'data'.
    //  and that will have a .model of course.

    // this.data.model.on change etc.
    


}

module.exports = Control_Validation_Target;
},{"lang-tools":186}],134:[function(require,module,exports){

const {Evented_Class} = require('lang-tools');

// view.enhance???

class Control_Validation_Validator extends Evented_Class {

    constructor(spec) {
        super();
    }
    // needs a 'data' property / field.

    // getter and setter in the class may be simplest for the moment....

    
    

}

module.exports = Control_Validation_Validator;
},{"lang-tools":186}],135:[function(require,module,exports){


const {field, Data_Object, Evented_Class} = require('lang-tools');

// And the View Data as well...

const Data = require('./Data');
const Control_View_UI = require('./Control_View_UI');
const Control_View_Data = require('./Control_View_Data');
const Control_View_Low_Level = require('./Control_View_Low_Level');


class Control_View extends Evented_Class {
    // .data.model
    // .ui.data.model

    constructor(spec = {}) {
        super();
        if (spec.context) this.context = spec.context;
        const {context} = this;

        // view.data.model

        // Allow specifying different inner constructors...???
        //   Dependency injection basically.


        // .data being a Data_Object?
        //   Could make sense when responding to models being changed or updated.

        //const o_data = {context};
        const o_data = {};
        // Maybe create a specific 'view data model'.
        //   Though not sure how different it should be to other sorts.
        if (spec.data) {
            if (spec.data.model) {
                //this.data.model = spec.data.model;
                o_data.model = spec.data.model;
            } else {
                
            }
        }

        this.data = new Control_View_Data(o_data);
        //field(this.data, 'model');

        // Data: is the control selected

        // No, make it a Control_UI object. Or Control_View_UI.
        /*

        this.ui = {
            data: new Data_Object({context})
        }
        */

        const o_ui = {context};
        if (spec.ui && spec.ui.data) {
            o_ui.data = spec.ui.data;
        }

        this.ui = new Control_View_UI(o_ui);

        // UI - if the control is selected, how is that displayed?

        


        // Not to sure we need the low level control view object.
        //   May be worth making a directory where the systems can be grouped together?
        //   Though really want to set a standard for all controls.
        //   Does seem better to add another level to the view when needed.
        //     As an option rather than to the Control.




        /*

        const ll = new Control_View_Low_Level();
        Object.defineProperty(this, 'll', {get: () => ll});

        */


        // and .ll of course...




        // Set up the view data model.



        


        // And the UI will have a compositional model.
        //   Could even have multiple compositional models.
        //   But focus on supporting one to start with...?

        // but set .compositional.model = ... should be fine for now....

        //    .active.compositional.model and .compositional.models ????

        // .active.compositional.model does make sense of course.
        //   Support a friendly API with possibly strange objects and classes.

        // Control_View_UI_Active perhaps....?













        // .ui.compositional.data.model....

        // Does seem sensible to store various properties deeper within structures.
        




        //field(this.ui.data, 'model');
        //  Because it now already has that 'model' field

        if (spec.data) {


            
        }
        if (!this.data.model) {

            // Or create a Data_Value for the moment???

            //this.data.model = new Data_Object({context});
        }


        // Improve this somewhat....

        /*

        if (spec.ui && spec.ui.data) {

            if (spec.ui.data.model) {


                this.ui.data.model = spec.ui.data.model;
            } else {
                this.ui.data.model = new Data_Object({context});
            }
        }
        */

        // 

    }
}

module.exports = Control_View;
},{"./Control_View_Data":136,"./Control_View_Low_Level":137,"./Control_View_UI":139,"./Data":142,"lang-tools":186}],136:[function(require,module,exports){


const Control_Data = require('./Control_Data');

class Control_View_Data extends Control_Data {
    constructor(spec) {
        super(spec);



        
        
    }

}

module.exports = Control_View_Data;
},{"./Control_Data":130}],137:[function(require,module,exports){


const {field, Data_Object, Data_Value, Evented_Class} = require('lang-tools');

const Control_View_Low_Level_Data = require('./Control_View_Low_Level_Data');

class Control_View_Low_Level extends Data_Object {
    constructor(spec = {}) {
        super(spec)

        const {context} = this;

        // And it needs its own .data

        // then that needs its own .model

        // just set .data???
        //  from spec???

        /*

        if (spec.data) {
            //this.data = spec.data;
        } else {
            this.data = new Control_View_UI_Low_Level_Data({context});
        }
        */

        const data = (() => {
            if (spec.data) {
                return spec.data;
            } else {
                return new Control_View_Low_Level_Data({context});
            }
        })();
        Object.defineProperty(this, 'data', {get: () => data});



    }
}

module.exports = Control_View_Low_Level;
},{"./Control_View_Low_Level_Data":138,"lang-tools":186}],138:[function(require,module,exports){


const Control_Data = require('./Control_Data');

class Control_View_Low_Level_Data extends Control_Data {
    constructor(spec) {
        super(spec);

        // And would have .model as well....

        // To start with, need to get this set up in the right control(s).
        //   Text_Input to start with.

        




    }

}

module.exports = Control_View_Low_Level_Data;
},{"./Control_Data":130}],139:[function(require,module,exports){
const {field, Data_Object, Data_Value, Evented_Class} = require('lang-tools');


const Control_View_UI_Low_Level = require('./Control_View_UI_Low_Level');

// Have a Data class?
//  Data_Model_Data even???
//  Just call it Data for the moment.

// jsgui3-data for now.

// And the Data class has a .model

// Control_View_UI_Compositional

// Compositional system is a bit complex....




class Control_View_UI_Compositional extends Data_Object {
    constructor(...a) {
        super(...a);

        // Models....
        //   Data_Model_List???
        //   Is getting on to Collection.

        // But just an array for the moment.

        
        this.models = [];


        field(this, 'model', new Data_Value());

        // A Data_Value that is set up to store an array?
        //  Later... just use js array here.


    }
}

class Control_View_UI_Active_Compositional extends Control_View_UI_Compositional {
    constructor(...a) {
        super(...a);

        // And this has a .model, a Data_Value (possibly???)
        //  That Data_Value would need to store control constructors.
        //  That should be OK, can get that better supported if needed.

        // .model of course.

        // a .model property.


        // maybe just a field for model so it can change and updates known about???

        // should respond to changes....
        //   at least raise the event.

        //field(this, 'model', new Data_Value());

        // Will need to listen to changes to recompose, as well as being able to use this compositional model to compose for the first time.









    }
}



class Control_View_UI_Active extends Data_Object {
    constructor(...a) {
        super(...a);

        const compositional = new Control_View_UI_Active_Compositional();
        Object.defineProperty(this, 'compositional', {get: () => compositional});


    }
}




class Control_View_UI extends Data_Object {
    constructor(...a) {
        super(...a);

        // context????


        // .data.model

        const active = new Control_View_UI_Active();
        // and a read-only property to access it....
        Object.defineProperty(this, 'active', {get: () => active});

        // .compositional

        const compositional = new Control_View_UI_Compositional();
        Object.defineProperty(this, 'compositional', {get: () => compositional});

        // compositional.model property is needed.
        //   And need to be able to set and make use of compositional models.

        //const ll = new Control_View_UI_Low_Level();
        //Object.defineProperty(this, 'll', {get: () => ll});




        // ui.compositional.active.model
        // ui.active.compositional.model

        // view.presentational???


        // view.ui.presentational.data.model perhaps???


        // view.ui.ll.data.model makes sense.








        // Does make for very clear syntax, and clarity that there can be inactive compositional models too.



        // ui.compositional.models too


    }

}

module.exports = Control_View_UI;
},{"./Control_View_UI_Low_Level":140,"lang-tools":186}],140:[function(require,module,exports){


const {field, Data_Object, Data_Value, Evented_Class} = require('lang-tools');

const Control_View_UI_Low_Level_Data = require('./Control_View_UI_Low_Level_Data');

class Control_View_UI_Low_Level extends Data_Object {
    constructor(spec = {}) {
        super(spec)

        const {context} = this;

        // And it needs its own .data

        // then that needs its own .model

        // just set .data???
        //  from spec???

        if (spec.data) {
            this.data = spec.data;
        } else {
            this.data = new Control_View_UI_Low_Level_Data({context});
        }
    }
}

module.exports = Control_View_UI_Low_Level;
},{"./Control_View_UI_Low_Level_Data":141,"lang-tools":186}],141:[function(require,module,exports){


const Control_Data = require('./Control_Data');

class Control_View_UI_Low_Level_Data extends Control_Data {
    constructor(spec) {
        super(spec);

        // And would have .model as well....

        // To start with, need to get this set up in the right control(s).
        //   Text_Input to start with.

        




    }

}

module.exports = Control_View_UI_Low_Level_Data;
},{"./Control_Data":130}],142:[function(require,module,exports){
const {field, Data_Object, Data_Value, Data_Model, Evented_Class} = require('lang-tools');
class Data extends Evented_Class {
    constructor(...a) {
        super(...a);
        const [spec] = a;
        if (spec.context) this.context = spec.context;
        if (spec.model) {
            if (spec.model instanceof Data_Model) {
                this._model = spec.model;
            } else {
                console.trace();
                throw 'stop';
            }
        }
        if (spec.model_constructor) {
            this.model_constructor = spec.model_constructor;
        }
    }
    get model() {
        if (this._model === undefined) {
            if (this.model_constructor) {
                this._model = new this.model_constructor({context: this.context});
            } else {
                this._model = new Data_Value({context: this.context});
            }
        }
        return this._model;
    }
    set model(value) {
        if (value !== this._model) {
            const old = this._model;
            this._model = value;
            this.raise('change', {
                name: 'model',
                old,
                value
            })
        }
    }
}
module.exports = Data;
},{"lang-tools":186}],143:[function(require,module,exports){

const Ctrl_Enh = require('./control-enh');

const {Data_Object} = require('lang-tools');

// Quite a lot of the standard controls should become this.
//   It should provide mechanisms for the app to efficiently process and pass on updates at the various different stages.
//   Want to work both with well defined app data models, as well has having them created simply / automatically to 
//     facilitate easy (to code) sharing of data between different parts of the app, and easy to code data persistance and update
//     operations.

// A server side data model could replay changes and then update the DB as necessary.
//   Could undo changes too (if history is stored).

// These two models would help a lot when it comes to the app state history.
//   eg don't undo maximising and minimising windows within the app, but also have a good way to save the state (automatically essentially).


// Can have fairly complex code on lower and especially mid levels, but the high level code should be simple and cleary express what's being done
//   though also allowing for shorthands that would not be as readable but would be more compact.
// Could maybe search and replace on building to use the shorthand forms instead, maybe even replace the functions with the
//   long form names (though that would likely be a day or two's work at least)

const Control_Data = require('./Control_Data');
const Control_View = require('./Control_View');

// Possibly not so much to do here right now???

// Maybe will use this to make some other controls more concise.

// Maybe make both Data_Model_View_Model_Control_Single_Value
//   and Data_Model_View_Model_Control_Multi_Value_Data_Object
//         so it would have properties available with string keys.
//   maybe also make some kind(s) of Collection or Array holding data models.



// Not totally sure what interface / conventions this should be using and expressing for the moment.
//   Would like to make it really easy to base controls that have both a data model and view model on this.

// May also be important sending or properly recreating the data / view model on the client-side.
//   Having them made in the constructor from lang-tools classes could be effective.
//     Then would be recreated automatically and identically on the client-side.

// Likely do want a Data_Value subclass that represents the application's Data_Model.
//   And this Data_Value subclass for the moment could just set up the functional data type as a validator.

// new Data_Value(value_to_wrap, data_type);






// Both want to get this Data base type control working, as well as get the pattern well finessed to implement
//   directly into a control.
// Then will be able to use either.
//   May then work on improved abstractions.


// Will make some kind of multi-model mixin.

// Data, View Data, Composition, Data Representation

// Maybe there are 5 different models there.



// Likely will deprecate this, and use the more complicated mixin, which currently is called in the ctrl-enh constructor.
//   Will try making it available and useful at a low level, but may later restrict when it gets used / set up for perf reasons.
//   However, the more complex system of multiple models may help controls to be specified and used much more easily.
//     Lower and mid levels will handle complexity, high level code can be really clear and concise about the data and its
//       representation using controls in the GUI.



// Likely want to retire this soon...?
// Possibly redo the Text_Field control or whichever controls use this for the moment.
//   Though making use of the compositional model makes a lot more sense for the moment.





class Data_Model_View_Model_Control extends Ctrl_Enh {
    constructor(...a) {
        super(...a);

        const spec = a[0] || {};
        // Possibly set up both models here, but should look out for data and view models in the spec.

        // Also, look out for it in pre_activate I think. Would be good to reconnect those models here.

        // Would also need to add the appropriate .dom.attributes['data-jsgui-view-model']
        //                                        .dom.attributes['data-jsgui-data-model']

        // 
        //console.log('');
        //console.log('construct Data_Model_View_Model_Control');


        const {context} = this;

        // spec.view
        // spec.data

        // and would both need 'model' properties???
        //   does seem best for the moment to make it really explicit.

        // But then recognising and passing on changes...?
        //   Should work when not activated if possible.

        // Though seems like it would need a bit more code in the higher level classes.
        // Possibly more in intialisation, telling it what property names to use.
        //   Though could default to 'value' to allow easy sharing between 2 or more objects where it's just one
        //     value that gets shared.


        // Probably need to set up fields / change events on the model objects.

        // Could try it with 'value' hardcoded here???

        //  Or take the 'fields' in the spec???

        // With the Text_Field (and Text_Input) will need to have it change the Data Model appropriately.
        //   Maybe could have a decent default for it, but explicitly set it as well with a short string eg 'onexit' or 'exit' or 'leave'
        // But would more likely want an 'cancel | confirm' non-modal popup, and control the positioning of that popup.
        //   Likely to want it just below in this example.

        // This can likely be very effective....


        if (spec.data) {
            this.data = new Control_Data();
            if (spec.data.model) {
                this.data.model = spec.data.model;

                this.data.model.on('change', e => {
                    console.log('Data_Model_View_Model_Control this.data.model change e:', e);

                    // Set the view model here???


                })

                this.dom.attributes['data-jsgui-data-model'] = this.data.model._id();
            }
        }
        if (spec.view) {
            this.view = new Control_View();

            // 

            // data-jsgui-view-data-model
            //   does seem like it would be worth being able to get that....
            //     (even back from the context)
            //   but maybe the view data model should (only) be internal to this (for the moment?)

            // Maybe do need to / best to register these controls in the context.
            //  


            if (!spec.view.data) {
                // create new view data model.

                const view_data_model = new Data_Object({context});
                this.view.data = {
                    model: view_data_model
                }
            } else {
                this.view.data = spec.view.data;

                if (!this.view.data.model) {
                    this.view.data.model = new Data_Object({context});
                }

            }



            if (this.view.data.model) {

                this.view.data.model.on('change', e => {
                    console.log('Data_Model_View_Model_Control this.view.data.model change e:', e);
                })

                this.dom.attributes['data-jsgui-view-data-model'] = this.view.data.model._id();
            }
            // Could create other internal view.data???





            // view.data.model????
            if (spec.view.model) {
                this.view.model = spec.view.model;
                this.view.model.on('change', e => {
                    console.log('Data_Model_View_Model_Control this.view.model change e:', e);
                });
                this.dom.attributes['data-jsgui-view-model'] = this.view.model._id();
            }

            // Otherwise create new internal view model?

            

        }

        //console.log('Data_Model_View_Model_Control !!this.dom.el', !!this.dom.el);

        if (this.dom.el) {

            const context_keys = Array.from(Object.keys(this.context));
            //console.log('context_keys', context_keys);

            const context_map_controls_keys = Array.from(Object.keys(this.context.map_controls));
            //console.log('context_map_controls_keys', context_map_controls_keys);

            if (this.dom.el.hasAttribute('data-jsgui-data-model')) {
                const data_model_jsgui_id = this.dom.el.getAttribute('data-jsgui-data-model');

                //console.log('Data_Model_View_Model_Control data_model_jsgui_id:', data_model_jsgui_id);

                const data_model = this.context.map_controls[data_model_jsgui_id];

                //console.log('Data_Model_View_Model_Control !!data_model', !!data_model);

                if (data_model) {
                    this.data = this.data || new Control_Data({context});

                    //console.log('Data_Model_View_Model_Control pre assign this.data.model');
                    //console.log('data_model', data_model);
                    this.data.model = data_model;
                    //console.log('post assign this.data.model\n');
                }

                


                // Then set up the syncing here????

                //   If the data model changes, set the .value field....?


                data_model.on('change', e => {
                    //console.log('Data_Model_View_Model_Control data_model change', e);
                })
            }


            // And if it does not have that attribute, create its own internal view model.




            if (this.dom.el.hasAttribute('data-jsgui-view-model')) {
                this.view = this.view || new Control_View({context});
                const view_model_jsgui_id = this.dom.el.getAttribute('data-jsgui-view-model');

                //console.log('Data_Model_View_Model_Control view_model_jsgui_id:', view_model_jsgui_id);

                // then get it from the context.

                const view_model = this.context.map_controls[view_model_jsgui_id];

                if (!!view_model) {
                    this.view.model = view_model;

                    view_model.on('change', e => {
                        //console.log('Data_Model_View_Model_Control view_model change', e);
                    });
                } else {
                    //console.log('Data_Model_View_Model_Control missing view_model (not found at this.context.map_controls[view_model_jsgui_id])');
                }

                
                

                // Load the view model at the very beginning???


                // But in the activated part it would need to change the model???
                //   Not necessarily.
                //   It could change that in respond to the field changing.
                //     Then would change the view model in response to the that data model change.
                //     Then would update the DOM in response to the view model change (would have to be the responsibility of the
                //       specific control I think???)

                


            } else {
                //console.log('Data_Model_View_Model_Control with el lacks view model, need to make one');
                this.view = this.view || {};
                this.view.model = new Data_Object({
                    context
                });



            }
        }
    }
    pre_activate() {
        super.pre_activate();


        // re-assign the .data.model and .view.model if they are available....

        // These models would need to exist within the Page_Context.
        //   That probably should be the case, working isomorphically.
        //     Model creation would be within the Page_Context.





        console.log('Data_Model_View_Model_Control pre_activate complete');

        // should be able to access own data_model???


    }
}

module.exports = Data_Model_View_Model_Control;
},{"./Control_Data":130,"./Control_View":135,"./control-enh":147,"lang-tools":186}],144:[function(require,module,exports){


const {field, Data_Object, Data_Value, Evented_Class, tof} = require('lang-tools');


class Validation_State extends Evented_Class {


    constructor(spec = {}) {
        super(spec);

        // Which properties????

        

        // .value property????
        // .valid property?

        // .valid for the moment.

    }

    // a set() function????
    //   because a few things at once get set.

    set(value) {
        if (value === true) {
            this._valid = true;
        } else if (value === false) {
            this._valid = false;
        } else {
            console.trace();
            throw 'NYI';
        }
    }

    get valid() {
        return this._valid;
    }




}

module.exports = Validation_State;
},{"lang-tools":186}],145:[function(require,module,exports){
const pal_crayola = [{
    "hex": "#EFDECD",
    "name": "Almond",
    "rgb": "(239, 222, 205)"
},
{
    "hex": "#CD9575",
    "name": "Antique Brass",
    "rgb": "(205, 149, 117)"
},
{
    "hex": "#FDD9B5",
    "name": "Apricot",
    "rgb": "(253, 217, 181)"
},
{
    "hex": "#78DBE2",
    "name": "Aquamarine",
    "rgb": "(120, 219, 226)"
},
{
    "hex": "#87A96B",
    "name": "Asparagus",
    "rgb": "(135, 169, 107)"
},
{
    "hex": "#FFA474",
    "name": "Atomic Tangerine",
    "rgb": "(255, 164, 116)"
},
{
    "hex": "#FAE7B5",
    "name": "Banana Mania",
    "rgb": "(250, 231, 181)"
},
{
    "hex": "#9F8170",
    "name": "Beaver",
    "rgb": "(159, 129, 112)"
},
{
    "hex": "#FD7C6E",
    "name": "Bittersweet",
    "rgb": "(253, 124, 110)"
},
{
    "hex": "#000000",
    "name": "Black",
    "rgb": "(0,0,0)"
},
{
    "hex": "#ACE5EE",
    "name": "Blizzard Blue",
    "rgb": "(172, 229, 238)"
},
{
    "hex": "#1F75FE",
    "name": "Blue",
    "rgb": "(31, 117, 254)"
},
{
    "hex": "#A2A2D0",
    "name": "Blue Bell",
    "rgb": "(162, 162, 208)"
},
{
    "hex": "#6699CC",
    "name": "Blue Gray",
    "rgb": "(102, 153, 204)"
},
{
    "hex": "#0D98BA",
    "name": "Blue Green",
    "rgb": "(13, 152, 186)"
},
{
    "hex": "#7366BD",
    "name": "Blue Violet",
    "rgb": "(115, 102, 189)"
},
{
    "hex": "#DE5D83",
    "name": "Blush",
    "rgb": "(222, 93, 131)"
},
{
    "hex": "#CB4154",
    "name": "Brick Red",
    "rgb": "(203, 65, 84)"
},
{
    "hex": "#B4674D",
    "name": "Brown",
    "rgb": "(180, 103, 77)"
},
{
    "hex": "#FF7F49",
    "name": "Burnt Orange",
    "rgb": "(255, 127, 73)"
},
{
    "hex": "#EA7E5D",
    "name": "Burnt Sienna",
    "rgb": "(234, 126, 93)"
},
{
    "hex": "#B0B7C6",
    "name": "Cadet Blue",
    "rgb": "(176, 183, 198)"
},
{
    "hex": "#FFFF99",
    "name": "Canary",
    "rgb": "(255, 255, 153)"
},
{
    "hex": "#1CD3A2",
    "name": "Caribbean Green",
    "rgb": "(28, 211, 162)"
},
{
    "hex": "#FFAACC",
    "name": "Carnation Pink",
    "rgb": "(255, 170, 204)"
},
{
    "hex": "#DD4492",
    "name": "Cerise",
    "rgb": "(221, 68, 146)"
},
{
    "hex": "#1DACD6",
    "name": "Cerulean",
    "rgb": "(29, 172, 214)"
},
{
    "hex": "#BC5D58",
    "name": "Chestnut",
    "rgb": "(188, 93, 88)"
},
{
    "hex": "#DD9475",
    "name": "Copper",
    "rgb": "(221, 148, 117)"
},
{
    "hex": "#9ACEEB",
    "name": "Cornflower",
    "rgb": "(154, 206, 235)"
},
{
    "hex": "#FFBCD9",
    "name": "Cotton Candy",
    "rgb": "(255, 188, 217)"
},
{
    "hex": "#FDDB6D",
    "name": "Dandelion",
    "rgb": "(253, 219, 109)"
},
{
    "hex": "#2B6CC4",
    "name": "Denim",
    "rgb": "(43, 108, 196)"
},
{
    "hex": "#EFCDB8",
    "name": "Desert Sand",
    "rgb": "(239, 205, 184)"
},
{
    "hex": "#6E5160",
    "name": "Eggplant",
    "rgb": "(110, 81, 96)"
},
{
    "hex": "#CEFF1D",
    "name": "Electric Lime",
    "rgb": "(206, 255, 29)"
},
{
    "hex": "#71BC78",
    "name": "Fern",
    "rgb": "(113, 188, 120)"
},
{
    "hex": "#6DAE81",
    "name": "Forest Green",
    "rgb": "(109, 174, 129)"
},
{
    "hex": "#C364C5",
    "name": "Fuchsia",
    "rgb": "(195, 100, 197)"
},
{
    "hex": "#CC6666",
    "name": "Fuzzy Wuzzy",
    "rgb": "(204, 102, 102)"
},
{
    "hex": "#E7C697",
    "name": "Gold",
    "rgb": "(231, 198, 151)"
},
{
    "hex": "#FCD975",
    "name": "Goldenrod",
    "rgb": "(252, 217, 117)"
},
{
    "hex": "#A8E4A0",
    "name": "Granny Smith Apple",
    "rgb": "(168, 228, 160)"
},
{
    "hex": "#95918C",
    "name": "Gray",
    "rgb": "(149, 145, 140)"
},
{
    "hex": "#1CAC78",
    "name": "Green",
    "rgb": "(28, 172, 120)"
},
{
    "hex": "#1164B4",
    "name": "Green Blue",
    "rgb": "(17, 100, 180)"
},
{
    "hex": "#F0E891",
    "name": "Green Yellow",
    "rgb": "(240, 232, 145)"
},
{
    "hex": "#FF1DCE",
    "name": "Hot Magenta",
    "rgb": "(255, 29, 206)"
},
{
    "hex": "#B2EC5D",
    "name": "Inchworm",
    "rgb": "(178, 236, 93)"
},
{
    "hex": "#5D76CB",
    "name": "Indigo",
    "rgb": "(93, 118, 203)"
},
{
    "hex": "#CA3767",
    "name": "Jazzberry Jam",
    "rgb": "(202, 55, 103)"
},
{
    "hex": "#3BB08F",
    "name": "Jungle Green",
    "rgb": "(59, 176, 143)"
},
{
    "hex": "#FEFE22",
    "name": "Laser Lemon",
    "rgb": "(254, 254, 34)"
},
{
    "hex": "#FCB4D5",
    "name": "Lavender",
    "rgb": "(252, 180, 213)"
},
{
    "hex": "#FFF44F",
    "name": "Lemon Yellow",
    "rgb": "(255, 244, 79)"
},
{
    "hex": "#FFBD88",
    "name": "Macaroni and Cheese",
    "rgb": "(255, 189, 136)"
},
{
    "hex": "#F664AF",
    "name": "Magenta",
    "rgb": "(246, 100, 175)"
},
{
    "hex": "#AAF0D1",
    "name": "Magic Mint",
    "rgb": "(170, 240, 209)"
},
{
    "hex": "#CD4A4C",
    "name": "Mahogany",
    "rgb": "(205, 74, 76)"
},
{
    "hex": "#EDD19C",
    "name": "Maize",
    "rgb": "(237, 209, 156)"
},
{
    "hex": "#979AAA",
    "name": "Manatee",
    "rgb": "(151, 154, 170)"
},
{
    "hex": "#FF8243",
    "name": "Mango Tango",
    "rgb": "(255, 130, 67)"
},
{
    "hex": "#C8385A",
    "name": "Maroon",
    "rgb": "(200, 56, 90)"
},
{
    "hex": "#EF98AA",
    "name": "Mauvelous",
    "rgb": "(239, 152, 170)"
},
{
    "hex": "#FDBCB4",
    "name": "Melon",
    "rgb": "(253, 188, 180)"
},
{
    "hex": "#1A4876",
    "name": "Midnight Blue",
    "rgb": "(26, 72, 118)"
},
{
    "hex": "#30BA8F",
    "name": "Mountain Meadow",
    "rgb": "(48, 186, 143)"
},
{
    "hex": "#C54B8C",
    "name": "Mulberry",
    "rgb": "(197, 75, 140)"
},
{
    "hex": "#1974D2",
    "name": "Navy Blue",
    "rgb": "(25, 116, 210)"
},
{
    "hex": "#FFA343",
    "name": "Neon Carrot",
    "rgb": "(255, 163, 67)"
},
{
    "hex": "#BAB86C",
    "name": "Olive Green",
    "rgb": "(186, 184, 108)"
},
{
    "hex": "#FF7538",
    "name": "Orange",
    "rgb": "(255, 117, 56)"
},
{
    "hex": "#FF2B2B",
    "name": "Orange Red",
    "rgb": "(255, 43, 43)"
},
{
    "hex": "#F8D568",
    "name": "Orange Yellow",
    "rgb": "(248, 213, 104)"
},
{
    "hex": "#E6A8D7",
    "name": "Orchid",
    "rgb": "(230, 168, 215)"
},
{
    "hex": "#414A4C",
    "name": "Outer Space",
    "rgb": "(65, 74, 76)"
},
{
    "hex": "#FF6E4A",
    "name": "Outrageous Orange",
    "rgb": "(255, 110, 74)"
},
{
    "hex": "#1CA9C9",
    "name": "Pacific Blue",
    "rgb": "(28, 169, 201)"
},
{
    "hex": "#FFCFAB",
    "name": "Peach",
    "rgb": "(255, 207, 171)"
},
{
    "hex": "#C5D0E6",
    "name": "Periwinkle",
    "rgb": "(197, 208, 230)"
},
{
    "hex": "#FDDDE6",
    "name": "Piggy Pink",
    "rgb": "(253, 221, 230)"
},
{
    "hex": "#158078",
    "name": "Pine Green",
    "rgb": "(21, 128, 120)"
},
{
    "hex": "#FC74FD",
    "name": "Pink Flamingo",
    "rgb": "(252, 116, 253)"
},
{
    "hex": "#F78FA7",
    "name": "Pink Sherbet",
    "rgb": "(247, 143, 167)"
},
{
    "hex": "#8E4585",
    "name": "Plum",
    "rgb": "(142, 69, 133)"
},
{
    "hex": "#7442C8",
    "name": "Purple Heart",
    "rgb": "(116, 66, 200)"
},
{
    "hex": "#9D81BA",
    "name": "Purple Mountain's Majesty",
    "rgb": "(157, 129, 186)"
},
{
    "hex": "#FE4EDA",
    "name": "Purple Pizzazz",
    "rgb": "(254, 78, 218)"
},
{
    "hex": "#FF496C",
    "name": "Radical Red",
    "rgb": "(255, 73, 108)"
},
{
    "hex": "#D68A59",
    "name": "Raw Sienna",
    "rgb": "(214, 138, 89)"
},
{
    "hex": "#714B23",
    "name": "Raw Umber",
    "rgb": "(113, 75, 35)"
},
{
    "hex": "#FF48D0",
    "name": "Razzle Dazzle Rose",
    "rgb": "(255, 72, 208)"
},
{
    "hex": "#E3256B",
    "name": "Razzmatazz",
    "rgb": "(227, 37, 107)"
},
{
    "hex": "#EE204D",
    "name": "Red",
    "rgb": "(238,32 ,77 )"
},
{
    "hex": "#FF5349",
    "name": "Red Orange",
    "rgb": "(255, 83, 73)"
},
{
    "hex": "#C0448F",
    "name": "Red Violet",
    "rgb": "(192, 68, 143)"
},
{
    "hex": "#1FCECB",
    "name": "Robin's Egg Blue",
    "rgb": "(31, 206, 203)"
},
{
    "hex": "#7851A9",
    "name": "Royal Purple",
    "rgb": "(120, 81, 169)"
},
{
    "hex": "#FF9BAA",
    "name": "Salmon",
    "rgb": "(255, 155, 170)"
},
{
    "hex": "#FC2847",
    "name": "Scarlet",
    "rgb": "(252, 40, 71)"
},
{
    "hex": "#76FF7A",
    "name": "Screamin' Green",
    "rgb": "(118, 255, 122)"
},
{
    "hex": "#9FE2BF",
    "name": "Sea Green",
    "rgb": "(159, 226, 191)"
},
{
    "hex": "#A5694F",
    "name": "Sepia",
    "rgb": "(165, 105, 79)"
},
{
    "hex": "#8A795D",
    "name": "Shadow",
    "rgb": "(138, 121, 93)"
},
{
    "hex": "#45CEA2",
    "name": "Shamrock",
    "rgb": "(69, 206, 162)"
},
{
    "hex": "#FB7EFD",
    "name": "Shocking Pink",
    "rgb": "(251, 126, 253)"
},
{
    "hex": "#CDC5C2",
    "name": "Silver",
    "rgb": "(205, 197, 194)"
},
{
    "hex": "#80DAEB",
    "name": "Sky Blue",
    "rgb": "(128, 218, 235)"
},
{
    "hex": "#ECEABE",
    "name": "Spring Green",
    "rgb": "(236, 234, 190)"
},
{
    "hex": "#FFCF48",
    "name": "Sunglow",
    "rgb": "(255, 207, 72)"
},
{
    "hex": "#FD5E53",
    "name": "Sunset Orange",
    "rgb": "(253, 94, 83)"
},
{
    "hex": "#FAA76C",
    "name": "Tan",
    "rgb": "(250, 167, 108)"
},
{
    "hex": "#18A7B5",
    "name": "Teal Blue",
    "rgb": "(24, 167, 181)"
},
{
    "hex": "#EBC7DF",
    "name": "Thistle",
    "rgb": "(235, 199, 223)"
},
{
    "hex": "#FC89AC",
    "name": "Tickle Me Pink",
    "rgb": "(252, 137, 172)"
},
{
    "hex": "#DBD7D2",
    "name": "Timberwolf",
    "rgb": "(219, 215, 210)"
},
{
    "hex": "#17806D",
    "name": "Tropical Rain Forest",
    "rgb": "(23, 128, 109)"
},
{
    "hex": "#DEAA88",
    "name": "Tumbleweed",
    "rgb": "(222, 170, 136)"
},
{
    "hex": "#77DDE7",
    "name": "Turquoise Blue",
    "rgb": "(119, 221, 231)"
},
{
    "hex": "#FFFF66",
    "name": "Unmellow Yellow",
    "rgb": "(255, 255, 102)"
},
{
    "hex": "#926EAE",
    "name": "Violet (Purple)",
    "rgb": "(146, 110, 174)"
},
{
    "hex": "#324AB2",
    "name": "Violet Blue",
    "rgb": "(50, 74, 178)"
},
{
    "hex": "#F75394",
    "name": "Violet Red",
    "rgb": "(247, 83, 148)"
},
{
    "hex": "#FFA089",
    "name": "Vivid Tangerine",
    "rgb": "(255, 160, 137)"
},
{
    "hex": "#8F509D",
    "name": "Vivid Violet",
    "rgb": "(143, 80, 157)"
},
{
    "hex": "#FFFFFF",
    "name": "White",
    "rgb": "(255, 255, 255)"
},
{
    "hex": "#A2ADD0",
    "name": "Wild Blue Yonder",
    "rgb": "(162, 173, 208)"
},
{
    "hex": "#FF43A4",
    "name": "Wild Strawberry",
    "rgb": "(255, 67, 164)"
},
{
    "hex": "#FC6C85",
    "name": "Wild Watermelon",
    "rgb": "(252, 108, 133)"
},
{
    "hex": "#CDA4DE",
    "name": "Wisteria",
    "rgb": "(205, 164, 222)"
},
{
    "hex": "#FCE883",
    "name": "Yellow",
    "rgb": "(252, 232, 131)"
},
{
    "hex": "#C5E384",
    "name": "Yellow Green",
    "rgb": "(197, 227, 132)"
},
{
    "hex": "#FFAE42",
    "name": "Yellow Orange",
    "rgb": "(255, 174, 66)"
}
]

module.exports = pal_crayola;
},{}],146:[function(require,module,exports){
const jsgui = require('lang-tools');
const oext = require('obext');
const {Data_Model, Data_Object, Collection, tof, stringify, get_a_sig, each, Evented_Class } = jsgui;
const Text_Node = require('./text-node');
const {
	prop,
	field
} = require('obext');
var px_handler = (target, property, value, receiver) => {
	let res;
	var t_val = tof(value);
	if (t_val === 'number') {
		res = value + 'px';
	} else if (t_val === 'string') {
		var match = value.match(/(\d*\.?\d*)(.*)/);
		if (match.length === 2) {
			res = value + 'px';
		} else {
			res = value;
		}
	}
	return res;
}
var style_input_handlers = {
	'width': px_handler,
	'height': px_handler,
	'left': px_handler,
	'top': px_handler
}
var new_obj_style = () => {
	let style = new Evented_Class({});
	style.__empty = true;
	style.toString = () => {
		var res = [];
		var first = true;
		each(style, (value, key) => {
			const tval = typeof value;
			if (tval !== 'function' && key !== 'toString' && key !== '__empty' && key !== '_bound_events' && key !== 'on' && key !== 'subscribe' && key !== 'raise' && key !== 'trigger') {
				if (first) {
					first = false;
				} else {
					res.push(' ');
				}
				res.push(key + ': ' + value + ';');
			}
		});
		return res.join('');
	}
	const res = new Proxy(style, {
		set: (target, property, value, receiver) => {
			let res;
			target['__empty'] = false;
			var old_value = target[property];
			if (style_input_handlers[property]) {
				res = target[property] = style_input_handlers[property](target, property, value, receiver);
			} else {
				res = target[property] = value;
			}
			style.raise('change', {
				'key': property,
				'name': property,
				'old': old_value,
				'new': value,
				'value': value
			});
			return res;
		},
		get: (target, property, receiver) => {
			if (property === 'toString') {
				return () => target + '';
			} else {
				return target[property];
			}
		}
	});
	return res;
}
class DOM_Attributes extends Evented_Class {
	constructor(spec) {
		super(spec);
		this.style = new_obj_style();
		this.style.on('change', e_change => {
			this.raise('change', {
				'property': 'style',
				'key': 'style',
				'name': 'style',
				'value': this.style.toString()
			});
		})
	}
}
class Control_DOM extends Evented_Class {
	constructor() {
		super();
		var dom_attributes = new DOM_Attributes();
		var attrs = this.attrs = this.attributes = new Proxy(dom_attributes, {
			'set': (target, property, value, receiver) => {
				if (property === 'style') {
					var t_value = tof(value);
					if (t_value === 'string') {
						var s_values = value.trim().split(';');
						var kv;
						each(s_values, (s_value) => {
							kv = s_value.split(':');
							if (kv.length === 2) {
								kv[0] = kv[0].trim();
								kv[1] = kv[1].trim();
								target.style[kv[0]] = kv[1];
							}
						});
						dom_attributes.raise('change', {
							'property': property
						});
					}
				} else {
					var old_value = target[property];
					target[property] = value;
					dom_attributes.raise('change', {
						'key': property,
						'name': property,
						'old': old_value,
						'new': value,
						'value': value
					});
				}
				return true;
			},
			get: (target, property, receiver) => {
				return target[property];
			}
		});
	}
}
class Control_Background extends Evented_Class {
	constructor(spec = {}) {
		super(spec);
		let _color, _opacity;
		Object.defineProperty(this, 'color', {
			get() {
				return _color;
			},
			set(value) {
				const old = _color;
				_color = value;
				this.raise('change', {
					'name': 'color',
					'old': old,
					'new': _color,
					'value': _color
				});
			},
			enumerable: true,
			configurable: true
		});
	}
	set(val) {}
}
class Control_Core extends Data_Object {
	constructor(spec = {}, fields) {
		spec.__type_name = spec.__type_name || 'control';
		super(spec, fields);
		if (spec.id) {
			this.__id = spec.id;
		}
		if (spec.__id) {
			this.__id = spec.__id;
		}
		this.mapListeners = {};
		this.__type = 'control';
		var spec_content;
		let d = this.dom = new Control_DOM();
		prop(this, 'background', new Control_Background(), (e_change) => {
			let {
				value
			} = e_change;
		});
		this.background.on('change', evt => {
			if (evt.name === 'color') {
				d.attributes.style['background-color'] = evt.value;
			}
		});
		prop(this, 'disabled', false);
		prop(this, 'size', spec.size, (e_change) => {
			let {
				value,
				old
			} = e_change;
			let [width, height] = value;
			const s = this.dom.attrs.style;
			s.width = width;
			s.height = height;
			this.raise('resize', {
				'value': value
			});
		});
		prop(this, 'pos', undefined, (e_change) => {
			let {
				value,
				old
			} = e_change;
			if (value.length === 2) {
			}
			let [left, top] = value;
			let o_style = {
				'left': left,
				'top': top
			}
			this.style(o_style);
			this.raise('move', {
				'value': value
			});
		});
		if (spec.pos) this.pos = spec.pos;
		this.on('change', e => {
			if (e.name === 'disabled') {
				if (e.value === true) {
					this.add_class('disabled');
				} else {
					this.remove_class('disabled');
				}
			}
		});
		let tagName = spec.tagName || spec.tag_name || 'div';
		d.tagName = tagName;
		var content = this.content = new Collection({});
		spec_content = spec.content;
		if (spec_content) {
			var tsc = tof(spec_content);
			if (tsc === 'array') {
				each(spec.content, item => {
					content.add(item);
				})
			} else if (tsc === 'string' || tsc === 'control') {
				content.add(spec_content);
			}
		}
		if (spec.el) {
			d.el = spec.el;
			if (spec.el.tagName) d.tagName = spec.el.tagName.toLowerCase();
		}
		var context = this.context || spec.context;
		if (context) {
			if (context.register_control) context.register_control(this);
		} else {}
		if (spec['class']) {
			this.add_class(spec['class']);
		}
		if (spec['css_class']) {
			this.add_class(spec['css_class']);
		}
		if (spec['cssClass']) {
			this.add_class(spec['cssClass']);
		}
		if (spec.hide) {
			this.hide();
		}
		if (spec.add) {
			this.add(spec.add);
		}
		if (spec.attrs) {
			this.dom.attributes = spec.attrs;
		}
	}
	get left() {
		const sl = this.dom.attributes.style.left;
		if (sl) {
			return parseInt(sl) + this.ta[6];
		}
	}
	get top() {
		const st = this.dom.attributes.style.top;
		if (st) {
			return parseInt(st) + this.ta[7];
		}
	}
	set top(value) {
		if (typeof value === 'number') {
			const measured_current_top = this.top;
			const diff = Math.round(value - measured_current_top);
			this.ta[7] += diff;
		}
	}
	'hide'() {
		let e = {
			cancelDefault: false
		}
		this.raise('hide', e)
		if (!e.cancelDefault) {
			this.add_class('hidden');
		}
	}
	'show'() {
		let e = {
			cancelDefault: false
		}
		this.raise('show', e);
		if (!e.cancelDefault) {
			this.remove_class('hidden');
		}
	}
	get html() {
		return this.all_html_render();
	}
	get internal_relative_div() {
		return this._internal_relative_div || false;
	}
	set internal_relative_div(value) {
		var old_value = this._internal_relative_div;
		this._internal_relative_div = value;
		if (value === true) {}
	}
	get color() {
		return this.background.color;
	}
	set color(value) {
		this.background.color = value;
	}
	'post_init'(spec) {
		if (spec && spec.id === true) {
			this.dom.attrs.id = this._id();
		}
	}
	'has'(item_name) {
		var arr = item_name.split('.');
		var c = 0,
			l = arr.length;
		var i = this;
		var s;
		while (c < l) {
			s = arr[c];
			if (typeof i[s] == 'undefined') {
				return false;
			}
			i = i[s];
			c++;
		};
		return i;
	}
	'renderDomAttributes'() {
		if (this.beforeRenderDomAttributes) {
			this.beforeRenderDomAttributes();
		}
		var dom_attrs = this.dom.attributes;
		if (!dom_attrs) {
			throw 'expecting dom_attrs';
		} else {
			if (this._) {
				var keys = Object.keys(this._);
				var key;
				for (var c = 0, l = keys.length; c < l; c++) {
					key = keys[c];
					if (key !== '_bound_events') {
						if (key instanceof Control_Core) {
							(this._ctrl_fields = this._ctrl_fields || {})[key] = this._[key];
						} else {
							this._fields = this._fields || {};
							this._fields[key] = this._[key];
						}
					}
				}
			}
			if (this._ctrl_fields) {
				var obj_ctrl_fields = {};
				var keys = Object.keys(this._ctrl_fields);
				var key;
				for (var c = 0, l = keys.length; c < l; c++) {
					key = keys[c];
					if (key !== '_bound_events') {
						obj_ctrl_fields[key] = this._ctrl_fields[key]._id();
					}
				}
				let scf = stringify(obj_ctrl_fields).replace(/"/g, "'");
				if (scf.length > 2) {
					dom_attrs['data-jsgui-ctrl-fields'] = scf;
				}
			}
			if (this._fields) {
				let sf = stringify(this._fields).replace(/"/g, "'");
				if (sf.length > 2) {
					dom_attrs['data-jsgui-fields'] = sf;
				}
			}

			// Then will get these back in activate / pre-activate.
			//   Or post-activate even?

			// Pre seems best. Or the autoactivate part of the activate process.


			if (this.view.data.model.mixins) {
				let smxs = '[';
				let first = true;
				this.view?.data?.model?.mixins?.each((mx) => {
					if (!first) {
						smxs += ',';
					} else {
						first = false;
					}
					const smx = JSON.stringify(mx);
					smxs += smx;
					
				});
				smxs += ']';
				smxs = smxs.replace(/"/g, "'");
				if (smxs.length > 2) {
					dom_attrs['data-jsgui-mixins'] = smxs;
				}
			}
			
			
			
			

			// is this.

			// mixins as well?
			//   or within ._fields?

			// a separate ._mixins property would help.




			const arr = [];
			const id = this._id();
			if (id !== undefined) {
				arr.push(' data-jsgui-id="' + this._id() + '"');
			}
			if (this.data && this.data._model instanceof Data_Model) {
				const dmid = this.data._model.__id;
				if (dmid) {
					arr.push(' data-jsgui-data-model-id="' + dmid + '"');
				}
			}
			const exempt_types = {
				html: true,
				head: true,
				body: true
			}
			if (this.context && this.__type_name) {
				if (!exempt_types[this.__type_name] && this.__type_name !== undefined) {
					arr.push(' data-jsgui-type="' + this.__type_name + '"');
				}
			}
			var dom_attrs_keys = Object.keys(dom_attrs);
			var key, item;
			for (var c = 0, l = dom_attrs_keys.length; c < l; c++) {
				key = dom_attrs_keys[c];
				if (key == '_bound_events') {} else if (key === 'style') {
					item = dom_attrs[key];
					if (typeof item !== 'function') {
						if (typeof item === 'object') {
							if (key === 'style') {
								const sprops = [];
								each(item, (v, k) => {
									const tval = typeof v;
									if (tval !== 'function') {
										if (k !== '__empty') {
											const sprop = k + ':' + v;
											sprops.push(sprop);
										}
									}
								});
								if (sprops.length > 0) arr.push(' ', key, '="', sprops.join(';'), '"');
							} else {
								console.trace();
								throw 'NYI';
							}
						} else {
							let is = item.toString();
							if (!item.__empty && is.length > 0) {
								arr.push(' ', key, '="', is, '"');
							}
						}
					}
				} else {
					item = dom_attrs[key];
					if (item && item.toString) {
						arr.push(' ', key, '="', item.toString(), '"');
					}
				}
			}
			return arr.join('');
		}
	}
	'renderBeginTagToHtml'() {
		const tagName = this.dom.tagName;
		var res;
		if (tagName === false) {
			res = '';
		} else {
			res = ['<', tagName, this.renderDomAttributes(), '>'].join('');
		}
		return res;
	}
	'renderEndTagToHtml'() {
		var res;
		const tagName = this.dom.tagName;
		const noClosingTag = this.dom.noClosingTag;
		if (tagName === false || noClosingTag) {
			res = '';
		} else {
			res = ['</', tagName, '>'].join('');
		}
		return res;
	}
	'renderHtmlAppendment'() {
		return this.htmlAppendment || '';
	}
	'renderEmptyNodeJqo'() {
		return [this.renderBeginTagToHtml(), this.renderEndTagToHtml(), this.renderHtmlAppendment()].join('');
	}
	'register_this_and_subcontrols'() {
		const context = this.context;
		this.iterate_this_and_subcontrols((ctrl) => {
			context.register_control(ctrl);
		});
	}
	'iterate_subcontrols'(ctrl_callback) {
		const content = this.content;
		content.each(v => {
			ctrl_callback(v);
			if (v && v.iterate_subcontrols) {
				v.iterate_subcontrols(ctrl_callback);
			}
		});
	}
	'iterate_this_and_subcontrols'(ctrl_callback) {
		ctrl_callback(this);
		const content = this.content;
		let tv;
		if (typeof content !== 'string') {
			content.each(v => {
				tv = tof(v);
				if (tv == 'string') {} else if (tv == 'data_value') {} else {
					if (v && v.iterate_this_and_subcontrols) {
						v.iterate_this_and_subcontrols(ctrl_callback);
					}
				}
			});
		}
	}
	'all_html_render'(callback) {
		if (callback) {
			var arr_waiting_controls = [];
			this.iterate_this_and_subcontrols((control) => {
				if (control.__status == 'waiting') arr_waiting_controls.push(control);
			});
			if (arr_waiting_controls.length == 0) {
				callback(null, this.all_html_render());
			} else {
				var c = arr_waiting_controls.length;
				var complete = () => {
					this.pre_all_html_render();
					var dom = this.dom;
					if (dom) {
						callback(null, [this.renderBeginTagToHtml(), this.all_html_render_internal_controls(), this.renderEndTagToHtml(), this.renderHtmlAppendment()].join(''));
					}
				}
				each(arr_waiting_controls, (control, i) => {
					control.on('ready', e_ready => {
						c--;
						if (c == 0) {
							complete();
						}
					});
				});
			}
		} else {
			this.pre_all_html_render();
			var dom = this.dom;
			if (dom) {
				return [this.renderBeginTagToHtml(), this.all_html_render_internal_controls(), this.renderEndTagToHtml(), this.renderHtmlAppendment()].join('');
			}
		}
	}
	'render_content'() {
		var content = this.content;
		if (tof(content) === 'string') {
			return content;
		} else {
			var contentLength = content.length();
			var res = new Array(contentLength);
			var tn, output;
			var arr = content._arr;
			var c, l = arr.length,
				n;
			for (c = 0; c < l; c++) {
				n = arr[c];
				tn = tof(n);
				if (tn === 'string') {
					res.push(jsgui.output_processors['string'](n));
				} else if (tn === 'data_value') {
					res.push(n._);
				} else {
					if (tn === 'data_object') {
						throw 'stop';
					} else {
						res.push(n.all_html_render());
					}
				}
			}
			return res.join('');
		}
	}
	'all_html_render_internal_controls'() {
		return this.render_content();
	}
	'render'() {
		return this.all_html_render(); 
	}
	'pre_all_html_render'() {
		// if on the server side...
		//   not sure to what extent this fn call on every render will slow it down, raising an event on the server too.

		

		if (typeof document === 'undefined') {
			this.raise('server-pre-render');
		}

	}
	'compose'() {}
	'visible'(callback) {
		this.style('display', 'block', callback);
	}
	'transparent'(callback) {
		this.style('opacity', 0, callback);
	}
	'opaque'(callback) {
		return this.style({
			'opacity': 1
		}, callback);
	}
	'remove'() {
		return this.parent.content.remove(this);
	}
	'add'(new_content) {
		const tnc = tof(new_content);
		let res;
		if (tnc === 'array') {
			let res = [];
			each(new_content, (v) => {
				res.push(this.add(v));
			});
		} else {
			if (new_content) {
				if (tnc === 'string') {
					new_content = new Text_Node({
						'text': new_content,
						'context': this.context
					});
				} else {
					if (!new_content.context) {
						if (this.context) {
							new_content.context = this.context;
						}
					}
				}
				var inner_control = this.inner_control;
				if (inner_control) {
					res = inner_control.content.add(new_content);
				} else {
					res = this.content.add(new_content);
				}
				new_content.parent = this;
			}
		}
		return res;
	}
	'insert_before'(target) {
		const target_parent = target.parent;
		const target_index = target._index;
		const content = target_parent.content;
		content.insert(this, target_index);
	}
	'style'() {
		const a = arguments,
			sig = get_a_sig(a, 1), d = this.dom,
			da = d.attrs;
		a.l = a.length;
		let style_name, style_value, modify_dom = true;
		if (sig == '[s]') {
			style_name = a[0];
			const res = getComputedStyle(d.el)[style_name];
			return res;
		} else if (sig == '[s,s,b]') {
			[style_name, style_value, modify_dom] = a;
		} else if (sig == '[s,s]' || sig == '[s,n]') {
			[style_name, style_value] = a;
		};
		if (style_name && typeof style_value !== 'undefined') {
			if (da.style) {
				da.style[style_name] = style_value;
				da.raise('change', {
					'property': 'style',
					'name': 'style',
					'value': da.style + ''
				});
			} else {}
		}
		if (sig == '[o]') {
			each(a[0], (v, i) => {
				this.style(i, v);
			});
		}
	}
	'active'() {}
	'find_selection_scope'() {
		var res = this.selection_scope;
		if (res) return res;
		if (this.parent && this.parent.find_selection_scope) return this.parent.find_selection_scope();
	}
	'click'(handler) {
		this.on('click', handler);
	}
	'add_class'(class_name) {
		let da = this.dom.attrs,
			cls = da['class'];
		if (!cls) {
			da['class'] = class_name;
		} else {
			const tCls = tof(cls);
			if (tCls == 'object') {
				throw 'removed';
			} else if (tCls == 'string') {
				let arr_classes = cls.split(' '),
					already_has_class = false,
					l = arr_classes.length,
					c = 0;
				while (c < l && !already_has_class) {
					if (arr_classes[c] === class_name) {
						already_has_class = true;
					}
					c++;
				}
				if (!already_has_class) {
					arr_classes.push(class_name);
				}
				da['class'] = arr_classes.join(' ');
			}
		}
	}
	'has_class'(class_name) {
		let da = this.dom.attrs,
			cls = da['class'];
		if (cls) {
			var tCls = tof(cls);
			if (tCls == 'object') {
				throw 'removed';
			}
			if (tCls == 'string') {
				var arr_classes = cls.split(' ');
				var arr_res = [];
				var l = arr_classes.length,
					c = 0;
				while (c < l) {
					if (arr_classes[c] === class_name) {
						return true;
					}
					c++;
				}
			}
		}
	}
	'remove_class'(class_name) {
		let da = this.dom.attrs,
			cls = da['class'];
		if (cls) {
			var tCls = tof(cls);
			if (tCls == 'object') {
				throw 'removed';
			}
			if (tCls == 'string') {
				var arr_classes = cls.split(' ');
				var arr_res = [];
				var l = arr_classes.length,
					c = 0;
				while (c < l) {
					if (arr_classes[c] != class_name) {
						arr_res.push(arr_classes[c]);
					}
					c++;
				}
				da['class'] = arr_res.join(' ');
			}
		}
	}
	'is_ancestor_of'(target) {
		var t_target = tof(target);
		var el = this.dom.el;
		var inner = (target2) => {
			if (target2 == el) {
				return true;
			}
			var parent = target2.parentNode;
			if (!parent) {
				return false;
			} else {
				return inner(parent);
			}
		}
		if (t_target === 'object') {
			if (el !== target) {
				var parent = target.parentNode;
				if (parent) {
					return inner(parent);
				}
			}
		} else {
			if (t_target === 'control') {}
		}
	}
	'find_selected_ancestor_in_scope'() {
		var s = this.selection_scope;
		var ps = this.parent.selection_scope;
		if (s === ps) {
			var psel = this.parent.selected;
			if (psel && psel.value && psel.value() == true) {
				return this.parent;
			} else {
				return this.parent.find_selected_ancestor_in_scope();
			}
		}
	}
	'closest'(match) {
		let tmatch = tof(match);
		if (tmatch === 'string') {}
		if (tmatch === 'function') {
			let search = (ctrl) => {
				if (match(ctrl)) {
					return ctrl;
				} else {
					if (ctrl.parent) {
						return search(ctrl.parent);
					} else {
						return undefined;
					}
				}
			}
			return search(this);
		}
	}
	'shallow_copy'() {
		var res = new Control({
			'context': this.context
		});
		var da = this.dom.attributes;
		var cl = da.class;
		var map_class_exclude = {
			'selected': true
		}
		each(cl.split(' '), (v, i) => {
			if (i && !map_class_exclude[i]) res.add_class(i);
		})
		var res_content = res.content;
		this.content.each((v, i) => {
			if (tof(v) == 'data_value') {
				res_content.add(v.value());
			} else {
				res_content.add(v.shallow_copy());
			}
		})
		return res;
	}
	'matches_selector'(selector) {
		throw 'NYI'
	}
	'find'(selector) { 
		const res = [];
		const desc = (node, callback) => {
			if (node.$match(selector)) {
				callback(node);
			}
			node.content.each(child => {
				desc(child, callback);
			})
		}
		desc(this, (node => res.push(node)));
		return res;
	}
	'$match'(selector) {
		if (typeof selector === 'function') {
			return selector(this);
		} else {
			let parse_word = word => {
				if (word[0] === '.') {
					return () => this.has_class(word.substr(1));
				} else {
					return () => this.__type_name === word;
				}
			}
			let parse_selector = selector => {
				let words = selector.split(' ');
				let res = words.map(x => parse_word(x));
				return res;
			}
			let parsed = parse_selector(selector);
			if (parsed.length === 1) {
				return parsed[0]();
			} else {
				console.trace();
				throw 'NYI';
			}
		}
		let res = false;
		let tn = this.__type_name;
		if (tn) {
			if (tn === selector) res = true;
		}
		return res;
	}
	'$'(selector, handler) {
		let match = this.$match(selector);
		let res = [];
		if (match) {
			if (handler) handler(this);
			res.push(this)
		}
		this.content.each(item => {
			if (item.$) {
				let nested_res = item.$(selector, handler);
				Array.prototype.push.apply(res, nested_res);
			}
		});
		return res;
	}
	'clear'() {
		this.content.clear();
	}
	'activate'() {}
	get this_and_descendents() {
		const res = [];
		this.iterate_this_and_subcontrols(ctrl => res.push(ctrl));
		return res;
	}
	get descendents() {
		const res = [];
		this.iterate_subcontrols(ctrl => res.push(ctrl));
		return res;
	}
	get siblings() {
		const res = [];
		if (this.parent) {
			const _ = this.parent.content._arr;
			_.forEach(x => {
				if (x !== this) res.push(x);
			})
		}
		return res;
	}
};
var p = Control_Core.prototype;
p.connect_fields = true;
const customInspectSymbol = Symbol.for('nodejs.util.inspect.custom');
if (jsgui.custom_rendering === 'very-simple') {
	p[customInspectSymbol] = function(depth, inspectOptions, inspect) {
		return '< ' + this.dom.tagName + ' ' + this.__type_name +  ' >'
	};
}
module.exports = Control_Core;
if (require.main === module) {
	const Control = Control_Core;
	function test_svg() {
		const passed = [];
		const failed = [];
		let svg;
		try {
			svg = new Control({
				tagName: 'svg'
			});
			passed.push('Create SVG control');
		} catch (error) {
			failed.push('Create SVG control');
		}
		try {
			const circle = new Control({
				tagName: 'circle',
				attrs: {
					cx: 100,
					cy: 100,
					r: 50
				}
			});
			svg.add(circle);
			passed.push('Add circle to SVG control');
		} catch (error) {
			console.log('error', error);
			failed.push('Add circle to SVG control');
		}
		try {
			const rect = new Control({
				tagName: 'rect',
				attrs: {
					x: 150,
					y: 150,
					width: 100,
					height: 100
				}
			});
			svg.add(rect);
			passed.push('Add rectangle to SVG control');
		} catch (error) {
			console.log('error', error);
			failed.push('Add rectangle to SVG control');
		}
		try {
			const expected = '<svg><circle cx="100" cy="100" r="50"></circle><rect x="150" y="150" width="100" height="100"></rect></svg>';
			const actual = svg.all_html_render();
			console.log('actual', actual);
			if (expected === actual) {
				passed.push('Check rendering of SVG control');
			} else {
				failed.push('Check rendering of SVG control');
			}
		} catch (error) {
			console.log('error', error);
			failed.push('Check rendering of SVG control');
		}
		return {
			passed,
			failed
		};
	}
	console.log(test_svg()); 
	const test_background_color = () => {
		const expectedColor = '#ff0000';
		const passed = [];
		const failed = [];
		let div;
		try {
			div = new Control({
				tagName: 'div',
			});
			passed.push('Create div control');
		} catch (error) {
			failed.push(['Create div control', error]);
		}
		try {
			div.background.color = expectedColor;
			passed.push('Set background color of div control');
		} catch (error) {
			failed.push(['Set background color of div control', error]);
		}
		try {
			const validationColor = div.background.color;
			if (validationColor === expectedColor) {
				passed.push('Validate background color of div control');
			} else {
				failed.push(['Validate background color of div control', 'Background color is not as expected']);
			}
		} catch (error) {
			failed.push(['Validate background color of div control', error]);
		}
		try {
			const expected = `<div style="background-color:${expectedColor}"></div>`;
			const actual = div.all_html_render();
			if (expected === actual) {
				passed.push('Check rendering of div control');
			} else {
				failed.push(['Check rendering of div control', 'Rendering does not match expected output', {
					expected,
					actual
				}]);
			}
		} catch (error) {
			failed.push(['Check rendering of div control', error]);
		}
		return {
			passed,
			failed,
		};
	};
	const rtest = test_background_color();
	console.log(rtest);
	console.log(rtest.failed);
}
},{"./text-node":153,"lang-tools":186,"obext":382}],147:[function(require,module,exports){
var jsgui = require('lang-tools');
const {
	get_a_sig,
	each,
	tof,
	def
} = jsgui;
const v_subtract = jsgui.util.v_subtract;
const {
	prom_or_cb
} = require('fnl');
const Text_Node = require('./text-node');
var Control_Core = require('./control-core');
const has_window = typeof window !== 'undefined';
const gfx = require('jsgui3-gfx-core');
const {Rect} = gfx;


// Or can't load them at the very start?

//const mixins = require('../control_mixins/mx');
//const {model_data_view_compositional_representation} = mixins;

const model_data_view_compositional_representation = require('../control_mixins/model_data_view_compositional_representation');

// Need to be able to load / access the mixins here.
//   Need to avoid circular references. Therefore mixins can't use this module.
//     Or not directly?
//       Mixins do seem to need to be able to do things such as create controls.


//console.trace();
//throw 'stop';

// Maybe have a 'mixins available' event somewhere.





const desc = (ctrl, callback) => {
	if (ctrl.get) {
		var content = ctrl.get('content');
		if (content) {
			var t_content = typeof content;
			if (t_content === 'string' || t_content === 'number') {} else {
				var arr = content._arr;
				var c, l = arr.length;
				var item, t_item;
				for (c = 0; c < l; c++) {
					item = arr[c];
					t_item = typeof item;
					if (t_item === 'string' || t_item === 'numbers') {} else {
						callback(arr[c]);
						desc(arr[c], callback);
					}
				}
			}
		}
	}
}
var dom_desc = (el, callback) => {
	callback(el);
	var cns = el.childNodes;
	var l = cns.length;
	for (var c = 0; c < l; c++) {
		dom_desc(cns[c], callback);
	}
}
const mapDomEventNames = {
	'change': true,
	'click': true,
	'dblclick': true,
	'mousedown': true,
	'mouseup': true,
	'mousemove': true,
	'mouseover': true,
	'mouseout': true,
	'blur': true,
	'focus': true,
	'keydown': true,
	'keyup': true,
	'keypress': true,
	'contextmenu': true,
	'touchstart': true,
	'touchmove': true,
	'touchend': true,
	'touchcancel': true,
	'touchforcechange': true,
	'transitionend': true,
	'abort': true,
	'canplay': true,
	'canplaythrough': true,
	'durationchange': true,
	'emptied': true,
	'ended': true,
	'error': true,
	'loadeddata': true,
	'loadedmetadata': true,
	'loadstart': true,
	'pause': true,
	'play': true,
	'playing': true,
	'progress': true,
	'ratechange': true,
	'seeked': true,
	'seeking': true,
	'submit': true,
	'stalled': true,
	'suspend': true,
	'timeupdate': true,
	'volumechange': true,
	'waiting': true
};
class Control extends Control_Core {
	constructor(spec, fields) {
		spec = spec || {};
		super(spec, fields);
		const o_repr = {};
		if (spec.data) o_repr.data = spec.data;
		model_data_view_compositional_representation(this, o_repr);
		if (spec.id) {
			this.__id = spec.id;
		}
		if (spec.__id) {
			this.__id = spec.__id;
		}
		if (spec.__type_name) {
			this.__type_name = spec.__type_name;
		}
		this.map_raises_dom_events = {};
		if (spec.el) {

			// Not so sure about putting it in the spec rather than applying it to the control.
			//   Or keeping these persisted properties to apply later?

			// ctrl._persisted_fields perhaps?
			//   then can assign those persisted fields once the mixins have been initialised.




			var jgf = spec.el.getAttribute('data-jsgui-fields');
			if (jgf) {
				//console.log('jgf', jgf);
				this._persisted_fields = this._persisted_fields || {};
				var s_pre_parse = jgf.replace(/\[DBL_QT\]/g, '"').replace(/\[SNG_QT\]/g, '\'');
				s_pre_parse = s_pre_parse.replace(/\'/g, '"');
				var props = JSON.parse(s_pre_parse);
				//console.log('props', props);
				let exempt_prop_names = {}
				each(props, (v, i) => {
					if (exempt_prop_names[i]) {} else {
						//spec[i] = v;
						this._persisted_fields[i] = v;

						// maybe apply those fields after the mixins have been set up.
					}
				});
			}
		}
		if (spec.el) {
			if (def(this.selection_scope)) {
				this.selection_scope = this.context.new_selection_scope(this);
			}
			var tn = spec.el.getAttribute('data-jsgui-type');
			if (tn) this.__type_name = tn;
			var id = spec.el.getAttribute('data-jsgui-id');
			if (id) this.__id = id;
		}
		if (!spec.el) {
			this.compose_using_compositional_model();
		}
		this.view.ui.compositional.on('change', e => {
			const {name} = e;
			if (name === 'model') {
				this.recompose_using_compositional_model();
			}
		});
		if (spec.size) {
			this.size = spec.size;
		}
		if (spec.background) {
			if (spec.background.color) {
				this.background.color = spec.background.color;
			}
		}
		const set_view_ui_composition_model_from_spec = () => {
			if (spec.comp) {
				this.view.ui.compositional.model = spec.comp;
			} else if (spec.composition) {
				this.view.ui.compositional.model = spec.composition;
			} else if (spec.view) {
				if (spec.view.ui) {
					if (spec.view.ui.compositional) {
						if (spec.view.ui.compositional.model) {
							this.view.ui.compositional.model = spec.view.ui.compositional.model;
						}
					}
				}
			}
		}
		set_view_ui_composition_model_from_spec();
	}
	recompose_using_compositional_model() {
		this.content.clear();
		this.compose_using_compositional_model();
	}
	compose_using_compositional_model() {
		let cm;
		const {context} = this;
		if (this.view.ui.compositional.model) {
			cm = this.view.ui.compositional.model;
		}
		const tcm = tof(cm);
		const compose_from_compositional_model_array = (arr_cm) => {
			const l = arr_cm.length;
			if (l > 0) {
				for (let c = 0; c < l; c++) {
					const composition_item = arr_cm[c];
					const tci = tof(composition_item);
					if (tci === 'function' || tci === 'control') {
						const ctrl = new composition_item({context});
						this.add(ctrl);
					} else if (tci === 'array') { 
						if (composition_item.length === 2) {
							const [t0, t1] = [tof(composition_item[0]), tof(composition_item[1])];
							if ((t0 === 'function' || t0 === 'control') && t1 === 'object') {
								composition_item[1].context = context;
								const ctrl = new composition_item[0](composition_item[1]);
								this.add(ctrl);
							} else if (t0 === 'string' && (t1 === 'function' || t1 === 'control')) {
								const ctrl = new composition_item[1]({context});
								this.add(ctrl);
								this._ctrl_fields = this._ctrl_fields || {};
								this._ctrl_fields[composition_item[0]] = ctrl;
							} else {
								console.log('[t0, t1]', [t0, t1]);
								console.trace();
								throw 'stop / nyi';
							}
						} else if (composition_item.length === 3) {
							const [t0, t1, t2] = [tof(composition_item[0]), tof(composition_item[1]), tof(composition_item[2])];
							if ((t0 === 'string') && (t1 === 'function' || t1 === 'control') && t2 === 'object') {
								composition_item[2].context = context;
								const ctrl = new composition_item[1](composition_item[2]);
								this.add(ctrl);
								this._ctrl_fields = this._ctrl_fields || {};
								this._ctrl_fields[composition_item[0]] = ctrl;
							} else {
								console.log('[t0, t1, t2]', [t0, t1, t2]);
								console.trace();
								throw 'stop / nyi';
							}
						} else {
							console.trace();
							throw 'stop / nyi';
						}
					}
				}
			}
		}
		if (tcm === 'array') {
			compose_from_compositional_model_array(cm);
		}
	}
	'ctrls' (obj_ctrls) {
		this._ctrl_fields = this._ctrl_fields || {};
		let cf = this._ctrl_fields;
		each(obj_ctrls, (ctrl, name) => {
			cf[name] = this[name] = ctrl;
			this.add(ctrl);
		});
		return this;
	}
	'bcr' () {
		var a = arguments;
		a.l = a.length;
		var sig = get_a_sig(a, 1);
		if (sig === '[]') {
			var el = this.dom.el;
			var bcr = el.getBoundingClientRect();
			const res_rect = new Rect([bcr.width, bcr.height], [bcr.left, bcr.top]);
			return res_rect;
		} else if (sig === '[a]') {
			let [pos, br_pos, size] = a[0];
			this.style({
				'position': 'absolute',
				'left': pos[0] + 'px',
				'top': pos[1] + 'px',
				'width': size[0] + 'px',
				'height': size[1] + 'px'
			});
		}
	}
	get size() {
		if (this._size) {
			return this._size;
		} else {
			if (this.dom.el) {
				var bcr = this.dom.el.getBoundingClientRect();
				return [bcr.width, bcr.height];
			}
		}
	}
	'add_text' (value) {
		var tn = new Text_Node({
			'context': this.context,
			'text': value + ''
		})
		this.add(tn);
		return tn;
	}
	'computed_style' () {
		var a = arguments;
		a.l = a.length;
		var sig = get_a_sig(a, 1);
		var y;
		if (sig == '[s]') {
			var property_name = a[0];
			var el = this.dom.el;
			if (el.currentStyle)
				y = el.currentStyle[styleProp];
			else if (window.getComputedStyle)
				y = document.defaultView.getComputedStyle(el, null).getPropertyValue(property_name);
			return y;
		}
	}
	'padding' () {
		var a = arguments;
		a.l = a.length;
		var sig = get_a_sig(a, 1);
		if (sig == '[]') {
			var left, top, right, bottom;
			var c_padding = this.computed_style('padding');
			var s_c_padding = c_padding.split(' ');
			if (s_c_padding.length == 3) {
				top = parseInt(s_c_padding[0], 10);
				right = parseInt(s_c_padding[1], 10);
				bottom = parseInt(s_c_padding[2], 10);
				return [0, top, right, bottom];
			}
		} else {
			console.trace();
			throw 'Required argument: (array)'
		}
	}
	'border' () {
		var a = arguments;
		a.l = arguments.length;
		var sig = get_a_sig(a, 1);
		if (sig == '[]') {
			var left, top, right, bottom;
			var c_border = this.computed_style('border');
			console.log('c_border', c_border);
			throw 'stop';
		} else {
			console.trace();
			throw 'Required argument: (array)'
		}
	}
	'border_thickness' () {
		var a = arguments;
		a.l = arguments.length;
		var sig = get_a_sig(a, 1);
		if (sig == '[]') {
			var left, top, right, bottom;
			var c_border = this.computed_style('border');
			var b2 = c_border.split(', ').join('');
			var s_c_border = b2.split(' ');
			var thickness = parseInt(s_c_border[0], 10);
			return thickness;
		}
	}
	'activate_recursive' () {
		var el = this.dom.el;
		var context = this.context;
		var map_controls = context.map_controls;
		var parent_control;
		recursive_dom_iterate_depth(el, el2 => {
			const nt = el2.nodeType;
			if (nt == 1) {
				var jsgui_id = el2.getAttribute('data-jsgui-id');
				if (jsgui_id) {
					var ctrl = map_controls[jsgui_id];
					if (!ctrl.__active) ctrl.activate(el2);
				}
			}
		})
	}
	'add_dom_event_listener' (event_name, fn_handler) {
		if (has_window) {
			const {
				context
			} = this;
			const el = this.dom.el;
			const m = this.map_handlers_to_outer_handlers = this.map_handlers_to_outer_handlers || new Map();
			let outer_handler;
			if (m.has(fn_handler)) {
				outer_handler = m.get(fn_handler);
			} else {
				outer_handler = e => {
					const {
						target
					} = e;
					const jid = target.getAttribute('data-jsgui-id');
					if (jid) {
						e.ctrl_target = context.map_controls[jid];
					}
					fn_handler(e);
				};
				m.set(fn_handler, outer_handler);
			}
			if (el) {
				el.addEventListener(event_name, outer_handler, false);
			}
		}
	}
	'remove_dom_event_listener' (event_name, fn_handler) {
		if (has_window) {
			const m = this.map_handlers_to_outer_handlers;
			let outer_handler;
			if (m) {
				if (m.has(fn_handler)) {
					outer_handler = m.get(fn_handler);
				}
			}
			outer_handler = outer_handler || fn_handler;
			const el = this.dom.el;
			if (el) {
				el.removeEventListener(event_name, outer_handler, false);
			}
		}
	}
	'remove_event_listener' () {
		const a = arguments;
		const sig = get_a_sig(a, 1);
		if (sig === '[s,f]') {
			let [event_name, fn_handler] = a;
			if (mapDomEventNames[event_name]) {
				this.remove_dom_event_listener(event_name, fn_handler);
			}
			Control_Core.prototype.remove_event_listener.apply(this, a);
		} else if (sig === '[o]') {
			each(a[0], (v, i) => {
				this.remove_event_listener(i, v);
			});
		}
	}
	'add_event_listener' () {
		const a = arguments;
		const l = a.length;
		const sig = get_a_sig(a, 1);
		if (l === 1) {
			each(a[0], (v, i) => {
				this.add_event_listener(i, v);
			});
		}
		if (l === 2) {
			super.add_event_listener(a[0], a[1]);
		}
		if (l === 3) {
			super.add_event_listener(a[0], a[2]);
		}
		if (sig === '[s,f]' || sig === '[s,b,f]') {
			let event_name = a[0];
			let using_dom = true;
			if (l === 3 && a[1] === false) using_dom = false;
			let fn_handler;
			if (l === 2) fn_handler = a[1];
			if (l === 3) fn_handler = a[2];
			if (mapDomEventNames[a[0]] && using_dom) {
				this.add_dom_event_listener(event_name, fn_handler);
			}
		}
	}
	'once_active' (cb) {
		if (typeof document !== 'undefined') {
			return prom_or_cb((solve, jettison) => {
				if (this.__active) {
					solve();
				} else {
					let fn_activate = () => {
						solve();
						setTimeout(() => {
							this.off('activate', fn_activate);
						}, 0)
					}
					this.on('activate', fn_activate);
				}
			}, cb);
		}
	}
	'pre_activate'() {
		if (typeof document !== 'undefined') {
			if (!this.dom.el) {
				let found_el = this.context.get_ctrl_el(this) || this.context.map_els[this._id()] || document.querySelectorAll('[data-jsgui-id="' + this._id() + '"]')[0];
				if (found_el) {
					this.dom.el = found_el;
				}
			}
			if (!this.dom.el) {} else {
				this.load_dom_attributes_from_dom();

				//  reconstruct a special .view.data.model.mixins collection from the dom attributes.
				//    collection seems logically best - though collection may be redone soon.

				if (this.dom.attributes["data-jsgui-mixins"] !== undefined) {
					const str_mixins = this.dom.attributes["data-jsgui-mixins"]?.replace(/'/g, '"');
					if(str_mixins) {
						const o_mixins = JSON.parse(str_mixins);
						//this.view.data.model.mixins.clear();
						//each(mixins, mixin => {
						//	this.view.data.model.mixins.push(mixin);

						//console.log('o_mixins', o_mixins);

						const old_silent = this.view.data.model.mixins.silent;

						// .silently(cb) function could be one way to do these things.

						this.view.data.model.mixins.silent = true;
						//});
						//console.log('o_mixins', o_mixins);

						each(o_mixins, (mixin) => {
							const {name, options} = mixin;

							const converted_name = name.replace(/-/g, '_');

							//console.log('mixin', mixin);

							//console.log('mixin converted_name', converted_name);

							// and run the mixin here???

							this.view.data.model.mixins.push(mixin);

							const the_mixin = this.context.mixins[converted_name];

							//console.log('!!the_mixin', !!the_mixin);

							if (the_mixin) {
								the_mixin(this);
							}

							// And add this back to the view data model??



						});

						this.view.data.model.mixins.silent = old_silent;

						// Set it back up in the view.data.model.mixins collection.


					}
				}

				if (this._persisted_fields) {
					each(this._persisted_fields, (v, i) => {
						this[i] = v;
					});
				}

				if (this.dom.attributes["data-jsgui-data-model-id"] !== undefined) {
					const context_referenced_data_model = this.context.map_data_models[this.dom.attributes["data-jsgui-data-model-id"]];
					if (context_referenced_data_model) {
						this.data.model = context_referenced_data_model;
						console.log('have used data.model referenced from context: ' + context_referenced_data_model.__id);
					}
				}
				this.pre_activate_content_controls();
				this.add_content_change_event_listener();
				this.add_dom_attributes_changes_listener();
			}
		} else {}
	}
	'activate' (el) {
		if (typeof document !== 'undefined' && !this.__active) {
			this.__active = true;
			if (!this.dom.el) {
				let found_el = this.context.get_ctrl_el(this) || this.context.map_els[this._id()] || document.querySelectorAll('[data-jsgui-id="' + this._id() + '"]')[0];
				if (found_el) {
					this.dom.el = found_el;
				}
			}
			if (!this.dom.el) {} else {
				this.activate_content_controls();

				// activate / load the mixins from the view model of them...???

				this.raise('activate');
			}
		} else {}
	}
	'add_dom_attributes_changes_listener' () {
		var dom_attributes = this.dom.attributes;
		var el = this.dom.el;
		dom_attributes.on('change', (e_change) => {
			var property_name = e_change.name || e_change.key,
				val = e_change.value || e_change.new;
			if (el && el.nodeType === 1) {
				el.setAttribute(property_name, val);
			}
		});
	}
	'activate_this_and_subcontrols' () {
		this.iterate_this_and_subcontrols((ctrl) => {
			if (ctrl.dom.el) {
				ctrl.activate();
			}
		});
	}
	'add_content_change_event_listener' () {
		const {
			context
		} = this;
		var map_controls = context.map_controls;
		let el = this.dom.el;
		this.content.on('change', (e_change) => {
			let itemDomEl;
			var type = e_change.name;
			if (type === 'insert') {
				var item = e_change.value;
				var retrieved_item_dom_el = item.dom.el;
				var t_ret = tof(retrieved_item_dom_el);
				if (t_ret === 'string') {
					itemDomEl = retrieved_item_dom_el;
				} else {
					if (retrieved_item_dom_el) {
						itemDomEl = retrieved_item_dom_el;
					}
					if (!itemDomEl) {
						if (context.map_els[item._id()]) {
							itemDomEl = context.map_els[item._id()];
						}
					}
					if (!itemDomEl) {
						var item_tag_name = 'div';
						var dv_tag_name = item.dom.tagName;
						if (dv_tag_name) {
							item_tag_name = dv_tag_name;
						}
						var temp_el;
						if (item_tag_name === 'circle' || item_tag_name === 'line' || item_tag_name === 'polyline') {
							var temp_svg_container = e_change.item.context.document.createElement('div');
							temp_svg_container.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">' + e_change.item.all_html_render() + '</svg>';
							itemDomEl = temp_svg_container.childNodes[0].childNodes[0];
						} else {
							temp_el = e_change.item.context.document.createElement('div');
							temp_el.innerHTML = e_change.item.all_html_render();
							itemDomEl = temp_el.childNodes[0];
						}
						item.dom.el = itemDomEl;
						context.map_els[item._id()] = itemDomEl;
					};
				}
				var t_item_dom_el = tof(itemDomEl);
				if (t_item_dom_el === 'string') {
					itemDomEl = document.createTextNode(itemDomEl);
				}
				if (!itemDomEl) {}
				if (itemDomEl) {
					el.appendChild(itemDomEl);
					e_change.item.register_this_and_subcontrols();
				}
			} else if (type === 'clear') {
				if (el) {
					el.innerHTML = '';
				}
			} else if (type === 'remove') {
				if (e_change.value.dom.el) {
					e_change.value.dom.el.parentNode.removeChild(e_change.value.dom.el);
				}
			} else {
				console.trace();
				throw 'NYI - Unexpected change type. e_change: ' + e_change;
			}
		});
	}
	'rec_desc_ensure_ctrl_el_refs' (el) {
		el = el || this.dom.el;
		var context = this.context;
		if (el) {
			var c, l, cns;
			var jsgui_id;
			var map_els = {};
			dom_desc(el, el => {
				if (el.getAttribute) {
					jsgui_id = el.getAttribute('data-jsgui-id');
					if (jsgui_id) {
						map_els[jsgui_id] = el;
						context.map_els[jsgui_id] = el;
					}
				}
			});
			desc(this, (ctrl) => {
				var t_ctrl = tof(ctrl);
				if (ctrl !== this && t_ctrl === 'control') {
					var id = ctrl._id();
					if (map_els[id]) {
						if (ctrl.dom.el !== map_els[id]) {
							ctrl.dom.el = map_els[id];
						} else {}
					}
					ctrl.activate();
				}
			});
		}
	}
	'rec_desc_activate' () {
		desc(this, ctrl => {
			const t_ctrl = tof(ctrl);
			if (t_ctrl === 'control') {
				ctrl.activate();
			}
		});
	}
	'activate_content_controls' () {
		const do_activation = () => {
			if (!this.dom.el) {
				let found_el = this.context.get_ctrl_el(this);
				if (found_el) {
					this.dom.el = found_el;
				}
			}
			const el = this.dom.el;
			if (el) {
				const context = this.context;
				let ctrl_fields = {},
					c, l;
				if (el.getAttribute) {
					let cns = el.childNodes;
					let content = this.content;
					for (c = 0, l = cns.length; c < l; c++) {
						let cn = cns[c];
						if (cn) {
							let nt = cn.nodeType;
							if (nt === 1) {
								let cn_jsgui_id = cn.getAttribute('data-jsgui-id');
								let cctrl = context.map_controls[cn_jsgui_id];
								let found = false;
								if (cctrl) {
									cctrl.activate();
								}
							}
						}
					}
				}
			} else {
			}
		}
		do_activation();
	}
	'pre_activate_content_controls' () {
		const do_pre_activation = () => {
			if (!this.dom.el) {
				let found_el = this.context.get_ctrl_el(this);
				if (found_el) {
					this.dom.el = found_el;
				}
			}
			const el = this.dom.el;
			if (el) {
				const context = this.context;
				let ctrl_fields = {},
					c, l;
				if (el.getAttribute) {
					let str_ctrl_fields = el.getAttribute('data-jsgui-ctrl-fields');
					if (str_ctrl_fields) {
						ctrl_fields = JSON.parse(str_ctrl_fields.replace(/'/g, '"'));
					}
					let ctrl_fields_keys = Object.keys(ctrl_fields);
					let l_ctrl_fields_keys = ctrl_fields_keys.length;
					let key, value;
					for (c = 0; c < l_ctrl_fields_keys; c++) {
						key = ctrl_fields_keys[c];
						value = ctrl_fields[key];
						this[key] = context.map_controls[value];
					}
					let cns = el.childNodes;
					let content = this.content;
					for (c = 0, l = cns.length; c < l; c++) {
						let cn = cns[c];
						if (cn) {
							let nt = cn.nodeType;
							if (nt === 1) {
								let cn_jsgui_id = cn.getAttribute('data-jsgui-id');
								let cctrl = context.map_controls[cn_jsgui_id];
								let found = false;
								if (cctrl) {
									let ctrl_id = cctrl.__id;
									if (ctrl_id) {
										content.each((v, i) => {
											if (v.__id) {
												if (v.__id === ctrl_id) found = true;
											}
										});
									}
									if (!found) {
										content._arr.push(cctrl);
									}
									cctrl.parent = this;
								}
							}
							if (nt === 3) {
								const i_sibling = c;
								const corresponding_ctrl = content._arr[i_sibling];
								if (corresponding_ctrl) {
									if (corresponding_ctrl.text === cn.nodeValue) {
										corresponding_ctrl.dom.el = cn;
									}
								} else {
									console.log('&&& no corresponding control');
								}
								const do_add = () => {
									let val = cn.nodeValue;
									console.log('adding Text_Node control', val);
									const tn = new Text_Node({
										context: this.context,
										text: val,
										el: cn
									})
									content.add(tn);
								}
							}
						}
					}
				}
			} else {
			}
		}
		do_pre_activation();
	}
	'load_dom_attributes_from_dom' () {
		const el = this.dom.el;
		const dom_attributes = this.dom.attributes;
		let item, name, value, i;
		if (el) {
			const attrs = el.attributes;
			if (attrs) {
				const l = attrs.length
				for (i = 0; i < l; i++) {
					item = attrs.item(i);
					name = item.name;
					value = item.value;

					/*
					if (name === 'data-jsgui-id') {} else if (name === 'data-jsgui-type') {} else if (name === 'style') {
						dom_attributes[name] = value;
					} else if (name === 'class') {
						dom_attributes[name] = value;
					} else {
						dom_attributes[name] = value;
					}
						*/

					dom_attributes[name] = value;
				}
			}
		}
	}
	'_search_descendents' (search) {
		const recursive_iterate = (ctrl, item_callback) => {
			const content = ctrl.content,
				t_content = tof(content);
			if (t_content === 'collection') {
				if (content.length() > 0) {
					content.each((item, i) => {
						item_callback(item);
						recursive_iterate(item, item_callback);
					})
				}
			}
		}
		const arr_matching = [];
		recursive_iterate(this, (item) => {
			const item_type = item.__type_name;
			if (item_type === search) {
				arr_matching.push(item);
			} else {}
		});
		return arr_matching;
	}
	'_search_ancestor' (search) {
		const parent = this.parent;
		if (parent) {
			if (parent === search) {
				return true;
			} else {
				if (typeof parent.ancestor === 'function') {
					return parent.ancestor(search);
				}
			}
		} else {
			return false;
		}
	}
	'add' (new_content) {
		const {
			context
		} = this;
		if (context) {
			const m = context.map_controls_being_added_in_frame = context.map_controls_being_added_in_frame || {};
			const tnc = tof(new_content);
			if (tnc === 'array') {
				each(new_content, (v) => {
					const candd = v.this_and_descendents;
					if (candd) {
						each(candd, ctrl => {
							if (ctrl._id) {
								m[ctrl._id()] = ctrl;
							}
						})
					}
				});
			} else {
				if (new_content) {
					const candd = new_content.this_and_descendents;
					if (candd) {
						each(candd, ctrl => {
							if (ctrl._id) {
								m[ctrl._id()] = ctrl;
							}
						})
					}
				}
			}
		}
		return super.add(new_content);
	}
	'clear' () {
		const {
			context
		} = this;
		context.map_controls_being_removed_in_frame = context.map_controls_being_removed_in_frame || {};
		each(this.descendents, ctrl => {
			if (ctrl._id) context.map_controls_being_removed_in_frame[ctrl._id()] = ctrl;
		});
		super.clear();
	}
};
let p = Control.prototype;
p.on = p.add_event_listener;
p.off = p.remove_event_listener;
module.exports = Control;
},{"../control_mixins/model_data_view_compositional_representation":55,"./control-core":146,"./text-node":153,"fnl":6,"jsgui3-gfx-core":14,"lang-tools":186}],148:[function(require,module,exports){
//var Control = require('./control-enh');


const Control = require('./Data_Model_View_Model_Control');

module.exports = Control;
},{"./Data_Model_View_Model_Control":143}],149:[function(require,module,exports){
const jsgui = require('lang-tools');
const Text_Node = require('./text-node');
const Page_Context = require('./page-context');
const Selection_Scope = require('./selection-scope');
const Control_Data = require('./Control_Data');
const Control_View = require('./Control_View');
const {parse_mount, parse} = require('./parse-mount');
const {str_arr_mapify, get_a_sig, each, prop} = jsgui;
//const Control = jsgui.Control = require('./control-enh');

const Control = jsgui.Control = require('./Data_Model_View_Model_Control');
jsgui.load_type('control', 'C', item => (item instanceof Control));
const Evented_Class = jsgui.Evented_Class;
var tof = jsgui.tof;
var map_Controls = jsgui.map_Controls = {};
const def = jsgui.is_defined;
var core_extension = str_arr_mapify(function (tagName) {
    jsgui.controls[tagName] = jsgui[tagName] = class extends Control {
        constructor(spec) {
            let str;
            if (typeof spec === 'string') {
                str = spec;
                spec = {
                    __type_name: tagName
                } 
            } else {
                if (typeof spec === 'object') {
                    spec.__type_name = tagName;
                }
            }
            super(spec);
            this.dom.tagName = tagName;
        }
    };
    jsgui[tagName].prototype._tag_name = tagName;
    map_Controls[tagName] = jsgui[tagName];
});
var core_extension_no_closing_tag = str_arr_mapify(function (tagName) {
    jsgui[tagName] = class extends Control {
        constructor(spec) {
            spec.__type_name = tagName;
            super(spec);
            this.dom.tagName = tagName;
            this.dom.noClosingTag = true;
        }
    };
    jsgui[tagName].prototype._tag_name = tagName;
    map_Controls[tagName] = jsgui[tagName];
});
var recursive_dom_iterate = function (el, callback) {
    callback(el);
    var cns = el.childNodes;
    for (var c = 0, l = cns.length; c < l; c++) {
        recursive_dom_iterate(cns[c], callback);
    }
}
var recursive_dom_iterate_depth = function (el, callback) {
    var cns = el.childNodes;
    for (var c = 0, l = cns.length; c < l; c++) {
        recursive_dom_iterate_depth(cns[c], callback);
    }
    callback(el);
}
const pre_activate = (context) => {
    console.log('jsgui html-core pre_activate');
    if (!context) {
        throw 'jsgui-html-enh pre_activate(context) - need to supply context parameter.';
    }
    const map_controls = context.map_controls || {};
    var map_jsgui_els = {};
    var map_jsgui_types = {};
    var arr_controls = [];
    var max_typed_ids = {};
    const map_ctrl_parent_ids_by_ctrl_ids = {};
    var id_before__ = function (id) {
        var pos1 = id.lastIndexOf('_');
        var res = id.substr(0, pos1);
        return res;
    }
    var num_after = function (id) {
        return parseInt(id.substr(id.lastIndexOf('_') + 1), 10);
    }
    let map_els = () => {
        recursive_dom_iterate(document, el => {
            const nt = el.nodeType;
            if (nt === 1) {
                const jsgui_id = el.getAttribute('data-jsgui-id');
                if (jsgui_id) {
                    if (el.parentNode) {
                        if (el.parentNode.nodeType === 1) {
                            const parent_jsgui_id = el.parentNode.getAttribute('data-jsgui-id');
                            if (parent_jsgui_id) {
                                map_ctrl_parent_ids_by_ctrl_ids[jsgui_id] = parent_jsgui_id;
                            }
                        }
                    }
                    const ib = id_before__(jsgui_id), num = num_after(jsgui_id);
                    if (!def(max_typed_ids[ib])) {
                        max_typed_ids[ib] = num;
                    } else {
                        if (num > max_typed_ids[ib]) max_typed_ids[ib] = num;
                    }
                    map_jsgui_els[jsgui_id] = el;
                    var jsgui_type = el.getAttribute('data-jsgui-type');
                    if (jsgui_type) map_jsgui_types[jsgui_id] = jsgui_type;
                }
            }
        });
    }
    map_els();
    context.set_max_ids(max_typed_ids);
    each(map_jsgui_els, (el, jsgui_id) => {
        const l_tag_name = el.tagName.toLowerCase();
        if (jsgui_id) {
            var type = map_jsgui_types[jsgui_id];
            if (!map_controls[jsgui_id]) {
                var Cstr = context.map_Controls[type];
                if (Cstr) {
                    const parent_jsgui_id = map_ctrl_parent_ids_by_ctrl_ids[jsgui_id];
                    const ctrl_spec = {
                        'context': context,
                        '__type_name': type,
                        'id': jsgui_id,
                        'el': el
                    }
                    if (parent_jsgui_id) {
                        if (map_controls[parent_jsgui_id]) {
                        }
                    }
                    var ctrl = new Cstr(ctrl_spec);
                    if (parent_jsgui_id) {
                        if (map_controls[parent_jsgui_id]) {
                        }
                    }
                    arr_controls.push(ctrl);
                    if (l_tag_name === 'html') {
                        context.ctrl_document = ctrl;
                    }
                    map_controls[jsgui_id] = ctrl;
                } else {
                    console.log('Missing context.map_Controls for type ' + type + ', using generic Control');
                    var ctrl = new Control({
                        'context': context,
                        '__type_name': type,
                        'id': jsgui_id,
                        'el': el
                    });
                    arr_controls.push(ctrl);
                    map_controls[jsgui_id] = ctrl;
                }
            } else {
                var ctrl = map_controls[jsgui_id];
                ctrl.dom.el = el;
                if (ctrl.attach_dom_events) ctrl.attach_dom_events();
            }
        }
    });
    recursive_dom_iterate_depth(document, (el) => {
        var nt = el.nodeType;
        if (nt === 1) {
            var jsgui_id = el.getAttribute('data-jsgui-id');
            if (jsgui_id) {
                const ctrl = map_controls[jsgui_id];
                ctrl.pre_activate(ctrl.dom.el);
            }
        }
    });
}
const activate = function (context) {
    const map_controls = context.map_controls;
    console.log('jsgui html-core activate');
    console.log('jsgui.def_server_resources', jsgui.def_server_resources);
    if (!context) {
        throw 'jsgui-html-enh activate(context) - need to supply context parameter.';
    }
    recursive_dom_iterate_depth(document, (el) => {
        var nt = el.nodeType;
        if (nt === 1) {
            var jsgui_id = el.getAttribute('data-jsgui-id');
            if (jsgui_id) {
                const ctrl = map_controls[jsgui_id];
                ctrl.activate(ctrl.dom.el);
            }
        }
    });
};
jsgui.controls = jsgui.controls || {
    Control
};

// Maybe get rid of this, should work in abstract anyway.
jsgui.controls.span = jsgui.span = class span extends Control {
    constructor(spec) {
        spec.__type_name = 'span';
        super(spec);
        this.dom.tagName = 'span';
        spec = spec || {};
        prop(this, 'text', spec.text || '');
        this.on('change', e_change => {
            const {name} = e_change;
            if (name === 'text') {
                if (this.content._arr.length === 1) {
                    if (this.content._arr[0] instanceof Text_Node) {
                        this.content._arr[0].text = e_change.value;
                    }
                } else {
                    if (this.content._arr.length === 0) {
                    } else {
                        console.log('this.content._arr', this.content._arr);
                        console.trace();
                        throw 'NYI';
                    }
                }
            }
        })
        if (!spec.el) {
            this.compose_span();
        }
    }
    compose_span() {
        if (this.text && this.text.length > 0) {
            this.add(this.tn = this.text_node = new Text_Node({
                context: this.context,
                text: this.text
            }));
        }
    }
}
class String_Control extends Control {
    constructor(spec = {}) {
        spec.__type_name = 'string_control';
        super(spec);
        this.dom.tagName = undefined;
        spec = spec || {};
        if (typeof spec.text !== 'undefined') {
            this._text = spec.text;
        } else {
            this._text = '';
        }
        if (!spec.el) {
        }
    }
    get text() {
        return this._text;
    }
    set text(value) {
        this._text = value;
        this.raise('change', {
            'name': 'text',
            'value': value
        });
    }
    all_html_render() {
        return this._text;
    }
    activate() {
    }
}
jsgui.pre_activate = pre_activate;
jsgui.activate = activate;
core_extension('html head title body div select option h1 h2 h3 h4 h5 h6 label p a script link button form textarea img ul li audio video table tr td caption thead colgroup col svg defs marker polygon line section code samp canvas');
core_extension_no_closing_tag('link input meta');
class HTML_Document extends jsgui.Control {
    constructor(spec = {}) {
        spec.tag_name = 'html';
        super(spec);
    }
}
class Blank_HTML_Document extends HTML_Document {
    constructor(spec = {}) {
        super(spec);
        var context = this.context;
        if (!spec.el) {
            var head = new jsgui.head({
                'context': context
            });
            this.content.add(head);
            var title = new jsgui.title({
                'context': context
            });
            head.content.add(title);
            var body = new jsgui.body({
                'context': context
            });
            this.content.add(body);
            this.head = head;
            this.title = title;
            this.body = body;
        }
    }
    'body'() {
        var a = arguments;
        a.l = arguments.length;
        var sig = get_a_sig(a, 1);
        if (sig == '[]') {
            var content = this.content;
            var body = content.get(1);
            return body;
        }
    }
};
class Intersection_Finder extends Evented_Class {
    constructor(spec) {
        super(spec);
        let coords_ctrls;
        let update_ctrl_coords = () => {
            coords_ctrls = [];
            each(spec.controls || spec.ctrls, ctrl => {
                coords_ctrls.push([ctrl.bcr(), ctrl]);
            });
        }
        let map_selected = new Map();
        let find_intersections = (coords) => {
            update_ctrl_coords();
            let intersecting = [],
                newly_intersecting = [],
                previously_intersecting = [];;
            let [btl, bbr] = coords;
            each(coords_ctrls, cc => {
                let [ccoords, ctrl] = cc;
                let [cpos, cbr, csize] = ccoords;
                let intersect = (cpos[0] <= bbr[0] &&
                    btl[0] <= cbr[0] &&
                    cpos[1] <= bbr[1] &&
                    btl[1] <= cbr[1])
                if (intersect) {
                    if (map_selected.get(ctrl) !== true) {
                        newly_intersecting.push(ctrl);
                        map_selected.set(ctrl, true);
                    }
                    intersecting.push(ctrl);
                } else {
                    if (map_selected.get(ctrl) === true) {
                        previously_intersecting.push(ctrl);
                        map_selected.set(ctrl, false);
                    }
                }
            });
            return [intersecting, newly_intersecting, previously_intersecting];
        }
        prop(this, 'coords', (transform_coords) => {
            if (transform_coords[0][1] > transform_coords[1][1]) {
                let [a, b] = transform_coords;
                transform_coords = [b, a];
            }
            if (transform_coords[0][0] > transform_coords[1][0]) {
                let a = transform_coords[1][0];
                transform_coords[1][0] = transform_coords[0][0];
                transform_coords[0][0] = a;
            }
            return transform_coords;
        }, (change_coords) => {
            let intersections = find_intersections(change_coords[0]);
            if (intersections[1].length > 0 || intersections[2].length > 0) {
                this.raise('change', {
                    'name': 'intersections',
                    'value': intersections
                });
            }
        });
        this.find_intersections = find_intersections;
    }
}
class Relative extends Control {
    constructor(spec) {
        spec.class = 'relative';
        super(spec);
    }
}

//jsgui.Active_HTML_Document = require('./Active_HTML_Document');

jsgui.Control_Data = Control_Data;
jsgui.Control_View = Control_View;
jsgui.Relative = Relative;
jsgui.String_Control = jsgui.controls.String_Control = String_Control;
jsgui.HTML_Document = HTML_Document;
jsgui.Blank_HTML_Document = Blank_HTML_Document;
jsgui.Text_Node = jsgui.controls.Text_Node = jsgui.Text_Node = jsgui.controls.Text_Node = Text_Node;
jsgui.Page_Context = Page_Context;
jsgui.Selection_Scope = Selection_Scope
jsgui.Intersection_Finder = Intersection_Finder;
jsgui.parse_mount = parse_mount;
jsgui.parse = parse;
module.exports = jsgui;
},{"./Control_Data":130,"./Control_View":135,"./Data_Model_View_Model_Control":143,"./page-context":150,"./parse-mount":151,"./selection-scope":152,"./text-node":153,"lang-tools":186}],150:[function(require,module,exports){
const jsgui = require('lang-tools');
const {each, tof, is_defined, get_a_sig, Evented_Class, Data_Model} = jsgui;
const Selection_Scope = require('./selection-scope');
class Page_Context extends Evented_Class {
    constructor(spec) {
        spec = spec || {};
        super(spec);
        if (spec.browser_info) {
            this.browser_info = spec.browser_info;
        };
        if (spec.resource_pool) {
            this.resource_pool = spec.resource_pool;
        }
        this.get_vector_methodology = function () {
            if (this.browser_info.ie) {
                return 'vml';
            } else {
                return 'svg';
            }
        };
        this.selection_scopes = {};
        this.selection_scope_id_counter = 0;
        var map_new_ids = {};
        var map_objects = {};
        var _get_new_typed_object_id = (type_name) => {
            if (!is_defined(map_new_ids[type_name])) {
                map_new_ids[type_name] = 0;
            }
            var res = type_name + '_' + map_new_ids[type_name];
            map_new_ids[type_name]++;
            return res;
        }
        this.new_id = _get_new_typed_object_id;
        this.set_max_ids = (map_max_ids) => {
            each(map_max_ids, (v, i) => {
                map_new_ids[i] = v + 1;
            })
        }
        var map_Controls = this.map_Controls = {};
        var map_controls = this.map_controls = {};
        this.map_data_models = this.map_data_models || {};
        this.map_data_model_iids = this.map_data_model_iids || {};
        this.map_control_iids = {};
        this.next_iid = 1;
    }
    'new_selection_scope'(ctrl) {
        var res = new Selection_Scope({
            'context': this,
            'id': this.selection_scope_id_counter++,
            'ctrl': ctrl
        })
        this.selection_scopes[res.id] = res;
        if (ctrl) {
            ctrl.selection_scope = res;
            if (typeof document === 'undefined') {
                ctrl._fields = ctrl._fields || {};
                ctrl._fields.selection_scope = res.id;
            }
        }
        return res;
    }
    'make' (source) {
        let t_source = tof(source);
        if (t_source === 'string') {
            let parsed = jsgui.parse_and_mount(source, this);
        }
    }
    'update_Controls' () {
        var a = arguments;
        a.l = arguments.length;
        var sig = get_a_sig(a, 1);
        if (sig === '[o]') {
            var o = a[0];
            var map_Controls = this.map_Controls;
            each(o, (name, Constructor) => {
                name = name.toLowerCase();
                map_Controls[name] = Constructor;
            });
        }
        if (sig === '[s,f]') {
            var name = a[0];
            var Constructor = a[1];
            name = name.toLowerCase();
            this.map_Controls[name] = Constructor;
        }
    }
    'register_control' (control) {
        control.context = this;
        var id = control._id();
        this.map_controls[id] = control;
        control.iid = this.next_iid;
        this.map_control_iids[id] = this.next_iid++;
    }
    register_data_model(data_model) {
        if (data_model instanceof Data_Model) {
            const id = data_model._id();
            this.map_data_models[id] = data_model;
            data_model.iid = this.next_iid;
            this.map_data_model_iids[id] = this.next_iid++;
        } else {
            console.trace();
            throw 'Expected Data_Model instance';
        }
    }
    'first_ctrl_matching_type' (type_name) {
        var res;
        each(this.map_controls, (ctrl, ctrl_id, fn_stop) => {
            if (ctrl.__type_name === type_name) {
                fn_stop();
                res = ctrl;
            }
        });
        return res;
    }
}
module.exports = Page_Context;
},{"./selection-scope":152,"lang-tools":186}],151:[function(require,module,exports){
//const htmlparser = require('htmlparser');

// htmlparser2
//  faster? used in cheerio (like jQuery)

// page_context.map_Ctrls
//  then it will create the controls using the appropriate constructors.

// It's appropriate to make this before making the Business Suite controls.

// Mount content into a control - meaning the control itself would need to be changed.

// parse_mount function will just create the controls.
//  they could then be put into a DOM.

var htmlparser = require("htmlparser");
const {tof, each} = require('lang-tools');

const map_jsgui_attr_names = {
    'name': true,
    'class': true,
    'content': true,
    '__type_name': true,
    'context': true,
    'key': true,
    'size': true
}

// Maybe redo this, making use of a recursion function.

// Just parse and add?
// Parse and instantiate?
// Parse and construct?

const log = () => {}
const parse = function(str_content, context, control_set, callback) {
    //console.log('Parsing');
    //console.log('-------');
    //console.log('');
    str_content = str_content.trim();

    const handler = new htmlparser.DefaultHandler(function (error, dom) {
        if (error) {
            log('parse error', error);
        }
            //[...do something for errors...]
        else {
            log('dom', dom);
            
            let recurse = (dom, depth, callback) => {
                let tdom = tof(dom);
                let res;
                log('tdom', tdom);
                log('dom item', dom);

                if (tdom === 'array') {
                    //res = [];
                    each(dom, (v, i) => {
                        //res.push(recurse)
                        recurse(v, depth + 1, callback);
                        // then later (depth first) callback
                        callback(v, depth, i);

                    })
                } else if (tdom === 'object') {
                    if (dom.children) {
                        each(dom.children, (child, i) => {
                            recurse(child, depth + 1, callback);

                            callback(child, depth, i);
                        })
                    }
                } else {
                    log('dom', dom);
                }
            }
            let last_depth = 0;
            let map_siblings_at_depth = {};
            let res_controls = {};
            const handle_text = (text, depth, sibling_index) => {
                // Not so sure we can give it the parent right here.
                //  Can only reconnect it once it's been put into the DOM.

                let tn = new control_set.Text_Node({
                    text: text,
                    context: context,
                    sibling_index: sibling_index
                });
                res_controls.unnamed = res_controls.unnamed || [];
                res_controls.unnamed.push(tn);
                map_siblings_at_depth[depth] = map_siblings_at_depth[depth] || [];
                map_siblings_at_depth[depth].push(tn);
                last_depth = depth;

                // Any way of reconnecting the text node back with the DOM element?
                //  sibling_index property could help them to be reconnected later on, once its in the DOM.

                // Does seem like work on reconnecting text content / nodes with the activation of controls will be useful.
                //  Want the jsgui text node controls to have a reference to the DOM node.

                // Will look them up using the sibling index.

            }

            const handle_tag = (tag, depth, sibling_index) => {
                //console.log('handle_tag tag', tag);
                //console.log('depth', depth);
                //console.log('last_depth', last_depth);
                const tag_with_no_children = {};
                if (tag.raw) tag_with_no_children.raw = tag.raw;
                if (tag.data) tag_with_no_children.data = tag.data;
                if (tag.type) tag_with_no_children.type = tag.type;
                if (tag.name) tag_with_no_children.name = tag.name;
                if (tag.attribs) tag_with_no_children.attribs = tag.attribs;

                // Probably only worth giving the sibling index for text nodes, as that's where its needed to reconnect them.
                //  Need to make sure things work right with non-parse-mount too.

                const create_ctrl = (tag, content) => {

                    //console.log('tag.name', tag.name);
                    //console.log('!!control_set[tag.name]', !!control_set[tag.name]);

                    if (control_set[tag.name]) {
                        let Ctrl = control_set[tag.name];
                        log('tag', tag);
                        let a = tag.attribs || {};
                        if (content) a.content = content;
                        each(content, item => {
                            //log('content item', item);
                            //log('Object.keys(content item)', Object.keys(item));
                            //log('(content item.__type_name)', (item.__type_name));
                            //log('(content item._text)', (item._text));
                            //log('(content item.text)', (item.text));
                        })
                        // want an easier way to view the content.
                        //  don't want large printouts of the jsgui controls.
                        log('attribs a', a);
                        log('\n\n');
                        //log('!!target', !!target);
                        //log('!!target.context', !!target.context);
                        a.context = context;
                        let ctrl = new Ctrl(a);
                        if (a.name) {
                            res_controls.named = res_controls.named || {};
                            res_controls.named[a.name] = ctrl;
                        } else {
                            res_controls.unnamed = res_controls.unnamed || [];
                            res_controls.unnamed.push(ctrl);
                        }
                        
                        const arr_dom_attrs = [];
                        each(a, (a_value, a_name) => {
                            if (!map_jsgui_attr_names[a_name]) {
                                arr_dom_attrs.push([a_name, a_value])
                            }
                        })
                        each(arr_dom_attrs, attr => {
                            const [name, value] = attr;
                            ctrl.dom.attributes[name] = value;
                        });
                        return ctrl;
                    } else {
                        // The app's controls need to be loaded / registered previous to this.
                        //log('lacking jsgui control for ' + tag.name);
                        // The server app should register it?
                        //console.log('tag', tag);
                        console.trace();
                        throw 'lacking jsgui control for ' + tag.name;
                    }
                }
                let my_children;
                let ctrl;

                if (depth > last_depth) {
                    ctrl = create_ctrl(tag_with_no_children);
                    map_siblings_at_depth[depth] = []; // because its a new depth?
                    map_siblings_at_depth[depth].push(ctrl);

                } else if (depth < last_depth) {
                    //console.log('depth decrease');
                    my_children = map_siblings_at_depth[last_depth];
                    if (my_children) {
                        ctrl = create_ctrl(tag_with_no_children, my_children);
                    } else {
                        ctrl = create_ctrl(tag_with_no_children);
                    }
                    map_siblings_at_depth[depth] = map_siblings_at_depth[depth] || [];
                    map_siblings_at_depth[last_depth] = null;
                    map_siblings_at_depth[depth].push(ctrl);
                } else {
                    ctrl = create_ctrl(tag_with_no_children);
                    map_siblings_at_depth[depth] = map_siblings_at_depth[depth] || [];
                    map_siblings_at_depth[depth].push(ctrl);
                }
                // Create a control out of the tag
                last_depth = depth;
            }
            // goes depth-first.
            //  want the item's sibling index too.
            recurse(dom, 0, (item, depth, sibling_index) => {
                if (item.type === 'text') {
                    let trimmed = item.data.trim();
                    //log('trimmed', trimmed);
                    //log('trimmed.length', trimmed.length);
                    if (trimmed.length > 0) {
                        handle_text(item.raw, depth, sibling_index);
                    }
                    // Need to rapidly 
                } else if (item.type === 'tag') {
                    // does it have children?
                    // if not, create a control from the children.
                    // then if it does, what are its control children?
                    //log('tag item', item);
                    //log('item.children.length', item.children.length);
                    handle_tag(item, depth, sibling_index);
                }
            });
            const depth_0_ctrls = map_siblings_at_depth[0];
            callback(null, [depth_0_ctrls, res_controls]);
        }
            //[...parsing done, do something...]
    });
    var parser = new htmlparser.Parser(handler);
    parser.parseComplete(str_content);
}

// Not sure why this separation breaks things.
//  Timing - cant be async, needs to be immediate with callback. Cant await the parsing promise and have it work.


// Maybe change back to old parse_mount and fix tomorrow?
//  Or parse function will always / just use a callback?

const parse_mount = function(str_content, target, control_set) {
    // And this should be a promise too, it seems.
    //  Not so sure though.
    //  Promise puts in some kind of a delay.

    // Maybe this fn would be better with a callback too.
    return new Promise(async(solve, jettison) => {
        let container;
        let a = arguments;
        let l = a.length;
        if (l === 4) {
            container = a[2];
            control_set = a[3];
        } else {
            container = target;
        }
        const {context} = target;
        // And make it async to announce when it's complete?
        //  Won't take long though.

        //const [depth_0_ctrls, res_controls] = await parse(str_content, context, control_set);

        parse(str_content, context, control_set, (err, res_parse) => {
            if (err) {
                jettison(err);
            } else {

                const [depth_0_ctrls, res_controls] = res_parse;

                //console.log('depth_0_ctrls', depth_0_ctrls);
                //console.log('res_controls', res_controls);

                // Go through all named controls.
                //  Set the name of target[a.name] = ctrl;
                each(res_controls.named, (ctrl, name) => {
                    //console.log('name', name);
                    target[name] = ctrl;
                });
                const is_active_context = context.__is_active;

                //console.log('is_active_context', is_active_context);
                //console.log('depth_0_ctrls.length', depth_0_ctrls.length);
                each(depth_0_ctrls, new_ctrl => {
                    //console.log('pre add new_ctrl');

                    // how many children within this control?
                    //console.log('');
                    //console.log('new_ctrl._id()', new_ctrl._id());
                    //console.log('new_ctrl', new_ctrl);

                    // parse does not add content (correctly) to the first level 0.

                    container.add(new_ctrl);
                    // activate it here?
                    //  test to see if it's in an active context?
                    //console.log('is_active_context', is_active_context);
                    // Wait...?
                    //  May be better to integrate auto activation at a lower level.

                    if (is_active_context) {
                        setTimeout(() => {
                            new_ctrl.activate();
                        }, 0);
                    }
                });
                
                //log('res_controls', res_controls);
                //log('Object.keys(res_controls)', Object.keys(res_controls));
                //console.log('Object.keys(res_controls.named)', Object.keys(res_controls.named));

                // Go through the named controls.
                // should have both .named and .unnamed

                // Maybe don't bother with this?
                //  Are they all named?
                //   Or reconstruct it?

                //console.log('!!res_controls.named', !!res_controls.named);

                if (res_controls.named) {
                    target._ctrl_fields = target._ctrl_fields || {};
                    Object.assign(target._ctrl_fields, res_controls.named);
                }

                solve(depth_0_ctrls);

            }
        })



        


    })


    
    

}





// with 4 params - have a target, and a container

const ____old_parse_mount = function(str_content, target, control_set) {

    let container;
    let a = arguments;
    let l = a.length;
    if (l === 4) {
        container = a[2];
        control_set = a[3];
    } else {
        container = target;
    }
    // Add it to the container (may be subcontrol). Mount it to the target.
    // A promise would probably do for the moment.
    //  could use var DOMParser = require('xmldom').DOMParser;

    // May need to make some nice isomorphic code for browser and node.

    console.log('parse_mount str_content', str_content);
    // Unfortunately seems like it will be async when using htmlparser?
    //  Or need a callback?
    //  Make a new parser, find one, use integrated parser somehow?

    // Parse the str_content into a DOM.
    //  parse-mounts into the target

    // Comes up with a spec for each of the items parsed.

    // remove white space first

    str_content = str_content.trim();

    const {context} = target;

    //log('parse_mount str_content', str_content);
    //log('target._id()', target._id());

    // Recursively go through the html-like, creating jsgui controls.
    //  This will enable much more concise expression of jgsui controls.

    //var rawHtml = "Xyz <script language= javascript>var foo = '<<bar>>';< /  script><!--<!-- Waah! -- -->";
    var handler = new htmlparser.DefaultHandler(function (error, dom) {
        if (error) {
            log('parse error', error);
        }
            //[...do something for errors...]
        else {
            log('dom', dom);
            // Then can recurse through the dom object.
            //  Nice that it parses non-standard elements.

            // depth-first recursion for creation of the elements.
            //  Then will add them to the parents as they get created.
            // replace the children with controls?

            // when doing 

            let recurse = (dom, depth, callback) => {
                let tdom = tof(dom);
                let res;
                log('tdom', tdom);
                log('dom item', dom);

                if (tdom === 'array') {
                    //res = [];
                    each(dom, v => {
                        //res.push(recurse)
                        recurse(v, depth + 1, callback);

                        // then later (depth first) callback
                        callback(v, depth);

                    })
                } else if (tdom === 'object') {
                    if (dom.children) {
                        each(dom.children, child => {
                            recurse(child, depth + 1, callback);

                            callback(child, depth);
                        })
                    }
                } else {
                    log('dom', dom);
                }
            }
            // want to create the items as well.
            //  start with innermost, adding the child controls to the outer ones.
            //   need to be able to run controls from these strings which come as templates.
            //   eliminate the need for much of the control construction code, at least make it much more concise.


            /*
            const new_ctrl_made = (ctrl) => {
                // this will need to assemble to controls into a heirachy.
                //  May need to know the depth so to know which to join together.

                // includes text controls
            }
            */

            // handle text
            //  should know what level the text is at
            //   needs to know when the level decreases so we can put the children in the parent.

            let last_depth = 0;

            // maybe need a map of siblings at depth
            //let child_nodes = [];
            // siblings in a list, children in a list?
            //  or only need one list with depth-first?
            // can build it up within the closure.

            // sounds like we need it as we add to the tree at different depths.
            // map of open arrays at different depths?

            // need to push the text node at the depth.

            let map_siblings_at_depth = {};
            // Then when moving up a depth we nullify the array
            //  Then moving down the depth we create a new array.
            //  Do this for controls.
            //  Including text controls.

            let res_controls = {};

            const handle_text = (text, depth) => {

                //child_nodes.push(text);

                // Maybe don't need the text node control here.
                //  When we have the text as a single child, we can declare it as a property.
                //  However, the full text node instantiation makes sense for not taking shortcuts.

                let tn = new control_set.Text_Node({
                    text: text,
                    context: context
                });

                //log('tn', tn);
                //log('text', text);
                //log('tn instanceof Text_Node', tn instanceof control_set.Text_Node);
                //log('tn.text', tn.text);
                //log('tn._text', tn._text);
                //throw 'stop';
                res_controls.unnamed = res_controls.unnamed || [];
                res_controls.unnamed.push(tn);
                // push it into siblings at depth too.
                map_siblings_at_depth[depth] = map_siblings_at_depth[depth] || [];
                map_siblings_at_depth[depth].push(tn);

                // doesn't have a name though.
                //  there will be other unnamed controls that should be returned in the results.
                // The names maybe will not be so important.

                last_depth = depth;
            }

            // an array of siblings at levels
            //  then remove? the array when going up a level, use it as the children for a node?

            // need to be able to start up a node while specifying its content?
            //  including the content in the spec could work well.
            //   

            // Get rid of the span rendering shortcut?
            //  Always use the textNode?
            //  Have the .text property a shortcut to modifying that text node?

            // Span .text is really convenient in many cases.
            // Spans can contain other elements so it's worth being careful.

            // The .text shortcut looks like its not carrying out the underlying dom functionality.
            //  Better to have it do the underlying dom tasks properly, and then have sugar around that.

            // So don't have special rendering for the span element.
            // Divs / controls can take text nodes too.

            // Maybe have .text read-only.
            //  .set_text too?
            //  .set_text for convenience in some situations.
            //   In other situations, we use proper text nodes alongside whatever else goes inside a span.

            // the .text set and get property could stay for convienience.
            //  It needs to deal with textNode object underneith though.

            // General route is to handle things in the conventional DOM way on a lower level
            //  Then on a higher level there will be systems of convenience for the programmer.

            // So setting text will replace the content.
            //  Get rid of the specialised span rendering.
            //  Get rid of text property for the moment?
            //   Or have it do its stuff on a lower level.


            const handle_tag = (tag, depth) => {

                console.log('handle_tag tag', tag);

                const tag_with_no_children = {};
                if (tag.raw) tag_with_no_children.raw = tag.raw;
                if (tag.data) tag_with_no_children.data = tag.data;
                if (tag.type) tag_with_no_children.type = tag.type;
                if (tag.name) tag_with_no_children.name = tag.name;
                if (tag.attribs) tag_with_no_children.attribs = tag.attribs;

                // Then the name property - need to use these named controls to set the control's _ctrl_fields

                //log('handle_tag tag_with_no_children', tag_with_no_children);
                // maybe pass through the tag with no children. the children have been made into controls.

                // will add to the collection of siblings.
                // has the depth increased?
                // create control...

                // and the children? content
                const create_ctrl = (tag, content) => {
                    if (control_set[tag.name]) {
                        //log('has jsgui control for ' + tag.name);
    
                        // need to look into if there are child jsgui controls within this.
    
                        let Ctrl = control_set[tag.name];
                        // work out the spec as well.
                        log('tag', tag);
                        let a = tag.attribs || {};

                        // Why isnt content working in the spec?
                        //  Expecially with a Text_Node?
                        if (content) a.content = content;
                        //log('content.length', content.length);

                        each(content, item => {
                            //log('content item', item);
                            //log('Object.keys(content item)', Object.keys(item));
                            //log('(content item.__type_name)', (item.__type_name));
                            //log('(content item._text)', (item._text));
                            //log('(content item.text)', (item.text));
                        })

                        // want an easier way to view the content.
                        //  don't want large printouts of the jsgui controls.



                        log('attribs a', a);
                        log('\n\n');
                        //log('!!target', !!target);
                        //log('!!target.context', !!target.context);
                        a.context = context;
    
                        let ctrl = new Ctrl(a);
                        if (a.name) {
                            res_controls.named = res_controls.named || {};
                            res_controls.named[a.name] = ctrl;

                            // Expected behaviour to replace existing composition code.
                            target[a.name] = ctrl;

                            //res_controls[a.name] = ctrl;
                        } else {
                            res_controls.unnamed = res_controls.unnamed || [];
                            res_controls.unnamed.push(ctrl);
                        }
                        // and unnamed controls
                        //  an array of them...
    
                        // The name property - possibly name could be stored by the control itself.
                        //  Different to its id.
    
                        //log('!!ctrl', !!ctrl);
                        //log('depth', depth);

                        return ctrl;
                    } else {
                        // The app's controls need to be loaded / registered previous to this.
                        //log('lacking jsgui control for ' + tag.name);

                        // The server app should register it?


                        //console.log('tag', tag);
                        console.trace();

                        throw 'lacking jsgui control for ' + tag.name;
                    }
                }

                // create the control at this stage?
                //  having a 'content' or 'children' property could work well here.
                //  setting .content would make sense well.

                let my_children;
                let ctrl;

                if (depth > last_depth) {

                    // Likely will happen.
                    //  The fix I put in got lost before.
                    //  It does not need to do that much where there are no child nodes.

                    

                    ctrl = create_ctrl(tag_with_no_children);
                    //map_siblings_at_depth[depth] = map_siblings_at_depth[depth] || [];

                    map_siblings_at_depth[depth] = []; // because its a new depth?
                    map_siblings_at_depth[depth].push(ctrl);

                    console.log('depth > last_depth [depth, last_depth]', [depth, last_depth]);
                    console.trace();
                    //throw 'NYI';

                    // Not sure how this will happen as the depth should move outwards?
                    //  Will need to check / measure recursion order.

                    // depth increase.
                    //  means moving to new child.
                    //   this does depth first, but starting from the first.
                    //    not sure that makes sense, need to check that it works.

                    // 
                    map_siblings_at_depth[depth] = [];

                    // but need to add the item.
                    //map_siblings_at_depth[depth].push();

                    //log('child_nodes', child_nodes);

                    //child_nodes = [];


                } else if (depth < last_depth) {

                    //log('child_nodes', child_nodes);
                    // create the control.

                    //child_nodes = [];
                    // my children in array!!!
                    //log('last_depth', last_depth);

                    my_children = map_siblings_at_depth[last_depth];
                    //log('my_children', my_children);

                    //throw 'stop';

                    if (my_children) {
                        //log('my_children.length', my_children.length);
                        ctrl = create_ctrl(tag_with_no_children, my_children);
                    } else {
                        ctrl = create_ctrl(tag_with_no_children);
                    }
                    //log('ctrl.content._arr.length', ctrl.content._arr.length);
                    map_siblings_at_depth[depth] = map_siblings_at_depth[depth] || [];

                    // do we need to keep these child controls now?
                    //  prob best not to.
                    map_siblings_at_depth[last_depth] = null;
                    map_siblings_at_depth[depth].push(ctrl);

                    // create the ctrl including the content.

                    // create the control with the children.
                    //  maybe just say they are 'content'.

                    // being able to choose content subcontrols at declaration seems very important here.


                } else {
                    ctrl = create_ctrl(tag_with_no_children);
                    map_siblings_at_depth[depth] = map_siblings_at_depth[depth] || [];
                    map_siblings_at_depth[depth].push(ctrl);

                    // I think that means that this one doesn't have children either.
                    // same depth - sibling
                    //  create a new control.
                    //   I think this means that the last control in the loop had no subcontrols.
                    // Will need to observe the algo in operation to make sure it works correctly.
                    //child_nodes.push(tag)

                }
                // Create a control out of the tag
                last_depth = depth;
            }

            // goes depth-first.
            recurse(dom, 0, (item, depth) => {
                //log('item', item);
                //log('depth', depth);

                // analyse the item
                //  is it an element (tag)?

                if (item.type === 'text') {
                    // These don't have children
                    //  They are also the inner-most.
                    // create a jsgui text node.
                    //log('text item', item);
                    // trim it

                    let trimmed = item.data.trim();
                    //log('trimmed', trimmed);
                    //log('trimmed.length', trimmed.length);

                    if (trimmed.length > 0) {
                        handle_text(item.raw, depth);
                    }
                    // Need to rapidly 
                } else if (item.type === 'tag') {
                    // does it have children?

                    // if not, create a control from the children.

                    // then if it does, what are its control children?

                    //log('tag item', item);
                    //log('item.children.length', item.children.length);

                    handle_tag(item, depth);

                    /*
                    if (!item.children) {
                        log('no children item', item);
                        throw 'stop';
                    }
                    */

                }
            });
            // Really not that good parse-mount being async.
            //  May need to fix that for it to work.
            //   Composition should be instant, but does not need to return a value.

            // Would be best to separate out the parsing.
            //
            // the parse result is the depth 0 controls.

            const depth_0_ctrls = map_siblings_at_depth[0];


            // then once the recursion is done, see what's at level 0
            //log('');
            //log('map_siblings_at_depth[0]', map_siblings_at_depth[0]);

            //log('map_siblings_at_depth[0].length', map_siblings_at_depth[0].length);

            //log('map_siblings_at_depth', map_siblings_at_depth);
            //throw 'stop';

            // context.__is_active?
            //  
            //const context = target.context;
            const is_active_context = context.__is_active;

            each(depth_0_ctrls, new_ctrl => {
                container.add(new_ctrl);

                // activate it here?
                //  test to see if it's in an active context?

                //console.log('is_active_context', is_active_context);

                // Wait...?
                //  May be better to integrate auto activation at a lower level.

                if (is_active_context) {
                    setTimeout(() => {
                        new_ctrl.activate();
                    }, 0);
                }

            });

            target._ctrl_fields = target._ctrl_fields || {};
            //log('res_controls', res_controls);
            //log('Object.keys(res_controls)', Object.keys(res_controls));
            //console.log('Object.keys(res_controls.named)', Object.keys(res_controls.named));

            // Go through the named controls.
            // should have both .named and .unnamed

            // Maybe don't bother with this?
            //  Are they all named?
            //   Or reconstruct it?

            if (res_controls.named) {
                Object.assign(target._ctrl_fields, res_controls.named);
            }

            //throw 'stop';

            // and a callback?
            // Seems like the async is not a problem - but its not adding the text.

            // Handling async composition may be useful though.



            //throw 'stop';
        }
            //[...parsing done, do something...]
    });
    var parser = new htmlparser.Parser(handler);
    parser.parseComplete(str_content);
}
//

const res = {
    parse: parse,
    parse_mount: parse_mount
}

module.exports = res;
},{"htmlparser":8,"lang-tools":186}],152:[function(require,module,exports){
var jsgui = require('lang-tools');
var each = jsgui.each;
var tof = jsgui.tof;
const Control = require('./control');

// Selection takes place within a view of a document.
//   At least this code does not look too HTML specific.

class Selection_Scope extends jsgui.Data_Object {
	//var Selection_Scope = jsgui.Class.extend({
	constructor(spec) {
		super(spec);
		if (spec.context) this.context = spec.context;
		if (typeof spec.id !== 'undefined') this.id = spec.id;
		if (spec.ctrl) this.control = spec.ctrl;
		if (spec.control) this.control = spec.control;
		// Needs to be a list / map of all controls that are selected.
		// map of selected controls by id?
		//  also need to be able to go through the list of controls.
		this.map_selected_controls = {};
		// set the items by their id to point to the control.
		//  the control will know its index within its parent, can look up more info there.
	}
	'select_only'(ctrl, silent = false) {
		var currently_selected;
		var count_deselected = 0;
		var selected;
		//console.log('select_only this.map_selected_controls', this.map_selected_controls);
		each(this.map_selected_controls, (v, i) => {
			// Don't want to select the selection scope itself.
			if (v && v !== ctrl && v !== this.control) {
				if (v.selected) {
					v.selected = false;
					//v.remove_class('selected');
					count_deselected++;
				}
				//console.log('should have deselcted ' + v._id())
			}
			//console.log('v !== this.control', v !== this.control);
			if (v === ctrl && v !== this.control) {
				currently_selected = v.selected;
				//v.add_class('selected');
			}
		});
		this.map_selected_controls = {};
		if (typeof ctrl._id === 'function') {
			this.map_selected_controls[ctrl._id()] = ctrl;
		} else {
			//console.log('typeof ctrl._id', typeof ctrl._id);
		}
		// and then tell the control that it's selected.
		// could possibly set a CSS flag.
		//console.log('currently_selected', currently_selected);

		if (!currently_selected) {
			ctrl.selected = true;
			if (!silent) {
				this.raise('change', {
					name: 'selected',
					value: ctrl
				});
				ctrl.raise('select');
			}
		}
		if (count_deselected > 0 & !currently_selected) {
			//this.raise('change');
		}
	}
	'deselect_all'(silent = false) {
		//console.log('this.map_selected_controls', this.map_selected_controls);
		each(this.map_selected_controls, (v, i) => {
			// Don't want to select the selection scope itself.
			if (v) {
				if (v.selected) {
					v.selected = false;
					//count_deselected++;
					v.raise('deselect');
				}
			}
		});
		if (!silent) {
			this.raise('change', {
				name: 'selected',
				value: undefined
			});
		}
		
		this.map_selected_controls = {};
	}
	'deselect'(ctrl, silent = false) {
		if (ctrl.selected === true) {
			ctrl.selected = false;
			
		}
		if (!silent) {
			ctrl.raise('deselected');
			this.raise('change', {
				name: 'selected',
				map_selected_controls: this.map_selected_controls
			})
		}
	}
	'select'(ctrl, silent = false) {
		if (!ctrl.selected) {
			ctrl.selected = true;
			
		}
		if (!silent) {
			ctrl.raise('selected');
			this.raise('change', {
				name: 'selected',
				map_selected_controls: this.map_selected_controls
			});
		}
	}
	// deselect controls internal to a control.

	// When selecting a control, we want to make it so that controls inside it, in the same selection context are not selected.
	//  The Selection Scope does a fair bit of the management of the selections.

	'deselect_ctrl_content'(ctrl, silent = false) {
		//var cs = ctrl.get('selection_scope');
		var cs = ctrl.selection_scope;
		var msc = this.map_selected_controls;
		//var that = this;
		ctrl.content.each(v => {
			//var tv = tof(v);
			if (v instanceof Control) {
				v.selected = false;
				var id = v._id();
				if (msc[id]) msc[id] = false;
				this.deselect_ctrl_content(v);
				if (!silent) v.raise('deselected');
			}
		});
		if (!silent) {
			this.raise('change', {
				name: 'selected',
				map_selected_controls: this.map_selected_controls
			});
		}
		
		//throw 'stop';
	}
	'select_toggle'(ctrl, silent = false) {
		var sel = ctrl.selected;
		//console.log('tof(sel) ' + tof(sel));
		var msc = this.map_selected_controls;
		var id = ctrl._id();
		if (!sel) {
			var sel_anc = ctrl.find_selected_ancestor_in_scope();
			if (sel_anc) {
				console.log('1) not selecting because a selected ancestor in the selection scope has been found.');
			} else {
				ctrl.selected = true;
				// Check for a selected ancestor control in the scope.
				this.deselect_ctrl_content(ctrl, silent);
				msc[id] = ctrl;
			}
		} else {
			var tsel = tof(sel);
			//console.log('tsel ' + (tsel))
			/*
			if (tsel == 'data_value') {
				var val = sel.get();
				//console.log('val ' + val);
				if (val) {
					ctrl.selected = false;
					msc[id] = false;
				} else {
					var sel_anc = ctrl.find_selected_ancestor_in_scope();
					if (sel_anc) {
						console.log('2) not selecting because a selected ancestor in the selection scope has been found.');
					} else {
						ctrl.selected = true;
						this.deselect_ctrl_content(ctrl, silent);
						msc[id] = ctrl;
					}
				}
			}
			*/
			if (tsel === 'boolean') {
				if (sel) {
					//ctrl.remove_class('selected');
					ctrl.selected = false;
					msc[id] = false;
				} else {
					var sel_anc = ctrl.find_selected_ancestor_in_scope();
					if (sel_anc) {
						console.log('2) not selecting because a selected ancestor in the selection scope has been found.');
					} else {
						this.deselect_ctrl_content(ctrl, silent);
						ctrl.selected = true;
						msc[id] = ctrl;
					}
				}
			}
		}
		if (!silent) {
			this.raise('change');
		}
	}
}

module.exports = Selection_Scope;
},{"./control":148,"lang-tools":186}],153:[function(require,module,exports){
//const Control = require('./control-core');
const {tof, Evented_Class} = require('lang-tools');

// Using a field / prop may work better.
//  Get closer to the more concise and reasonable functional way of coding this.

const escape_html_replacements = [
    [/&/g, '&amp;'],
    [/</g, '&lt;'],
    [/>/g, '&gt;'],
    [/"/g, '&quot;'], //"
    [/'/g, '&#x27;'], //'
    [/\//g, '&#x2F;']
];

const escape_html = (str) => {

    //console.log('tof(str) ' + tof(str));

    //console.log('escape_html str ' + str);
    //console.log('tof str ' + tof(str));

    if (tof(str) == 'data_value') str = str.get();

    var single_replacement;
    for (var c = 0, l = escape_html_replacements.length; c < l; c++) {
        single_replacement = escape_html_replacements[c]
        str = str.replace(single_replacement[0], single_replacement[1]);
    }
    //each(escape_html_replacements, function (i, v) {
    //    str = str.replace(v[0], v[1]);
    //});

    return str;
};

// Want to be able to change the text of an active text node.
//  So, the text node will have an 'el'. Maybe dom.node?

// Maybe don't extend control?

// Do need to have activation as well...?
//  Need to correlate the text node with its dom element.
//   That can't be done through the use of jsgui ids.
//    Will use sibling_index instead.

// When activating controls containing text nodes, can then correlate the textNode class with the element, by referring to the sibling index.

// Can give its parent control or element in the spec?
//  That means we could get access to the element very quickly.

// Not actually an HTML element.
//   Can't have attributes (such as its jsgui-id in the HTML).
class textNode extends Evented_Class {
//class textNode extends Control {
    constructor(spec) {
        spec.__type_name = spec.__type_name || 'text_node'

        super();

        //super(spec);
        if (typeof spec == 'string') {
            //this._.text = spec;
            //this.innerHtml = spec;
            spec = {
                'text': spec
            };
        }

        spec.nodeType = 3;
        spec = spec || {};

        if (spec.el) {
            this.dom = {
                el: spec.el
            }
        } else {
            this.dom = {};
        }

        if (spec.sibling_index) this.sibling_index = spec.sibling_index;

        //ctrl_init_call(this, spec);
        //this._super(spec);

        // the underscore properties could make sense in Data_Objects and controls.
        //  have the getters and setters that change the property and also raise the change event.

        // Proxies seem like a possibility to listen for such changes.
        //  However, we would make the changes to the proxy object.
        //  Possibly could have something that raises a change event.

        // Proxies could get trickier when they are in the object heirachy.

        //this._ = {};

        // Value would be better than text - more generic. Better to use it as standard.

        if (typeof spec.text !== 'undefined') {
            this._text = spec.text;
        }
        //this.typeName = pr.typeName;
        //this.tagName = 'p';

        // Will not require activation.
        //  Don't think Text_Node gets activated anyway.
        this.on('change', e_change => {
            //console.log('Text_Node change', e_change);

            if (this.dom.el) {
                this.dom.el.nodeValue = e_change.value;
            }
        })

    }
    activate() {
        if (!this.__active) {

            //console.log('activate textNode control');
            //console.log('this.sibling_index', this.sibling_index);

            this.__active = true;
        }
    }
    get text() {
        return this._text;
    }
    set text(value) {
        this._text = value;
        this.raise('change', {
            'name': 'text',
            'value': value
        });
    }
    'all_html_render'() {
        // nx = no escape
        return this.nx ? this._text || '' : escape_html(this._text || '') || '';
    }

    // getter and setter for the text itself?
    //  A variety of properties will use getters and setters so that the updates get noted.

};

module.exports = textNode;
},{"lang-tools":186}],154:[function(require,module,exports){
const jsgui = require('./html-core/html-core');
jsgui.Router = require('./router/router');
jsgui.Resource = require('./resource/resource');
jsgui.Resource_Pool = require('./resource/pool');
jsgui.Resource.Data_KV = require('./resource/data-kv-resource');
jsgui.Resource.Data_Transform = require('./resource/data-transform-resource');
jsgui.Resource.Compilation = require('./resource/compilation-resource');
jsgui.Resource.Compiler = require('./resource/compiler-resource');
jsgui.gfx = require('jsgui3-gfx-core');
jsgui.Resource.load_compiler = (name, jsfn, options) => {
    throw 'NYI';
}
jsgui.controls = jsgui.controls || {};
//jsgui.controls.Active_HTML_Document = jsgui.Active_HTML_Document = require('./controls/organised/1-standard/5-ui/Active_HTML_Document');
Object.assign(jsgui.controls, require('./controls/controls'));
Object.assign(jsgui, jsgui.controls);
jsgui.mixins = jsgui.mx = require('./control_mixins/mx');
module.exports = jsgui;
},{"./control_mixins/mx":56,"./controls/controls":67,"./html-core/html-core":149,"./resource/compilation-resource":155,"./resource/compiler-resource":156,"./resource/data-kv-resource":157,"./resource/data-transform-resource":158,"./resource/pool":159,"./resource/resource":160,"./router/router":161,"jsgui3-gfx-core":14}],155:[function(require,module,exports){



const Data_Transform_Resource = require('./data-transform-resource');

// Could be the place for compilations...
// Or land-tools, later lang-mini.

// Multiple compilers...



class Compilation_Resource extends Data_Transform_Resource {
    constructor(spec) {

        // What types of code go in and out?

        super(spec);


        // Could hold multiple compilers.

        // Needs to direct to the correct compiler.

        // query_compiler_resources(input_lang, output_lang)
        




    }


    // Which languages?
    //  String names
    //  Or objects describing the languages / formats....

    // With templating, will need to provide it with various values as well....
    //  A single values object should be OK.
    //   Or a promise / observable that will return them.






    // Could be either remote or local....
    // Call through web API, other means, or directly calling a function in the JS codebase.
    



}

module.exports = Compilation_Resource;
},{"./data-transform-resource":158}],156:[function(require,module,exports){



const Data_Transform_Resource = require('./data-transform-resource');

// Could be the place for compilations...
// Or land-tools, later lang-mini.

// Multiple compilers...

// Could be accessible by function call, http api call, maybe path and fs based.

// Actual Lang / Language objects may be of use for setting up and correctly referencing / logging compilations.

// Language
// Version
// Language_Version


// Maybe building into lang-tools would be better.

// class Programming_Language
//  Could get into detailed definitions / descriptions.
//   Could wind up large and complex, a lot of info represented.

// Bringing some compilation to the client side in the longer run may be very helpful.
//  Or option of bringing compilation to client side.




// An instance of this could be compiler_babel.



class Compiler_Resource extends Data_Transform_Resource {
    constructor(spec) {

        // What types of code go in and out?

        // input.lang
        // output.lang


        super(spec);


    }


    // Which languages?
    //  String names
    //  Or objects describing the languages / formats....

    // With templating, will need to provide it with various values as well....
    //  A single values object should be OK.
    //   Or a promise / observable that will return them.






    // Could be either remote or local....
    // Call through web API, other means, or directly calling a function in the JS codebase.
    



}

module.exports = Compiler_Resource;
},{"./data-transform-resource":158}],157:[function(require,module,exports){
    // Want to get the core resources working and tested.
//  Want to run a clock website / service to start with.
//  The server could have a clock, while clients could connect to it and share the information.
//  Could also experiment with P2P distribution of the data.
//  A clock is also useful because it contains time signals so we can see how long it takes for data to reach various machines.


// Intersted in having a remote Linux computer.
//  Ability to SSH into it and run commands.

// Want to be able to remotely configure and access a Raspberry Pi as a Resource.

var jsgui = require('lang-tools');

//const {Evented_Class} = jsgui;

var Pool = require('./pool');

const Evented_Class = jsgui.Evented_Class;
var Class = jsgui.Class, Collection = jsgui.Collection;
var is_defined = jsgui.is_defined, fp = jsgui.fp, stringify = jsgui.stringify, tof = jsgui.tof;
var call_multi = jsgui.call_multi, get_a_sig = jsgui.get_a_sig;
var each = jsgui.each;

const Resource = require('./resource');
// Data_Resource extends Evented_Class
//  or it's itself observable
// Evented_Class with the observable events and API.




class Data_KV_Resource extends Resource {
    // The link between the abstract resource and the resource on the internet / network / computer.
    //'fields': {
    //	//'meta': Data_Object
    //	'meta': 'data_object'
    //},

    // Problem with how it sets the fields.

    constructor(spec) {
        //console.log('Resource init');
        //
        if (!is_defined(spec)) spec = {};

        super(spec);

        if (is_defined(spec.name)) {
            // Need to deal with both resource properties and inner properties.
            //  Not sure about having resource.set('name') naming the resource.
            //   Sounds OK normally, but Resource needs to be flexible, eg a resource could provide
            //   translations of a work to a different language, so get('name') needs to just be calling
            //   the resource with that value.

            // Perhaps some kind of inner get and set?
            // Or inner is the normal.
            //  An object to represent a resource's external properties?

            // Could have .name for it's name
            //  or .self for a Data_Object that refers to itself.
            //  or .inner or .resource for the Data_Object that is the resource's inner data?
            //  .data

            // I like having .get and .set for dealing with the resource's data.
            //  and different ways for indexing the resource.

            // .metadata

            // and name is part of the metadata.

            // this.set('meta.name')

            // This way there is a .meta object which holds the name




            //this.set('meta.name', spec.name);
        }

        if (spec.name) this.name = spec.name;
        if (spec.pool) this.pool = spec.pool;

        /*
        this.meta = new Data_Object({
            'fields': {
                name: 'string'
            }
        });
        */

        // But give the resource name in the spec?
        //  That may be the best way of doing it, but it's not the API for now.

        /*

        if (spec.meta) {
            var meta = spec.meta;
            if (meta.name) this.meta.set('name', meta.name);
            //console.log('meta.name ' + meta.name);
        }
        */
        // Set the meta url in the client side resource.

        if (is_defined(spec.startup_type)) {
            //this.set('startup_type', spec.startup_type);
            this.startup_type = spec.startup_type;
        }

        this.getters = {};
        this.setters = {};

    }

    'start'(callback) {
        // check the requirements

        callback(null, true);

        //  check requirements recursive - checks the requirements of everything required, and if they have the check_requirements function, it uses that.
        //   I think using the system of names APIs will help here.

        // I think the base class should raise the event.

        //this.trigger('start');

        //console.log(new Error().stack);
        //throw 'no start function defined for resource (subclass)'
    }

    // meets_requirements
    //  check if all the prerequisite resources are active
    //  maybe check for login status if applicable.

    'meets_requirements'() {
        // Likely will be part of Status

        //return false;

        return true;
    }

    // 'get' will be the function to use.

    // may have toJson / to_json.
    'get_abstract'() {

        // Abstract_Resource - would be a description of a resource?
        //  Perhaps we'll only need json and json schema.
        //  Making the data_object and collection conform to json schema would be nice.
        //  Would have something very nice to do with creating a gui for forms.
        /*


        var res = new AR.Abstract_Resource({

        })
        */
    }

    'authenticate'(token) {
        //console.log('basic resource authenticate');
        return true;
    }

    // Resources could also operate in connected mode.
    //  How the connection gets handled will be outside of the scope of the resource itself.

    // the last item in the signature is the callback

    'set'(name, value, callback) {
        var al = arguments.length;

        // self setter?

        if (al === 3) {
            if (this.setters[name]) {
                this.setters[name](value, callback);
            }
        }
    }

    'get'(name, callback) {
        var al = arguments.length;
        if (al === 2) {
            if (this.getters[name]) {
                this.getters[name](callback);
            }
        }
    }
}

Resource.Pool = Pool;

module.exports = Data_KV_Resource;
	//return Resource;
//});

},{"./pool":159,"./resource":160,"lang-tools":186}],158:[function(require,module,exports){
    // Want to get the core resources working and tested.
//  Want to run a clock website / service to start with.
//  The server could have a clock, while clients could connect to it and share the information.
//  Could also experiment with P2P distribution of the data.
//  A clock is also useful because it contains time signals so we can see how long it takes for data to reach various machines.


// Intersted in having a remote Linux computer.
//  Ability to SSH into it and run commands.

// Want to be able to remotely configure and access a Raspberry Pi as a Resource.

var jsgui = require('lang-tools');

//const {Evented_Class} = jsgui;

var Pool = require('./pool');

const Evented_Class = jsgui.Evented_Class;
var Class = jsgui.Class, Collection = jsgui.Collection;
var is_defined = jsgui.is_defined, fp = jsgui.fp, stringify = jsgui.stringify, tof = jsgui.tof;
var call_multi = jsgui.call_multi, get_a_sig = jsgui.get_a_sig;
var each = jsgui.each;

const Resource = require('./resource');
// Data_Resource extends Evented_Class
//  or it's itself observable
// Evented_Class with the observable events and API.

// A resource here to populate HTML templates?

// Looks programatically like the right place for JSX compilation.
//  Keep that on the server for the moment.

// Compiling jsx to js?
// data pipeline type work...? render data to an HTML template?





// Could (in theory at least here) be a remote resource.

// Could be a streaming codec, remote or local, even a codec suite.
class Data_Transform_Resource extends Resource {
    // The link between the abstract resource and the resource on the internet / network / computer.
    //'fields': {
    //	//'meta': Data_Object
    //	'meta': 'data_object'
    //},

    // Problem with how it sets the fields.

    // JSON input data description info object
    // JSON output data description info object
    // JSON transformation data description info object.

    // .info
    // .meta.info

    // Will be POJOs.???

    // .i.i .i.o .i.t
    //  input schema, output schema, transformation function
    //  make it possible to express the algo here / in the constructor.
    //  also should be able to work remotely when the resource is remote.

    // .m.i.i


    constructor(spec) {
        //console.log('Resource init');
        if (!is_defined(spec)) spec = {};

        super(spec);

        if (is_defined(spec.name)) {
        }

        if (spec.name) this.name = spec.name;
        if (spec.pool) this.pool = spec.pool;

        const meta = {
            info: {},
            fn: {}
        };

        Object.defineProperty(this, 'meta', {
            get() {
                return meta;
            }
        });
        Object.defineProperty(this, 'm', {
            get() {
                return meta;
            }
        });
        Object.defineProperty(meta, 'i', {
            get() {
                return meta.info;
            }
        });
        Object.defineProperty(meta, 'fns', {
            get() {
                return meta.fn;
            }
        });

        Object.defineProperty(meta, 'fn', {
            get() {
                return meta.fn;
            }
        });
        Object.defineProperty(meta, 'f', {
            get() {
                return meta.fn;
            }
        });

        if (spec.fn_transform) {
            if (tof(spec.transform) === 'function') {
                meta.fn.transform = spec.fn_transform;
            } else {

            }
        }

        // this.m.f

        // setter for the meta function transform property?

        // meta.fn_transform
        // meta.fn_validate_input
        // meta.fn_validate_output




        /*
        this.meta = new Data_Object({
            'fields': {
                name: 'string'
            }
        });
        */

        // But give the resource name in the spec?
        //  That may be the best way of doing it, but it's not the API for now.

        /*

        if (spec.meta) {
            var meta = spec.meta;
            if (meta.name) this.meta.set('name', meta.name);
            //console.log('meta.name ' + meta.name);
        }
        */
        // Set the meta url in the client side resource.

        if (is_defined(spec.startup_type)) {
            //this.set('startup_type', spec.startup_type);
            this.startup_type = spec.startup_type;
        }

        //this.getters = {};
        //this.setters = {};

    }

    'start'(callback) {
        // check the requirements

        callback(null, true);

        //  check requirements recursive - checks the requirements of everything required, and if they have the check_requirements function, it uses that.
        //   I think using the system of names APIs will help here.

        // I think the base class should raise the event.

        //this.trigger('start');

        //console.log(new Error().stack);
        //throw 'no start function defined for resource (subclass)'
    }

    // meets_requirements
    //  check if all the prerequisite resources are active
    //  maybe check for login status if applicable.

    'meets_requirements'() {
        // Likely will be part of Status

        //return false;

        return true;
    }

    // 'get' will be the function to use.

    // may have toJson / to_json.
    'get_abstract'() {
        // Abstract_Resource - would be a description of a resource?
        //  Perhaps we'll only need json and json schema.
        //  Making the data_object and collection conform to json schema would be nice.
        //  Would have something very nice to do with creating a gui for forms.
        /*
        var res = new AR.Abstract_Resource({

        })
        */
    }

    'authenticate'(token) {
        //console.log('basic resource authenticate');
        return true;
    }

    // Resources could also operate in connected mode.
    //  How the connection gets handled will be outside of the scope of the resource itself.

    // the last item in the signature is the callback

    'transform'(value, options) {
        // returning an observable seems best...?
        //  or an easy to use stream?

        // need specific transform implementation for that resource.
        //  maybe filling in values within an HTML template.

        throw 'Need specific implementation';

    }
}

Resource.Pool = Pool;

module.exports = Data_Transform_Resource;
	//return Resource;
//});

},{"./pool":159,"./resource":160,"lang-tools":186}],159:[function(require,module,exports){
var jsgui = require('lang-tools');
//var Resource = require('./resource');

var stringify = jsgui.stringify,
	each = jsgui.each,
	arrayify = jsgui.arrayify,
	tof = jsgui.tof,
	get_a_sig = jsgui.get_a_sig;
var filter_map_by_regex = jsgui.filter_map_by_regex;
var Evented_Class = jsgui.Evented_Class,
	Data_Object = jsgui.Data_Object;
var fp = jsgui.fp,
	is_defined = jsgui.is_defined;
var Collection = jsgui.Collection;


class Resource_Pool extends Evented_Class {
	constructor(spec) {
		super(spec);
		this.resources = new Collection({
			//'index_by': 'name'
			'fn_index': (item) => {
				var key = item.name;
				return key;
			}
		});
	}

	'add'(obj) {
		var obj_name = obj.name;
		let log_trace = () => {
			console.log('');
			console.log('** obj_name ' + obj_name);
			console.trace();
			console.log('');
		}
		//log_trace();
		// Items able to name themselves?

		if (obj_name === undefined) {
			console.log('obj', obj);
			console.trace();
			throw 'Resource_Pool.add(undefined) error';
		}
		if (this.has_resource(obj_name)) {
			throw 'Resource pool already has resource with name ' + obj_name;
		} else {
			this.resources.add(obj);
			obj.pool = this;
			if (obj.name !== undefined) {
				Object.defineProperty(this, obj.name, {
					get() {
						return obj;
					}
				});
			}
			this.raise_event('added', obj);
		}
	}
	'push'(obj) {
		return this.add(obj);
	}
	'has_resource'() {
		const a = arguments;
		//a.l = arguments.length;
		const sig = get_a_sig(a, 1);
		//return is_defined(this._dict_resources[resource_name]);
		//return
		if (sig == '[s]') {
			// one string value, that will be the value of the unique primary index
			const obj_lookup_val = a[0];
			return this.resources.has(obj_lookup_val);
		}
	}
	get resource_names() {
		var res = [];
		each(this.resources, (resource) => {
			res.push(resource.name);
		})
		return res;
	}
	'get_resource'() {
		var a = arguments;
		a.l = arguments.length;
		var sig = get_a_sig(a, 1);

		if (sig === '[s]') {
			var obj_lookup_val = a[0];
			var find_result = this.resources.find(obj_lookup_val);
			if (find_result) {
				var res = find_result;
			}
			return res;
		}
	}
	'count'() {
		return this.resources.length;
	}
	// May be useful to have a callback parameter here rather than just publish / subscribe.

	'start'(callback) {
		var arr_resources_meeting_requirements = [];
		this.resources.each(function (v, i) {
			var mr = v.meets_requirements();
			if (mr) {
				arr_resources_meeting_requirements.push(v);
			}
		});
		var l_resources = this.resources.length();
		if (arr_resources_meeting_requirements.length === l_resources) {
			var fns = [];
			var num_to_start = arr_resources_meeting_requirements.length;
			var num_starting = 0,
				num_started = 0;
			var cb = function (err, start_res) {
				num_starting--;
				num_started++;
				//console.log('cb');
				//console.log('num_started ' + num_started);

				if (num_started == num_to_start) {
					if (callback) callback(null, true);
				}
			}
			each(arr_resources_meeting_requirements, resource_ready_to_start => {
				resource_ready_to_start.start(cb);
				num_starting++;
			});
		}
	}
}

module.exports = Resource_Pool;
},{"lang-tools":186}],160:[function(require,module,exports){
    // Want to get the core resources working and tested.
//  Want to run a clock website / service to start with.
//  The server could have a clock, while clients could connect to it and share the information.
//  Could also experiment with P2P distribution of the data.
//  A clock is also useful because it contains time signals so we can see how long it takes for data to reach various machines.


// Intersted in having a remote Linux computer.
//  Ability to SSH into it and run commands.

// Want to be able to remotely configure and access a Raspberry Pi as a Resource.

var jsgui = require('lang-tools');

//const {Evented_Class} = jsgui;

var Pool = require('./pool');

const Evented_Class = jsgui.Evented_Class;
var Class = jsgui.Class, Collection = jsgui.Collection;
var is_defined = jsgui.is_defined, fp = jsgui.fp, stringify = jsgui.stringify, tof = jsgui.tof;
var call_multi = jsgui.call_multi, get_a_sig = jsgui.get_a_sig;
var each = jsgui.each;


// Data_Resource extends Evented_Class
//  or it's itself observable
// Evented_Class with the observable events and API.








// Could move this to its own module.

// Make Resource extend Evented_Class

// Then could move it outside of jsgui3


// Status to see if a resource has started or not?
//  I think resource status is important.
//  However status may entail more things.
//   status.phase
//   phase

// meta.phase

// A resource's context matters.
//  It will be the server rather than a page context.



// Resources can have events as well.
//  Look into how the publisher deals with them.

// A Data_Resource? Data_KV_Resource?
//  get, set?

// Also want Data_Transform_Resource.
//  And they should work both locally and remotely.



// Data_Transform_Resource:
//  .transform
//  no .get no .set


class Resource extends Evented_Class {
    // The link between the abstract resource and the resource on the internet / network / computer.
    //'fields': {
    //	//'meta': Data_Object
    //	'meta': 'data_object'
    //},

    // Problem with how it sets the fields.

    constructor(spec) {
        //console.log('Resource init');
        //
        if (!is_defined(spec)) spec = {};

        super(spec);

        if (spec.name) this.name = spec.name;
        if (spec.pool) this.pool = spec.pool;

        if (is_defined(spec.startup_type)) {
            //this.set('startup_type', spec.startup_type);
            this.startup_type = spec.startup_type;
        }

        this.getters = {};
        this.setters = {};

    }

    'start'(callback) {
        // check the requirements

        callback(null, true);

        //  check requirements recursive - checks the requirements of everything required, and if they have the check_requirements function, it uses that.
        //   I think using the system of names APIs will help here.

        // I think the base class should raise the event.

        //this.trigger('start');

        //console.log(new Error().stack);
        //throw 'no start function defined for resource (subclass)'
    }

    // meets_requirements
    //  check if all the prerequisite resources are active
    //  maybe check for login status if applicable.

    'meets_requirements'() {
        // Likely will be part of Status

        //return false;

        return true;
    }

    // 'get' will be the function to use.

    // may have toJson / to_json.
    'get_abstract'() {

        // Abstract_Resource - would be a description of a resource?
        //  Perhaps we'll only need json and json schema.
        //  Making the data_object and collection conform to json schema would be nice.
        //  Would have something very nice to do with creating a gui for forms.
        /*


        var res = new AR.Abstract_Resource({

        })
        */
    }

    'authenticate'(token) {
        //console.log('basic resource authenticate');
        return true;
    }

    // Resources could also operate in connected mode.
    //  How the connection gets handled will be outside of the scope of the resource itself.

    // the last item in the signature is the callback

    /*

    'set'(name, value, callback) {
        var al = arguments.length;

        // self setter?

        if (al === 3) {
            if (this.setters[name]) {
                this.setters[name](value, callback);
            }
        }
    }

    'get'(name, callback) {
        var al = arguments.length;
        if (al === 2) {
            if (this.getters[name]) {
                this.getters[name](callback);
            }
        }
    }

    */
}

Resource.Pool = Pool;

// Resource.Data_Transform etc...



module.exports = Resource;
	//return Resource;
//});


},{"./pool":159,"lang-tools":186}],161:[function(require,module,exports){
// Tree_Router?

// Somewhat substantial changes with it not removing the first '/'.

var url = require('url-parse'),
    //jsgui = require('lang-tools'),
    jsgui = require('lang-tools'),
    //os = require('os'),
    //http = require('http');
    //stringify = jsgui.stringify,
    //each = jsgui.each,
    //arrayify = jsgui.arrayify,
    tof = jsgui.tof;
//var filter_map_by_regex = jsgui.filter_map_by_regex;
//var Class = jsgui.Class,
//    Data_Object = jsgui.Data_Object;
//var fp = jsgui.fp,
//    is_defined = jsgui.is_defined;
//var Collection = jsgui.Collection;
var get_item_sig = jsgui.get_item_sig;

// Not a Data_Object.
//  Adding this to a Collection should not put it inside a Data_Object layer.

// Should make this able to deal with routing to different 'host' value servers.

const Routing_Tree = require('./routing-tree');

class Router {
    constructor(spec) {
        spec = spec || {};
        //super(spec);
        //this.set('type_levels', ['router']);
        if (spec.name) {
            this.name = spec.name;
        } else {
            this.name = 'Router';
        }
        this.routing_tree = new Routing_Tree();
    }
    'start'(callback) {
        callback(null, true);
    }
    'set_route'(str_route, context, fn_handler) {
        //var rt = this.get('routing_tree');

        // Routing tree not properly setting routes beginning with '/'?
        console.log('pre routing tree set route:', str_route);
        return this.routing_tree.set(str_route, context, fn_handler);
    }
    'meets_requirements'() {
        return true;
    }
    get arr_paths() {
        return this.routing_tree.arr_paths;
    }
    'process'(req, res) {

        // Want to be able to pass things got from the router such as wildcard_value

        //console.log('jsgui3-html router processing request');
        //console.log('');
        //console.log('req.url', req.url);
        //console.log('');

        // hmmm... maybe could have already extracted req.url.
        


        //var remoteAddress = req.connection.remoteAddress;
        //var rt = this.get('routing_tree');
        var rt = this.routing_tree;

        //console.log('process rt', rt);
        let parsed_url;
        try {
            parsed_url = url(req.url, true);
        } catch (err) {
            console.log('error parsing url', req.url);
        }

        if (parsed_url) {
            //console.log('parsed_url', parsed_url);
            var splitPath = parsed_url.pathname.substr(1).split('/');
            //console.log('splitPath', splitPath);

            //console.log('pre rt.get(url) req.url', req.url);

            var route_res = rt.get(req.url);

            //console.log('!!route_res', !!route_res);


            //console.log('route_res', route_res);


            var processor_values_pair;
            var t_handler;

            ///console.log('Object.keys(route_res)', Object.keys(route_res));

            //console.log('(route_res)', (route_res));

            if (tof(route_res) === 'array') {



                processor_values_pair = route_res;
                var context, handler, params;

                //console.log('route_res.length', route_res.length);

                if (route_res.length === 2) {

                    // Maybe is not a Data_Object....

                    var rr_sig = get_item_sig(route_res, 1);

                    //console.log('rr_sig', rr_sig);

                    // Maybe just need the context and handler.
                    //   Though having the router able to extract params would help a lot.
                    //   


                    if (rr_sig == '[D,f]') {
                        context = processor_values_pair[0];
                        handler = processor_values_pair[1];
                    } else if (rr_sig == '[f,o]') {
                        handler = processor_values_pair[0];
                        params = processor_values_pair[1];
                    } else if (rr_sig == '[o,f]') {
                        context = processor_values_pair[0];
                        handler = processor_values_pair[1];

                        //console.log('params', params);

                    }
                }
                if (route_res.length === 3) {
                    context = processor_values_pair[0];
                    handler = processor_values_pair[1];
                    params = processor_values_pair[2];
                }
                if (params) req.params = params;

                //console.log('context', context);
                //console.log('handler', handler);
                //console.log('params', params);

                if (context) {
                    handler.call(context, req, res);
                } else {
                    t_handler = typeof handler;
                    //  The handler type being wrong....?

                    if (typeof handler === 'function') {
                        handler(req, res);
                    } else {
                        if (t_handler === 'undefined') {
                            // Got this when some were trying to hack me.
                            //  Any .php is a hack attempt.
                            let their_ip = req.connection.remoteAddress;
                            let last_part = splitPath[splitPath.length - 1];
                            //console.log('last_part', last_part);
                            if (last_part.indexOf('.php') > -1) {
                                // looks like a hack attempt
                            }
                            console.log('1) no defined route result ', their_ip.padEnd(16, ' '), splitPath);

                            console.log('req.url', req.url);
                            console.log('parsed_url', parsed_url);

                            // Some kind of 404 handler makes sense.
                            return false;
                        } else {
                            // handler may be undefined.
                            console.log('handler', handler);
                            throw 'Expected handler to be a function';
                        }
                    }
                }
            } else if (tof(route_res) === 'function') {
                if (context) {
                    route_res.call(context, req, res);
                } else {
                    // call the function... but maybe it's best / necessary to include the context.
                    //  call using the context when it exists, within the wildcard handler.
                    route_res(req, res);
                }
            } else if (tof(route_res) === 'undefined') {



                console.log('2) no defined route result', splitPath);
                return false;
            }
            if (processor_values_pair) {

            }
            return true;
        } else {
            return false;
        }
        //var 
        //console.log('parsed_url', parsed_url);
    }
}
//Router.prototype.type_levels = ['router'];
Router.Routing_Tree = Routing_Tree;

module.exports = Router;
},{"./routing-tree":162,"lang-tools":186,"url-parse":386}],162:[function(require,module,exports){


// May need some general purpose traversal functions?
class Routing_Tree_Node {
    constructor(spec) {
        spec = spec || {};
        if (spec.handler) this.handler = spec.handler;
        this.mapNormalPathChildren = {};
    }
}
class Variable_Routing_Tree_Node {
    constructor(spec) {
        this.name = spec.name;
        if (spec.handler) this.handler = spec.handler;
        this.mapNormalPathChildren = {};
    }
}
class Wildcard_Routing_Tree_Node {
    constructor(spec) {

    }
}

// Wildcards having names?
//  Or it just processes the wildcard info as one variable?

// Want to be able to get the Routing_Tree_Node corresponding with a path

// Could make this a tree-router

// Could make this an Evented_Class / observable
//  Evented_Class that raises its own log events.



class Routing_Tree {
    constructor(spec) {
        this.root = new Routing_Tree_Node();
    }
    get arr_paths() {
        const res = [];
        const iterate = (node) => {


            if (node.mapNormalPathChildren) {
                // Object.entries()
                console.log('node.name', node.name);
                const children = Object.entries(node.mapNormalPathChildren);

                if (children.length > 0) {
                    for (let c = 0; c < children.length; c++) {
                        iterate(children[c]);
                    }
                }
            }
        }
        return res;
    }
    'setRoot404'(handler) {
        this.root404Handler = handler;
    }
    'set'(strRoute, context, handler) {

        if (!handler) {
            handler = context;
            context = undefined;
        }
        if (strRoute == '/') {
            //console.log('setting root handler');
            //throw 'stop';
            if (context) this.root.context = context;
            this.root.handler = handler;
        } else {


            // Maybe make some options / classes to hold options / option sets for URL modification.


            // 
            // Maybe best not to remove this initial '/'???

            //if (strRoute.substr(0, 1) == '/') strRoute = strRoute.substr(1);
            // remove any beginning or trailing '/' from the route

            //if (strRoute.substr(strRoute.length - 1) == '/') strRoute = strRoute.substr(0, strRoute.length - 1);
            //console.log('strRoute ' + strRoute);
            var splitRoute = strRoute.split('/');

            //console.log('splitRoute', splitRoute);

            var currentNode = this.root;

            // traverse through to find the place.
            //  need to deal with creating variable nodes too if needed.

            var c = 0;
            while (c < splitRoute.length) {
                var strLevel = splitRoute[c];
                var isVariable = strLevel.substr(0, 1) == ':';
                var isWildcard = strLevel == '*';
                if (isVariable) {
                    var variableName = strLevel.substr(1);
                    //console.log('variableName', variableName);
                    if (!currentNode.variableChild) {
                        currentNode.variableChild = new Variable_Routing_Tree_Node({
                            'name': variableName
                        });
                        if (c == splitRoute.length - 1) {
                            currentNode.variableChild.handler = handler;
                            if (context) currentNode.variableChild.context = context;
                        }
                        currentNode = currentNode.variableChild;
                    } else {
                        currentNode = currentNode.variableChild;
                    }
                    //throw '8) stop';
                } else {
                    if (isWildcard) {
                        currentNode.wildcardChild = new Wildcard_Routing_Tree_Node();
                        currentNode.wildcardChild.handler = handler;
                        if (context) currentNode.wildcardChild.context = context;
                    } else {
                        var next_level_node = currentNode.mapNormalPathChildren[strLevel];
                        //console.log('next_level_node', next_level_node);
                        if (!next_level_node) {
                            currentNode.mapNormalPathChildren[strLevel] = new Routing_Tree_Node();
                            next_level_node = currentNode.mapNormalPathChildren[strLevel];
                            // 
                            //console.log('should have made node');
                        }

                        if (c === splitRoute.length - 1) {
                            //console.log('c === splitRoute.length - 1');
                            //console.log('currentNode', currentNode);
                            currentNode.mapNormalPathChildren[strLevel].handler = handler;
                            if (context) currentNode.mapNormalPathChildren[strLevel].context = context;
                        }
                        currentNode = next_level_node;
                        //console.log('new currentNode ' + currentNode);
                    }
                }
                c++;
            }
        }
    }
    'get'(url) {
        // routes the URL through the tree

        //console.log('router get url: ', url);
        var params;
        if (url == '/') {
            var root = this.root;
            //console.log('root.context', root.context);
            if (root.context) {
                return [root.context, this.root.handler, {}];
            } else {
                var res;
                if (this.root.handler) {
                    res = this.root.handler;
                } else {
                    if (this.root.wildcardChild) {
                        if (this.root.wildcardChild.handler) {
                            if (this.root.wildcardChild.context) {
                                return [this.root.wildcardChild.context, this.root.wildcardChild.handler, {}];
                            } else {
                                return this.root.wildcardChild.handler;
                            }
                            throw 'stop';
                        }
                    }
                }
                return res;
            }
        } else {
            // remove any beginning or trailing '/' from the route???


            //if (url.substr(url.length - 1) == '/') url = url.substr(0, url.length - 1);

            //if (url.substr(0, 1) == '/') url = url.substr(1);
            // process the url to remove the querystring.
            var posQM = url.indexOf('?');
            if (posQM > -1) {
                url = url.substr(0, posQM);
            }
            //console.log('url ' + url);
            var splitUrl = url.split('/');
            var currentNode = this.root;
            // traverse through to find the place.
            var c = 0;
            while (c < splitUrl.length) {
                var strLevel = splitUrl[c];
                if (currentNode) {
                    var next_level_node = currentNode.mapNormalPathChildren[strLevel];
                    if (next_level_node) {
                        //console.log('no next level node'); //???
                    } else {
                        if (currentNode.variableChild) {
                            next_level_node = currentNode.variableChild;
                            //console.log('next_level_node', next_level_node);
                            params = params || {};
                            params[currentNode.variableChild.name] = decodeURI(strLevel);
                        } else {
                            if (currentNode.wildcardChild) {
                                var arr_the_rest = splitUrl.slice(c);
                                //console.log('arr_the_rest', arr_the_rest);
                                var str_wildcard_value = arr_the_rest.join('/');
                                if (url.endsWith('/')) str_wildcard_value += '/';

                                //console.log('url', url);
                                //console.log(`url.endsWith('/')`, url.endsWith('/'));
                                //console.log('a) str_wildcard_value', str_wildcard_value);

                                if (currentNode.wildcardChild.context) {
                                    return [currentNode.wildcardChild.context, currentNode.wildcardChild.handler, {
                                        'wildcard_value': str_wildcard_value
                                    }];
                                } else {
                                    return [currentNode.wildcardChild.handler, {
                                        'wildcard_value': str_wildcard_value
                                    }];
                                }
                            }
                        }
                    }
                }
                if (c === splitUrl.length - 1) {
                    //console.log('the last');
                    //console.log('!!next_level_node', !!next_level_node);
                    if (next_level_node) {
                        //console.log('next_level_node', next_level_node);
                        //console.log('next_level_node.handler ' + next_level_node.handler);
                        if (next_level_node.handler) {
                            if (params) {
                                if (next_level_node.context) {
                                    return [next_level_node.context, next_level_node.handler, params];
                                } else {
                                    return [next_level_node.handler, params];
                                }
                            } else {
                                if (next_level_node.context) {
                                    return [next_level_node.context, next_level_node.handler];
                                } else {
                                    return next_level_node.handler;
                                }
                            }
                        } else {
                            if (next_level_node.wildcardChild) {
                                var arr_the_rest = splitUrl.slice(c);
                                //console.log('arr_the_rest', arr_the_rest);
                                var str_wildcard_value = arr_the_rest.join('/');
                                //console.log('str_wildcard_value', str_wildcard_value);
                                if (params) {
                                    params.wildcard_value = decodeURI(str_wildcard_value);

                                    if (next_level_node.wildcardChild.context) {
                                        return [next_level_node.wildcardChild.context, next_level_node.wildcardChild.handler, params];
                                    } else {
                                        return [next_level_node.wildcardChild.handler, params];
                                    }
                                } else {
                                    if (next_level_node.wildcardChild.context) {

                                        return [next_level_node.wildcardChild.context, next_level_node.wildcardChild.handler, params];
                                    } else {
                                        return [next_level_node.wildcardChild.handler, {
                                            'wildcard_value': str_wildcard_value
                                        }];
                                    }
                                }
                            }
                            // Could handle a variable handler here?
                        }
                    } else {
                        if (currentNode) {
                            return [currentNode.handler, params];
                        }

                    }
                }
                currentNode = next_level_node;
                c++;
            }
            return this.root404Handler;
            // having 404 within websocket connection? why not, when using an internal path.
            //throw '5) stop';
        }
    }
}

Routing_Tree.Node = Routing_Tree_Node;
Routing_Tree.Variable_Node = Variable_Routing_Tree_Node;
Routing_Tree.Wildcard_Node = Wildcard_Routing_Tree_Node;

module.exports = Routing_Tree;
},{}],163:[function(require,module,exports){
module.exports = require('./old/Collection');
},{"./old/Collection":179}],164:[function(require,module,exports){
//var jsgui = require('lang-mini');
//var Evented_Class = require('./_evented-class');

//var j = jsgui;
//var Evented_Class = j.Evented_Class;

// What type is the value?


const {Evented_Class} = require('lang-mini');


/*
    Possible code inclusions:

    Could define some things as being more stable in the 2.0.
    All the data model items being given an ID could wind up being very useful.
        Maybe even some kind of 128 or 256 bit GUID / key.
    Though of course it would lower performance for some things.
    However, supporting very large data throughput won't be the objective of this framework.
    Easily supporting large amounts of data could help though.



*/

class Data_Model extends Evented_Class {
    constructor(spec = {}) {
        super(spec);
        this.__data_model = true;
        if (spec.context) {
            this.context = spec.context;

        }
        if (spec.name) {
            this.name = spec.name;
        }
        this.__type = 'data_model';
    }
};

module.exports = Data_Model;

},{"lang-mini":379}],165:[function(require,module,exports){
module.exports = require('./old/Data_Object')
},{"./old/Data_Object":180}],166:[function(require,module,exports){
module.exports = require('./new/Data_Value')
},{"./new/Data_Value":169}],167:[function(require,module,exports){


class Mini_Context {
    // Need quite a simple mechanism to get IDs for objects.
    // They will be typed objects/
    constructor(spec) {
        var map_typed_counts = {};
        var typed_id = function (str_type) {
            throw 'stop Mini_Context typed id';
            var res;
            if (!map_typed_counts[str_type]) {
                res = str_type + '_0';
                map_typed_counts[str_type] = 1;
            } else {
                res = str_type + '_' + map_typed_counts[str_type];
                map_typed_counts[str_type]++;
            }
            return res;
        };
        this.new_id = typed_id;
        //new_id
    }
    'make'(abstract_object) {
        if (abstract_object._abstract) {
            //var res = new
            // we need the constructor function.
            var constructor = abstract_object.constructor;
            //console.log('constructor ' + constructor);
            //throw 'stop';
            var aos = abstract_object._spec;
            // could use 'delete?'
            aos.abstract = null;
            //aos._abstract = null;
            aos.context = this;
            var res = new constructor(aos);
            return res;
        } else {
            throw 'Object must be abstract, having ._abstract == true';
        }
    }
}
module.exports = Mini_Context;
},{}],168:[function(require,module,exports){
var jsgui = require('lang-mini');
//var Evented_Class = require('./_evented-class');
const {more_general_equals} = require('./tools');
const Data_Model = require('../Data_Model');
const Immutable_Data_Model = require('./Immutable_Data_Model');

const {is_defined, input_processors, field, tof, each} = jsgui;

const setup_base_data_value_value_property = require('./setup_base_data_value_value_property');

// What type is the value???

// Examples / tests of using this in this module could help.
//   Benchmarks too?
let util;
if (typeof window === 'undefined') {
    const str_utl = 'util';
    util = require(str_utl);    
}


const lpurple = x => '\x1b[38;5;129m' + x + '\x1b[0m';
const ldarkPurple = x => `\x1b[38;5;54m${x}\x1b[0m`;

// Possibly do some (much?) simpler tests to start with...

// Copy the value when it gets set somehow.

// Not actually all that much shared between the mutable and immutable versions right now.
//   Could come back to this later.



class Base_Data_Value extends Data_Model {

    constructor(spec = {}) {
        super(spec);
        this.__data_value = true;

        if (spec.data_type) this.data_type = spec.data_type;
        if (spec.context) {
            this.context = spec.context;
        }
        this.__type = 'data_value';

        // this.__data_type = ...
        // this.__data_type_name = ... ?

        //this._bound_events = {};
        this._relationships = {};

        //console.log('Base_Data_Value spec', spec);

        // Does not have the field for 'value' though....

        // this.setup_value_property????


        


        // So here field ('value') is doing most of the work here.

        //  Do want to see about setting up the sub-fields too....

        const {data_type, context} = this;

        
        //setup_base_data_value_value_property(this);


        // Defining the property here could work....




        // Some kind of post-constructor function?????

        // or use an event handler and event????


        //setImmediate(() => {
        //    if (spec.value) {
        //        this.value = spec.value;
        //    }
        //})

    }

    

    equals(other) {
        // Are they both Data_Values???

        // or use Data_Model ???

        // make a general equals here, give it this for the moment.
        //   the more general equals will be used recursively for comparing arrays.

        return more_general_equals(this, other);

    }

    // Maybe see about immutable mode Data_Values / Data_Models.
    //   Or do make the immutable versions of all of them!!!
    //     And could make core functionality for both the immutable and mutable versions.
    //       Mutability Independent Code.


    // Immutable_Data_Integer does seem like it would in principle be (really?) simple.








    /*
    toImmutable() {
        // May be slightly difficult / tricky / complex.
        const {context, data_type, value} = this;

        // Create the new item...
        // Needs to copy the inner value....?

        const res = new Immutable_Data_Value({
            context, data_type, value
        });
        return res;
    }
    */

    
    'get'() {
        return this.value;
    }

    'toString'() {
        //return stringify(this.get());
        // con
        //console.log('this._val ' + stringify(this._val));
        //throw 'stop';
        return this.get() + '';
    }
    // Maybe a particular stringify function?
    'toJSON'() {
        return JSON.stringify(this.get());
    }

    // Need to copy / clone the ._ value
    /*
    'clone'() {

        //return this.toImmutable();
    }
    */

    // This is important to the running of jsgui3.
    //   Move to the lower level of Data_Model?


    '_id'() {
        if (this.__id) return this.__id;
        if (this.context) {
            //console.log('this.__type ' + this.__type);
            //throw 'stop';
            this.__id = this.context.new_id(this.__type_name || this.__type);
        } else {
            if (!is_defined(this.__id)) {
                throw 'Data_Value should have context';
                this.__id = new_data_value_id();
            }
        }
        return this.__id;
    }

}

module.exports = Base_Data_Value;
},{"../Data_Model":164,"./Immutable_Data_Model":171,"./setup_base_data_value_value_property":176,"./tools":178,"lang-mini":379}],169:[function(require,module,exports){
var jsgui = require('lang-mini');
const {more_general_equals} = require('./tools');
const Base_Data_Value = require('./Base_Data_Value');
const Value_Set_Attempt = require('./Value_Set_Attempt');
const Data_Model = require('../Data_Model');
const Immutable_Data_Model = require('./Immutable_Data_Model');
const Immutable_Data_Value = require('./Immutable_Data_Value');
const {is_defined, input_processors, field, tof, each, is_array, Data_Type} = jsgui;



const setup_data_value_data_type_set = require('./setup_data_value_data_type_set');
// Maybe make a more universal Data_Model system???


// For the moment improve, test, and refactor this.

// Do want to have some kind of validation status updates.

// Maybe deal with 2 models as a pair.
//   Synced, but possibly different data types.
let util;
if (typeof window === 'undefined') {
    const str_utl = 'util';
    util = require(str_utl);    
}
const lpurple = x => '\x1b[38;5;129m' + x + '\x1b[0m';
const validate_data_value = data_value => {
    const {data_type} = data_value;
    if (data_type) {
        return data_type.validate(data_value);
    } else {
        return true;
    }
}

// And attempt_set_value...

// Maybe we need a Value_Set_Operator class?
// Operator class carries out an operation on something.

// Data_Value_Set_Operator???
//  Data_Value_Set_Operator_Validator
//  Data_Value_Set_Operator_Input_Transformer (eg parser)
//  

// Data_Model_Property class even???

// data value synchronisation....????


// And a Base_Data_Value too perhaps, that Data_Number and Data_String would inherit from???



// Want to define relatively simply what this needs to do.
//   Store a value.
//   Store a value with a specified type.
//   Validate changes
//   Raise change events when the value is changed


// May well be worth reimplementing this with simpler code.
//   However, want to better test this, and syncing them where types differ.

// Automatic conversion of types - while keeping the code simple / compact?

// How could parts of this be moved to a separate file?
//  eg setup_Data_Value_typed_set ????

// Maybe when .set is called, always run create_set, always make a Value_Set_Attempt object, raise various events concerning setting
// eg begin-set-attempt
//    validate-set-attempt

// ????





// Making a Data_Array or Data_Object could help a lot here, keeping the Data_Value code itself simple.
//   Or continue with this, making the test cases, and fixing the error(s) that stops it working properly.
//   Refactoring code to helper file(s) could help a lot.

// Maybe something like a mixin for Data_Value functionality?
//   Only uses the mixin function if appropriate to the data_type / other settings.

// // Want a really simple high-level API if possible.
// See about making a greatly simplified Data_Value.
//   Maybe working on some lower level code will help most, such as field, property?
//   Data types and validation in lang-mini, use it here????

// Supporting Data_Type should be relatively simple, see what functionality in Data_Type will help.
//   Should be able to avoid needing hugh functions and code paths.

// Maybe need a bit more API complexity to do with imput parsing / transformations.

// or a plan_set function, produces a set_plan, which would include the parsing having been done already.

// 

class Data_Value extends Base_Data_Value {
    constructor(spec = {}) {

        //let using_value_as_spec;
        if (typeof spec !== 'object') {
            spec = {
                value: spec
            }
        }

        super(spec);


        this.__data_value = true;
        this.__type_name = 'data_value';
        const that = this;
        if (spec.data_type) {
            this.data_type = spec.data_type;
        } else if (spec.value?.data_type) {
            this.data_type = spec.value.data_type;
        }
        if (spec.context) {
            this.context = spec.context;
        }
        const {data_type, context} = this;
        

        // If it previously did not validate, but it then does....
        // Maybe some other issues with why 'set' is not working properly accross cases.

        // Sure gets complex here!!!!

        // Maybe better to break down the parts into smaller and separate and named logic.
        //   Typed_Data_Value perhaps????
        //     Then the type specific coding in there...???



        if (data_type) {
            //console.log('data_type', data_type);


            setup_data_value_data_type_set(this, data_type);

            // string typed??? String typed????

            
            if (spec.value) {
                this.value = spec.value;
            }
            
        } else {

            // just a field????
            //   maybe it's not properly recohered on the client-side.

            //console.log('* Data_Value setting .value as a field');
            //  does not seem to be working properly here.
            //    maybe look into this further, when not using a data_type.

            // A more advanced system here than just 'field'?

            // Some kind of pre-set event. Validation could then take place, and send something back to the code that would
            //   do the set, giving a reason why the set operation will / should not take place.


            field(this, 'value', spec.value);
        }
        

        // This could use some functions that get generalised from the setter.
        //   Could use the same code paths / use attempt_set_value when set is called.

        // maybe a .last_set_succeeded value.
        //   also the 'validate' event.

        // Should break things up into their more logical pieces, allowing code reuse.
        //   Being much more explicit would help with some things too.




        
        const attempt_set_value = this.attempt_set_value = (value) => {
            const get_local_js_value_copy = () => {
                const tljsv = tof(local_js_value);
                if (tljsv === 'undefined' || tljsv === 'string' || tljsv === 'number') {
                    return local_js_value;
                } else {
                    console.log('local_js_value', local_js_value);
                    console.log('tljsv', tljsv);
                    console.trace();
                    throw 'stop';
                }
            }

            // There will be some kind of parsing going on somehow.

            const old_local_js_value = get_local_js_value_copy();
            const old_equals_new = more_general_equals(old_local_js_value, value);
            if (old_equals_new === true) {

                // But no validation event raised....

                return new Value_Set_Attempt({success: false, equal_values: true});
            } else {
                if (this.data_type === undefined) {
                    local_js_value = value;
                    const o_change = {
                        name: 'value',
                        old: old_local_js_value,
                        value
                    }
                    this.raise('change', o_change);
                    return new Value_Set_Attempt({success: true, value});
                } else if (this.data_type instanceof Data_Type) {
                    const t_value = tof(value);
                    if (t_value === 'string') {
                        if (this.data_type.parse_string) {
                            const parsed_value = this.data_type.parse_string(value);
                            if (parsed_value !== undefined) {
                                const res = attempt_set_value(parsed_value);
                                res.parsed = true;
                                return res;
                            } else {
                                return new Value_Set_Attempt({success: false, value});
                            }
                        } else {
                            console.trace();
                            throw 'NYI';
                        }
                    } else {
                        if (t_value === 'number') {
                            const validation = this.data_type.validate(value);
                            if (validation === true) {
                                local_js_value = value;
                                const o_change = {
                                    name: 'value',
                                    old: old_local_js_value,
                                    value
                                }
                                this.raise('change', o_change);
                                return new Value_Set_Attempt({success: true, old: old_local_js_value, value});
                            } else {
                                return new Value_Set_Attempt({success: false, value});
                            }
                        } else {
                            console.log('t_value', t_value);
                            console.trace();
                            throw 'NYI';
                        }
                    }
                } else if (this.data_type === String) {
                    if (typeof value === 'number') {
                        const res = attempt_set_value(value + '');
                        res.data_type_transformation = ['number', 'string'];
                        return res;
                    } else if (typeof value === 'string') {
                        local_js_value = value;
                        const o_change = {
                            name: 'value',
                            old: old_local_js_value,
                            value
                        }
                        this.raise('change', o_change);
                        return new Value_Set_Attempt({success: true, old: old_local_js_value, value});
                    } else {
                        console.trace();
                        throw 'NYI';
                    }
                } else {
                    console.log('this.data_type', this.data_type);
                    console.trace();
                    throw 'NYI';
                }
            }
        }
        this.__type = 'data_value';
        this._relationships = {};
    }
    toImmutable() {
        const {context, data_type, value} = this;
        const res = new Immutable_Data_Value({
            context, data_type, value
        });
        return res;
    }
    'toObject'() {
        return this._;
    }
    'set'(val) {
        this.value = val;
    }
    'get'() {
        return this.value;
    }
    equals(other) {
        return more_general_equals(this, other);
    }
    'toString'() {
        return this.get() + '';
    }
    'toJSON'() {
        const t_value = tof(this.value);
        if (t_value === 'string') {
            return JSON.stringify(this.value);
        } else
        if (t_value === 'number') {
            return this.value + '';
        } else if (t_value === 'boolean' ) {
            this.value ? 'true' : 'false'
        } else if (t_value === 'array') {
            return JSON.stringify(this.value);
        } else if (t_value === 'data_value') {
            return this.value.toJSON();
        } else if (t_value === 'undefined') {
            return 'null'
        } else if (t_value === 'null') {
            return 'null'
        } else {
            console.log('toJSON this.value', this.value);
            console.log('t_value', t_value);
            console.trace();
            throw 'NYI';
        }
    }
    'clone'() {
        console.trace();
        throw 'NYI';
        var res = new Data_Value({
            'value': this._
        });
        return res;
    }
    '_id'() {
        if (this.__id) return this.__id;
        if (this.context) {
            this.__id = this.context.new_id(this.__type_name || this.__type);
        } else {
            if (!is_defined(this.__id)) {
                throw 'Data_Value should have context';
                this.__id = new_data_value_id();
            }
        }
        return this.__id;
    }
};

Data_Value.sync = (a, b) => {
    if (a instanceof Base_Data_Value && b instanceof Base_Data_Value) {

        a.on('change', e => {
            const {name, old, value} = e;
            if (name === 'value') {
                b.value = value;
            }
        });

        b.on('change', e => {
            const {name, old, value} = e;
            if (name === 'value') {
                a.value = value;
            }
        });

    } else {
        console.trace();
        throw 'Unexpected types';
    }

}

if (util) {
    Data_Value.prototype[util.inspect.custom] = function(depth, opts) {
        const {value} = this;
        const tv = tof(value);
        if (tv === 'number' || tv === 'string' || tv === 'boolean') {
            return lpurple(value);
        } else {
            if (value instanceof Array) {
                let res = lpurple('[ ');
                let first = true;
                each(value, item => {
                    if (!first) {
                        res = res + lpurple(', ');
                    } else {
                        first = false;
                    }
                    if (item instanceof Data_Model) {
                        const item_value = item.value;
                        res = res + lpurple(item_value)
                    } else [
                        res = res + lpurple(item)
                    ]
                })
                res = res + lpurple(' ]');
                return res;
            } else if (value instanceof Data_Model) {
                return value[util.inspect.custom]();
            } else {
                return lpurple(this.value);
            }
        }
    }
}
module.exports = Data_Value;

},{"../Data_Model":164,"./Base_Data_Value":168,"./Immutable_Data_Model":171,"./Immutable_Data_Value":172,"./Value_Set_Attempt":175,"./setup_data_value_data_type_set":177,"./tools":178,"lang-mini":379}],170:[function(require,module,exports){
var jsgui = require('lang-mini');
//var Evented_Class = require('./_evented-class');
const {more_general_equals} = require('./tools');
const Data_Model = require('../Data_Model');
const Immutable_Data_Model = require('./Immutable_Data_Model');

const {is_defined, input_processors, field, tof, each} = jsgui;

// What type is the value???

// Examples / tests of using this in this module could help.
//   Benchmarks too?
let util;
if (typeof window === 'undefined') {
    const str_utl = 'util';
    util = require(str_utl);    
}


const lpurple = x => '\x1b[38;5;129m' + x + '\x1b[0m';
const ldarkPurple = x => `\x1b[38;5;54m${x}\x1b[0m`;

// Possibly do some (much?) simpler tests to start with...

// Copy the value when it gets set somehow.

// Not actually all that much shared between the mutable and immutable versions right now.
//   Could come back to this later.



class Immutable_Base_Data_Value extends Immutable_Data_Model {

    constructor(spec = {}) {
        super(spec);
        this.__data_value = true;

        if (spec.data_type) this.data_type = spec.data_type;
        if (spec.context) {
            this.context = spec.context;
        }
        this.__type = 'data_value';

        // this.__data_type = ...
        // this.__data_type_name = ... ?

        //this._bound_events = {};
        this._relationships = {};


        // So here field ('value') is doing most of the work here.

        //  Do want to see about setting up the sub-fields too....

        const {data_type, context} = this;

    }

    equals(other) {
        // Are they both Data_Values???

        // or use Data_Model ???

        // make a general equals here, give it this for the moment.
        //   the more general equals will be used recursively for comparing arrays.

        return more_general_equals(this, other);

    }

    // Maybe see about immutable mode Data_Values / Data_Models.
    //   Or do make the immutable versions of all of them!!!
    //     And could make core functionality for both the immutable and mutable versions.
    //       Mutability Independent Code.


    // Immutable_Data_Integer does seem like it would in principle be (really?) simple.






    

    /*
    toImmutable() {
        // May be slightly difficult / tricky / complex.
        const {context, data_type, value} = this;

        // Create the new item...
        // Needs to copy the inner value....?

        const res = new Immutable_Data_Value({
            context, data_type, value
        });
        return res;
    }
    */

    
    'get'() {
        return this.value;
    }

    'toString'() {
        //return stringify(this.get());
        // con
        //console.log('this._val ' + stringify(this._val));
        //throw 'stop';
        return this.get() + '';
    }
    // Maybe a particular stringify function?
    'toJSON'() {
        return JSON.stringify(this.get());
    }

    // Need to copy / clone the ._ value
    /*
    'clone'() {

        //return this.toImmutable();
    }
    */

    // This is important to the running of jsgui3.
    //   Move to the lower level of Data_Model?


    '_id'() {
        if (this.__id) return this.__id;
        if (this.context) {
            //console.log('this.__type ' + this.__type);
            //throw 'stop';
            this.__id = this.context.new_id(this.__type_name || this.__type);
        } else {
            if (!is_defined(this.__id)) {
                throw 'Immutable_Base_Data_Value should have context';
                this.__id = new_data_value_id();
            }
        }
        return this.__id;
    }

}

module.exports = Immutable_Base_Data_Value;
},{"../Data_Model":164,"./Immutable_Data_Model":171,"./tools":178,"lang-mini":379}],171:[function(require,module,exports){


const Data_Model = require('../Data_Model');

class Immutable_Data_Model extends Data_Model {
    constructor(...a) {
        super(...a);
    }
}

module.exports = Immutable_Data_Model;
},{"../Data_Model":164}],172:[function(require,module,exports){
var jsgui = require('lang-mini');
//var Evented_Class = require('./_evented-class');
const {more_general_equals} = require('./tools');
const Data_Model = require('../Data_Model');
const Immutable_Data_Model = require('./Immutable_Data_Model');
const Immutable_Base_Data_Value = require('./Immutable_Base_Data_Value');

const {is_defined, input_processors, field, tof, each} = jsgui;

// What type is the value???

// Examples / tests of using this in this module could help.
//   Benchmarks too?
let util;
if (typeof window === 'undefined') {
    const str_utl = 'util';
    util = require(str_utl);    
}


const lpurple = x => '\x1b[38;5;129m' + x + '\x1b[0m';
const ldarkPurple = x => `\x1b[38;5;54m${x}\x1b[0m`;

// Possibly do some (much?) simpler tests to start with...

// Copy the value when it gets set somehow.

class Immutable_Data_Value extends Immutable_Base_Data_Value {

    constructor(spec = {}) {
        super(spec);
        this.__data_value = true;
        this.__immutable = true;
        this.__type_name = 'data_value';

        if (spec.data_type) this.data_type = spec.data_type;
        if (spec.context) {
            this.context = spec.context;
        }

        const {data_type, context} = this;
        
        if (data_type) {
            

            const to_local_js_value = (value) => {
                //
                if (value !== undefined) {
                    const t = tof(value);
                    //

                    if (t === 'number' || t === 'string' || t === 'boolean') {
                        return value;
                    } else {

                        // So if it's an array....
                        //   Would need to create the items inside it.
                        //     Receate inner items when making a copy of an array, as they could be Data_Values we would need to
                        //     get the value of, or the bare values....

                        // Does seem a bit laborious here, go through array, depending on type of item copy it in different way.
                        //   As in with the inner strings, numbers and booleans we can do the direct = assignment because they
                        //   dont (?) share actual objects.

                        if (t === 'array') {
                            // go through it....
                            //const arr_value = value;
                            const l = value.length;
                            const res = new Array(l);
                            for (let c = 0; c < l; c++) {
                                res[c] = to_local_js_value(value[c]);
                            }
                            return res;
                        } else if (t === 'data_value') {
                            return value.toImmutable();
                        } else {

                            // If it's a Data_Value (in the/an array???) we need to get an immutable version of it.
                            console.log('to_local_js_value value', value);
                            console.log('t', t);
                            
                            console.trace();
                            throw 'NYI';
                        }
                    }
                }
            }
            
            const local_js_value = to_local_js_value(spec.value);

            //  inner_js_type ???

            // inner_value could help....

            Object.defineProperty(this, 'value', {
                get() {
                    return local_js_value;
                    //return _prop_value;
                }
            });
            
        } else {
            
            let value;

            // then if it's an array, would need to slice it, and (possibly) wrap inner items as being immutable too.

            if (spec.value instanceof Array) {
                value = spec.value.map(x => {
                    if (x instanceof Data_Model) {
                        return x.toImmutable();
                    } else {
                        return x;
                    }
                })
            } else {
                value = spec.value;
            }
            Object.defineProperty(this, 'value', {
                get() {
                    return value
                }
            })
            //field(this, 'value', spec.value);
        }
        this.__type = 'data_value';

        // this.__data_type = ...
        // this.__data_type_name = ... ?

        //this._bound_events = {};
        this._relationships = {};


    }

    equals(other) {

        return more_general_equals(this, other);
    }

    
    toImmutable() {
        // May be slightly difficult / tricky / complex.
        const {context, data_type, value} = this;

        // Create the new item...
        // Needs to copy the inner value....?

        const res = new Immutable_Data_Value({
            context, data_type, value
        });
        return res;
    }
    'get'() {
        return this.value;
    }


    'toString'() {
        //return stringify(this.get());
        // con
        //console.log('this._val ' + stringify(this._val));
        //throw 'stop';
        return this.get() + '';
    }
    // Maybe a particular stringify function?
    'toJSON'() {

        // Seems like cases where sometimes 

        const t_value = tof(this.value);

        if (t_value === 'string') {
            return JSON.stringify(this.value);
        } else
        if (t_value === 'number') {
            //
            return this.value + '';

        } else if (t_value === 'boolean' ) {
            this.value ? 'true' : 'false'
        } else if (t_value === 'array') {

            let res = '[';
            const l = this.value.length;
            for (let c = 0; c < l; c++) {
                const item = this.value[c];
                if (c > 0) res += ','
                if (item.toJSON) {
                    res += item.toJSON();
                } else {
                    res += JSON.stringify(item);
                }

            }

            res = res + ']';

            return res;
            //return JSON.stringify(this.value);
        } else if (t_value === 'data_value') {
            return this.value.toJSON();
        } else if (t_value === 'undefined') {
            return 'null'
        } else if (t_value === 'null') {
            return 'null'
        } else {
            console.log('toJSON this.value', this.value);
            console.log('t_value', t_value);
            console.trace();
            throw 'NYI';
        }

        

        //return JSON.stringify(this.value);
    }

    // Need to copy / clone the ._ value

    'clone'() {
        return this.toImmutable();
    }

    // This is important to the running of jsgui3.
    //   Move to the lower level of Data_Model?


    '_id'() {
        if (this.__id) return this.__id;
        if (this.context) {
            //console.log('this.__type ' + this.__type);
            //throw 'stop';
            this.__id = this.context.new_id(this.__type_name || this.__type);
        } else {
            if (!is_defined(this.__id)) {
                throw 'Data_Value should have context';
                this.__id = new_data_value_id();
            }
        }
        return this.__id;
    }

    'toObject'() {
        return this._;

    }
};


if (util) {
    Immutable_Data_Value.prototype[util.inspect.custom] = function(depth, opts) {
        //return 'foo = ' + this.foo.toUpperCase();

        // But then display it in a specific color....

        //return ldarkPurple(this.value);

        const {value} = this;

        if (value instanceof Array) {
            // could go through each item in that array.

            let res = ldarkPurple('[ ');
            let first = true;

            each(value, item => {
                if (!first) {
                    res = res + ldarkPurple(', ');
                } else {
                    first = false;
                }

                if (item instanceof Data_Model) {
                    const item_value = item.value;
                    res = res + ldarkPurple(item_value)

                } else [
                    res = res + ldarkPurple(item)
                ]

            })
            res = res + ldarkPurple(' ]');
            return res;

        } else {
            return ldarkPurple(this.value);
        }
    }
}

module.exports = Immutable_Data_Value;

},{"../Data_Model":164,"./Immutable_Base_Data_Value":170,"./Immutable_Data_Model":171,"./tools":178,"lang-mini":379}],173:[function(require,module,exports){


class Validation_Result {

}

module.exports = Validation_Result;
},{}],174:[function(require,module,exports){


const Validation_Result = require('./Validation_Result');


class Validation_Success extends Validation_Result {
    constructor(spec) {

        super(spec);

    }
}

module.exports = Validation_Success;
},{"./Validation_Result":173}],175:[function(require,module,exports){
class Value_Set_Attempt {
    constructor(spec = {}) {
        // name, old, value (attempted value), success, (current???), error(s)?, reasons????
        // failure.reasons could help....

        // .success.token perhaps too....
        // .success.transaction.id ????

        Object.assign(this, spec);





    }
}

module.exports = Value_Set_Attempt;
},{}],176:[function(require,module,exports){
const Validation_Success = require("./Validation_Success");


const setup_base_data_value_value_property = (data_value) => {

    let local_js_value;

    // but the old value too???
    //   do we need more complex usage of isomorphic code????

    const set_value_with_valid_and_changed_value = (valid_and_changed_value) => {

        const old = local_js_value;
        local_js_value = valid_and_changed_value;

        data_value.raise('change', {
            name: 'value',
            old,
            value: local_js_value
        })




    }


    Object.defineProperty(data_value, 'value', {

        get() {
            return local_js_value;
        },
        set(value) {

            if (data_value.transform_validate_value) {

                // otherwise????
                //   nothing yet.

                // assume the other functions:
                // is_value_correct_type
                // can_value_be_parsed_to_correct_type
                // parse_value
                // validate_value


                // .assess_set ????

                // maybe a set_with_valid_value function?

                // get the transform and validare result obj

                const obj_transform_and_validate_value_results = data_value.transform_validate_value(value);
                //console.log('obj_transform_and_validate_value_results', obj_transform_and_validate_value_results);

                if (obj_transform_and_validate_value_results.validation instanceof Validation_Success) {
                    // need to check that it's changed....


                    if (obj_transform_and_validate_value_results.transformed_value !== undefined) {
                        const value_has_changed = local_js_value !== obj_transform_and_validate_value_results.transformed_value;

                        if (value_has_changed) {
                            set_value_with_valid_and_changed_value(obj_transform_and_validate_value_results.transformed_value);
                        } else {
                            // maybe nothing here now.

                        }
                    } else {
                        const value_has_changed = local_js_value !== obj_transform_and_validate_value_results.value;

                        if (value_has_changed) {
                            set_value_with_valid_and_changed_value(obj_transform_and_validate_value_results.value);
                        } else {
                            // maybe nothing here now.

                        }
                    }

                    

                }



            } else {
                set_value_with_valid_and_changed_value(value);
            }

            // Will make use of various subclass helper functions when they are available.




            // transform_validate_value
            // parse_validate_value

            //if (data_value.validate_value)

        }

    })


}

module.exports = setup_base_data_value_value_property;
},{"./Validation_Success":174}],177:[function(require,module,exports){
var jsgui = require('lang-mini');
const {more_general_equals} = require('./tools');
const Base_Data_Value = require('./Base_Data_Value');
const Value_Set_Attempt = require('./Value_Set_Attempt');
const Data_Model = require('../Data_Model');
const Immutable_Data_Model = require('./Immutable_Data_Model');
const Immutable_Data_Value = require('./Immutable_Data_Value');
const {is_defined, input_processors, field, tof, each, is_array, Data_Type} = jsgui;

const setup_data_value_data_type_set = (data_value, data_type) => {
    let local_js_value;

    const define_string_value_property = () => {

        Object.defineProperty(data_value, 'value', {
            get() {
                return local_js_value;
            },
            set(value) {

                // Than in 'inner set'???
                




                //console.log('1) set(value)');

                const old_value = local_js_value;

                //console.log('old_value (local_js_value)', old_value);

                const immu = data_value.toImmutable();

                //console.log('immu', immu);
                //console.log('value', value);

                const value_equals_current = immu.equals(value);
                //console.log('value_equals_current', value_equals_current);
                if (!value_equals_current) {
                    const t_value = tof(value);
                    //console.log('t_value', t_value);
                    let made_change = false;
                    if (t_value === 'string') {
                        if (local_js_value instanceof Base_Data_Value) {
                            console.log('existing local_js_value instanceof Data_Value');
                            console.log('local_js_value.value', local_js_value.value);
                            console.log('local_js_value.data_type.name', local_js_value.data_type.name);
                            console.trace();
                            throw 'NYI';
                        } else if (local_js_value === undefined) {
                            local_js_value = value;
                            made_change = true;
                        } else if (typeof local_js_value === 'string') {
                            local_js_value = value;
                            made_change = true;
                        } else {
                            console.trace();
                            throw 'stop';
                        }
                    } else {
                        if (value instanceof Base_Data_Value) {
                            console.log('t_value', t_value);
                            console.log('value', value);
                            console.trace();
                            throw 'stop';
                        } else {


                            const tval = tof(value);

                            if (tval === 'number') {
                                local_js_value = value + '';
                                made_change = true;

                            } else {

                                console.log('-- INVALID TYPE --');

                                // Maybe need more handling here though....

                                console.log('tof(old_value)', tof(old_value));
                                console.log('tof(value)', tof(value));



                                data_value.raise('validate', {
                                    valid: false,
                                    reason: 'Invalid Type',
                                    value,
                                    old: local_js_value
                                });

                            }

                            
                        }
                    }
                    if (made_change) {
                        const my_e = {
                            name: 'value',
                            old: old_value,
                            value: local_js_value
                        }
                        data_value.raise('change', my_e);
                    }
                }
            }
        });
    }

    const define_data_type_typed_value_property = () => {
        const {wrap_properties, property_names, property_data_types, wrap_value_inner_values, value_js_type,
            abbreviated_property_names, named_property_access, numbered_property_access, parse_string} = data_type;
        let num_properties;
        if (property_names && property_data_types) {
            if (property_names.length === property_data_types.length) {
                num_properties = property_names.length;
                if (numbered_property_access) {
                }
            }
        } else if (property_names) {
            num_properties = property_names.length;
        }
        let _current_immutable_value, _previous_immutable_value;
        let prev_outer_value, current_outer_value;
        let _numbered_property_access_has_been_set_up = false, _named_property_access_has_been_set_up = false;



        Object.defineProperty(data_value, 'value', {
            get() {
                return local_js_value;
            },
            set(value) {
                const immu = data_value.toImmutable();
                const value_equals_current = immu.equals(value);
                //console.log('2) set(value)');

                if (value_equals_current) {

                    //console.log('value_equals_current', value_equals_current);

                    // Don't even validate. Maybe raise event saying set-refused?
                    //   set_to_current event possibly???


                } else {
                    const passed_first_validation = data_type.validate(value);
                    //console.log('value', value);
                    //console.log('passed_first_validation', passed_first_validation);


                    let passed_validation = passed_first_validation;
                    if (!passed_first_validation) {
                        const t_value = tof(value);
                        //console.log('failed first validation t_value:', t_value);
                        if (t_value === 'string' && data_type.parse_string) {
                            const parsed_value = data_type.parse_string(value);
                            if (parsed_value !== undefined) {
                                if (data_type.validate(parsed_value)) {
                                    if (!immu.equals(parsed_value)) {
                                        value = parsed_value;
                                        passed_validation = true;
                                    }
                                }
                            }
                        }
                        // 
                    }
                    //console.log('passed_validation', passed_validation);
                    if (passed_validation) {
                        data_value.raise('validate', {
                            valid: true,
                            value
                        });
                    } else {
                        data_value.raise('validate', {
                            valid: false,
                            value
                        });
                    }


                    if (passed_validation) {
                        const do_actual_set = (value) => {
                            //console.log('do_actual_set');
                            const array_specific_value_processing = () => {
                                if (value_js_type === Array) {
                                    let t = tof(local_js_value);
                                    if (t === 'undefined') {
                                        const create_array_with_wrapped_items = () => {
                                            if (num_properties) {
                                                if (wrap_value_inner_values) {
                                                    if (property_data_types) {
                                                        let i = 0;
                                                        if (value.__immutable) {
                                                            const l = value.length;
                                                            const arr_wrapped_value_values = new Array(l);
                                                            const value_value = value.value;
                                                            do_actual_set(value_value);
                                                        } else {
                                                            if (value instanceof Data_Value) {
                                                                const arr_wrapped_value_values = new Array(num_properties);
                                                                const arr_dv_value = value.value;
                                                                console.log('arr_dv_value', arr_dv_value);
                                                                console.trace();
                                                                throw 'stop';
                                                            } else if (is_array(value)) {
                                                                const arr_wrapped_value_values = value.map(value => {
                                                                    const property_index = i;
                                                                    let property_name;
                                                                    if (property_names) {
                                                                        property_name = property_names[property_index];
                                                                    }
                                                                    const wrapped_value = new Data_Value({context, value, data_type: property_data_types[i]});
                                                                    wrapped_value.on('change', e => {
                                                                        const {name} = e;
                                                                        if (name === 'value') {
                                                                            current_outer_value = data_value.toImmutable();
                                                                            const my_e = {
                                                                                name,
                                                                                event_originator: wrapped_value,
                                                                                parent_event: e,
                                                                                value: current_outer_value
                                                                            }
                                                                            if (property_name) {
                                                                                my_e.property_name = property_name;
                                                                            }
                                                                            my_e.property_index = property_index;
                                                                            data_value.raise('change', my_e);
                                                                            prev_outer_value = current_outer_value;
                                                                        }
                                                                    })
                                                                    i++;
                                                                    return wrapped_value;
                                                                });
                                                                local_js_value = arr_wrapped_value_values;
                                                                const my_e = {
                                                                    name: 'value',
                                                                    old: _previous_immutable_value,
                                                                    value: data_value.toImmutable()
                                                                }
                                                                data_value.raise('change', my_e);
                                                            }
                                                        }
                                                    } else {
                                                        let i = 0;
                                                        const arr_wrapped_value_values = value.map(value => {
                                                            const property_index = i;
                                                            let property_name;
                                                            if (property_names) {
                                                                property_name = property_names[property_index];
                                                            }
                                                            const wrapped_value = new Data_Value({context, value});
                                                            wrapped_value.on('change', e => {
                                                                const {name} = e;
                                                                if (name === 'value') {
                                                                    const my_e = {
                                                                        name,
                                                                        event_originator: wrapped_value,
                                                                        parent_event: e,
                                                                        value: data_value.toImmutable()
                                                                    }
                                                                    if (property_name) {
                                                                        my_e.property_name = property_name;
                                                                    }
                                                                    my_e.property_index = property_index;
                                                                    data_value.raise('change', my_e);
                                                                }
                                                            })
                                                            i++;
                                                            return wrapped_value;
                                                        });
                                                        local_js_value = arr_wrapped_value_values;
                                                    }
                                                } else {
                                                    local_js_value = value;
                                                }
                                            } else {
                                                console.trace();
                                                throw 'stop - number of properties not found';
                                            }
                                        }
                                        create_array_with_wrapped_items();
                                    } else if (t === 'array') {
                                        const t_value = tof(value);
                                        if (t_value === 'data_value') {
                                            if (is_array(value.value)) {
                                                if (value.value.length === local_js_value.length) {
                                                    each(value.value, (inner_value, idx) => {
                                                        if (inner_value instanceof Data_Model) {
                                                            const matching_local_inner_value = local_js_value[idx];
                                                            if (inner_value.equals(matching_local_inner_value)) {
                                                            } else {
                                                                matching_local_inner_value.value = inner_value;
                                                            }
                                                        } else {
                                                            console.trace();
                                                            throw 'NYI';
                                                        }
                                                    })
                                                } else {
                                                    console.trace();
                                                    throw 'NYI';
                                                }
                                            } else {
                                                console.trace();
                                                throw 'NYI';
                                            }
                                        } else {
                                            if (t_value === 'array') {
                                                if (local_js_value.length === value.length) {
                                                    const l = value.length;
                                                    let all_local_js_items_are_data_model = true, c = 0;
                                                    do {
                                                        const local_item = local_js_value[c];
                                                        if (!(local_item instanceof Data_Model)) {
                                                            all_local_js_items_are_data_model = false;
                                                        }
                                                        c++;
                                                    } while (all_local_js_items_are_data_model && c < l);
                                                    if (all_local_js_items_are_data_model) {
                                                        let c = 0;
                                                        do {
                                                            const local_item = local_js_value[c];
                                                            local_item.value = value[c];
                                                            c++;
                                                        } while (c < l);
                                                    } else {
                                                        console.trace();
                                                        throw 'NYI';
                                                    }
                                                } else {
                                                    console.trace();
                                                    throw 'NYI';
                                                }
                                            } else {
                                                console.log('value', value);
                                                console.trace();
                                                throw 'NYI';
                                            }
                                        }
                                    } else {
                                    }
                                } else {
                                }
                            }
                            array_specific_value_processing();
                            const general_value_processing = () => {
                                if (local_js_value instanceof Base_Data_Value) {
                                    console.log('existing local_js_value instanceof Data_Value');
                                    console.log('local_js_value.value', local_js_value.value);
                                    console.log('local_js_value.data_type.name', local_js_value.data_type.name);
                                    console.trace();
                                    throw 'NYI';
                                } else if (local_js_value instanceof Array) {
                                    if (value instanceof Data_Model) { 
                                        if (value.equals(local_js_value)) {
                                        } else {
                                            console.log('value', value);
                                            console.log('local_js_value', local_js_value);
                                            console.trace();
                                            throw 'NYI';
                                        }
                                    } else if (value instanceof Array) {
                                        if (property_names.length === value.length) {
                                            if (property_data_types) {
                                                const num_properties = property_names.length;
                                                for (let i_property = 0; i_property < num_properties; i_property++) {
                                                    const name = property_names[i_property];
                                                    const data_type = property_data_types[i_property];
                                                    if (local_js_value[i_property] instanceof Data_Value) {
                                                        local_js_value[i_property].value = value[i_property];
                                                    } else {
                                                        console.trace();
                                                        throw 'NYI';
                                                    }
                                                }
                                                if (numbered_property_access && !_numbered_property_access_has_been_set_up) {
                                                    for (let i_property = 0; i_property < num_properties; i_property++) {
                                                        const name = property_names[i_property];
                                                        const data_type = property_data_types[i_property];
                                                        Object.defineProperty(data_value, i_property, {
                                                            get() {
                                                                return local_js_value[i_property];
                                                            },
                                                            set(value) {
                                                                const item_already_there = local_js_value[i_property];
                                                                if (item_already_there instanceof Data_Model) {
                                                                    item_already_there.value = value;
                                                                } else {
                                                                    console.log('item_already_there', item_already_there);
                                                                    console.trace();
                                                                    throw 'stop';
                                                                }
                                                                if (value instanceof Data_Model) {
                                                                } else {
                                                                }
                                                            }
                                                        })
                                                    }
                                                    Object.defineProperty(data_value, 'length', {
                                                        get() {
                                                            return local_js_value.length;
                                                        }
                                                    });
                                                    _numbered_property_access_has_been_set_up = true;
                                                }
                                                if (named_property_access && !_named_property_access_has_been_set_up) {
                                                    if (numbered_property_access) {
                                                        if (property_names) {
                                                            for (let i_property = 0; i_property < num_properties; i_property++) {
                                                                const name = property_names[i_property];
                                                                const data_type = property_data_types[i_property];
                                                                Object.defineProperty(data_value, name, {
                                                                    get() {
                                                                        return local_js_value[i_property];
                                                                    },
                                                                    set(value) {
                                                                        const item_already_there = local_js_value[i_property];
                                                                        if (item_already_there instanceof Data_Model) {
                                                                            item_already_there.value = value;
                                                                        } else {
                                                                            console.log('item_already_there', item_already_there);
                                                                            console.trace();
                                                                            throw 'stop';
                                                                        }
                                                                    }
                                                                })
                                                            }
                                                        }
                                                        if (abbreviated_property_names) {
                                                            for (let i_property = 0; i_property < num_properties; i_property++) {
                                                                const name = abbreviated_property_names[i_property];
                                                                const data_type = property_data_types[i_property];
                                                                Object.defineProperty(data_value, name, {
                                                                    get() {
                                                                        return local_js_value[i_property];
                                                                    },
                                                                    set(value) {
                                                                        const item_already_there = local_js_value[i_property];
                                                                        if (item_already_there instanceof Data_Model) {
                                                                            item_already_there.value = value;
                                                                        } else {
                                                                            console.log('item_already_there', item_already_there);
                                                                            console.trace();
                                                                            throw 'stop';
                                                                        }
                                                                        if (value instanceof Data_Model) {
                                                                        } else {
                                                                        }
                                                                    }
                                                                })
                                                            }
                                                        }
                                                    }
                                                    _named_property_access_has_been_set_up = true;
                                                }
                                            }
                                        } else {
                                            console.trace();
                                            throw 'NYI';
                                        }
                                    } else {
                                        console.log('value', value);
                                        console.log('local_js_value', local_js_value);
                                        console.log('value_equals_current', value_equals_current);
                                        console.log('immu', immu);
                                        console.trace();
                                        throw 'NYI';
                                    }
                                } else {
                                    if (value instanceof Data_Model) {
                                        if (value.data_type === data_value.data_type) {
                                            const tvv = tof(value.value);
                                            if (tvv === 'number' || tvv === 'string' || tvv === 'boolean') {
                                                local_js_value = value.value;
                                            } else {
                                                console.trace();
                                                throw 'NYI';
                                            }
                                        } else {
                                            console.trace();
                                            throw 'NYI';
                                        }
                                    } else {
                                        local_js_value = value;
                                    }
                                    data_value.raise('change', {
                                        name: 'value',
                                        old: immu,
                                        value: value
                                    });
                                    prev_outer_value = current_outer_value;
                                }
                            }
                            general_value_processing();
                        }

                        do_actual_set(value);


                    } else {
                    }
                    
                }
            }
        });
    }

    if (data_type === String) {
        define_string_value_property();
    } else if (data_type instanceof Data_Type) {
        define_data_type_typed_value_property();
    } else {
        console.trace();
        throw 'NYI';
    }


}

module.exports = setup_data_value_data_type_set;
},{"../Data_Model":164,"./Base_Data_Value":168,"./Immutable_Data_Model":171,"./Immutable_Data_Value":172,"./Value_Set_Attempt":175,"./tools":178,"lang-mini":379}],178:[function(require,module,exports){
const Data_Model = require('../Data_Model');
const {tof} = require('lang-mini');

const more_general_equals = (that, other) => {

    if (other instanceof Data_Model) {
        // Compare the values???

        // For the moment, get them as JSON....

        // Though it looks like getting the values as JSON is not working properly in some cases.

        

        const my_json = that.toJSON();
        const other_json = other.toJSON();



        //console.log('[my_json, other_json]', [my_json, other_json]);

        //console.trace();
        //throw 'stop';

        return my_json === other_json;

    } else {
        // what type is being stored in this????

        // look at .value????
        //   or the unwrapped value....?

        // Does it have a .value????

        //console.log('[that, other]', [that, other]);

        if (that === other) {
            return true;
        } else {

            if (that === undefined) {
                return false;
            } else {
                const {value} = that;

                const t_value = tof(value), t_other = tof(other);

                //console.log('[t_value, t_other]', [t_value, t_other]);
                //console.log('*** [value, other]', [value, other]);

                if (t_value === t_other) {
                    //console.log('*** [value, other]', [value, other]);

                    if (value === other) {
                        return true;
                    } else {
                        if (typeof value.equals === 'function' && typeof other.equals === 'function') {
                            return value.equals(other);
                        } else {

                            if (value === other) {
                                return true;
                            } else {

                                if (t_value === 'number' || t_value === 'string' || t_value === 'boolean') {
                                    return value === other;
                                } else {

                                    if (t_value === 'array') {
                                        // or tostring / tojson???

                                        if (value.length === other.length) {
                                            // compare each of them....

                                            let res = true, c = 0, l = value.length;

                                            do {
                                                res = more_general_equals(value[c], other[c]);
                                                c++;
                                            } while (res === true && c < l)
                                            return res;

                                        } else {
                                            return false;
                                        }

                                    } else {
                                        console.log('[value, other]', [value, other]);
                                        console.trace();
                                        throw 'NYI';

                                    }
                                }
                            }
                        }
                    }


                    
                } else {
                    // But number parsing etc....
                    return false;
                }


            }
        }




        
    }
}

module.exports = {
    more_general_equals


}
},{"../Data_Model":164,"lang-mini":379}],179:[function(require,module,exports){

var lang = require('lang-mini');
//var Data_Structures = require('./jsgui-data-structures');
var Data_Value = require('./Data_Value');
var Data_Object = require('./Data_Object');
var Sorted_KVS = require('../../sorted-kvs');
var dobj = Data_Object.dobj;
//console.log('Data_Object', Data_Object);
//var Data_Object_Field_Collection = Data_Object.Fields_Collection;
//var Constraint = require('./constraint');

var Constraint = Data_Object.Constraint;
var each = lang.each;
var tof = lang.tof;
var is_defined = lang.is_defined;
var stringify = lang.stringify;
var get_a_sig = lang.get_a_sig;
//var constraint_from_obj = Constraint.from_obj;
var native_constructor_tof = lang.native_constructor_tof;
var dop = Data_Object.prototype;

// Could definitely do with more work and testing.
//  Being sure of what its API is.
// .A fixed version of what it is now, consider and ask about improvements.

// May make a new version that's a copy of it, and make breaking changes to it.
//   Maybe also work on a ground-up implementation, and introduce parts of that into the new copy of Collection.

// May also want a Data_Object or Data_Value that holds or uses or represents a Typed_Array.
//   However, would not (be able to??) respond to changes in the value(s) in that typed aray.
//    Unless some trickery was done....
//    A wrapped Data_Model_Typed_Array could slow things down too much.

// At some points need to be OK with holding and sometimes changing raw values.
//   If you want to trigger the change notifications, use the higher level APIs.



// Want to enable silent updates.
//   So it does not raise events.



// .silent property.
//   would check for it before raising events.





class Collection extends Data_Object {
    constructor(spec = {}, arr_values) {
        super(spec);
        this.__type = 'collection';
        this.__type_name = 'collection';

        var t_spec = tof(spec);
        if (spec.abstract === true) {
            if (t_spec === 'function') {
                this.constraint(spec);
            }
        } else {

            // For the moment, mainly wraps the ._arr object.
            //   In newer version(s) may retain the ._arr property. Maybe not though.
            //     Perhaps this class would better use a proxy to provide access to multiple items in the array,
            //      and responding to them being changed?





            this._relationships = this._relationships || {};
            this._arr_idx = 0;
            this._arr = [];
            this.index = new Sorted_KVS();
            this.fn_index = spec.fn_index;

            if (t_spec === 'array') {
                spec = {
                    'load_array': spec
                };
            } else {
                if (t_spec === 'function') {
                    if (spec.abstract === true) {
                        //throw 'Collection with abstract spec function';
                        this._abstract = true;
                    } else {
                    }

                } else if (t_spec === 'string') {
                    var map_native_constructors = {
                        'array': Array,
                        'boolean': Boolean,
                        'number': Number,
                        'string': String,
                        'object': Object
                    }
                    var nc = map_native_constructors[spec];
                    if (nc) {
                        spec = {
                            'constraint': nc
                        };
                        if (nc == String) {
                            spec.index_by = 'value';
                        }
                    }
                }
            }
            if (is_defined(spec.items)) {
                spec.load_array = spec.load_array || spec.items;
            }
            if (arr_values) {
                //console.log('load arr_values ------------');
                spec.load_array = arr_values;
            }
            // keeping these things below the expected public interface.
            if (is_defined(spec.accepts)) {
                this._accepts = spec.accepts;
            }
            if (lang.__data_id_method === 'init') {
                // but maybe there will always be a context. May save download size on client too.
                if (this.context) {
                    this.__id = this.context.new_id(this.__type_name || this.__type);
                    this.context.map_objects[this.__id] = this;
                } else {
                    // don't think we want a whole bunch of objects mapped like this....
                    //  IDs will be very useful when they are controls... but maybe not always needed.

                    //this.__id = new_collection_id();
                    //map_jsgui_ids[this.__id] = this;
                }
            }
            if (!this.__type) {

            }
            if (spec.load_array) {
                this.load_array(spec.load_array);
            }
        }
    }
    // maybe use fp, and otherwise apply with the same params and context.
    'set' (value) {
        var tval = tof(value);
        if (tval === 'data_object' || tval === 'data_value') {
            this.clear();
            return this.push(value);
        } else if (tval === 'array') {
            // for an array... clear, then add each.
            this.clear();
            each(value, (v, i) => {
                this.push(v);
            });
        } else {
            if (tval === 'collection') {
                // need to reindex - though could have optimization that checks to see if the indexes are the same...
                throw 'stop';
                this.clear();
                value.each(function (v, i) {
                    that.push(v);
                });
            } else {
                //console.log("_super:" + value);
                return this.super.set(value);
            }
        }
    }

    'clear' () {



        this._arr_idx = 0;
        this._arr = [];
        this.index.clear();
        // listner class hears the event but then loses access to its own this.

        // The future change clear event could have an immutable copy of this efore the change, and return it as the old value???

        // However, Collection (maybe?) would not even have .value.
        //   or .value could be the array like ._arr???
        //   and also provide a ._arr interface in the future.





        this.raise('change', {
            'name': 'clear'
        });
    }

    'stringify' () {
        var res = [];
        if (this._abstract) {
            // then we can hopefully get the datatype name
            // if it's abstract we detect it, otherwise it should be in there.
            var ncto = native_constructor_tof(this._type_constructor);
            res.push('~Collection(')
            if (ncto) {
                res.push(ncto);
            } else {

            }
            res.push(')');
        } else {
            res.push('Collection(');
            //console.log('obj._arr ' + stringify(obj._arr));
            var first = true;
            this.each(function (v, i) {
                if (!first) {
                    res.push(', ');
                } else {
                    first = false;
                }
                res.push(stringify(v));
            });
            res.push(')');
        }
        return res.join('');
    }

    'toString' () {
        return stringify(this._arr);
    }

    'toObject' () {
        var res = [];
        this.each(function (v, i) {
            res.push(v.toObject());
        });
        return res;
    }

    'each' () {
        var a = arguments;
        a.l = arguments.length;
        var sig = get_a_sig(a, 1);
        // was callback, context
        // ever given the context?

        if (sig == '[f]') {
            return each(this._arr, a[0]);
        } else {

            if (sig == '[X,f]') {
                // X for index

                // we use the order of the index.
                //  possibly we can iterate using the index itself, maybe with that same callback.

                var index = a[0];
                var callback = a[1];
                return index.each(callback);

            } else {
                if (a.l == 2) {
                    return each(this._arr, a[0], a[1]);
                }
            }
        }
    }

    '_id' () {
        // gets the id (a new one sometimes)
        if (this.context) {
            this.__id = this.context.new_id(this.__type_name || this.__type);
        } else {
            //if (!is_defined(this.__id)) {

                // get a temporary id from somewhere?
                //  but the collection should really have a context...
                //  or without a context, the collection is its own context?

                // Won't go setting the ID for the moment.

                //this.__id = new_collection_id();
            //}
        }
        return this.__id;
    }
    'length' () {
        return this._arr.length;
    }
    get len () {
        return this._arr.length
    }
    'find' () {
        var a = arguments;
        a.l = arguments.length;
        var sig = get_a_sig(a, 1);
        if (a.l == 1) {
            var pos = this.index.get(a[0])[0];
            //console.log('pos', pos);
            var item = this._arr[pos];
            return item;
            // if there is only one index in the system then the search will be simple.
        }
        if (sig == '[o,s]') {
            return this.index_system.find(a[0], a[1]);
        }
        // and if looking for more than one thing...
        if (sig == '[s,s]') {
            return this.index_system.find(a[0], a[1]);
        }
        if (sig == '[a,s]') {
            return this.index_system.find(a[0], a[1]);
        }
        if (sig == '[s,o]') {
            var propertyName = a[0];
            var query = a[1];
            var foundItems = [];
            // for each object we need to go deeper into the fields.
            each(this, (item, index) => {
                if (item.get) {
                    var itemProperty = item.get(propertyName);
                } else {
                    var itemProperty = item[propertyName];
                }
                var tip = tof(itemProperty);
                var tip2;
                var ip2;

                if (tip === 'data_value') {
                    var ip2 = itemProperty.value();
                    tip2 = tof(ip2);
                } else {
                    ip2 = itemProperty;
                    tip2 = tip;
                }
                if (tip2 === 'array') {
                    each(ip2, (v, i) => {
                        //console.log('v ' + stringify(v));
                        var matches = obj_matches_query_obj(v, query);
                        //console.log('matches ' + matches);
                        if (matches) {
                            foundItems.push(v);
                        }
                    })
                };
            });
            var res = new Collection(foundItems);
            return res;
        }
    }
    // get seems like the way to get unique values.

    'get' () {
        var a = arguments;
        a.l = arguments.length;
        var sig = get_a_sig(a, 1);
        if (sig == '[n]' || sig == '[i]') {
            return this._arr[a[0]];
        }
        if (sig == '[s]') {
            var ix_sys = this.index_system;
            var res;
            if (ix_sys) {
                //console.log('ix_sys', ix_sys);
                var pui = ix_sys._primary_unique_index;
                //console.log(pui);
                res = pui.get(a[0])[0];
            }
            if (res) {
                return res;
            }
            return Data_Object.prototype.get.apply(this, a);
        }
    }

    'insert' (item, pos) {
        this._arr.splice(pos, 0, item);
        this.raise('change', {
            'name': 'insert',
            'item': item,
            'value': item,
            'pos': pos
        });
    }
    swap(item, replacement) {
        let r_parent = replacement.parent;
        let repl_pos = replacement.parent.content.remove(replacement);
        let i_parent = item.parent;
        let item_pos = item.parent.content.remove(item);
        let item_index;
        i_parent.content.insert(replacement, item_pos);
        r_parent.content.insert(item, repl_pos);
    }

    // may have efficiencies for adding and removing multiple items at once.
    //  can be sorted for insertion into index with more rapid algorithmic time.

    'remove' () {
        // Make more monomorphic. ????2023????

        var a = arguments;
        a.l = arguments.length;
        var sig = get_a_sig(a, 1);
        //var that = this;

        //console.log('remove sig:', sig);

        if (sig === '[n]') {
            var pos = a[0];
            //console.log('pos - item index', pos);
            var item = this._arr[pos];
            //var o_item = item;
            var spliced_pos = pos;
            this._arr.splice(pos, 1);
            this._arr_idx--;
            //var length = this._arr.length;

            /*
            while (pos < length) {
                // reassign the stored position of the item
                var item = this._arr[pos];

                // Not so sure about 'relationships' here.
                //item.relationships[own_id] = [this, pos];

                pos++;
            }
            */


            var e = {
                'target': this,
                'value': item,
                'position': spliced_pos,
                'name': 'remove'
            }
            this.raise('change', e);

            return pos;
        } else if (sig === '[s]') {
            var key = a[0];
            var obj = this.index_system.find([
                ['value', key]
            ]);
            var my_id = this.__id;
            var item_pos_within_this = obj[0]._relationships[my_id];
            this._arr.splice(item_pos_within_this, 1);
            for (var c = item_pos_within_this, l = this._arr.length; c < l; c++) {
                //console.log('c ' + c);
                var item = this._arr[c];
                item._relationships[my_id]--;
            }
            var e = {
                'target': this,
                'value': obj[0],
                'position': item_pos_within_this,
                'name': 'remove'
            }
            this.raise('change', e);
        } else {
            let item_index;
            // or swap the item itself
            const item = a[0];

            // 

            let arr = this._arr,
                l = arr.length;
            if (typeof item === 'number') {
                item_index = item;
            } else {
                let found = false,
                    c = 0;
                
                
                while (!found && c < l) {
                    found = arr[c] === item;

                    if (found) {
                        item_index = c;
                    }

                    
                    c++;
                }
                //if (found) {
                //}

                if (is_defined(item_index)) {
                    return this.remove(item_index);
                }
            }
        }
    }

    'has' (obj_key) {
        // This part needs (temp?) fixing...

        //console.log('obj_key', obj_key);

        if (this.get_index(obj_key) === undefined) {
            return false;
        } else {
            return true;
        }

        //console.trace();
        //throw 'NYI';
    }
    'get_index' () {
        // Make (more) monomorphic, have it consult the sorted KVS.
        var a = arguments;
        a.l = arguments.length;
        var sig = get_a_sig(a, 1);
        if (sig === '[s]') {

            if (this.index_system) {

                return this.index_system.search(a[0]);

                

            } else {
                //console.log('a[0]', a[0]);

                // Could search by name...?

                //console.log('this._arr', this._arr);

                if (this._arr.length === 0) {
                    return undefined;
                } else {

                    // go through the objects in the array.
                    //   check against 'name' properties...

                    for (let c = 0; c < this._arr.length; c++) {
                        const item = this._arr[c];



                        if (item?.name === a[0]) {
                            return c;
                        }

                    }

                    return undefined;

                    //console.trace();
                    //throw 'stop';
                }

                
            }

            
        } else {
            console.trace();
            throw 'Expected [s]';
        }
    }
    
    // More fp way of indexing.
    'index_by' () {
        var a = arguments;
        a.l = arguments.length;
        var sig = get_a_sig(a, 1);

        console.log('Indexing not implemented (like this)');
        console.trace();
    }

    'push' (value) {

        const {silent} = this;



        let tv = tof(value);
        let fn_index = this.fn_index;
        let idx_key, has_idx_key = false,
            pos;
        if (fn_index) {
            idx_key = fn_index(value);
            has_idx_key = true;
        }
        if (tv === 'object' || tv === 'function') {
            // Long comments removed. Use functional constraint satisfaction if we have that.
            pos = this._arr.length;
            this._arr.push(value);
            //console.log('pushing value', value);
            //this.index_system.unsafe_add_object(value);
            this._arr_idx++;


            if (!silent) {
                const e = {
                    'target': this,
                    'item': value,
                    'value': value,
                    'position': pos,
                    'name': 'insert'
                }
                this.raise('change', e);
            }

            
        } else if (tv === 'collection') {
            pos = this._arr.length;
            this._arr.push(value);
            this._arr_idx++;

            if (!silent) {
                const e = {
                    'target': this,
                    'item': value,
                    'value': value,
                    'position': pos,
                    'name': 'insert'
                }
                this.raise('change', e);
            }

        } else if (tv === 'data_object' || tv === 'control') {
            pos = this._arr.length;
            // Should not need a context or ID just to be put in place.
            this._arr.push(value);
            this._arr_idx++;
            if (!silent) {
                const e = {
                    'target': this,
                    'item': value,
                    'value': value,
                    'position': pos,
                    'name': 'insert'
                }
                this.raise('change', e);
            }
        } else if (tv === 'array') {
            const new_coll = new Collection(value);
            pos = this._arr.length;
            // Should not need a context or ID just to be put in place.
            this._arr.push(new_coll);
            if (!silent) {
                const e = {
                    'target': this,
                    'item': value,
                    'value': value,
                    'position': pos,
                    'name': 'insert'
                }
                this.raise('change', e);
            }
        }

        if (tv === 'string' || tv === 'number') {
            // Not so sure about this now.
            const dv = new Data_Value({
                'value': value
            });
            pos = this._arr.length;
            // Should not need a context or ID just to be put in place.
            this._arr.push(dv);
            if (!silent) {
                const e = {
                    'target': this,
                    'item': value,
                    'value': value,
                    'position': pos,
                    'name': 'insert'
                }
                this.raise('change', e);
            }
        }
        if (has_idx_key) {
            this.index.put(idx_key, pos);
        }
        //this._arr_idx++;
        return value;
    }

    'load_array' (arr) {
        for (var c = 0, l = arr.length; c < l; c++) {
            this.push(arr[c]);
        }
        this.raise('load');
    }
    'values' () {
        var a = arguments;
        a.l = a.length;
        //var sig = get_a_sig(a, 1);
        if (a.l === 0) {
            return this._arr;
        } else {
            var stack = new Error().stack;
            throw 'not yet implemented';
        }
    }
    'value' () {
        const res = [];
        this.each((v, i) => {
            if (typeof v.value == 'function') {
                res.push(v.value());
            } else {
                res.push(v);
            }
        });
        return res;
    }
};

var p = Collection.prototype;
p.add = p.push;
module.exports = Collection;
},{"../../sorted-kvs":189,"./Data_Object":180,"./Data_Value":181,"lang-mini":379}],180:[function(require,module,exports){
var jsgui = require('lang-mini');


// 2022 - Looks like it could be modified into being Model, or part of one.
// 2023 - In the process of doing this.


//var Evented_Class = require('./_evented-class');
//var Data_Structures = require('./jsgui-data-structures');
var Data_Value = require('./Data_Value');
//var Constraint = require('./constraint');
//var Fields_Collection = require('./fields-collection');
//var Collection = require('jsgui2-collection');
var j = jsgui;
var Evented_Class = j.Evented_Class;
var Class = j.Class;
var each = j.each;
var is_array = j.is_array;
var is_dom_node = j.is_dom_node;
var is_ctrl = j.is_ctrl;
var extend = j.extend;
var get_truth_map_from_arr = j.get_truth_map_from_arr;
var get_map_from_arr = j.get_map_from_arr;
var arr_like_to_arr = j.arr_like_to_arr;
var tof = j.tof;
var is_defined = j.is_defined;
var stringify = j.stringify;
var functional_polymorphism = j.functional_polymorphism;
var fp = j.fp;
var arrayify = j.arrayify;
var mapify = j.mapify;
var are_equal = j.are_equal;
var get_item_sig = j.get_item_sig;
var get_a_sig = j.get_a_sig;
var set_vals = j.set_vals;
var truth = j.truth;
var trim_sig_brackets = j.trim_sig_brackets;
var ll_set = j.ll_set;
var ll_get = j.ll_get;
var input_processors = j.input_processors;
var iterate_ancestor_classes = j.iterate_ancestor_classes;
var is_arr_of_arrs = j.is_arr_of_arrs;
var is_arr_of_strs = j.is_arr_of_strs;
var is_arr_of_t = j.is_arr_of_t;
var clone = jsgui.clone;
var data_value_index = 0;
//var data_value_abbreviation = 'val';

// do data objects get an ID when they are initialized.
jsgui.__data_id_method = 'init';


// Seems worthwhile to get rid of constraint matching and fields.
//  Constraint matching will be added back in using a more functional system.
//  Indexing should be put down to a simple process that calls some simple functions.
//   It has got way too complicated so far. We need to map between an object (reading specific properties) and an array value.
//    The lists of keys for these items will be stored within a sorted structure.

// Data_Object and Data_Value both being Data_Item????
// Or Data_Model ????

// Or within a 'Model' category.
//   This is working now as the 'M' within 'MVC' or 'CMVM'

// data-model directory overall???
// data_model_base perhaps????

// or just start at data_model Data_Model for now.



// Get fields key from object.
//  Worth keeping consistent and formatted notes about what the fields key is.
//  Possibly will still use some object oriented structures. Complex OO structures are easier to understand than bunches of variables.

// However, an improved function that calculates field keys from objects makes sense.
//  May not be impossible to fix things from this codebase.

// Just not sure about the indexing right now.


// This seems a little bit like 'Model'.





//var obj_matches_constraint = Constraint.obj_matches_constraint;
//var native_constructor_tof = jsgui.native_constructor_tof;

//var value_as_field_constraint = Constraint.value_as_field_constraint;

//var Ordered_String_List = Data_Structures.Ordered_String_List;

const Mini_Context = require('../Mini_Context');
const Data_Model = require('../Data_Model');

var is_js_native = function (obj) {
    var t = tof(obj);

    // other types????
    return t == 'number' || t == 'string' || t == 'boolean' || t == 'array';
};

// Seems as though fields are not important to how these work effectively (fields being in obext / oext)

class Data_Object extends Data_Model {
    constructor(spec = {}, fields) {
        //console.log('1* spec.__type_name', spec.__type_name);
        super(spec);
        if (spec.id) {
			this.__id = spec.id;
		}
		if (spec.__id) {
			this.__id = spec.__id;
		}
        this.__type_name = spec.__type_name || 'data_object';

        // Will be better to use obext for fields.

        // Does seem worth not using this any longer....
        //   Replace with something more powerful?

        // Moving obext field to lang-mini could help....
        //   Copying it there, for the moment.
        //     Could even modify obext so it passes through fields from lang-mini.



        if (fields) this.set_fields_from_spec(fields, spec);

        // Should incorporate data types within fields.
        //   Maybe grammer too....?

        this.__data_object = true;

        // Do need to still be concious of performance here.
        //   This is currently working as a basis for jsgui controls, which do work efficiently at the moment.
        //     Will need to be careful about changing the API.
        //     Could even write code at a higher level that would check which API is being used and use that....
        // Late 2023 - Seems as though there is a chance to make breaking changes here and fix them.
        //   So long as it makes the overall concepts clearer, and aids in more concise code.

        // don't want the .value() function, use getters and setters, or maybe the obext field.

        // Data_Value could have a 'name' or 'key_name' or 'key' property.
        //   Could use 'key' and 'name' interchangably.
        //   data_value.value ????    seems like it would be needed on some levels.
        //     maybe .toObject, toNumber, toString, toArray, toJSON, toInteger, toHashString????

        // 

        // .to(type)




        //   











        //if (!spec) spec = {};
        // if it's abstract call the abstract_init.

        //console.log('1** spec', spec);

        // Possibly will not need to handle abstract Data_Objects.
        //   It was done as an alternative to not using new with the old-style constructors, which was allowed, and could
        //     be detected.

        // Not sure about removing this.

        //   Easier of definition of fields.
        //     Fields as provided by obext. See about further support for that.
        //     See about those fields supporting Grammar or other type capabilities from lang-mini.

        // See about a little bit more code to get lang-mini enforcing (or providing enforcement functions to support) specific types,
        //   incl ranges within types, number of DP (auto-rounding).

        // 




        if (spec.abstract === true) {
            this._abstract = true;
            var tSpec = tof(spec);

            if (tSpec == 'function') {
                this._type_constructor = spec;
                // could possibly
                // but maybe want to keep this json-friendly.

                // the type constructor could be used in a collection.
                //  could be more leightweight than other things? specific constraint objects.
            } else if (tSpec == 'object') {
                this._spec = spec;
                // could possibly
                // but maybe want to keep this json-friendly.

                // the type constructor could be used in a collection.
                //  could be more leightweight than other things? specific constraint objects.
            }

        } else {
            //var that = this;
            //this._initializing = true;

            var t_spec = tof(spec);
            //console.log('t_spec', t_spec);

            if (!this.__type) {
                this.__type = 'data_object';
            }

            // 18/12/2016 getting rid of ._

            //if (!this.hasOwnProperty('_')) {
            //    this._ = {};
            //}

            //console.log('t_spec', t_spec);

            // Maybe could check for actual controls better.
            if (t_spec === 'object' || t_spec === 'control') {
                // Normal initialization

                if (spec.context) {
                    //console.log('spec has context');
                    this.context = spec.context;
                }
                if (spec.id) {
                    this.__id = spec.id;
                }
                if (spec._id) {
                    this.__id = spec._id;
                }
                if (spec.__id) {
                    this.__id = spec.__id;
                }
                //console.log('this.__id', this.__id);
                // want to see if we are using any of the spec items as fields.
            } else if (t_spec == 'data_object') {
                // Initialization by Data_Object value (for the moment)
                // Not so sure about copying the id of another object.
                if (spec.context) this.context = spec.context;
                // then copy the values over from spec
                
                /*.
                //var spec_keys = spec.keys();
                //console.log('spec_keys', spec_keys);
                each(spec_keys, function (i, key) {
                    //that.set(key, spec.get(key));
                    that.set(key, spec.get(key));
                });
                */
            }

            /*
            if (!is_defined(this.__id) && jsgui.__data_id_method == 'init') {
                if (this.context) {
                    //console.log('this.context ' + this.context);
                    //console.log('sfy this.context ' + stringify(this.context));

                    // Don't need an ID here.
                    //  I think.

                    //console.log('getting new id');
                    //this.__id = this.context.new_id(this.__type_name || this.__type);
                    //console.trace();
                    //console.log('DataObject new ID from context: ' + this.__id);
                    //this.context.map_objects[this.__id] = this;
                    // Not keeping a map of objects by id in the context.
                } else {

                }
            }
            */

            if (is_defined(spec.parent)) {
                //this.set('parent', spec.parent);
                this.parent = spec.parent;
            }

            if (this.context) {
                this.init_default_events();
            }

            //this._initializing = false;
        }
        //console.log('end Data_Object init');
    }



    'set_fields_from_spec'(fields, spec) {
        // obext fields don't work like this.
        //   Should do more to support obext fields, powerful functionality that raises change events.

        // .field.on('change') ???

        // So model.background.color would be a field (somehow???)
        //   Make some advances on this level, and then integrate it into an app.






        //let that = this;
        each(fields, field => {
            if (typeof spec[field[0]] !== 'undefined') {
                this[field[0]] = spec[field[0]];
            } else {
                this[field[0]] = field[2];
            }

        })
    }

    'init_default_events'() {
        // May still / again make use of this with some controls.

    }

    /*
     'data_def': fp(function(a, sig) {
     if (sig == '[o]') {
     // create the new data_def constraint.


     }
     }),
     */

    'keys'() {
        return Object.keys(this._);
    }

    'toJSON'() {
        var res = [];
        res.push('Data_Object(' + JSON.stringify(this._) + ')');
        return res.join('');
    }

    // using_fields_connection()
    //  will search up the object heirachy, to see if the Data_Objects fields need to be connected through the use of functions.
    //  that will make the fields easy to change by calling a function. Should make things much faster to access than when programming with Backbone.
    // then will connect the fields with connect_fields()


    /*
    'using_fields_connection'() {
        var res = false;
        iterate_ancestor_classes(this.constructor, function (a_class, stop) {
            if (is_defined(a_class._connect_fields)) {
                res = a_class._connect_fields;
                stop();
            }
        });
        return res;
    }
    */


    get parent() {
        return this._parent;
    }
    set parent(value) {
        return this._parent = value;
    }

    '_id'() {
        // gets the id.
        //console.log('Data_Object _id this.context ' + this.context);

        // Should get the context at an early stage if possible.
        //  Need to have it as the item is added, I think.
        if (this.__id) return this.__id;
        //if (!this.context) {
        //    if (this.parent.context) 
        //}

        if (this.context) {
            this.__id = this.context.new_id(this.__type_name || this.__type);
        } else {
            if (this._abstract) {
                return undefined;
            } else if (!is_defined(this.__id)) {

                // try the context of the parent.

                // What does not have the abstract?

                //var stack = new Error().stack;
                //console.log(stack);

                // no such function... but there should be something declared in many situations.
                //console.trace();
                //throw 'stop, currently unsupported.';
                //this.__id = new_data_object_id();

                //console.log('!!! no context __id ' + this.__id);
                return undefined;
            }
        }
        return this.__id;
    }

    // Problems with name (fields).
    //  Fields are given as a description of the fields.
    //   Gets more complicated when we have a function to access the fields as well.
    //   What if we want to override that function?

    // Will call it field
    //  18/12/2016 - Getting rid of this confusion, will mostly remove / greatly simplify field functionality.
    //  Just need to know which fields any class has, keeping track of this will use some data structures like Sorted_KVS,
    //   but not much complex code within this part.

    // Not so sure what a field function will do right now.
    //  Does not seem like such an essential part of the API.
    //   Can just define the fields, then they act a bit differently.
    //   Have field handling in Data_Object.
    //   Collection would have the same field capabilities. Fields should not be so important anyway.



    // 18/12/2016 Will remove constraints, then make them much more functional.
    

    'each'(callback) {
        each(this._, callback);
    }


    // could make this polymorphic so that it
    'position_within'(parent) {
        var p_id = parent._id();
        //console.log('p_id ' + p_id);
        //console.log('this._parents ' + stringify(this._parents));

        if (this._parents && is_defined(this._parents[p_id])) {
            var parent_rel_info = this._parents[p_id];
            //console.log('parent_rel_info ' + stringify(parent_rel_info));

            //var parents = this._parents;
            //if (parents) {
            //
            //}
            var pos_within = parent_rel_info[1];

            // It is indexed by position in parent through the parent.

            return pos_within;
        }
    }

    // Maybe just 'remove' function.
    //  This may be needed with multiple parents, which are not being used at the moment.

    'remove_from'(parent) {
        var p_id = parent._id();

        if (this._parents && is_defined(this._parents[p_id])) {

            var parent = this._parents[p_id][0];
            var pos_within = this._parents[p_id][1];

            // is the position within accurate?
            var item = parent._arr[pos_within];
            //console.log('item ' + stringify(item));


            //console.log('');
            //console.log('pos_within ' + pos_within);
            // Then remove the item in the collection (or Data_Object?) ....
            // and the actual parent?

            // can get control / dataobject / collection by its ID of course.
            parent.remove(pos_within);
            // Remove it by index.
            delete this._parents[p_id];
        }
    }

    //  
    // Maybe only do this with the fields anyway

    'load_from_spec'(spec, arr_item_names) {
        //var that = this;
        each(arr_item_names, (v) => {
            var spec_item = spec[v];
            if (is_defined(spec_item)) {
                this.set(v, spec_item);
            }
        });
    }

    // They will be treated as values in many cases anyway.
    //  Will turn them to different types of object where possible.

    /*
    'value'() {
        var a = arguments; a.l = arguments.length; var sig = get_a_sig(a, 1);
        // could operate like both get and set, but does not return data_objects, returns the value itself.
        var name;
        //var res;
        if (sig === '[s]') {
            name = a[0];
            var possibly_dobj = this.get(name);
            //var t_obj = tof(possibly_dobj);

            if (possibly_dobj) {
                if (possibly_dobj.value && typeof possibly_dobj.value === 'function') {
                    return possibly_dobj.value();
                } else {
                    return possibly_dobj;
                }
            }
        }
    }
    */

    // Get could be greatly simplified as well.
    //  Input and output processing will be more streamlined in a functional way.

    // 19/12/2016 - Not using get or set nearly as much anyway.


    'get'() {
        var a = arguments;
        a.l = arguments.length;
        var sig = get_a_sig(a, 1);
        var do_typed_processing = false;

        // Not sure about this 'typed processing'.
        //  if (is_defined(this.__type_name) && this.__type_name !== 'data_object') do_typed_processing = true;

        if (do_typed_processing) {
            // should possibly have this assigned for controls...
            //var raw_input = a;
            //console.log('this.__type_name is defined: ' + this.__type_name);
            //var parsed_input_obj = jsgui.input_processors[this.__type_name](raw_input);
            if (a.l === 0) {
                var output_obj = jsgui.output_processors[this.__type_name](this._);
                return output_obj;
            } else {
                console.log('a', a);
                console.trace();
                throw 'not yet implemented';
            }
        } else {

            // Fields will be done more simply, look up the field by name from the fields skvs.
            //  Can directly use a Sorted_KVS rather than a Collection with indexing to get somet hings like
            //   collection indexing done.

            // Less signature checking. Make it monomorphic where possible.
            //  Just get the object whether or not is is considered a field.
            //   For the moment, don't look for data or anything in the ._ object.
            //   Getting rid of the ._ object for the moment.
            //    Could have a .private() or .p() function internally.
            //    For the moment, don't have any private fields.
            //  The _ object would be easily proxyable.
            //   a private() object could be proxyable too.

            // Get and set less important now anyway.
            //  Still useful in some cases probably.



            //var field_info, field_name, field_type_name;

            if (sig == '[s,f]') {

                // Not yet????
                //   Or use promises rather than support callbacks here?
                //   Or support callbacks on promises and obs?

                throw 'Asyncronous access not allowed on Data_Object get.';
                var res = this.get(a[0]);
                var callback = a[1];
                if (typeof res == 'function') {
                    res(callback);
                } else {
                    return res;
                }
                // could check if we had a function returned.
                //  then we execute that function
                //callback(null, res);
            } else if (sig == '[s]') {
                var res = ll_get(this, a[0]);
                return res;
            } else if (a.l === 0) {
                // need to get the values of all fields.
                //  Think they are now being held in the field collection, fc.
                return this._;
            }
        }
    }

    // Or don't use / support get and set for the moment?
    //   Only use property / field access?
    //   Define property, with getter and setter, seems like a more cleanly defined system.

    // May see about making a new simplified implementation of this and running it through tests.
    //   Though the new Data_Value seems like the more appropriate way for the moment.

    // May look into seeing where Data_Value is used in the current system too.
    //   Could see about further incorportating its use (in places).





    //'set': fp(function(a, sig) {
    'set'() {

        // Using ll_set or something recursive would be good.
        //  Again, set function is much less important now that ES6 setters have arrived.

        // Want a simple API here. No or very little changing of data.


        // Make (more) monomorphic
        //  Can greatly simplify this too.

        var a = arguments;
        a.l = arguments.length;
        var sig = get_a_sig(a, 1);

        if (this._abstract) return false;

        var that = this,
            res;

        var input_processors = jsgui.input_processors;
        //if (this._module_jsgui) {
        //    input_processors = this._module_jsgui.input_processors;
        //} else {
        //    input_processors = this._get_input_processors();
        //}

        if (a.l == 2 || a.l == 3) {
            var property_name = a[0],
                value = a[1];
            var ta2 = tof(a[2]);
            //console.log('ta2', ta2);
            var silent = false;
            var source;
            if (ta2 == 'string' || ta2 == 'boolean') {
                silent = a[2];
            }
            if (ta2 == 'control') {
                source = a[2];
            }
            if (!this._initializing && this._map_read_only && this._map_read_only[property_name]) {
                throw 'Property "' + property_name + '" is read-only.';
            } else {
                var split_pn = property_name.split('.');

                if (split_pn.length > 1 && property_name != '.') {
                    //console.log('split_pn ' + stringify(split_pn));
                    var spn_first = split_pn[0];
                    var spn_arr_next = split_pn.slice(1);
                    var data_object_next = this.get(spn_first);
                    //console.log('data_object_next', data_object_next);
                    if (data_object_next) {
                        res = data_object_next.set(spn_arr_next.join('.'), value);
                        if (!silent) {
                            var e_change = {
                                'name': property_name,
                                'value': value,
                                'bubbled': true
                            };
                            if (source) {
                                e_change.source = source;
                            }
                            this.raise_event('change', e_change);
                        }
                    } else {
                        throw ('No data object at this level.');
                    }
                } else {
                    var data_object_next = this.get(property_name);
                    //console.log('data_object_next', data_object_next);
                    if (data_object_next) {
                        //console.log('property_name', property_name);
                        //var field = this.field(property_name);
                        var field = this[property_name];
                        //console.log('field', field);
                        if (field) {

                            data_object_next.__type_name = field[1] || data_object_next.__type_name;
                        }
                        //console.log('property_name', property_name);
                        //console.log('value', value);
                        data_object_next.set(value);
                        //console.log('3) data_object_next', data_object_next);
                    }
                    if (!is_defined(data_object_next)) {
                        var tv = typeof value;
                        var dv;
                        //console.log('property_name', property_name);
                        //console.log('tv ' + tv);
                        // And for an array?
                        if (tv === 'string' || tv === 'number' || tv === 'boolean' || tv === 'date') {
                            dv = new Data_Value({
                                'value': value
                            });
                        } else {
                            // And could make an array into a collection.
                            //  That seems like the most logical internal way of doing things.
                            //  An option to have them as arrays would make sense for performance (or typed arrays),
                            //   but a Collection makes the most sense logically.

                            if (tv === 'array') {
                                dv = new Data_Value({
                                    'value': value
                                });
                            } else {
                                if (tv === 'object') {
                                    if (value.__data_object || value.__data_value || value.__data_grid) {
                                        dv = value;
                                    } else {
                                        dv = new Data_Value({
                                            'value': value
                                        });
                                    }
                                } else {
                                    //console.log('tv', tv);
                                    dv = value;
                                }
                                //dv = value;
                            }
                        }
                        //this._[property_name] = dv;
                        this[property_name] = dv;

                        if (!silent) {
                            e_change = {
                                'name': property_name,
                                'value': dv
                            };
                            if (source) {
                                e_change.source = source;
                            }
                            this.raise_event('change', e_change);
                        }
                        return value;
                    } else {
                        var next_is_js_native = is_js_native(data_object_next);
                        if (next_is_js_native) {
                            //console.log('is_js_native');
                            //this.set
                            // but maybe that object should be wrapped in Data_Object?
                            //this._[property_name] = value;
                            this[property_name] = value;
                            res = value;
                        } else {
                            //console.log('not is_js_native');
                            //var res = data_object_next.set(value);
                            res = data_object_next;
                            //this._[property_name] = data_object_next;
                            this[property_name] = data_object_next;
                        }


                        if (!silent) {
                            var e_change = {
                                'name': property_name,
                                'value': data_object_next.value()
                            };
                            if (source) {
                                e_change.source = source;
                            }
                            this.trigger('change', e_change);
                        }
                        // want to listen to the set event for some things such as GUI components in particular.

                        return res;
                    }
                }
            }
        } else {
            // But maybe it should be a data_value, not a data_object.
            //console.log('3) else sig ' + sig);
            var value = a[0];
            var property_name = a[1];
            var input_processor = input_processors[this.__type_name];

            if (input_processor) {

                // Act differently if it has a field as well?

                var processed_input = input_processor(value);
                //console.log('processed_input', processed_input);
                value = processed_input;
                this._[property_name] = value;

                this.raise_event('change', {
                    'value': value
                });
                return value;


            } else {
                // Need to be on the lookout for that.


                // And for a Data_Object?
                //  Basically put it into place.

                if (sig === '[D]') {
                    //console.log('property_name ' + property_name);
                    this._[property_name] = value;
                    // Or just have 3 parameters?
                    this.raise_event('change', [property_name, value]);

                    // Raise a change event?
                    //  Or is set event OK?
                    return value;
                } else if (sig === '[o]') {
                    //console.log('setting with a provided object');

                    //var that = this;
                    // may need to be recursive.
                    res = {};
                    each(a[0], function (v, i) {
                        //console.log('i ' + i);
                        //console.log('v ' + stringify(v));

                        res[i] = that.set(i, v);
                        //that.raise_event('change', [i, v]);

                    });
                    return res;
                }

                // C for collection?
                if (sig === '[c]') {
                    //this._[]
                    this._[property_name] = value;
                    this.raise_event('change', [property_name, value]);
                    //throw 'unsupported';
                    return value;
                }
            }
        }
    }

    'has'(property_name) {
        return is_defined(this.get(property_name));
    }
}

// Can be done just with a getter, no setter.

jsgui.map_classes = jsgui.map_classes || {};

// seems like an overlap with the new jsgui.fromObject function.
//  That will initially go in the Enhanced_Data_Object module, or jsgui-enh

var dobj = (obj, data_def) => {
    // could take a data_def?
    // Could use the enhanced data object if we patch backwards?
    //  So Enhanced_Data_Object could hopefully patch backwards in the code?

    //var tdd = tof(data_def);

    var cstr = Data_Object;
    //if (Enhanced_Data_Object) cstr = Enhanced_Data_Object;
    //console.log('Enhanced_Data_Object ' + Enhanced_Data_Object);

    var res;
    if (data_def) {
        res = new cstr({
            'data_def': data_def
        });
    } else {
        res = new cstr({});
    }

    var tobj = tof(obj);

    //console.log('obj ' + stringify(obj));
    if (tobj == 'object') {
        var res_set = res.set;
        each(obj, (v, i) => {
            //res.set(i, v);
            res_set.call(res, i, v);
        });
    }

    return res;
};


Data_Object.dobj = dobj;
Data_Object.Mini_Context = Mini_Context;
module.exports = Data_Object;
},{"../Data_Model":164,"../Mini_Context":167,"./Data_Value":181,"lang-mini":379}],181:[function(require,module,exports){
var jsgui = require('lang-mini');
//var Evented_Class = require('./_evented-class');
const Data_Model = require('../Data_Model');

var j = jsgui;
var Evented_Class = j.Evented_Class;
//var Class = j.Class;
var each = j.each;
var is_array = j.is_array;
var is_dom_node = j.is_dom_node;
var is_ctrl = j.is_ctrl;
var extend = j.extend;
var get_truth_map_from_arr = j.get_truth_map_from_arr;
var get_map_from_arr = j.get_map_from_arr;
var arr_like_to_arr = j.arr_like_to_arr;
var tof = j.tof;
var is_defined = j.is_defined;
var stringify = j.stringify;
var functional_polymorphism = j.functional_polymorphism;
var fp = j.fp;
var arrayify = j.arrayify;
var mapify = j.mapify;
var are_equal = j.are_equal;
var get_item_sig = j.get_item_sig;
var set_vals = j.set_vals;
var truth = j.truth;
var trim_sig_brackets = j.trim_sig_brackets;
var ll_set = j.ll_set;
var ll_get = j.ll_get;
var input_processors = j.input_processors;
var iterate_ancestor_classes = j.iterate_ancestor_classes;
var is_arr_of_arrs = j.is_arr_of_arrs;
var is_arr_of_strs = j.is_arr_of_strs;
var is_arr_of_t = j.is_arr_of_t;
var clone = jsgui.clone;

var input_processors = jsgui.input_processors;

// What type is the value?

// Data_Model items maybe are best existing within a context.
//   Not sure that's a necessary restriction / requirement.





class Data_Value extends Data_Model {


    constructor(spec = {}) {
        super(spec);
        this.__data_value = true;
        console.log('old (1.1) Data_Value constructor');

        if (spec.context) {
            this.context = spec.context;
        }
        if (is_defined(spec.value)) {
            this._ = spec.value;
        }
        // Maybe don't use __type.
        //   instanceOf, maybe typeOf ....
        this.__type = 'data_value';
        //this._bound_events = {};

        // Not so sure about _relationships.
        //   Maybe it will be of use.

        this._relationships = {};
    }
    // Get but with a format change?
    //   Get and validate???

    'get'() {
        //return this._val;
        return this._;
    }

    // get value and set value.

    'value'() {
        return this._;
    }


    'toObject'() {
        return this._;

    }

    // .value =
    //   Though .set could have more input, eg a format shifter????

    'set'(val) {
        //this._val = val;

        // This may also need to make use of input_processors

        var input_processor = input_processors[this.__type_name];


        if (input_processor) {
            val = input_processor(val);
        }
        var old_val = this._;
        //console.log('old_val', old_val);
        this._ = val;
        //console.log('val', val);
        this.raise('change', {
            'old': old_val,
            'value': val
        });
        return val;
    }


    'toString'() {
        //return stringify(this.get());
        // con
        //console.log('this._val ' + stringify(this._val));
        //throw 'stop';
        return this.get();
    }
    // Maybe a particular stringify function?
    'toJSON'() {
        var val = this.get();
        //var tval = tof(val);
        var tval = typeof val;
        if (tval == 'string') {
            return '"' + val + '"';
        } else {
            return val;
        }
    }

    // Need to copy / clone the ._ value

    'clone'() {
        var res = new Data_Value({
            'value': this._
        });
        return res;
    }

    // This is important to the running of jsgui3.

    '_id'() {
        if (this.__id) return this.__id;
        if (this.context) {
            //console.log('this.__type ' + this.__type);
            //throw 'stop';
            this.__id = this.context.new_id(this.__type_name || this.__type);
        } else {
            if (!is_defined(this.__id)) {
                throw 'DataValue should have context';
                this.__id = new_data_value_id();
            }
        }
        return this.__id;
    }


    'parent'() {
        var a = arguments; a.l = arguments.length; var sig = get_a_sig(a, 1);

        // .sibling_index instead. Clearer, matched HTML terminology in places.

        var obj, index;
        //console.log('parent sig', sig);
        if (a.l == 0) {
            return this._parent;
        } else if (a.l == 1) {
            obj = a[0];

            if (!this.context && obj.context) {
                this.context = obj.context;
            }

            var relate_by_id = function (that) {
                var obj_id = obj._id();
                that._relationships[obj_id] = true;
            }

            var relate_by_ref = function (that) {
                that._parent = obj;
            }
            relate_by_ref(this);
        } else if (a.l == 2) {
            obj = a[0];
            index = a[1];

            if (!this.context && obj.context) {
                this.context = obj.context;
            }

            this._parent = obj;
            this._index = index;
        }

        /*

        if (is_defined(index)) {
            // I think we just set the __index property.
            //  I think a __parent property and a __index property would do the job here.
            //  Suits DOM heirachy.
            // A __relationships property could make sense for wider things, however, it would be easy (for the moment?)
            // to just have .__parent and .__index
            //

            // Not sure all Data_Objects will need contexts.
            //  It's mainly useful for Controls so far
        } else {
            // get the object's id...

            // setting the parent... the parent may have a context.
        }

        */
    }
};

module.exports = Data_Value;

},{"../Data_Model":164,"lang-mini":379}],182:[function(require,module,exports){


/*
 if (typeof define !== 'function') {
 var define = require('amdefine')(module);
 }


 // May sway implementations of the particular items more easily when they are in their own files.

 define(["./jsgui-lang-essentials", "./jsgui-data-structures-stiffarray"], function (jsgui, StiffArray) {
 */

//var jsgui = require('./jsgui-lang-essentials');


var StiffArray = require('./stiffarray');

// B+ Tree

// some B+ Tree description can be found here:
// http://www.cs.berkeley.edu/~kamil/teaching/su02/080802.pdf
// http://baze.fri.uni-lj.si/dokumenti/B+%20Trees.pdf


// sample tree classic presentation:
//
//	              [] 7 []
//	              /     \
//	             /       -----------------
//	            /                         \
//	           /                           \
//	     [] 3 [] 5 []                  [] 8 [] 8 []
//	     /    |     \                  /     \    \
//	    /     |      \                /       |    ----
//     /      |       \              /         \       \
//  {1,2}   {3,4}    {5,6,7}      {8,8,8}    {8,8}    {8,9}
//
//   the diagram notation:
//   numbers are "keys" array items
//   "[]" figures are "children" array items


// sample tree toText() presentation:
//
//	      {1,2}
//	    3
//	      {3,4}
//	    5
//	      {5,6,7}
//  7
//	      {8,8,8}
//	    8
//	      {8,8}
//	    8
//	      {8,9}


// sample tree toString() presentation:
//
// {{{1,2}3{3,4}5{5,6,7}}7{{8,8,8}8{8,8}8{8,9}}}


// some remarks:
//
//  children.length == keys.length + 1
//
//  (max children[i] key) <= (keys[i]) <= (min children[i+1] key)
//
//  the node overflow threshold referred somewhere as "node order" is referred as "node capacity" here


// -----------------------------------------
//
//	              global variables:
//
// -----------------------------------------

//var B_Plus_Tree_NextNodeDebugId = 1;
// uncomment the line above to include unique node IDs
// to the toString() and toTest() output

// -----------------------------------------
//
//	              B_Plus_Node:
//
// -----------------------------------------

// Likely to get this into the core, and do some more polymorphic optimization to reduce file size.
//  One various things are running, I will focus on some code size optimizations to bring things down to really small sizes when used in
//  conjunction with Essentials.

// Not sure about the B+ tree making use of Collections but with no indexing?
//  I think by making Collection really flexible, and a version that mixes in other functionality to a more basic one,
//  it would be possible to make the B+ tree use a Collection with StiffArray capabilities.
//   Not worth it right now. Keep StiffArray as a low level component used for the tree. Maybe move it out of its own JavaScript file, not sure it
//    will be used for that much else. Not sure, could be good for when binary searches are required.








// B+ tree index node:
var B_Plus_Node = function (nodeCapacity) {

    // -----------------------------------------
    //              public interface:
    // -----------------------------------------

    var m_public = {
        isLeaf: false,
        parent: null,
        keys: new StiffArray(nodeCapacity + 1),     // +1: to allow temporary owerflow
        children: new StiffArray(nodeCapacity + 2) // +2: children.length == keys.length + 1
    };

    // -----------------------------------------
    //                  debug ID:
    // -----------------------------------------

    //if (typeof (B_Plus_Tree_NextNodeDebugId) != "undefined") m_public.debugId = B_Plus_Tree_NextNodeDebugId++;

    // -----------------------------------------
    //       return the public interface:
    // -----------------------------------------

    return m_public;
};

// -----------------------------------------
//
//	              B_Plus_Leaf:
//
// -----------------------------------------

// B+ tree leaf node:

var B_Plus_Leaf = function (nodeCapacity) {

    // -----------------------------------------
    //              public interface:
    // -----------------------------------------

    var m_public = {
        isLeaf: true,
        parent: null,
        keys: new StiffArray(nodeCapacity + 1),
        values: new StiffArray(nodeCapacity + 1),
        //
        // leafs chain:
        prevLeaf: null,
        nextLeaf: null
    };

    // -----------------------------------------
    //                  debug ID:
    // -----------------------------------------

    //if (typeof(B_Plus_Tree_NextNodeDebugId) != "undefined") m_public.debugId = B_Plus_Tree_NextNodeDebugId++;

    // -----------------------------------------
    //       return the public interface:
    // -----------------------------------------

    return m_public;
};


// -----------------------------------------
//
//	              B_Plus_Tree:
//
// -----------------------------------------

// B+ tree:

// Using Crockford's Module Pattern.
//  Need to be careful about how it is not initialized with a constructor and the 'new' keyword.

var FindInfo = (key, value, isPrefixSearch) => {
    isPrefixSearch = !!isPrefixSearch;
    var isKeyPresent = (key != undefined);
    var isValuePresent = (value != undefined);
    var prefixLength = 0;
    if (isPrefixSearch) {
        if (typeof (key) != "string") {
            isPrefixSearch = false;
        } else {
            prefixLength = key.length;
        }
    }
    //
    return {
        key: key,     // key to find (if present)
        value: value, // value to find (if present)
        isPrefixSearch: isPrefixSearch, // prefix search mode
        leaf: null,   // found leaf
        index: -1,    // found leaf item index
        isKeyPresent: isKeyPresent, // function () { return this.key !== undefined; }, // is the search criteria contains key
        isValuePresent: isValuePresent, // function () { return this.value !== undefined; }, // is the search criteria contains value
        foundKey: function () { return this.leaf.keys.items[this.index]; }, // found items's key
        foundValue: function () { return this.leaf.values.items[this.index]; }, // found item's value
        //
        prefix_length: prefixLength, // prefix length
        check_prefix: function () {  // check the current key to match the prefix
            if (!isPrefixSearch) return false;
            if (this.index >= this.leaf.keys.count) return false;
            var keyToCheck = this.foundKey();
            if (this.prefix_length > keyToCheck.length) return false;
            return (keyToCheck.substr(0, this.prefix_length) == this.key)
        }
    };
};



var B_Plus_Tree = function (nodeCapacity) {

    // -----------------------------------------
    //            arguments processing:
    // -----------------------------------------

    if (nodeCapacity === undefined) nodeCapacity = 10;
    if (nodeCapacity < 4) throw "B_Plus_Tree(): node capacity must be >= 4";

    // -----------------------------------------
    //              public interface:
    // -----------------------------------------


    var m_public = {
        // tree root:
        root: new B_Plus_Leaf(nodeCapacity),
        //
        // leafs chain:
        firstLeaf: null,
        //
        lastLeaf: null,
        //
        // ---------------------
        //     editing:
        // ---------------------
        //
        // clear the tree:
        clear: function () {
            p_Clear();
        },
        //

        // insert(key, value)
        // insert([key, value])
        insert: function (key, value) {
            if (arguments.length == 2) {
                return p_Insert(key, value);
            } else {
                return p_Insert(key[0], key[1]);
            }
        },
        //

        // remove(key) - remove all values with given key
        // remove(key, value) - remove one value occurrence
        remove: function (key, value) {
            if (arguments.length == 2) {
                return p_Remove(key, value);
            } else {
                p_RemoveKey(key);
            }
        },
        //
        // ---------------------
        //       finding:
        // ---------------------
        //

        // findFirst() - find the very first item
        // findFirst(key) - find the first item for the given key
        // findFirst(key, value) - find the first key+value occurrence
        //
        // returns the FindInfo object:
        //    key: key,     // key to find (if present)
        //    value: value, // value to find (if present)
        //
        //    leaf: null,   // the current found leaf
        //    index: -1,    // the current found index
        //
        //    foundKey():   // the current found key
        //    foundValue(): // the current found value
        //
        findFirst: function (key, value) {
            return p_FindFirst(key, value);
        },
        //
        // find first key matching the prefix:
        findFirstPrefix: function (prefix) {
            return p_FindFirst(prefix, undefined, true);
        },
        //
        // find next search conditions occurence
        findNext: function (findInfo) {
            return p_FindNext(findInfo);
        },

        //
        // findLast() - find the very last item
        // findLast(key) - find the last item for the given key
        // findLast(key, value) - find the last key+value occurrence
        findLast: function (key, value) {
            return p_FindLast(key, value);
        },
        //
        // find last key matching the prefix:
        findLastPrefix: function (prefix) {
            return p_FindLast(prefix, undefined, true);
        },
        //
        // find previous search conditions occurence
        findPrevious: function (findInfo) {
            return p_FindPrev(findInfo);
        },
        //
        // ---------------------
        // dictionary-like usage:
        // ---------------------
        //
        // get one value by key (or null):
        getValue: function (key) {
            return p_GetValue(key);
        },
        // set one value by key (insert or update):
        setValue: function (key, value) {
            p_SetValue(key, value);
        },
        //
        //
        // ---------------------
        //   other functions:
        // ---------------------
        //

        // count() - count all values
        // count(key) - count values with the given key
        count: function (key) {
            if (arguments.length == 1) {
                return p_CountKey(key);
            } else {
                return p_Count();
            }
        },
        //

        // tree capacity:
        getCapacity: function () {
            return m_nodeMaxCount;
        },
        //
        // ---------------------
        // additional functions:
        // ---------------------
        //
        // iterate through each key + value pair
        // callback is function(key, value)
        'each': function (callback) {
            return p_each(callback);
        },
        //
        // get all keys
        'keys': function () {
            return p_keys();
        },
        //
        // get all [key, value] pairs
        'keys_and_values': function () {
            return p_keys_and_values();
        },
        //
        //
        // get keys and values by prefix
        'get_by_prefix': function (prefix) {
            return p_get_by_prefix(prefix);
        },
        //
        // get keys by prefix
        'get_keys_by_prefix': function (prefix) {
            return p_get_keys_by_prefix(prefix);
        },
        //
        // get values at key...
        'get_values_by_key': function (key) {
            return p_get_values_by_key(key);
        }
    };

    // -----------------------------------------
    //              initialization:
    // -----------------------------------------

    m_public.firstLeaf = m_public.root;
    m_public.lastLeaf = m_public.root;

    // -----------------------------------------
    //              private variables:
    // -----------------------------------------

    var m_nodeMaxCount = nodeCapacity;
    var m_nodeMinCount = Math.floor(m_nodeMaxCount / 2);

    // -----------------------------------------
    //                 clear():
    // -----------------------------------------

    // clear the tree
    // (just create new empty root)
    var p_Clear = function () {
        m_public.root = new B_Plus_Leaf(m_nodeMaxCount);
        m_public.firstLeaf = m_public.root;
        m_public.lastLeaf = m_public.root;
    };

    // -----------------------------------------
    //                iterations:
    // -----------------------------------------

    var p_keys = function () {
        var res = [];
        _p_each_key(function (key) {
            res.push(key);
        });
        return res;
    }

    var p_keys_and_values = function () {
        var res = [];
        p_each(function (key, value) {
            res.push([key, value]);
        });
        return res;
    }

    var _p_each_key = function (callback) {
        var findInfo = p_FindFirst();
        while (findInfo != null) {
            var fk = findInfo.foundKey();
            callback(fk);
            findInfo = p_FindNext(findInfo);
        }
    }

    var p_each = function (callback) {
        var findInfo = p_FindFirst();

        var doStop = false;


        while (findInfo != null) {
            //var stop =
            //console.log('doStop ' + doStop);
            var fk = findInfo.foundKey();
            var fv = findInfo.foundValue();
            // callback with the key and the value
            callback(fk, fv, function() {
                //throw 'stop';
                //console.log('stop!!!');
                doStop = true;
            });
            //console.log('2) doStop ' + doStop);
            if (doStop) {
                findInfo = null;
            } else {
                findInfo = p_FindNext(findInfo);
            }

        }
    }

    // -----------------------------------------
    //                insert():
    // -----------------------------------------

    // insert (key, value) item to the tree
    var p_Insert = function (key, value) {
        //
        // search leaf to insert:
        var searchResult = searchLeaf(key);
        var leaf = searchResult.node;
        //
        // insert to the leaf:
        leaf.keys.insert(searchResult.index, key);
        leaf.values.insert(searchResult.index, value);
        //
        // if overflow:
        if (leaf.keys.count > m_nodeMaxCount) {
            if ((leaf.prevLeaf != null) && (leaf.prevLeaf.keys.count < m_nodeMaxCount) && (leaf.prevLeaf.parent == leaf.parent)) {
                rotateAmongLeavesToLeft(leaf.prevLeaf, leaf);
            } else if ((leaf.nextLeaf != null) && (leaf.nextLeaf.keys.count < m_nodeMaxCount) && (leaf.nextLeaf.parent == leaf.parent)) {
                rotateAmongLeavesToRight(leaf, leaf.nextLeaf);
            } else {
                splitLeaf(leaf);
            }
        }
    };

    // split leaf to 2 leaves
    // (create right sibling)
    var splitLeaf = function (leaf) {
        var leftCount = m_nodeMinCount;
        var rightCount = leaf.keys.count - leftCount;
        //
        // create right leaf:
        var newRightLeaf = new B_Plus_Leaf(m_nodeMaxCount);
        newRightLeaf.parent = leaf.parent;
        //
        // copy to the right:
        newRightLeaf.keys.copy_from(leaf.keys, leftCount, rightCount);
        newRightLeaf.values.copy_from(leaf.values, leftCount, rightCount);
        //
        // update the left:
        leaf.keys.count = leftCount;
        leaf.values.count = leftCount;
        //
        // update leafs chain:
        newRightLeaf.nextLeaf = leaf.nextLeaf;
        if (newRightLeaf.nextLeaf != null) newRightLeaf.nextLeaf.prevLeaf = newRightLeaf;
        newRightLeaf.prevLeaf = leaf;
        leaf.nextLeaf = newRightLeaf;
        if (m_public.lastLeaf == leaf) m_public.lastLeaf = newRightLeaf;
        //
        // update parent:
        if (leaf.parent != null) {
            var leafIndex = calcChildIndex(leaf.parent, leaf);
            insertToParent(leaf.parent, newRightLeaf, newRightLeaf.keys.first(), leafIndex + 1);
        } else {
            createNewRoot(leaf, newRightLeaf, newRightLeaf.keys.first());
        }
    };

    // create new root
    var createNewRoot = function (nodeLeft, nodeRight, key) {
        // create new root containing nodeLeft and nodeRight children
        // btw nodeLeft and nodeRight can be leaves
        //
        // create the root node:
        var newRoot = new B_Plus_Node(m_nodeMaxCount);
        newRoot.keys.add(key);
        newRoot.children.add(nodeLeft);
        newRoot.children.add(nodeRight);
        //
        // update parent references:
        nodeLeft.parent = newRoot;
        nodeRight.parent = newRoot;
        //
        // update root reference:
        m_public.root = newRoot;
    };

    // insert newChildNode with key newChildFirstKey into the parentNode
    // the newChildNode inserts into the newChildIndex position in the children
    var insertToParent = function (parentNode, newChildNode, newChildFirstKey, newChildIndex) {
        //
        // insert child info:
        parentNode.keys.insert(newChildIndex - 1, newChildFirstKey); // -1: the related key is "before" the child
        parentNode.children.insert(newChildIndex, newChildNode);
        //
        // update parent reference:
        newChildNode.parent = parentNode;
        //
        // update parent if overflow:
        if (parentNode.keys.count > m_nodeMaxCount) {
            splitNode(parentNode);
        }
    };

    // split the overflowed node into 2 nodes
    var splitNode = function (node) {
        // split node: create right sibling
        //
        var newLeftCount = m_nodeMinCount;
        var newRightCount = m_nodeMaxCount - newLeftCount;
        var middleKey = node.keys.items[newLeftCount]; // key to move up
        //
        // create right node:
        var newRightNode = new B_Plus_Node(m_nodeMaxCount);
        newRightNode.keys.copy_from(node.keys, newLeftCount + 1, newRightCount);
        newRightNode.children.copy_from(node.children, newLeftCount + 1, newRightCount + 1);
        //
        // update the node:
        node.keys.count = newLeftCount;
        node.children.count = newLeftCount + 1;
        //
        // update children's parent:
        for (var i = 0; i < newRightNode.children.count; i++) newRightNode.children.items[i].parent = newRightNode;
        //
        // update parent:
        if (node.parent == null) {
            createNewRoot(node, newRightNode, middleKey);
        } else {
            var nodeIndex = calcChildIndex(node.parent, node);
            insertToParent(node.parent, newRightNode, middleKey, nodeIndex + 1);
        }
    };

    // -----------------------------------------
    //                remove():
    // -----------------------------------------

    // remove (key, value) item from the tree
    var p_Remove = function (key, value) {
        var searchResult = searchLeafValue(key, value);
        if (!searchResult.found) return false;
        //
        removeFromLeaf(searchResult.node, searchResult.index);
        return true;
    };

    // remove all the items with given key
    var p_RemoveKey = function (key) {
        while (true) {
            var searchResult = searchLeaf(key);
            if (!searchResult.found) break;
            //
            removeFromLeaf(searchResult.node, searchResult.index);
        }
    };

    // remove the item from index position of the leaf
    var removeFromLeaf = function (leaf, index) {
        leaf.keys.removeAt(index);
        leaf.values.removeAt(index);
        //
        // the item is removed; then update the tree if the leaf is underflowed:
        if (leaf.keys.count < m_nodeMinCount) {
            if ((leaf.prevLeaf != null) && (leaf.parent == leaf.prevLeaf.parent) && (leaf.prevLeaf.keys.count > m_nodeMinCount)) {
                rotateAmongLeavesToRight(leaf.prevLeaf, leaf);
            } else if ((leaf.nextLeaf != null) && (leaf.parent == leaf.nextLeaf.parent) && (leaf.nextLeaf.keys.count > m_nodeMinCount)) {
                rotateAmongLeavesToLeft(leaf, leaf.nextLeaf);
            } else {
                mergeLeaf(leaf);
            }
        }
        return true;
    };

    // merge the underflowed leaf with left or right sibling
    var mergeLeaf = function (leaf) {
        // if the leaf is root, then underflow is allowed:
        if (leaf.parent == null) {
            return;
        }
        //
        // calculate keys count in left and right sibling:
        var leftCount = m_nodeMaxCount + 1;
        var rightCount = m_nodeMaxCount + 1;
        if ((leaf.prevLeaf != null) && (leaf.prevLeaf.parent == leaf.parent)) {
            leftCount = leaf.prevLeaf.keys.count;
        }
        if ((leaf.nextLeaf != null) && (leaf.nextLeaf.parent == leaf.parent)) {
            rightCount = leaf.nextLeaf.keys.count;
        }
        //
        // select sibling to merge:
        if (leftCount < rightCount) {
            if (leftCount + leaf.keys.count > m_nodeMaxCount) throw "B_Plus_Tree.mergeLeaf(): leftCount";
            mergeLeaves(leaf.prevLeaf, leaf);
        } else {
            if (rightCount + leaf.keys.count > m_nodeMaxCount) throw "B_Plus_Tree.mergeLeaf(): rightCount";
            mergeLeaves(leaf, leaf.nextLeaf);
        }
    };

    // merge 2 leaf nodes: leafLeft and leafRight
    var mergeLeaves = function (leafLeft, leafRight) { // merge (left + right) -> left
        //
        // add right to left:
        leafLeft.keys.add_from(leafRight.keys);
        leafLeft.values.add_from(leafRight.values);
        //
        // update leafs chain:
        leafLeft.nextLeaf = leafRight.nextLeaf;
        if (leafLeft.nextLeaf != null) leafLeft.nextLeaf.prevLeaf = leafLeft;
        if (m_public.lastLeaf == leafRight) m_public.lastLeaf = leafLeft;
        //
        // remove right from parent:
        var parent = leafRight.parent;
        var leafRightIndex = calcChildIndex(parent, leafRight);
        parent.keys.removeAt(leafRightIndex - 1);
        parent.children.removeAt(leafRightIndex);
        //
        // update parent if underflow:
        if (parent.keys.count < m_nodeMinCount) {
            mergeNode(parent);
        };
    };

    // fix underflower index (non-leaf) node:
    // rotate among sibling, or merge with sibling
    var mergeNode = function (node) { // merge the node with sibling
        var parent = node.parent;
        //
        // remove root if the node became empty root:
        if (node.parent == null) {
            if (node.keys.count == 0) {
                m_public.root = node.children.items[0];
                m_public.root.parent = null;
            }
            return;
        }
        //
        // find left and right siblings:
        var nodeIndex = calcChildIndex(parent, node);
        var leftSibling = (nodeIndex > 0) ? parent.children.items[nodeIndex - 1] : null;
        var rightSibling = ((nodeIndex + 1) < parent.children.count) ? parent.children.items[nodeIndex + 1] : null;
        //
        // try rotation:
        if ((leftSibling != null) && (leftSibling.keys.count > m_nodeMinCount)) {
            rotateAmongNodesToRight(leftSibling, node);
            return;
        }
        if ((rightSibling != null) && (rightSibling.keys.count > m_nodeMinCount)) {
            rotateAmongNodesToLeft(node, rightSibling);
            return;
        }
        //
        // calculate siblings key count:
        var leftCount = m_nodeMaxCount + 1;
        var rightCount = m_nodeMaxCount + 1;
        if (leftSibling != null) {
            leftCount = leftSibling.keys.count;
        }
        if (rightSibling != null) {
            rightCount = rightSibling.keys.count;
        }
        //
        // select sibling to merge:
        if (leftCount < rightCount) {
            if (leftSibling == null) throw "B_Plus_Tree.mergeNode(): leftSibling";
            mergeNodes(leftSibling, node, nodeIndex);
        } else {
            if (rightSibling == null) throw "B_Plus_Tree.mergeNode(): rightSibling";
            mergeNodes(node, rightSibling, nodeIndex + 1);
        }
    };

    // merge 2 index (non-leaf) nodes nodeLeft and nodeRight into one node
    // the nodeRightIndex is the nodeRight index in parent's children array;
    // the nodeRightIndex is known in caller, so it's not needed to calculate it here
    var mergeNodes = function (nodeLeft, nodeRight, nodeRightIndex) { // merge (left + right) -> left
        var parent = nodeLeft.parent;
        //
        // update right children parent:
        for (var i = 0; i < nodeRight.children.count; i++) nodeRight.children.items[i].parent = nodeLeft;
        //
        // move down key from parent:
        nodeLeft.keys.add(nodeLeft.parent.keys.items[nodeRightIndex - 1]);
        //
        // add right to left:
        nodeLeft.keys.add_from(nodeRight.keys);
        nodeLeft.children.add_from(nodeRight.children);
        //
        // remove right from parent:
        parent.keys.removeAt(nodeRightIndex - 1);
        parent.children.removeAt(nodeRightIndex);
        //
        // update parent if underflow:
        if (parent.keys.count < m_nodeMinCount) {
            mergeNode(parent);
        };
    };


    // -----------------------------------------
    //          findFirst() / findNext():
    // -----------------------------------------

    // FindInfo nested class
    // contains the search criteria (key, value) and search result (leaf, index)


    // find first item matching (key, value) search criteria
    // use cases:
    // p_FindFirst()
    // p_FindFirst(key)
    // p_FindFirst(key, value)
    // p_FindFirst(key, undefined, true)
    var p_FindFirst = function (key, value, isPrefixSearch) {
        var findInfo = FindInfo(key, value, isPrefixSearch);
        //
        if (findInfo.isKeyPresent) {
            if (findInfo.isPrefixSearch && findInfo.isValuePresent) throw "B_Plus_Tree.p_FindFirst(): arguments error: isPrefixSearch, but value is present";
            //
            var searchResult = findInfo.isValuePresent ? searchLeafValue(key, value) : searchLeaf(key);
            findInfo.leaf = searchResult.node;
            findInfo.index = searchResult.index;
            if (!searchResult.found) {
                if (!findInfo.check_prefix()) {
                    return null;
                }
            }
        } else {
            if (findInfo.isValuePresent) throw "B_Plus_Tree.findFirst(): arguments error: key is not present, but value is present";
            //
            findInfo.leaf = m_public.firstLeaf;
            findInfo.index = 0;
            if (findInfo.leaf.keys.count <= 0) return null;
        }
        //
        return findInfo;
    };

    // find last item matching (key, value) search criteria
    // use cases:
    // p_FindLast()
    // p_FindLast(key)
    // p_FindLast(key, value)
    // p_FindLast(key, undefined, true)
    var p_FindLast = function (key, value, isPrefixSearch) {
        var findInfo = new FindInfo(key, value, isPrefixSearch);
        //
        if (findInfo.isKeyPresent) {
            if (findInfo.isPrefixSearch && findInfo.isValuePresent) throw "B_Plus_Tree.p_FindLast(): arguments error: isPrefixSearch, but value is present";
            //
            if (findInfo.isPrefixSearch) {
                var searchResult = searchLastLeafByPrefix(key);
                findInfo.leaf = searchResult.node;
                findInfo.index = searchResult.index;
                if (!searchResult.found) {
                    return null;
                }
            } else {
                var searchResult = findInfo.isValuePresent ? searchLastLeafValue(key, value) : searchLastLeaf(key);
                findInfo.leaf = searchResult.node;
                findInfo.index = searchResult.index;
                if (!searchResult.found) {
                    return null;
                }
            }
        } else {
            if (findInfo.isValuePresent) throw "B_Plus_Tree.findLast(): arguments error: key is not present, but value is present";
            //
            findInfo.leaf = m_public.lastLeaf;
            findInfo.index = findInfo.leaf.keys.count - 1;
            if (findInfo.index < 0) return null;
        }
        //
        return findInfo;
    };

    // move to next item
    var findGoToNext = function (findInfo) {
        findInfo.index++;
        if (findInfo.index >= findInfo.leaf.keys.count) {
            findInfo.leaf = findInfo.leaf.nextLeaf;
            findInfo.index = 0;
        }
        //
        return (findInfo.leaf != null);
    };

    // move to previous item
    var findGoToPrev = function (findInfo) {
        findInfo.index--;
        if (findInfo.index < 0) {
            findInfo.leaf = findInfo.leaf.prevLeaf;
            if (findInfo.leaf == null) return false;
            findInfo.index = findInfo.leaf.keys.count - 1;
        }
        //
        return true;
    };

    // find next item after the findInfo's found item, matching the findInfo's search criteria
    var p_FindNext = function (findInfo) {
        while (true) {
            if (!findGoToNext(findInfo)) return null;
            //
            if (findInfo.isPrefixSearch) {
                if (!findInfo.check_prefix()) return null;
            } else {
                if (findInfo.isKeyPresent && (findInfo.key != findInfo.foundKey())) return null;
            }
            //
            if (findInfo.isValuePresent) {
                if (findInfo.value == findInfo.foundValue()) return findInfo;
            } else {
                return findInfo;
            }
        }
    };

    // find previous item after the findInfo's found item, matching the findInfo's search criteria
    var p_FindPrev = function (findInfo) {
        while (true) {
            if (!findGoToPrev(findInfo)) return null;
            //
            //if (findInfo.isKeyPresent && (findInfo.key != findInfo.foundKey())) return null;
            if (findInfo.isPrefixSearch) {
                if (!findInfo.check_prefix()) return null;
            } else {
                if (findInfo.isKeyPresent && (findInfo.key != findInfo.foundKey())) return null;
            }
            //
            if (findInfo.isValuePresent) {
                if (findInfo.value == findInfo.foundValue()) return findInfo;
            } else {
                return findInfo;
            }
        }
    };

    // -----------------------------------------
    //          additional methods:
    // -----------------------------------------

    // get values at key...
    //  make this always return an array, even if there is one item.
    //  will make interpretation easier.

    // will move the prefix search code into here.

    // iterate nodes by prefix... that may be a more efficient way of doing this, may be less efficient, it assigns one more thing I think.
    //  possibly a fast iterator?

    //  definitely would be easier code, I think it would be worth doing.
    //  could also be given its own check function.
    //   maybe gets given starting location.+


    var p_get_values_by_key = function (key) {
        var res = [];
        var findInfo = p_FindFirst(key);
        while (findInfo != null) {
            res.push(findInfo.foundValue());
            findInfo = p_FindNext(findInfo);
        }
        return res;
    }

    // get keys and values by prefix

    var p_get_by_prefix = function (prefix) {
        var res = [];
        var findInfo = m_public.findFirstPrefix(prefix);
        while (findInfo != null) {
            res.push([findInfo.foundKey(), findInfo.foundValue()]);
            findInfo = m_public.findNext(findInfo);
        }
        return res;
    }

    // get keys by prefix

    var p_get_keys_by_prefix = function (prefix) {
        var res = [];
        var findInfo = m_public.findFirstPrefix(prefix);
        while (findInfo != null) {
            res.push(findInfo.foundKey());
            findInfo = m_public.findNext(findInfo);
        }
        return res;
    }


    // -----------------------------------------
    //          getValue() / setValue():
    // -----------------------------------------

    // get value for the given key
    var p_GetValue = function (key) {
        var searchResult = searchLeaf(key);
        if (!searchResult.found) return null;
        return searchResult.node.values.items[searchResult.index];
    };

    // set value for the given key
    var p_SetValue = function (key, value) {
        var searchResult = searchLeaf(key);
        if (searchResult.found) {
            removeFromLeaf(searchResult.node, searchResult.index);
        }
        //
        p_Insert(key, value);
    };

    // -----------------------------------------
    //                 count():
    // -----------------------------------------

    // count all the value items in the tree
    // is that an easier way to iterate?

    var p_Count = function () {
        var result = 0;
        //
        var leaf = m_public.firstLeaf;
        while (leaf != null) {
            result += leaf.keys.count;
            leaf = leaf.nextLeaf;
        }
        //
        return result;
    };

    // count the value items with given key in the tree
    var p_CountKey = function (key) {
        var result = 0;
        //
        var findInfo = m_public.findFirst(key);
        while (findInfo != null) {
            result++;
            findInfo = m_public.findNext(findInfo);
        }
        //
        return result;
    };

    // -----------------------------------------
    //                 toText():
    // -----------------------------------------

    // returns multi-line text presentation for the tree

    /*

     var _p_ToText = function () {
     var result = m_public.root.toText("");
     //
     if (typeof (B_Plus_Tree_NextNodeDebugId) != "undefined") {
     // print leafs chain:
     result += "\r\n";
     var leaf = m_public.firstLeaf;
     while (leaf != null) {
     result += "(" + leaf.debugId + ") ";
     leaf = leaf.nextLeaf;
     }
     }
     //
     return result;
     };

     */

    // -----------------------------------------
    //                rotations:
    // -----------------------------------------

    // "rotation" means moving items between siblings instead of split/merge

    // the following conditions are true when rotation is called:
    // leftNode.parent == rightNode.parent
    // leftLeaf.parent == rightLeaf.parent

    // move a key item to the left between leftNode and rightNode index (non-leaf) nodes
    // right node first item -> parent
    // parent item -> left node
    var rotateAmongNodesToLeft = function (leftNode, rightNode) {
        // move item from rightNode to LeftNode
        //
        var parent = rightNode.parent;
        var rightIndex = calcChildIndex(parent, rightNode);
        //
        // move the key:
        leftNode.keys.add(parent.keys.items[rightIndex - 1]); // copy the key down
        parent.keys.items[rightIndex - 1] = rightNode.keys.first(); // copy the key up
        rightNode.keys.removeFirst(); // remove from right
        //
        // move the child reference:
        rightNode.children.first().parent = leftNode; // update parent reference
        leftNode.children.add(rightNode.children.first()); // copy to left
        rightNode.children.removeFirst(); // remove from right
    };

    // move a key item to the right between leftNode and rightNode index (non-leaf) nodes
    // left node last item -> parent
    // parent item -> right node
    var rotateAmongNodesToRight = function (leftNode, rightNode) {
        // move item from leftNode to rightNode
        //
        var parent = rightNode.parent;
        var rightIndex = calcChildIndex(parent, rightNode);
        //
        // move the key:
        rightNode.keys.insert(0, parent.keys.items[rightIndex - 1]); // copy the key down
        parent.keys.items[rightIndex - 1] = leftNode.keys.last(); // copy the key up
        leftNode.keys.removeLast(); // remove from left
        //
        // move the child reference:
        rightNode.children.insert(0, leftNode.children.last()); // copy to right
        rightNode.children.first().parent = rightNode; // update parent reference
        leftNode.children.removeLast(); // remove from left
    };

    // move an item to the left between leftLeaf and rightLeaf leaf nodes
    // right leaf first item -> left leaf
    var rotateAmongLeavesToLeft = function (leftLeaf, rightLeaf) {
        // move item from rightLeaf to leftLeaf
        //
        var rightIndex = calcChildIndex(rightLeaf.parent, rightLeaf);
        //
        // copy to left:
        leftLeaf.keys.add(rightLeaf.keys.first());
        leftLeaf.values.add(rightLeaf.values.first());
        //
        // remove from right:
        rightLeaf.keys.removeFirst();
        rightLeaf.values.removeFirst();
        //
        // update parent:
        rightLeaf.parent.keys.items[rightIndex - 1] = rightLeaf.keys.first();
    };

    // move an item to the right between leftLeaf and rightLeaf leaf nodes
    // left leaf last item -> right leaf
    var rotateAmongLeavesToRight = function (leftLeaf, rightLeaf) {
        // move from leftLeaf to rightLeaf
        //
        var rightIndex = calcChildIndex(rightLeaf.parent, rightLeaf);
        //
        // copy to right:
        rightLeaf.keys.insert(0, leftLeaf.keys.last());
        rightLeaf.values.insert(0, leftLeaf.values.last());
        //
        // remove from left:
        leftLeaf.keys.removeLast();
        leftLeaf.values.removeLast();
        //
        // update parent:
        rightLeaf.parent.keys.items[rightIndex - 1] = rightLeaf.keys.first();
    };

    // -----------------------------------------
    //             internal searches:
    // -----------------------------------------

    // short description: returns the "child" index in the "node"
    // long description: calculates the "child" node index in the "node.children" array
    // (usually node == child.paren)
    var calcChildIndex = function (node, child) {
        var key = child.keys.first();
        var searchResult = node.keys.search_first(key);
        if (!searchResult.found) {
            if (node.children.items[searchResult.index] != child) throw "B_PlusTree.calcChildIndex(): 1";
            return searchResult.index;
        }
        //
        var index = searchResult.index;
        for (; ; ) {
            if (node.children.items[index] == child) return index;
            //
            index++;
            if (index >= node.children.count) break;
            if (node.keys.items[index - 1] != key) break;
        }
        throw "B_PlusTree.calcChildIndex(): 2";
    };

    // returns leaf node containing an item with the given key
    var searchLeaf = function (key) {
        //
        var doSearchLeaf = function (node, key) {
            var searchResult = node.keys.search_first(key);
            //
            if (node.isLeaf) {
                return { node: node, found: searchResult.found, index: searchResult.index };
            }
            //
            if (searchResult.found) {
                // illustration: [left child] key [right child]
                // both children (left and right i.e. before and after the key) can contain the key
                //
                // try the left child first:
                var resultLeft = doSearchLeaf(node.children.items[searchResult.index], key);
                if (resultLeft.found) return resultLeft;
                //
                // try the right child
                return doSearchLeaf(node.children.items[searchResult.index + 1], key);
            } else {
                // the pointed key is greater than the searched key. Only left child can be considered:
                return doSearchLeaf(node.children.items[searchResult.index], key);
            }
        };
        //
        return doSearchLeaf(m_public.root, key);
    };

    // returns last leaf node containing an item with the given key
    var searchLastLeaf = function (key) {
        //
        var doSearchLastLeaf = function (node, key) {
            var searchResult = node.keys.search_last(key);
            //
            if (node.isLeaf) {
                return { node: node, found: searchResult.found, index: searchResult.index };
            }
            //
            if (searchResult.found) {
                // illustration: [left child] key [right child]
                // both children (left and right i.e. before and after the key) can contain the key
                //
                // try the right child first:
                var resultRight = doSearchLastLeaf(node.children.items[searchResult.index + 1], key);
                if (resultRight.found) return resultRight;
                //
                // try the left child
                return doSearchLastLeaf(node.children.items[searchResult.index], key);
            } else {
                // the pointed key is greater than the searched key. Only left child can be considered:
                return doSearchLastLeaf(node.children.items[searchResult.index], key);
            }
        };
        //
        return doSearchLastLeaf(m_public.root, key);
    };

    // returns last leaf node containing an item with the given prefix
    var searchLastLeafByPrefix = function (prefix) {
        //
        var doSearchLastLeafByPrefix = function (node, prefix) {
            var searchResult = node.keys.search_last_prefix(prefix);
            //
            if (node.isLeaf) {
                return { node: node, found: searchResult.found, index: searchResult.index };
            }
            //
            if (searchResult.found) {
                // illustration: [left child] key [right child]
                // both children (left and right i.e. before and after the key) can contain the prefix
                //
                // try the right child first:
                var resultRight = doSearchLastLeafByPrefix(node.children.items[searchResult.index + 1], prefix);
                if (resultRight.found) return resultRight;
                //
                // try the left child
                return doSearchLastLeafByPrefix(node.children.items[searchResult.index], prefix);
            } else {
                // the pointed key is greater than the searched prefix. Only left child can be considered:
                return doSearchLastLeafByPrefix(node.children.items[searchResult.index], prefix);
            }
        };
        //
        return doSearchLastLeafByPrefix(m_public.root, prefix);
    };

    // returns leaf node containing an item with the given key and value
    var searchLeafValue = function (key, value) {
        // search the key:
        var searchResult = searchLeaf(key);
        if (!searchResult.found) return searchResult;
        //
        // search the value (if there are several the same keys):
        var valueFound = false;
        var leaf = searchResult.node;
        var index = searchResult.index;
        for (; ; ) {
            if (index >= leaf.values.count) {
                leaf = leaf.nextLeaf;
                if (leaf == null) break;
                index = 0;
            }
            if (leaf.keys.items[index] != key) break;
            if (leaf.values.items[index] == value) {
                valueFound = true;
                break;
            }
            index++;
        }
        //
        return { node: leaf, found: valueFound, index: index };
    };

    // returns last leaf node containing an item with the given key and value
    var searchLastLeafValue = function (key, value) {
        // search the key:
        var searchResult = searchLastLeaf(key);
        if (!searchResult.found) return searchResult;
        //
        // search the value (if there are several the same keys):
        var valueFound = false;
        var leaf = searchResult.node;
        var index = searchResult.index;
        //var foundIndex = 0;
        for (; ; ) {
            if (index < 0) {
                leaf = leaf.prevLeaf;
                if (leaf == null) break;
                index = leaf.values.count - 1;
            }
            if (leaf.keys.items[index] != key) break;
            if (leaf.values.items[index] == value) {
                valueFound = true;
                break;
            }
            index--;
        }
        //
        return { node: leaf, found: valueFound, index: index };
    };

    // -----------------------------------------
    //       return the public interface:
    // -----------------------------------------

    return m_public;
};

B_Plus_Tree.FindInfo = FindInfo;

//return B_Plus_Tree;
module.exports = B_Plus_Tree;



},{"./stiffarray":183}],183:[function(require,module,exports){

// This is resulting in smaller code in other parts of the framework.
//  This section is getting quite big (again)
//  Still need to make use of the B+ free for ordered indexing.

// Moving some code to jsgui-lang-essentials
//  Will be publishing a 0.4 version of that before so long?
//   Maybe with more explanation?

// It may be worth publishing this, and a discussion forum about it on my own web forum.
//  Perhaps that could come later, but jsgui-lang-essentials may be a good step. Could call it version 0.35.
//   Could have a few examples
//   Would be a useful toolkit I could use while working elsewhere.

//  I think that web site would be lightening fast, and impress people with its speed compared to other web platforms that they are used to
//   (though Facebook is OK)

/*
 if (typeof define !== 'function') {
 var define = require('amdefine')(module);
 }


 // May sway implementations of the particular items more easily when they are in their own files.

 define(["./jsgui-lang-essentials"], function (jsgui) {
 */
//var jsgui = require('./jsgui-lang-essentials');

// StiffArray: an array with pre-allocated items
// it seems that this array is usually faster (excluding IE javascript engine)
// probably there is a reason to provide IE implementation based on usual dynamic arrays

var StiffArray = function (capacity) {

    // -----------------------------------------
    //              public interface:
    // -----------------------------------------

    var m_public = {
        items: new Array(capacity), // internal storage array
        count: 0, // items count
        first: function () {
            if (this.count == 0) throw "StiffArray.first()";
            return this.items[0];
        },
        last: function () {
            if (this.count == 0) throw "StiffArray.last()";
            return this.items[this.count - 1];
        },
        add: function (item) {
            if (this.count >= capacity) throw "StiffArray.add()";
            //
            this.items[this.count++] = item;
        },
        add_from: function (source) {
            if (this.count + source.count > capacity) throw "StiffArray.add_from()";
            //
            for (var i = 0; i < source.count; i++) this.items[this.count++] = source.items[i];
        },
        insert: function (index, item) {
            if ((index < 0) || (index > this.count)) throw "StiffArray.insert(): index";
            if (this.count >= capacity) throw "StiffArray.insert(): overflow";
            //
            for (var i = this.count; i > index; i--) this.items[i] = this.items[i - 1];
            this.items[index] = item;
            this.count++;
        },
        removeAt: function (index) {
            if ((index < 0) || (index >= this.count)) throw "StiffArray.removeAt()";
            //
            this.count--;
            for (var i = index; i < this.count; i++) this.items[i] = this.items[i + 1];
        },
        removeFirst: function () {
            this.removeAt(0);
        },
        removeLast: function () {
            this.removeAt(this.count - 1);
        },
        copy_from: function (source, index, count) {
            for (var i = 0; i < count; i++) {
                this.items[i] = source.items[i + index];
            }
            this.count = count;
        },
        search_first: function (item) {
            var cnt = this.count;
            var first = 0;
            while (cnt > 0) {
                var step = Math.floor(cnt / 2);
                var index = first + step;
                if (this.items[index] < item) {
                    first = index + 1;
                    cnt -= (step + 1);
                } else {
                    cnt = step;
                }
            }
            //
            if (first < this.count) {
                return { found: (this.items[first] == item), index: first };
            }
            return { found: false, index: first };
        },
        search_last: function (item) {
            var cnt = this.count;
            var first = 0;
            while (cnt > 0) {
                var step = Math.floor(cnt / 2);
                var index = first + step;
                if (item >= this.items[index]) {
                    first = index + 1;
                    cnt -= (step + 1);
                } else {
                    cnt = step;
                }
            }
            //
            if ((first > 0) && (first <= this.count)) {
                if (this.items[first - 1] == item) {
                    return { found: true, index: first - 1 };
                }
            }
            return { found: false, index: first };
        },
        search_last_prefix: function (prefix) {
            var prefix_length = prefix.length;
            //
            var check_prefix = function (item) {
                if (prefix_length > item.length) return false;
                return (item.substr(0, prefix_length) == prefix)
            }
            //
            var cnt = this.count;
            var first = 0;
            while (cnt > 0) {
                var step = Math.floor(cnt / 2);
                var index = first + step;
                var item = this.items[index];
                if ((prefix > item) || check_prefix(item)) {
                    first = index + 1;
                    cnt -= (step + 1);
                } else {
                    cnt = step;
                }
            }
            //
            if ((first > 0) && (first <= this.count)) {
                if (check_prefix(this.items[first - 1])) {
                    return { found: true, index: first - 1 };
                }
            }
            return { found: false, index: first };
        },
        toString: function () {
            return this.items.slice(0, this.count).toString();
        }
    };


    // -----------------------------------------
    //       return the public interface:
    // -----------------------------------------

    return m_public;
};
module.exports = StiffArray;


//return StiffArray;


//});



},{}],184:[function(require,module,exports){

const {each, is_array} = require('lang-mini');

// collective(arr).bcr() for example.... would call the bcr function on every item in the array (or collection?) 

// would help to make ut support other data types.
//.  possibly ones that can expose an array interface???


// eg collect(ctrl.siblings).bcr().overlaps(ctrl.bcr().extend('left', 80)).max('width') >= 80 ????

// or do:

// ctrl.bcr().extend('left', 80).overlaps(collect(ctrl.siblings).bcr()).max('width') >= 80

// or:

//. Will be nice to allow dense syntax in an unambiguous way where possible.
//.   Would automatically carry out the 'collect' operation, but that could be a more advanced stage of the implementation doing that.

// Really concise syntax to express the things which would take quite a lot of likes of JS, but simple enough to be able
//.  to be expressed in one dense and very readable line.

// This would be a good piece of code for the Window control to express looking to its left and seeing if it overlaps any siblings
//.  within 80 px, and what the overlap is with similar syntax.



// ctrl.bcr().extend('left', 80).overlaps(ctrl.siblings).max('width') > 0

// A direct and readable syntax will help...
// ctrl.bcr.extend('left', 80).overlaps(ctrl.siblings).max('width') > 0



const collective = (arr) => {

    /*
    each(arr, (item) => {

    })
    */

    if (is_array(arr)) {
        //const ref_arr = [];
        

        const target = {
          };
          
          const handler2 = {

            get(target, prop, receiver) {
                if (arr.hasOwnProperty(prop)) {
                    return arr[prop];
                } else {
                    
                    if (typeof arr[0][prop] === 'function') {

                        return (...a) => {
                            const res = [];
                            each(arr, item => {
                                res.push(item[prop](...a));
                            })
                            return res;
                        }

                        // Call the function on all of them
                    } else {
                        const res = [];
                        each(arr, item => {
                            res.push(item[prop]);
                        })
                        return res;
                    }

                    
                }

              //return "world";
            },
          };
          
          const proxy2 = new Proxy(target, handler2);
          return proxy2;


    } else {
        console.trace();
        throw 'NYI';
    }


}

module.exports = collective;
},{"lang-mini":379}],185:[function(require,module,exports){
class Node {
	constructor(spec) {
		// previous and next held as an array.

		// neighbours
		//  it could have no neighbours.
		//   a list will be empty, with no nodes.
		//   then it will have a node with no neighbours, which is both the first and the last node.
		//   then 2 nodes, 1 with each neighbour
		//   then 3 nodes, with the end nodes still having no neighbours.

		// This will just be for iterating through the list, adding, removing, doing basic operations.
		//  I may leave inefficient operations out, so the linked list gets used for what it is best at.
		//   But the inefficient/less efficient operations may be done to lower amounts, such as 12, by maintaining small LLs in data structures such as B+ trees.

		this.neighbours = spec.neighbours || [];

		// Adding and removing while maintaining an order?
		this.value = spec.value;

		// parent

	}
	'previous'() {
		return this.neighbours[0];
	}
	'next'() {
		return this.neighbours[1];
	}
};

// Do these linked list nodes need to have anything?
//  Just the means to insert their nodes etc?
//   Then their nodes could be made to carry other data by other components.

// Doubly_Linked_List could extend Node.
//  That way it can be put in a tree, and used for holding the data in a tree.
//  Want a B+ tree so that items can get put in correctly.

// Having a whole tree made up of a doubly linked list, with other structures indexing it?
//  Need some more fundamental data structures. The Collection and Data_Object will be good, but it will be good to store the fields in an appropriate object.


// Ordered_KVS - may be a useful one.
//  Would have the double linked list inside and map.


// Mapped_Linked_List? would need to know what field to look at.

/*
var nodify = function(fn) {

	var res = function(val) {
		if (val instanceof Node) {
			return fn(val);
		} else {
			var node = new Node({'value': val});
			return fn(node);
		}

	};
	return res;

}
*/

class Doubly_Linked_List {
	constructor(spec) {
		// spec could be the initial items for the list.

		this.first = null;
		this.last = null;

		this.length = 0;
		// harder to maintain the length when nodes could be moved around the list.
		//  would need to be able to see if a node is in the list to begin with...
		//   so each node could have a container object, and if it is set to the list already when an insert is done, then the list will be able to keep track of
		//    its length. That would be better than having to count them.

	}

	'each_node'(callback) {
		//console.log('each_node this.length ' + this.length);

		var node = this.first;
		var ctu = true;
		var stop = function () {
			ctu = false;
		};
		while (node && ctu) {
			callback(node, stop);
			node = node.neighbours[1];
		}
	}

	'each'(callback) {
		this.each_node(function (node, stop) {
			callback(node.value, stop);
		});
	}

	'remove'(node) {

		// can not remove a value... have to remove a node.
		//  this will be more useful when there is a map of values.

		if (node.neighbours[0]) {
			node.neighbours[0].neighbours[1] = node.neighbours[1];
		} else {
			this.first = node.neighbours[1];
		}

		if (node.neighbours[1]) {
			node.neighbours[1].neighbours[0] = node.neighbours[0];
		} else {
			this.last = node.neighbours[0];
		}

		node.neighbours = [];

		if (node.parent == this) {
			delete node.parent;
			this.length--;
		}

	}

	// check to see if the item is a 'node' object.
	//  if it is, can insert it as a node, otherwise create the node object and insert it.
	//   a bit like wrapping values in Data_Value.

	'insert_beginning'(val) {
		if (val instanceof Node) {
			if (this.first == null) {
				this.first = val;
				this.last = val;
				val.neighbours = [];
				if (val.parent != this) {
					val.parent = this;
					this.length++;
				}
			} else {
				// insert it before first item.
				this.insert_before(val, this.first);
			}
			return val;
		} else {
			var node = new Node({ 'value': val });
			return this.insert_beginning(node);
		}
	}

	// could use a nodify function.
	//  or ensure_data_wrapper

	'insert_before'(val, node) {
		// check to see if the new value is a node.

		if (val instanceof Node) {
			val.neighbours = [node.neighbours[0], node];
			if (node.neighbours[0] == null) {
				this.first = val;
			} else {
				node.neighbours[0].neighbours[1] = val;
			}
			node.neighbours[0] = val;

			if (val.parent != this) {
				val.parent = this;
				this.length++;
			}
			return val;
		} else {
			var new_node = new Node({ 'value': val });
			return this.insert_before(new_node, node);
		}
	}

	'insert_after'(val, node) {
		if (val instanceof Node) {
			//console.log('insert after node ' + node);

			val.neighbours = [node, node.neighbours[1]];
			if (node.neighbours[1] == null) {
				this.last = val;
			} else {
				node.neighbours[1].neighbours[0] = val;

			}
			node.neighbours[1] = val;

			//node.neighbours[0].neighbours[1] = val;
			if (val.parent != this) {
				val.parent = this;
				this.length++;
			}
			return val;
		} else {
			var new_node = new Node({ 'value': val });
			return this.insert_after(new_node, node);
		}
	}
	// not wrapping the item in a node?

	// want one where we are not pushing nodes, but items stored in nodes.
	//  Perhaps this is a Data_Value?
	// Or a doubly_linked_node.

	// Doubly_Linked_Node could take the form [prev, item, next]
	//  [prev, item, key, next]? probably not

	//  Maybe we could put more private variables, such as 'neighbours' as a var within the init statement.

	'push'(val) {

		if (val instanceof Node) {
			if (this.last == null) {
				this.insert_beginning(val);
			} else {
				return this.insert_after(val, this.last);
				/*
				 var last = this.last;
				 last.neighbours[1] = val;
				 this.last = val;

				 //console.log('val.parent ' + val.parent);
				 //console.log('this ' + this);

				 if (val.parent != this) {
				 val.parent = this;
				 this.length++;
				 }
				 */
			}
			return val;
		} else {
			var new_node = new Node({ 'value': val });
			return this.push(new_node);
		}
		// the item gets wrapped in a node.?
	}
};

Doubly_Linked_List.Node = Node;

module.exports = Doubly_Linked_List;

},{}],186:[function(require,module,exports){
/*
    Should make lang-tools module.
    // Get lang_mini using that instead.
    //  And this will use lang-mini.
    //  Cut down on number of code references in some cases.
*/


const lang_mini = require('lang-mini');
const collective = require('./collective');

const {more_general_equals} = require('./Data_Model/new/tools');

lang_mini.equals = more_general_equals;

lang_mini.collective = collective;
lang_mini.collect = collective;

const Evented_Class = lang_mini.Evented_Class;
//var Evented_Class = require('./_evented-class');
// Could use lang-mini for this.
//  Keep the code consisten
//  lang-ext
//  lang-enh
//  flang

const B_Plus_Tree = require('./b-plus-tree/b-plus-tree');
const Collection = require('./Data_Model/old/Collection');
const Data_Object = require('./Data_Model/Data_Object');
const Data_Value = require('././Data_Model/Data_Value');
const Data_Model = require('././Data_Model/Data_Model');
const Immutable_Data_Value = require('././Data_Model/new/Immutable_Data_Value');
const Immutable_Data_Model = require('././Data_Model/new/Immutable_Data_Model');
const Doubly_Linked_List = require('./doubly-linked-list');

const Ordered_KVS = require('./ordered-kvs');
const Ordered_String_List = require('./ordered-string-list');
const Sorted_KVS = require('./sorted-kvs');

// util...

const util = require('./util');

// merge util into lang_mini?

lang_mini.util = util;

lang_mini.B_Plus_Tree = B_Plus_Tree;
lang_mini.Collection = Collection;
lang_mini.Data_Object = Data_Object;
lang_mini.Data_Value = Data_Value;
lang_mini.Immutable_Data_Model = Immutable_Data_Model;
lang_mini.Immutable_Data_Value = Immutable_Data_Value;
lang_mini.Data_Model = Data_Model;
lang_mini.Doubly_Linked_List = Doubly_Linked_List;
//lang_mini.Evented_Class = Evented_Class;
lang_mini.Ordered_KVS = Ordered_KVS;
lang_mini.Ordered_String_List = Ordered_String_List;
lang_mini.Sorted_KVS = Sorted_KVS;
// remake it as an ec

const ec = new Evented_Class();
Object.assign(ec, lang_mini);

// Nothing here particularly about Resources.
//  Some resources may need to access the internet.
//   Less clearly lang specific?

// Or a data-transformer / transformer
//  compiler being a subset of transformer.
//  codec also being a subset of transformer.





// a compile command too, for command line usage.


// lang_mini.compilers.load('babel', babel.transform) ???
//  but will need to be able to send options through to compilers too.
//  Could have named option sets, easier shorthands.






module.exports = ec;
},{"././Data_Model/Data_Model":164,"././Data_Model/Data_Value":166,"././Data_Model/new/Immutable_Data_Model":171,"././Data_Model/new/Immutable_Data_Value":172,"./Data_Model/Data_Object":165,"./Data_Model/new/tools":178,"./Data_Model/old/Collection":179,"./b-plus-tree/b-plus-tree":182,"./collective":184,"./doubly-linked-list":185,"./ordered-kvs":187,"./ordered-string-list":188,"./sorted-kvs":189,"./util":190,"lang-mini":379}],187:[function(require,module,exports){
/**
 * Created by James on 16/09/2016.
 */

var Doubly_Linked_List = require('./doubly-linked-list');

class Ordered_KVS {
	constructor() {
		this.dll = new Doubly_Linked_List();
		this.node_map = {};
	}
	'length'() {
		return this.dll.length;
	}
	'put'(key, value) {
		// does it already exist with that key - if so that item gets replaced, stays in the same position?
		// or maybe push - that means the item that goes in gets added to the end.
		return this.push(key, value);
	}
	'get'(key) {
		//console.log('get key ' + key);
		var kvs_node = this.node_map[key];
		if (kvs_node) {
			return kvs_node.value;
		} else {
			return undefined;
			//throw 'Missing KVS node: ' + key;
		}
	}
	'push'(key, value) {
		// does it already have a node with that key?
		var node = this.dll.push(value);
		node.key = key;
		this.node_map[key] = node;
	}
	'out'(key) {
		var node = this.node_map[key];
		//delete node.key;
		delete this.node_map[key]

		this.dll.remove(node);
	}
	'each'(callback) {
		// return the key as well as the value in the callback.
		this.dll.each_node(function (node, stop) {
			callback(node.key, node.value, stop);
		});
		//this.dll.each(callback);
	}
	'values'() {
		var res = [];
		this.each(function (key, value) {
			res.push(value);
		});
		return res;
	}
	'keys'() {
		var res = [];
		this.each(function (key, value) {
			res.push(key);
		});
		return res;
	}
	'keys_and_values'() {
		var res = [];
		this.each(function (key, value) {
			res.push([key, value]);
		});
		return res;
	}
	// will not need to deal with nodes on the user level.
	// want to be able to add and remove items, normally items will get pushed to the end of the list.

	// will provide a key and value in order to do this.
};

module.exports = Ordered_KVS;
},{"./doubly-linked-list":185}],188:[function(require,module,exports){
/**
 * Created by James on 16/09/2016.
 */


// This could be useful for a few things, like storing tables in a DB
// schema.
// Maybe quite a few more things.

// May make some objects with friendlier interfaces...
//  And may use collection for this to store lists of strings.
//  Like CSS flags at the moment.

// Uses private variables.
class Ordered_String_List {
	constructor() {
		// console.log('init osl sig ' + sig);

		var arr = [];
		var dict_indexes = {};

		var reindex_dict_indexes = function () {
			dict_indexes = {};
			for (var c = 0, l = arr.length; c < l; c++) {
				dict_indexes[arr[c]] = c;
			}
		}

		// (add), remove, get, get_all, has, put, move, splice
		this.has = function (value) {
			return (typeof dict_indexes[value] !== 'undefined');
		}

		this.put = function (value) {
			// by default puts it at the end.
			if (this.has(value)) {
				// stays in same place.
				// arr[dict_indexes[value]]
				// do nothing
			} else {
				var index = arr.length;
				arr.push(value);
				dict_indexes[value] = index;
			}

		}

		this.out = function (value) {
			if (this.has(value)) {
				var idx = dict_indexes[value];
				arr.splice(idx, 1);

				delete dict_indexes[value];

				for (var c = idx, l = arr.length; c < l; c++) {
					var i = arr[c];
					dict_indexes[i]--;
				}
				// will need the items after it and lower their indexes.

			}
		}

		this.toggle = function (value) {
			if (this.has(value)) {
				this.out(value);
			} else {
				this.put(value);
			}
		}

		this.move_value = function (value, index) {
			if (this.has(value) && dict_indexes[value] != index) {

				// gets removed from current position, causes items after it
				// to move back.
				// gets put in new position, gets items after that to move
				// forwards.

				var old_index = dict_indexes[value];
				arr.splice(old_index, 1);

				arr.splice(index, 0, value);

				if (index < old_index) {
					// moving back.
					// dict_indexes[]
					dict_indexes[arr[index]] = index;
					// the index object of the one it

					// for (var c = index, l = arr.length; c < l; c++) {
					for (var c = index + 1; c <= old_index; c++) {
						dict_indexes[arr[c]]++;
					}
				} else if (index > old_index) {
					dict_indexes[arr[index]] = index;
					for (var c = old_index; c < index; c++) {
						dict_indexes[arr[c]]--;
					}
				}

			}

		}
		// for testing

		this._index_scan = function () {
			for (var c = 0, l = arr.length; c < l; c++) {
				console.log('c ' + c + ' arr[c] ' + arr[c] + ' idx '
					+ dict_indexes[arr[c]]);
			};
		}

		this.toString = function () {
			var res = arr.join(' ');
			return res;
		}

		this.toString.stringify = true;

		this.set = (function (val) {

			if (typeof val === 'string') {
				arr = val.split(' ');
				reindex_dict_indexes();
			}

			//if (sig == '[s]') {
			//	arr = a[0].split(' ');
			//	// console.log('arr ' + jsgui.stringify(arr));
			//	reindex_dict_indexes();
			//}
		});

		// if (sig == '[s]') {
		// this.set(a[0]);
		// }

		var a = arguments;
		if (a.length == 1) {
			var spec = a[0];
			if (typeof spec === 'string') {
				// console.log('setting');
				this.set(spec);
			}
		}

	}
};

module.exports = Ordered_String_List;
},{}],189:[function(require,module,exports){
/**
 * Created by James on 25/09/2016.
 */

var jsgui = require('lang-mini');
var mapify = jsgui.mapify;
var B_Plus_Tree = require('./b-plus-tree/b-plus-tree');

class Sorted_KVS {
	constructor(spec) {
		spec = spec || {};
		// both a dict and a BTree
		//  that is used in this case because the BTree only stores string keys.
		//  the improved B+ tree will have value objects/pointers within them

		if (typeof spec.unique_keys !== 'undefined') this.unique_keys = spec.unique_keys;
		//this.tree = new B_Plus_Tree(12); // order 12
		this.tree = B_Plus_Tree(12); // order 12


		//this.dict = {};
		// likely to make the dict refer to the tree node


	}

	'clear'() {
		this.tree.clear();
		//this.dict = {};
	}

	/*
	'put': mapify(function (key, value) {
		// inserting a bunch of things at once... could that be done more efficiently, such as in one traversal?
		//  sort the items, then can skip through the tree a bit quicker?


		var insert_res = this.tree.insert(key, value);
		// with tree.insert - nice if we can keep the treenode as a result.
		//  the tree does not store objects in the node.
		//   could make the tree node hold a reference to the object?

		//console.log('put insert_res ' + insert_res);
		//this.dict[key] = value;
	}),
	*/

	'out'(key) {
		//console.log('key ' + key);
		//

		this.tree.remove(key);
		//console.log('this.tree.keys_and_values() ' + stringify(this.tree.keys_and_values()));
		//throw '2.stop';
		//delete this.dict[key];
	}

	'get'(key) {
		//console.log('Sorted_KVS get');
		//console.log('key ' + stringify(key));


		// get all nodes with that key

		//var tree_res = this.tree.
		//console.log('this.tree.keys() ' + stringify(this.tree.keys()));
		//throw ('stop');

		//return
		// if this is treating the keys as unique it will just return 1 item or undefined / null.
		// otherwise it returns array on n items

		// don't want KVPs

		return this.tree.get_values_by_key(key);

		//return this.dict[key];
	}


	'has'(key) {
		//return (typeof this.dict[key] !== 'undefined');

		return this.key_count(key) > 0;

	}
	'get_cursor'() {
		//var res = new KSVS_Cursor(this);
		//res.move_first();
		//return res;
	}


	'keys'() {

		return this.tree.keys();

		//return this.tree.keys();
	}

	'keys_and_values'() {
		return this.tree.keys_and_values();
	}

	/*
	 'values': function() {
	 var keys = this.keys();
	 var res = [];
	 var that = this;
	 console.log('keys.length ' + keys.length );
	 console.log('keys ' + jsgui.stringify(keys));

	 each(keys, function(i, v) {
	 res.push(that.dict[v]);
	 });
	 return res;
	 },
	 */

	'key_count'(key) {

		if (typeof key !== 'undefined') {
			return this.tree.count(key);
		} else {
			return this.tree.count();
		}

		// also want to do it for a particular key


	}

	'get_keys_by_prefix'(prefix) {
		return this.tree.get_keys_by_prefix(prefix);
	}

	'each'(callback) {
		// iterate through every item
		//  key, value
		return this.tree.each(callback);
	}

	'get_by_prefix'(prefix) {

		return this.tree.get_by_prefix(prefix);
	}
};

// if we get a

Sorted_KVS.prototype.put = mapify(function (key, value) {
	// inserting a bunch of things at once... could that be done more efficiently, such as in one traversal?
	//  sort the items, then can skip through the tree a bit quicker?


	var insert_res = this.tree.insert(key, value);
	//return insert_res;
	// with tree.insert - nice if we can keep the treenode as a result.
	//  the tree does not store objects in the node.
	//   could make the tree node hold a reference to the object?


	//console.log('put insert_res ' + insert_res);
	//this.dict[key] = value;
});

module.exports = Sorted_KVS;
},{"./b-plus-tree/b-plus-tree":182,"lang-mini":379}],190:[function(require,module,exports){
/**
 * Created by James on 16/09/2016.
 */

var jsgui = require('lang-mini');
//var Data_Structures = require('./jsgui-data-structures');
var Collection = require('./Data_Model/Collection');

//var Data_Grid = require('jsgui2-data-grid');

var j = jsgui;
var each = j.each;
var tof = j.tof;
var atof = j.atof;
var is_defined = j.is_defined;
var fp = j.fp;
var arrayify = j.arrayify;
var mapify = j.mapify;
var get_item_sig = j.get_item_sig;


// ta-utils?
// ta-matrix
// ta-tensor

// Maybe expand lang-mini?
// Could spin out a lang-tools project.
// or jsgui3-lang, which uses lang-tools
//  maybe adds some jsgui specific features.

// A Matrix or Tensor data type could be very useful for single images.
// A Tensor data type could conveniently hold multiple images

// A Manifold Nexus would be able to store a Tensor within different storage devices / network addresses, and process them too.








//var B_Plus_Tree = Data_Structures.B_Plus_Tree;

// would prefer a version that applies to typed arrays.
// uses typed arrays internally

var vectorify = function(n_fn) {
	// Creates a new polymorphic function around the original one.

	var fn_res = fp(function(a, sig) {
		//console.log('vectorified sig ' + sig);
		if (a.l > 2) {
			var res = a[0];
			for ( var c = 1, l = a.l; c < l; c++) {
				res = fn_res(res, a[c]);
				// console.log('res ' + res);
			}
			return res;
		} else {
			if (sig == '[n,n]') {
				return n_fn(a[0], a[1]);
			} else {
				// will need go through the first array, and the 2nd... but
				// will need to compare them.
				var ats = atof(a);
				//console.log('ats ' + stringify(ats));
				if (ats[0] == 'array') {
					if (ats[1] == 'number') {
						var res = [], n = a[1];
						each(a[0], function(v, i) {
							res.push(fn_res(v, n));
						});
						return res;
					}
					if (ats[1] == 'array') {
						if (ats[0].length != ats[1].length) {
							throw 'vector array lengths mismatch';
						} else {
							var res = [], arr2 = a[1];
							each(a[0], function(v, i) {
								res.push(fn_res(v, arr2[i]));
							});
							return res;
						}
					}
				}
			}
		}
	});
	return fn_res;
};

var n_add = function(n1, n2) {
	return n1 + n2;
}, n_subtract = function(n1, n2) {
	return n1 - n2;
}, n_multiply = function(n1, n2) {
	return n1 * n2;
}, n_divide = function(n1, n2) {
	return n1 / n2;
};

// Simple and fast vector and tensor maths would help.

// new Vector(4, 3)
//  new Uint8Vector(4, 3);
//  new Uint8Matrix(40, 30);
//  new Uint8Tensor(40, 30, 3, 60);


var v_add = vectorify(n_add), v_subtract = vectorify(n_subtract);

// these are not the standard, established vector or matrix operations. They
// can be used for scaling of arrays of vectors.
var v_multiply = vectorify(n_multiply), v_divide = vectorify(n_divide);

var vector_magnitude = function(vector) {
	// may calculate magnitudes of larger dimension vectors too.
	// alert(tof(vector[0]));
	// alert(vector[0] ^ 2);

	var res = Math.sqrt((Math.pow(vector[0], 2)) + (Math.pow(vector[1], 2)));
	return res;

};

var distance_between_points = function(points) {
	var offset = v_subtract(points[1], points[0]);
	//console.log('offset ' + stringify(offset));
	return vector_magnitude(offset);
}


var execute_on_each_simple = function(items, fn) {
	// currently no arguments provided, there may be in the future / future
	// versions
	var res = [], that = this;
	each(items, function(i, v) {
		res.push(fn.call(that, v)); // function called with item as its only
									// parameter.
	});
	return res;
};

var filter_map_by_regex = function(map, regex) {
	var res = {};
	each(map, function(i, v) {
		// if (regex.match(i)) {
		if (i.match(regex)) {
			res[i] = v;
		}
	});
	return res;
}

// May be replaced by a more veristile replacement system, ie input transformation and parsing in schemas.
var npx = arrayify(function(value) {
	// don't think we can use arrayify?

	// good candidate for pf? but how it deals with array trees...
	// could have another one, like sf or spf that is simpler in terms of
	// treating an array in the signature as just one array?

	var res, a = arguments, t = tof(a[0]);

	// fn sigs??? performance?

	if (t === 'string') {
		res = a[0];
	} else if (t === 'number') {
		res = a[0] + 'px';
	}
	return res;
});

var no_px = arrayify(fp(function(a, sig) {
	// no_px - removes the 'px' if it ends with px
	// Generally returns a number.
	// value
	var re = /px$/, res;
	if (sig == '[s]' && re.test(a[0])) {
		res = parseInt(a[0]);
	} else {
		res = a[0];
	}
	;
	return res;
}));

var arr_ltrb = [ 'left', 'top', 'right', 'bottom' ];

var str_arr_mapify = function(fn) {
	var res = fp(function(a, sig) {
		if (a.l == 1) {
			if (sig == '[s]') {
				var s_pn = a[0].split(' ');
				// console.log('s_pn ' + s_pn.length);

				if (s_pn.length > 1) {
					return res.call(this, s_pn);
				} else {
					return fn.call(this, a[0]);
				}
			}

			if (tof(a[0]) == 'array') {
				var res2 = {}, that = this;

				each(a[0], function(i, v) {
					res2[v] = fn.call(that, v);
				});
				return res2;
			}
		}
	});
	return res;
};


var arr_hex_chars = [ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
	'A', 'B', 'C', 'D', 'E', 'F' ];
var dict_hex_to_bin = {
	'0' : 0,
	'1' : 1,
	'2' : 2,
	'3' : 3,
	'4' : 4,
	'5' : 5,
	'6' : 6,
	'7' : 7,
	'8' : 8,
	'9' : 9,
	'A' : 10,
	'B' : 11,
	'C' : 12,
	'D' : 13,
	'E' : 14,
	'F' : 15
};
var str_hex_to_int = function(str_hex) {
	str_hex = str_hex.toUpperCase();
	var i = str_hex.length; // or 10
	var res = 0, exp = 1;
	while (i--) {
		var i_part = dict_hex_to_bin[str_hex.charAt(i)];
		var ip2 = i_part * exp;
		res = res + ip2;
		exp = exp * 16;
		// ...
	}
	;
	return res;
};
var byte_int_to_str_hex_2 = function(byte_int) {
	var a = Math.floor(byte_int / 16), b = byte_int % 16, sa = arr_hex_chars[a], sb = arr_hex_chars[b], res = sa
		+ sb;
	return res;
};
var arr_rgb_to_str_hex_6 = function(arr_rgb) {
	var r = byte_int_to_str_hex_2(arr_rgb[0]);
	var res = r + byte_int_to_str_hex_2(arr_rgb[1])
		+ byte_int_to_str_hex_2(arr_rgb[2]);
	return res;
};
var arr_rgb_to_css_hex_6 = function(arr_rgb) {
	// a / b // divide a by b
	// a % b // find the remainder of division of a by b
	return '#' + arr_rgb_to_str_hex_6(arr_rgb);
};

var input_processors = {};

var output_processors = {};

var validators = {
	'number' : function(value) {
		return tof(value) == 'number';
	}
};

var referred_object_is_defined = function(object_reference) {
	return is_defined(object_reference[0][object_reference[1]]);
}

var set_vals = function(obj, map) {
	each(map, function(i, v) {
		obj[i] = v;
	});
};


var extend = jsgui.extend, fp = jsgui.fp, stringify = jsgui.stringify, tof = jsgui.tof;
// Connecting these input processors in this instance to the Enhanced_Data_Object?
// So keep the color declaration here. Outside of HTML?
// color is an indexed array.
//  Does that mean it should be stored as a Data_Value?

var data_types_info = {
	'color': ['indexed_array', [
		['red', 'number'],
		['green', 'number'],
		['blue', 'number']
	]],
	'oltrb': ['optional_array', ['left', 'top', 'right', 'bottom']]
}

jsgui.data_types_info = data_types_info;

// Will use better (ES6) factory methods than create_input_function_from_data_type_info

var color_preprocessor_parser = fp(function(a, sig) {
	//console.log('color_preprocessor_parser a ' + stringify(a));
	//console.log('color_preprocessor_parser sig ' + sig);
	if (sig == '[s]') {
		var input = a[0];
		var rx_hex = /(#([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2}))/;
		var m = input.match(rx_hex);
		//console.log('m ' + stringify(m));

		if (m) {
			// Could use arrayify or something to make the conversion quicker... will do that in more places, mainly want to get the code working now.

			var r = jsgui.str_hex_to_int(m[2]);
			var g = jsgui.str_hex_to_int(m[3]);
			var b = jsgui.str_hex_to_int(m[4]);

			var res = [r, g, b];
			return res;
		}
	}
})


var color_preprocessor = (function (fn_color_processor) {
	var that = this;
	//throw '!stop';
	var res = fp(function (a, sig) {

		//console.log('color_preprocessor sig ' + sig);

		if (sig == '[[s]]') {
			//var new_input =
			// use regexes to detect / read the string.

			//var rx_hex = /^#?[a-fA-F0-9][a-fA-F0-9][a-fA-F0-9]$/;
			var rx_hex = /(#([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2}))/;
			//var rx_hex = /(#(([0-9A-Fa-f]{2}){3}))/;
			//var rx_hex = /(#([0-9A-Fa-f]{2}){3})/;
			var input = a[0][0];

			//var m = rx_hex.match(input);
			var m = input.match(rx_hex);
			//console.log('m ' + stringify(m));

			if (m) {
				// Could use arrayify or something to make the conversion quicker... will do that in more places, mainly want to get the code working now.

				var r = jsgui.str_hex_to_int(m[2]);
				var g = jsgui.str_hex_to_int(m[3]);
				var b = jsgui.str_hex_to_int(m[4]);

				var res = [r, g, b];
				return res;
			}

		} else {
			// call with the same arguments.
			//console.log('calling normal...');
			return fn_color_processor.apply(that, a);

		}
	});
	return res;
});

// In previous modules, it won't keep the same input_processors.
//  Is there a way of retrieving that from the most inner modules?
//test_Color();

// And inputting an indexed array.
//  Will need to accept 2d size inputs.
// Size could possibly be 3d, maybe 1d? A line has a size, which is also its length (though in the world of GUI it could also have
//  a thickness).

// Optional array looks more like a language feature (enhancement).
//  Or even a core language feature?


// There will be different types of optional arrays, will have different input parameters.
input_processors['optional_array'] = fp(function (a, sig) {

	if (a.l == 2) {
		var oa_params = a[0],
			input = a[1];
		if (tof(input) == 'array') {
			// check it is within the right number.
			if (input.length <= oa_params.length) {
				return input;
			}
		} else {
			return input;
		}
	}
	if (a.l == 3) {
		var oa_params = a[0],
			items_data_type_name = a[1],
			input = a[2];
		// now need to get every item in the array or the item to conform to the given type.
		var input_processor_for_items = jsgui.input_processors[items_data_type_name];
		//console.log('input_processor_for_items ' + input_processor_for_items);
		//console.log('tof(input) ' + tof(input));
		if (tof(input) == 'array') {
			// check it is within the right number.
			if (input.length <= oa_params.length) {
				var res = [];
				each(input, function (i, v) {
					res.push(input_processor_for_items(v));
				});
				return res;
			}
		} else {
			return input_processor_for_items(input);
		}
	}
	//console.log('oa_params ' + stringify(oa_params));
});

input_processors['indexed_array'] = fp(function (a, sig) {
	// it may be taking some kind of data type that things need to be applied to.
	// eg 'size': ['indexed_array', ['distance', ['width', 'height']]],
	// would need to take in objects with the names of the properties as well.

	console.log('indexed_array sig', sig);

	if (a.l == 2) {
		var ia_params = a[0],
			input = a[1];
		//console.log('ia_params ' + stringify(ia_params));

		if (tof(input) == 'array') {
			if (input.length <= ia_params.length) {
				return input;
			}
		}
	}
	if (a.l == 3) {
		var ia_params = a[0],
			items_data_type_name = a[1],
			input = a[2];
		var input_processor_for_items = jsgui.input_processors[items_data_type_name];
		if (tof(input) == 'array') {
			// check it is within the right number.
			if (input.length <= ia_params.length) {
				var res = [];
				each(input, function (i, v) {
					res.push(input_processor_for_items(v));
				});
				return res;
			}
		}
	}
});

input_processors['n_units'] = function (str_units, input) {
	// this will change things to have both the number of units and a string with the unit in an array.
	//  will make it easier to do maths on the distances.

	if (tof(input) == 'number') {
		return [input, str_units];
	}
	if (tof(input) == 'string') {
		//var rx_n_units = /^(?:(\d+)(\w+))|(?:(\d*)\.(\d+)(\w+))$/;
		var rx_n_units = /^(\d+)(\w+)$/;
		// then match it, should be multiple parts to the match.

		// Do want to get the various pieces working for the Control system.
		//  Then will be very nice indeed when compacted for a mobile-client.

		var match = input.match(rx_n_units);
		//console.log('match ' + stringify(match));

		if (match) {
			return [parseInt(match[1]), match[2]];
		}

		rx_n_units = /^(\d*\.\d+)(\w+)$/;
		match = input.match(rx_n_units);
		//console.log('match ' + stringify(match));
		if (match) {
			return [parseFloat(match[1]), match[2]];
		}
		//throw('stop');
	}
};



// Previously...
//var ensure_data_type_data_object_constructor = function (data_type_name) {
// Will use a Factory instead (I think)
//  Simpler coding pattern
//   Not needing such a huge word, or huge words to describe it.
//    Don't need unique constructors anyway, will have far more convenient factory methods


//console.log('jsgui.input_processors ' + stringify(Object.keys(jsgui.input_processors)));
var dti_color = jsgui.data_types_info['color'];

input_processors['color'] = function(input) {


	var res;
	console.log('processing color input: ' + stringify(input));

	var input_sig = get_item_sig(input, 2);
	//console.log('input_sig ' + input_sig);

	//var i;

	if (input_sig == '[s]') {
		//i = input[0];
		res = color_preprocessor_parser(input[0]);
	}

	if (input_sig == '[n,n,n]') {
		//input = input[0];
		//i = input[0];
		//var res = color_preprocessor_parser(input);
		res = input;
	}




	// not sure that using the preprocessor is right...
	//  it returns a function, I think it applies to a function.
	//throw '!!stop';
	console.log('res ' + stringify(res));

	// So, the 'color' property gets set.
	//  Then would need to set the CSS background-color property?
	//   Depening on what type of Control it is.


	console.log('color input_processors output', res);



	return res;
}

//color_preprocessor(create_input_function_from_data_type_info(dti_color));
//jsgui.ensure_data_type_data_object_constructor('color');

jsgui.output_processors['color'] = function (jsgui_color) {
	var res = jsgui.arr_rgb_to_css_hex_6(jsgui_color);
	return res;
};

// collection needs a context...
//  can get the context from the first object.

// Grouping not working so well so far... ???? Still the case 2016?
//  Maybe a less reflective way of making the group function?



var group = function() {

	// Hope this grouping system is not too slow.
	//  May be able to optimize / selectively make the grouping functions.

	var a = arguments;

	if (a.length == 1 && tof(a[0]) == 'array') {
		return group.apply(this, a[0]);
	}

	//var res = new Collection();
	var res;
	for (var c = 0, l = a.length; c < l; c++) {
		var item = a[c];

		if (c == 0) {
			res = new Collection({'context': item.context});

		}
		res.push(item);

	}

	var C = a[0].constructor;
	var p = C.prototype;

	//console.log('C ' + C);
	//console.log('p ' + p);
	var i;
	for (i in p) {
		var tpi = tof(p[i]);
		if (tpi == 'function') {
			// make a group version.
			(function(i) {
				//console.log('i ' + i);

				if (i != 'each' && i != 'get' && i != 'add_event_listener') {
					res[i] = function() {
						var a = arguments;
						res.each(function(v, i2) {
							v[i].apply(v, a);
						})
					}
				}
			})(i)
		}
	}
	return res;
};

var true_vals = function(map) {
	var res = [];
	for (var i in map) {
		if (map[i]) res.push(map[i]);
	}
	return res;
};


const Ui16toUi32 = (ui16) => {
    let res = new Uint32Array(ui16.length / 2);
    let dv = new DataView(ui16.buffer);
    let l = ui16.length;
    let hl = l / 2;
    //console.log('l', l);
    //console.log('hl', hl);
    let resw = 0;
    for (let c = 0; c < hl; c++) {
        //console.log('c', c);
        res[resw++] = dv.getUint32(c * 4);
    }
    //console.log('res', res);
    return res;
}

const Ui32toUi16 = (ui32) => {
    let res = new Uint16Array(ui32.length * 2);
    let dv = new DataView(ui32.buffer);
    let l = ui32.length;
    //let dl = l * 2;
    //console.log('l', l);
    //console.log('dl', dl);
    let resw = 0;
    for (let c = 0; c < l; c++) {
        //console.log('c', c);
        //console.log('dv.getUint16(c)', dv.getUint16(c * 4 + 2));
        //console.log('dv.getUint16(c)', dv.getUint16(c * 4));

        res[resw++] = dv.getUint16(c * 4 + 2);
        res[resw++] = dv.getUint16(c * 4);
        //res[resw++] = dv.getUint16(c * 2 + 1);
        //res[resw++] = dv.getUint16(c * 2);
    }
    console.log('res', res);
    return res;
}

var util = {
	'Ui16toUi32': Ui16toUi32,
	'Ui32toUi16': Ui32toUi16,
	'vectorify' : vectorify,
	'v_add' : v_add,
	'v_subtract' : v_subtract,
	'v_multiply' : v_multiply,
	'v_divide' : v_divide,
	'vector_magnitude' : vector_magnitude,
	'distance_between_points' : distance_between_points,

	
	'execute_on_each_simple' : execute_on_each_simple,
	'mapify' : mapify,
	'filter_map_by_regex' : filter_map_by_regex,
	'atof' : atof,
	'npx' : npx,
	'no_px' : no_px,
	'str_arr_mapify' : str_arr_mapify,
	'arr_ltrb' : arr_ltrb,
	'true_vals': true_vals,
	'validators' : validators,
	'__data_id_method' : 'lazy',
	'str_hex_to_int' : str_hex_to_int,
	'arr_rgb_to_css_hex_6' : arr_rgb_to_css_hex_6,
	'group': group
};

module.exports = util;




},{"./Data_Model/Collection":163,"lang-mini":379}],191:[function(require,module,exports){
var jsgui = require('jsgui3-html');
const {
    Control,
    controls,
    deep_sig,
    each
} = jsgui;
const {
    Modal
} = controls;
var Client_Resource_Pool = require('./client-resource-pool');
const X = 0,
    Y = 1,
    H = 2,
    W = 3,
    R = 4,
    B = 5,
    TX = 6,
    TY = 7;
class Client_Page_Context extends jsgui.Page_Context {
    constructor(spec) {
        spec = spec || {};
        super(spec);
        const {
            map_controls,
            map_control_iids,
            next_iid
        } = this;
        this.document = spec.document || document;
        this.resource_pool = new Client_Resource_Pool({});
        this.__is_active = true;
        this.map_els = {};
        let ctrl_modal;

        this.mixins = jsgui.mixins;

        // Modal and overlay may be better implemented with mixins perhaps.

        Object.defineProperty(this, 'modal', {
            get() {
                if (ctrl_modal) {
                    return ctrl_modal;
                } else {
                    ctrl_modal = new Modal({
                        context: this,
                        class: 'modal'
                    });
                    const body = this.body();
                    if (body) {
                        body.add(ctrl_modal);
                    }
                    return ctrl_modal;
                }
            },
            enumerable: true
        });
        let ctrl_overlay;
        Object.defineProperty(this, 'overlay', {
            get() {
                if (ctrl_overlay) {
                    return ctrl_overlay;
                } else {
                    ctrl_overlay = new Control({
                        context: this,
                        class: 'overlay'
                    });
                    const body = this.body();
                    if (body) {
                        body.add(ctrl_overlay);
                        ctrl_overlay.activate();
                    }
                    ctrl_overlay.place = (ctrl, location) => {
                        const sloc = deep_sig(location);
                        let placement_abs_pos;
                        if (sloc === '[s,C]') {
                            const [str_description, ctrl_target] = location;
                            const target_bcr = ctrl_target.bcr();
                            const overlay_bcr = ctrl_overlay.bcr();
                            if (str_description === 'below') {
                                placement_abs_pos = [target_bcr[0][0], target_bcr[1][1]];
                                const overlay_size = overlay_bcr[1];
                                const body_size = body.bcr()[1];
                                const height_left_below_placement = body_size[1] - placement_abs_pos[1];
                                ctrl.pos = placement_abs_pos;
                                ctrl.dom.attributes.style.position = 'absolute';
                                ctrl.dom.attributes.style['max-height'] = height_left_below_placement + 'px';
                            } else {
                                console.trace();
                                throw 'NYI';
                            }
                        }
                        ctrl_overlay.add(ctrl);
                    }
                    return ctrl_overlay;
                }
            },
            enumerable: true
        });
        let frame_num = 0;
        let last_timestamp;
        let was_resized = false;
        this.map_controls_being_removed_in_frame = false;
        this.map_controls_being_added_in_frame = false;
        let map_ctrls_in_last_frame = {};
        let map_ctrls_in_this_frame;
        let count_dom_ctrls = 0;
        const num_data_points_per_ctrl = 32;

        // May want to simplify this in terms of API, make a page or two explaining it, and maybe make it disabled by default
        //.  or used on a lower level only by things that need it.

        // Could see about making use of this for detecing overlaps of siblings in a rectangle that extends from the left of a control.

        // This may be better integrated with some code more specific to geometries.
        //.  Could have some kinds of observers that watch the values that represent the geometries of various controls.



        

        this.on('activate', () => {
            //console.log('activated client page_context.... ***** map_controls', map_controls);
            each(map_controls, (ctrl, jsgui_id) => {
                if (ctrl.dom?.el) {
                    map_ctrls_in_last_frame[jsgui_id] = ctrl;
                    count_dom_ctrls++;
                }
            });
            let ta_last_frame;
            let ta_current_frame_stored;
            let ta_current_frame_for_user;
            let ta_user_frame_changes;
            let map_current_dom_ctrl_iids;
            let map_current_dom_ctrls_by_iid = {};
            const create_controls_number_props_ta = () => {
                const ta_length = num_data_points_per_ctrl * count_dom_ctrls;
                const res = new Float32Array(ta_length);
                const create_map_ctrls_iids = (map_dom_ctrls) => {
                    const keys = Object.keys(map_dom_ctrls);
                    const res = {};
                    each(keys, (jsgui_id, i) => {
                        res[jsgui_id] = i;
                        map_current_dom_ctrls_by_iid[i] = map_dom_ctrls[jsgui_id];
                    })
                    return res;
                }
                map_current_dom_ctrl_iids = create_map_ctrls_iids(map_ctrls_in_last_frame);
                const record_ctrls_info = (map_dom_ctrls, map_dom_ctrl_iids, ta) => {
                    each(map_dom_ctrls, (ctrl, jsgui_id) => {
                        const iid = map_dom_ctrl_iids[jsgui_id];
                        const el = ctrl.dom.el;
                        const bcr = el.getBoundingClientRect();
                        const start_pos = iid * num_data_points_per_ctrl;
                        let wpos = start_pos;
                        ta[wpos++] = bcr.left;
                        ta[wpos++] = bcr.top;
                        ta[wpos++] = bcr.width;
                        ta[wpos++] = bcr.height;
                        ta[wpos++] = bcr.right;
                        ta[wpos++] = bcr.bottom;

                        // t3dx: ta[6]
                        // t3dy: ta[7]
                        // t3dz: ta[8]
                    });
                }
                record_ctrls_info(map_ctrls_in_last_frame, map_current_dom_ctrl_iids, res);
                return res;
            }
            const assign_ctrls_ta_subarrays = (ta_current_frame_for_user, map_dom_controls, map_iids) => {
                each(map_dom_controls, (ctrl, jsgui_id) => {
                    const ctrl_iid = map_iids[jsgui_id];
                    const pos_start = ctrl_iid * num_data_points_per_ctrl;
                    const pos_end = pos_start + num_data_points_per_ctrl;
                    ctrl.ta = ta_current_frame_for_user.subarray(pos_start, pos_end);
                });
            }
            const frame_process = (timestamp) => {
                frame_num++;
                const find_control_numeric_values_changed = () => {
                    let i_ctrl = 0;
                    let pos = 0;
                    const l = ta_current_frame_for_user.length;
                    let has_change;
                    const ta_controls_which_have_changed_iids = new Int8Array(count_dom_ctrls);
                    ta_controls_which_have_changed_iids.fill(-1);
                    let tacwhci_wpos = 0;
                    while (pos < l) {
                        const change = ta_current_frame_for_user[pos] - ta_current_frame_stored[pos];
                        let ctrl_iid = Math.floor(pos / num_data_points_per_ctrl);
                        if (change !== 0) {
                            has_change = true;
                            ta_controls_which_have_changed_iids[tacwhci_wpos++] = ctrl_iid;
                        }
                        ta_user_frame_changes[pos] = change;
                        pos++;
                    }
                    if (has_change) {
                        let c = 0;
                        let l = ta_user_frame_changes.length;
                        let stop = false;
                        while (!stop && c < l) {
                            const ctrl_iid = ta_controls_which_have_changed_iids[c];
                            if (ctrl_iid === -1) {
                                stop = true;
                            } else {
                                const changed_ctrl = map_current_dom_ctrls_by_iid[ctrl_iid];
                                const ta_ctrl_changes = ta_user_frame_changes.subarray(ctrl_iid * num_data_points_per_ctrl, (ctrl_iid + 1) * num_data_points_per_ctrl);
                                const ctrl_ta = changed_ctrl.ta;
                                let i = 0,
                                    l = ctrl_ta.length;
                                let changed_transform = false;
                                for (i = 0; i < l; i++) {
                                    if (ta_ctrl_changes[i] !== 0) {
                                        const new_val = ctrl_ta[i];
                                        const X = 0,
                                            Y = 1,
                                            H = 2,
                                            W = 3,
                                            R = 4,
                                            B = 5,
                                            TX = 6,
                                            TY = 7;
                                        if (i === 1) {
                                        } else if (i === 2) {
                                        } else if (i === 3) {
                                        } else if (i === 4) {
                                        } else if (i === 5) {
                                        } else if (i === 6 || i === 7) {
                                            if (!changed_transform) {
                                                const tx = ctrl_ta[6];
                                                const ty = ctrl_ta[7];
                                                changed_ctrl.dom.attributes.style.transform = 'translate3d(' + tx + 'px, ' + ty + 'px, 0px)';
                                                changed_transform = true;
                                            }
                                        }
                                    }
                                }
                                let w_pos_ctrl = ctrl_iid * num_data_points_per_ctrl;
                                for (let i = 0; i < l; i++) {
                                    ta_current_frame_stored[w_pos_ctrl++] = ctrl_ta[i];
                                }
                            }
                            c++;
                        }
                    }
                }
                if (frame_num > 1) {
                    find_control_numeric_values_changed();
                } else {
                    assign_ctrls_ta_subarrays(ta_current_frame_for_user, map_ctrls_in_last_frame, map_current_dom_ctrl_iids);
                }
                let count_add = 0;
                let count_remove = 0;
                if (frame_num === 1) {} else {
                    map_ctrls_in_this_frame = {};
                }
                if (this.map_controls_being_removed_in_frame) {
                    //console.log('this.map_controls_being_removed_in_frame', this.map_controls_being_removed_in_frame);
                    each(map_ctrls_in_last_frame, (ctrl_in_last_frame, ctrl_id) => {
                        if (!this.map_controls_being_removed_in_frame[ctrl_id]) {
                            map_ctrls_in_this_frame[ctrl_id] = ctrl_in_last_frame;
                        }
                    });
                    count_remove += Object.keys(this.map_controls_being_removed_in_frame).length;
                    this.map_controls_being_removed_in_frame = false;
                } else {
                    map_ctrls_in_this_frame = map_ctrls_in_last_frame;
                }
                if (this.map_controls_being_added_in_frame) {
                    //console.log('this.map_controls_being_added_in_frame', this.map_controls_being_added_in_frame);
                    this.map_controls_being_added_in_frame = false;
                    each(this.map_controls_being_added_in_frame, (ctrl_added, ctrl_id) => {
                        map_ctrls_in_this_frame[ctrl_id] = ctrl_added;
                        count_add++;
                    })
                }
                this.raise('frame', {
                    number: frame_num,
                    timestamp: timestamp,
                    window_was_resized: was_resized,
                    count_ctrls_added: count_add,
                    count_ctrls_removed: count_remove,
                    map_dom_controls: map_ctrls_in_this_frame,
                    count_dom_ctrls: count_dom_ctrls,
                    ta_dom_controls_numeric_values: ta_current_frame_for_user,
                    map_dom_ctrl_iids: map_current_dom_ctrl_iids
                });
                last_timestamp = timestamp;
                window.requestAnimationFrame(frame_process);
                was_resized = false;
                map_ctrls_in_last_frame = map_ctrls_in_this_frame;
            }
            window.requestAnimationFrame(frame_process);
            window.addEventListener('resize', e => {
                was_resized = true;
                this.raise('window-resize', e);
            });
            //console.log('count_dom_ctrls', count_dom_ctrls);
            ta_current_frame_stored = create_controls_number_props_ta();
            //console.log('ta_current_frame_stored.length', ta_current_frame_stored.length);
            ta_current_frame_for_user = new Float32Array(ta_current_frame_stored.length);
            ta_user_frame_changes = new Float32Array(ta_current_frame_stored.length);
            ta_current_frame_for_user.set(ta_current_frame_stored);
        });



        const trial_fns_now_unused = () => {
            const create_dims_from_current_ctrls = this.create_dims_from_current_ctrls = () => {
                const {
                    next_iid
                } = this;
                const ctrl_length = 6;
                const ta_res = new Float32Array(next_iid * ctrl_length);
                let wpos = 0;
                each(map_controls, (ctrl, id) => {
                    const ctrl_iid = ctrl.iid;
                    wpos = ctrl_iid * ctrl_length;
                    if (ctrl.dom && ctrl.dom.el) {
                        const bcr = ctrl.dom.el.getBoundingClientRect();
                        ta_res[wpos++] = bcr.left;
                        ta_res[wpos++] = bcr.top;
                        ta_res[wpos++] = bcr.right;
                        ta_res[wpos++] = bcr.bottom;
                        ta_res[wpos++] = bcr.width;
                        ta_res[wpos++] = bcr.height;
                    }
                });
                return ta_res;
            }
        }
    }
    'get_ctrl_el' (ctrl) {
        return this.map_els[ctrl._id()];
    }
    'register_el' (el) {
        let jsgui_id = el.getAttribute('data-jsgui-id');
        if (jsgui_id) {
            this.map_els[jsgui_id] = el;
        }
    }
    'body' () {
        var doc = this.document;
        var bod = doc.body;
        if (!this._body) {
            var existing_jsgui_id = bod.getAttribute('data-jsgui-id');
            if (!existing_jsgui_id) {
                var ctrl_body = new jsgui.body({
                    'el': document.body,
                    'context': this
                });
                ctrl_body.dom.el.setAttribute('jsgui-id', ctrl_body._id());
                this.register_control(ctrl_body);
                this._body = ctrl_body;
            } else {
                if (this.map_controls[existing_jsgui_id]) {
                    this._body = this.map_controls[existing_jsgui_id];
                }
            }
        } else {
        }
        return this._body;
    }
}
Client_Page_Context.css = `
body .modal {
    position: absolute;
    left: 0px;
    top: 0px;
}
body .overlay {
    position: absolute;
    left: 0px;
    top: 0px;
}
`;
module.exports = Client_Page_Context;
},{"./client-resource-pool":10,"jsgui3-html":154}],192:[function(require,module,exports){
/**
 * Created by James on 09/10/2016.
 */

// But is this part of the html client, or it uses the html client.

// The client has page context.
//  Page context has the resource pool.

// So, client-resource will need html-enh I think, but not the client system.


/*
 define(['../../web/jsgui-html-enh', './resource'],
 function(jsgui, Resource) {
 */


/*
	2018, need to implement / redo some of resources.
	will make them a bit simpler where poss
	have resource publisher middleware on the server

*/

// 2022 - considering putting compilation features into the client.
//  Would need to load in / provide the actual compilation functions.
//   jsgui3-server would load them in for server-side use automatically (a few compilers at least).
//    want to redo the way that jsgui3-server runs its compilers.
//    will be more structured, and less code used in the JavaScript resource.

// Compilers will be integrated at a relatively low level.
//  Having compilers work on the client should be OK.
//  Even compiling compilers in Rust.




// The resource may be a compiler or data transformer.
//  Seems like it's worth doing more on a ll to support that functionality.

// Loading these from Rust / C++ to WASM is part of the issue with compilers.
//  Need server-side compilation for some of it to happen.

// Looks as though variety of compilers only work on the FS.
//  Maybe would need to be adapted to operate in mem / only as function.

// Could use an /out directory.







var jsgui = require('jsgui3-html');

// Could make a separate Data_Resource
//  That Data_Resource would have the API that DR in jsgui3 now has.
//   Will use self-logging and observable / observable-like functionality for monitoring it within the app
//   Will have a fairly general and specified get / set pattern
//    Things will work in a generally restful way.
//    Could look into graphql
//     Maybe would need to be graphql resource.




var Resource = jsgui.Resource;

const fnl = require('fnl');
const prom_or_cb = fnl.prom_or_cb;

var stringify = jsgui.stringify,
	each = jsgui.each,
	arrayify = jsgui.arrayify,
	tof = jsgui.tof;


const get_a_sig = jsgui.get_a_sig;

var filter_map_by_regex = jsgui.filter_map_by_regex;
var Class = jsgui.Class,
	Data_Object = jsgui.Data_Object,
	Enhanced_Data_Object = jsgui.Enhanced_Data_Object;
var fp = jsgui.fp,
	is_defined = jsgui.is_defined;
var Collection = jsgui.Collection;

// Extends AutoStart_Resource?

// May need to change around a fair few references to make it workable.
// May need some more complicated logic to change it to the path for service.

// There can be a client app that's specifically for a resource.
//  That's a special case.
// Other client side apps will access multiple resources.
//  They can do this through a Resource_Pool.
//  There could be client-side resources that make use of information sharing between these client and server side resources.

// This client resource could reference a remote resource.

// Will have client-remote-reference resource
//  maybe just client-remote
//  will work in a similar way to remote or node-remote in terms of API, but internally it will do HTTP calls differently.
//  Possibly could just use jsgui though, have it expose the same API for node and the client.

// This one is still fairly abstract.
//  It will be the client-remote-link resource which will have the functionality.
//  client-remote-link will connect with websockets to get events
//  it will do get with http.


// A resource control will recieve events from the client resource.
//  It may also ensure it has been set up.

// Also a Resource_Client file that sets up a resource connection with a particular resource?
//  Maybe don't set up such abstract resource linking for the moment?

// With the Resource-Client architure, we could define the back-end in terms of a Resource, and not need to write various pieces of boilerplate for them
//  to communicate with each other.

// Resource_Client may be a necessary JS file.
//  Would be JavaScript that runs on a page that's for when it's the client for a single resource?

// With the clock resource, would want it to have a resource control.
//  That control could possibly speak to the resource directly.
//  It could possibly speak to a client-side resource / aggregator that then speaks to the server resource.

// Serving a page with a component that connects back to the resource...
//  I think a lot of the activity will be in the user control,
//  however, it may be that the user control will just be making use of the client-side resources or client-side resource pool.

var ends_with = function (str, suffix) {
	return str.indexOf(suffix, str.length - suffix.length) !== -1;
}

// Should code in a way that allows for a (local) data transformation resource.

// resource location:
//  server (remote, needs HTTP requests)
//  local
//   within the app, available through js
//   available through a port / ports.

// The resource could be available as a local function.

// server
// local-fn

// Client_Resource_Referencing_Server
// Client_Resource_Referencing_Local

// Need to enable usage of client-side data transformation resources.
// As well as allow for their use and integration more generally into the jsgui3 system.

// Client_Resource_Referencing_Server_JSON
// Client_Resource__Server_JSON
// Client_Resource__Client_Transform_Function
//  Some functions to transform bmp <> jpeg could be in this category.


// Should not use / need Data_Object.
//  Though could improve and document Data_Object.

// May be better using observable pattern?

// A data transformation resource system for filling out HTML templates.
// Could introduce RSX at this point too.

// It maybe won't be at a URL.
//  Just needs to be available within client-side JS.

// HTTP_Resource or HTTP_Client_Resource



class Client_Resource extends Resource {
	//'fields': {
	//	'url': String
	//},
	// Subscribe?

	// Should likely work more like an observable.
	//  At least it extends evented_class

	constructor(spec = {}) {
		//this._super(spec);
		//spec = spec || {};
		super(spec);
		if (spec.meta) {
			var meta = spec.meta;
			//console.log('1) meta.url', meta.url);
			if (meta.url) this.meta.set('url', meta.url);
			if (meta.type_levels) this.meta.set('type_levels', meta.type_levels);
			//console.log('meta.name ' + meta.name);
		}

		// The data resource won't hold the data itself.
		//  (usually)
		//  It will download the data unless it's cached.

		// Will connect to the more customised server data resource.
		//  This is the interface between the client's data and the server.

		this.data = new Data_Object();
		// Not necessarily?

		//var that = this;
		// both in one parameter here?
		// Why not listen to the resource's data directly?
		//  Should not be a problem when doing it on the client?

		this.data.on('change', (property_name, property_value) => {
			//console.log('');
			//console.log('resource data change property_name', property_name);
			//console.log('property_value', property_value);
			this.trigger('change', property_name, property_value);
		});
	}

	// Set as well?

	'get' (path, callback) {
		return prom_or_cb((resolve, reject) => {
			//console.log('path', path);

			let ends_dot_json = ends_with(path, '.json');
			//console.log('ends_dot_json', ends_dot_json);
			let json_url;
			if (!ends_dot_json) {
				json_url = path + '.json';
			} else {
				json_url = path;
			}
			//console.log('this (Resource)', this);
			json_url = 'resources/' + this.name + '/' + json_url;
			//json_url = ''
			//console.log('json_url', json_url);
			jsgui.http(json_url, function (err, res) {
				if (err) {
					//callback(err);
					reject(err);
				} else {
					resolve(res);
				}
			})
		}, callback);
	}

	get status() {
		return (async () => {
			let res = await jsgui.http('/resources/' + this.name + '/status.json');
			return res;
		})();
	}
	// We don't notify it this way.
	//  Thinking of making a serparate Resource that uses websockets or sockjs. Should continue to have the normal non-sock client-side resource as well.
	///  Will not make its own HTTP connections.

	// Not that clear how this type of resource will receive these change notifications.
	//  Seems less likely that we will need this function here.
	//  06/06/2015 - about to make the socks resource connection for the client, it's going to allow for real-time updates, while using generally RESTful addressing.

	'notify_change_from_server' (property_name, property_value) {
		// needs to do some kind of silent set.
		//console.log('client resource notify_change_from_server');
		var data = this.data;
		this.data._[property_name] = property_value;

		this.data.trigger('change', property_name, property_value);
		// Or the resource listens to data changes, triggers change on itself when the data changes.
		// Or change on the resource itself I think.
	}
}

module.exports = Client_Resource;
},{"fnl":6,"jsgui3-html":154}],193:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"dup":12}],194:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13}],195:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"./convolution-kernels/kernels":194,"./pixel-buffer":209,"./pixel-buffer-painter":208,"./pixel-pos-list":210,"./shapes/Rectangle":214,"./ta-math":219,"dup":14}],196:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./Typed_Array_Binary_Read_Write":193,"./pixel-pos-list":210,"./ta-math":219,"buffer":3,"dup":15,"lang-mini":228,"obext":382}],197:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./Typed_Array_Binary_Read_Write":193,"./pixel-buffer-0-core-inner-structures":196,"./pixel-buffer-painter":208,"./pixel-pos-list":210,"./ta-math":219,"dup":16,"lang-mini":228,"obext":382}],198:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./Typed_Array_Binary_Read_Write":193,"./pixel-buffer-1-core-get-set-pixel":197,"./pixel-buffer-painter":208,"./pixel-pos-list":210,"./ta-math":219,"dup":17,"lang-mini":228,"obext":382}],199:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"./pixel-buffer-1.1-core-draw-line":198,"./shapes/Polygon":211,"./shapes/Polygon_Scanline_Edges":213,"./shapes/ScanlineProcessor":215,"./ta-math":219,"dup":18}],200:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"./pixel-buffer-1.2-core-draw-polygon":199,"./shapes/Polygon_Scanline_Edges":213,"./shapes/ScanlineProcessor":215,"dup":19}],201:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"./Typed_Array_Binary_Read_Write":193,"./pixel-buffer-1.5-core-mask":200,"./pixel-buffer-painter":208,"./pixel-pos-list":210,"./ta-math":219,"dup":20,"lang-mini":228,"obext":382}],202:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"./Typed_Array_Binary_Read_Write":193,"./pixel-buffer-2-core-reference-implementations":201,"./pixel-buffer-painter":208,"./pixel-pos-list":210,"./ta-math":219,"dup":21,"lang-mini":228,"obext":382}],203:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"./pixel-buffer-3-core":202,"dup":22,"lang-mini":228,"obext":382}],204:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./convolution-kernels/kernels":194,"./pixel-buffer-4-advanced-typedarray-properties":203,"dup":23}],205:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"./pixel-buffer-5-idiomatic-enh":204,"./pixel-pos-list":210,"dup":24}],206:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"./pixel-buffer-6-perf-focus-enh":205,"./ta-math":219,"dup":25}],207:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./pixel-buffer-7-specialised-enh":206,"dup":26}],208:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./ta-math":219,"dup":27}],209:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"./pixel-buffer-8-enh":207,"dup":28}],210:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],211:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"../ta-math":219,"./Polygon_Scanline_Edges":213,"./Rectangle":214,"./Shape":216,"_process":383,"dup":30,"lang-mini":228}],212:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"./TA_Table_8_Columns":217,"./is_debug":218,"dup":31}],213:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"./Polygon_Edges":212,"./is_debug":218,"dup":32}],214:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./Shape":216,"dup":33,"lang-mini":228,"obext":382}],215:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"./is_debug":218,"dup":34}],216:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],217:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"dup":36}],218:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"dup":37}],219:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./ta-math/bitwise":220,"./ta-math/copy":221,"./ta-math/draw":222,"./ta-math/info":223,"./ta-math/read":224,"./ta-math/transform":225,"./ta-math/write":226,"dup":38}],220:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39}],221:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"dup":40}],222:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41}],223:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"dup":42}],224:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43}],225:[function(require,module,exports){
const copy_px_to_ta_dest_byi = (ta_source, source_colorspace, source_xy, ta_dest, byi_dest) => {
    const [width, height, bypp, bypr, bipp, bipr] = source_colorspace;
    if (bipp === 24) {
        let byi_read = source_xy[0] * bypp + source_xy[1] * bypr;
        ta_dest[byi_dest] = ta_source[byi_read++];
        ta_dest[byi_dest + 1] = ta_source[byi_read++];
        ta_dest[byi_dest + 2] = ta_source[byi_read++];
    } else {
        console.trace();
        throw 'NYI';
    }
}
const each_pixel_in_colorspace = (colorspace, callback) => {
    const [width, height, bypp, bypr, bipp, bipr] = colorspace;
    let byi = 0;
    const xy = new Int16Array(2);
    for (xy[1] = 0; xy[1] < height; xy[1]++) {
        for (xy[0] = 0; xy[0] < width; xy[0]++) {
            callback(xy, byi);
            byi += bypp;
        }
    }
}
const __each_source_dest_pixels_resized = (source_colorspace, dest_size, callback) => {
    const [width, height, bypp, bypr, bipp, bipr] = source_colorspace;
    const dest_colorspace = new Int32Array([dest_size[0], dest_size[1], bypp, bypp * dest_size[0], bipp, bipp * dest_size[0]]);
    const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
    const source_fbounds = new Float32Array(4);
    const source_ibounds = new Int16Array(4);
    const source_i_any_coverage_size = new Int16Array(2);
    const source_total_coverage_ibounds = new Int16Array(4);
    let byi_read;
    each_pixel_in_colorspace(dest_colorspace, (dest_xy, dest_byi) => {
        source_fbounds[0] = dest_xy[0] * dest_to_source_ratio[0];
        source_fbounds[1] = dest_xy[1] * dest_to_source_ratio[1];
        source_fbounds[2] = source_fbounds[0] + dest_to_source_ratio[0];
        source_fbounds[3] = source_fbounds[1] + dest_to_source_ratio[1];
        source_ibounds[0] = source_fbounds[0];
        source_ibounds[1] = source_fbounds[1];
        source_ibounds[2] = Math.ceil(source_fbounds[2]);
        source_ibounds[3] = Math.ceil(source_fbounds[3]);
        source_i_any_coverage_size[0] = source_ibounds[2] - source_ibounds[0];
        source_i_any_coverage_size[1] = source_ibounds[3] - source_ibounds[1];
        byi_read = source_ibounds[0] * bypp + source_ibounds[1] * bypr;
        source_total_coverage_ibounds[0] = Math.ceil(source_fbounds[0]);
        source_total_coverage_ibounds[1] = Math.ceil(source_fbounds[1]);
        source_total_coverage_ibounds[2] = source_fbounds[2];
        source_total_coverage_ibounds[3] = source_fbounds[3];
        callback(dest_xy, dest_byi, source_fbounds, source_ibounds, source_i_any_coverage_size, source_total_coverage_ibounds, byi_read);
    });
}
const each_source_dest_pixels_resized_inline = (source_colorspace, dest_size, callback) => {
    let [width, height, bypp, bypr, bipp, bipr] = source_colorspace;
    const source_bypr = bypr;
    const dest_colorspace = new Int32Array([dest_size[0], dest_size[1], bypp, bypp * dest_size[0], bipp, bipp * dest_size[0]]);
    const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
    const source_fbounds = new Float32Array(4);
    const source_ibounds = new Int16Array(4);
    const source_i_any_coverage_size = new Int16Array(2);
    const source_total_coverage_ibounds = new Int16Array(4);
    let byi_read = 0;
    let dest_byi = 0;
    const dest_xy = new Int16Array(2);
    [width, height, bypp, bypr, bipp, bipr] = dest_colorspace;
    const _x_source_fbounds0 = new Float32Array(width);
    const _x_source_fbounds2 = new Float32Array(width);
    const _x_source_ibounds0 = new Int16Array(width);
    const _x_source_ibounds2 = new Int16Array(width);
    const _x_source_i_any_coverage_size = new Int16Array(width);
    const _x_source_i_total_coverage_l = new Int16Array(width);
    const _x_source_i_total_coverage_r = new Int16Array(width);
    const _x_byi_read = new Int32Array(width);
    for (dest_xy[0] = 0; dest_xy[0] < width; dest_xy[0]++) {
        _x_source_fbounds0[dest_xy[0]] = dest_xy[0] * dest_to_source_ratio[0];
        _x_source_fbounds2[dest_xy[0]] = _x_source_fbounds0[dest_xy[0]] + dest_to_source_ratio[0];
        _x_source_ibounds0[dest_xy[0]] = _x_source_fbounds0[dest_xy[0]];
        _x_source_ibounds2[dest_xy[0]] = Math.ceil(_x_source_fbounds2[dest_xy[0]]);
        _x_source_i_any_coverage_size[dest_xy[0]] = _x_source_ibounds2[dest_xy[0]] - _x_source_ibounds0[dest_xy[0]];
        _x_byi_read[dest_xy[0]] = _x_source_ibounds0[dest_xy[0]] * bypp;
        _x_source_i_total_coverage_l[dest_xy[0]] = Math.ceil(_x_source_fbounds0[dest_xy[0]]);
        _x_source_i_total_coverage_r[dest_xy[0]] = Math.floor(_x_source_fbounds2[dest_xy[0]]);
    }
    let row_byi;
    for (dest_xy[1] = 0; dest_xy[1] < height; dest_xy[1]++) {
        source_fbounds[1] = dest_xy[1] * dest_to_source_ratio[1];
        source_ibounds[1] = source_fbounds[1];
        source_fbounds[3] = source_fbounds[1] + dest_to_source_ratio[1];
        source_ibounds[3] = Math.ceil(source_fbounds[3]);
        source_i_any_coverage_size[1] = source_ibounds[3] - source_ibounds[1];
        source_total_coverage_ibounds[1] = Math.ceil(source_fbounds[1]);
        source_total_coverage_ibounds[3] = source_fbounds[3];
        row_byi = source_ibounds[1] * source_bypr;
        for (dest_xy[0] = 0; dest_xy[0] < width; dest_xy[0]++) {
            source_fbounds[0] = _x_source_fbounds0[dest_xy[0]];
            source_fbounds[2] = _x_source_fbounds2[dest_xy[0]];
            source_ibounds[0] = _x_source_ibounds0[dest_xy[0]];
            source_ibounds[2] = _x_source_ibounds2[dest_xy[0]];
            source_i_any_coverage_size[0] = _x_source_i_any_coverage_size[dest_xy[0]];
            byi_read = _x_byi_read[dest_xy[0]] + row_byi;
            source_total_coverage_ibounds[0] = _x_source_i_total_coverage_l[dest_xy[0]];
            source_total_coverage_ibounds[2] = _x_source_i_total_coverage_r[dest_xy[0]];
            callback(dest_xy, dest_byi, source_fbounds, source_ibounds, source_i_any_coverage_size, source_total_coverage_ibounds, byi_read);
            dest_byi += bypp;
        }
    }
}
const each_source_dest_pixels_resized = each_source_dest_pixels_resized_inline;
const __each_source_dest_pixels_resized_limited_further_info = (source_colorspace, dest_size, callback) => {
    const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
    const source_edge_distances = new Float32Array(4);
    const edge_distances_proportions_of_total = new Float32Array(4);
    const edge_segment_areas_proportion_of_total_area = new Float32Array(4);
    const corner_areas_proportions_of_total = new Float32Array(4);
    const fpx_area = dest_to_source_ratio[0] * dest_to_source_ratio[1];
    each_source_dest_pixels_resized(source_colorspace, dest_size, (dest_xy, dest_byi, source_fbounds, source_ibounds, source_i_any_coverage_size, source_total_coverage_ibounds, byi_read) => {
        if (source_i_any_coverage_size[0] === 1 && source_i_any_coverage_size[1] === 1) {
            callback(dest_byi, source_i_any_coverage_size, undefined, undefined, byi_read);
        } else if (source_i_any_coverage_size[0] === 1 && source_i_any_coverage_size[1] === 2) {
            source_edge_distances[1] = source_total_coverage_ibounds[1] - source_fbounds[1];
            source_edge_distances[3] = source_fbounds[3] - source_total_coverage_ibounds[3];
            if (source_edge_distances[1] === 0) source_edge_distances[1] = 1;
            if (source_edge_distances[3] === 0) source_edge_distances[3] = 1;
            edge_distances_proportions_of_total[1] = source_edge_distances[1] / dest_to_source_ratio[1];
            edge_distances_proportions_of_total[3] = source_edge_distances[3] / dest_to_source_ratio[1];
            callback(dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, undefined, byi_read);
        } else if (source_i_any_coverage_size[0] === 2 && source_i_any_coverage_size[1] === 1) {
            source_edge_distances[0] = source_total_coverage_ibounds[0] - source_fbounds[0];
            source_edge_distances[2] = source_fbounds[2] - source_total_coverage_ibounds[2];
            if (source_edge_distances[0] === 0) source_edge_distances[0] = 1;
            if (source_edge_distances[2] === 0) source_edge_distances[2] = 1;
            edge_distances_proportions_of_total[0] = source_edge_distances[0] / dest_to_source_ratio[0];
            edge_distances_proportions_of_total[2] = source_edge_distances[2] / dest_to_source_ratio[0];
            callback(dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, undefined, byi_read);
        } else if (source_i_any_coverage_size[0] === 2 && source_i_any_coverage_size[1] === 2) {
            source_edge_distances[0] = source_total_coverage_ibounds[0] - source_fbounds[0];
            source_edge_distances[1] = source_total_coverage_ibounds[1] - source_fbounds[1];
            source_edge_distances[2] = source_fbounds[2] - source_total_coverage_ibounds[2];
            source_edge_distances[3] = source_fbounds[3] - source_total_coverage_ibounds[3];
            if (source_edge_distances[0] === 0) source_edge_distances[0] = 1;
            if (source_edge_distances[1] === 0) source_edge_distances[1] = 1;
            if (source_edge_distances[2] === 0) source_edge_distances[2] = 1;
            if (source_edge_distances[3] === 0) source_edge_distances[3] = 1;
            corner_areas_proportions_of_total[0] = source_edge_distances[0] * source_edge_distances[1] / fpx_area;
            corner_areas_proportions_of_total[1] = source_edge_distances[2] * source_edge_distances[1] / fpx_area;
            corner_areas_proportions_of_total[2] = source_edge_distances[0] * source_edge_distances[3] / fpx_area;
            corner_areas_proportions_of_total[3] = source_edge_distances[2] * source_edge_distances[3] / fpx_area;
            callback(dest_byi, source_i_any_coverage_size, undefined, corner_areas_proportions_of_total, byi_read);
        } else {
            source_edge_distances[0] = source_total_coverage_ibounds[0] - source_fbounds[0];
            source_edge_distances[1] = source_total_coverage_ibounds[1] - source_fbounds[1];
            source_edge_distances[2] = source_fbounds[2] - source_total_coverage_ibounds[2];
            source_edge_distances[3] = source_fbounds[3] - source_total_coverage_ibounds[3];
            if (source_edge_distances[0] === 0) source_edge_distances[0] = 1;
            if (source_edge_distances[1] === 0) source_edge_distances[1] = 1;
            if (source_edge_distances[2] === 0) source_edge_distances[2] = 1;
            if (source_edge_distances[3] === 0) source_edge_distances[3] = 1;
            edge_distances_proportions_of_total[0] = source_edge_distances[0] / fpx_area;
            edge_distances_proportions_of_total[1] = source_edge_distances[1] / fpx_area;
            edge_distances_proportions_of_total[2] = source_edge_distances[2] / fpx_area;
            edge_distances_proportions_of_total[3] = source_edge_distances[3] / fpx_area;
            edge_segment_areas_proportion_of_total_area[0] = source_edge_distances[0] * source_edge_distances[1] / fpx_area;
            edge_segment_areas_proportion_of_total_area[1] = source_edge_distances[2] * source_edge_distances[1] / fpx_area;
            edge_segment_areas_proportion_of_total_area[2] = source_edge_distances[0] * source_edge_distances[3] / fpx_area;
            edge_segment_areas_proportion_of_total_area[3] = source_edge_distances[2] * source_edge_distances[3] / fpx_area;
            callback(dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, edge_segment_areas_proportion_of_total_area, byi_read);
        }
    });
}
const each_source_dest_pixels_resized_limited_further_info$inline = (source_colorspace, dest_size, callback) => {
    const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
    const source_edge_distances = new Float32Array(4);
    const edge_distances_proportions_of_total = new Float32Array(4);
    const corner_areas_proportions_of_total = new Float32Array(4);
    const fpx_area = dest_to_source_ratio[0] * dest_to_source_ratio[1];
    let [width, height, bypp, bypr, bipp, bipr] = source_colorspace;
    const source_bypr = bypr;
    const dest_colorspace = new Int32Array([dest_size[0], dest_size[1], bypp, bypp * dest_size[0], bipp, bipp * dest_size[0]]);
    const source_fbounds = new Float32Array(4);
    const source_ibounds = new Int16Array(4);
    const source_i_any_coverage_size = new Int16Array(2);
    const source_total_coverage_ibounds = new Int16Array(4);
    let byi_read;
    let dest_byi = 0;
    [width, height, bypp, bypr, bipp, bipr] = dest_colorspace;
    let x, y;
    for (y = 0; y < height; y++) {
        source_fbounds[1] = y * dest_to_source_ratio[1];
        source_fbounds[3] = source_fbounds[1] + dest_to_source_ratio[1];
        source_ibounds[1] = source_fbounds[1];
        source_ibounds[3] = Math.ceil(source_fbounds[3]);
        source_i_any_coverage_size[1] = source_ibounds[3] - source_ibounds[1];
        source_total_coverage_ibounds[1] = Math.ceil(source_fbounds[1]);
        source_total_coverage_ibounds[3] = source_fbounds[3];
        source_edge_distances[1] = source_total_coverage_ibounds[1] - source_fbounds[1];
        source_edge_distances[3] = source_fbounds[3] - source_total_coverage_ibounds[3];
        if (source_edge_distances[1] === 0) source_edge_distances[1] = 1;
        if (source_edge_distances[3] === 0) source_edge_distances[3] = 1;
        edge_distances_proportions_of_total[1] = source_edge_distances[1] / fpx_area;
        edge_distances_proportions_of_total[3] = source_edge_distances[3] / fpx_area;
        for (x = 0; x < width; x++) {
            source_fbounds[0] = x * dest_to_source_ratio[0];
            source_fbounds[2] = source_fbounds[0] + dest_to_source_ratio[0];
            source_ibounds[0] = source_fbounds[0];
            source_ibounds[2] = Math.ceil(source_fbounds[2]);
            source_i_any_coverage_size[0] = source_ibounds[2] - source_ibounds[0];
            byi_read = source_ibounds[0] * bypp + source_ibounds[1] * source_bypr;
            if (source_i_any_coverage_size[0] === 1 && source_i_any_coverage_size[1] === 1) {
                callback(dest_byi, source_i_any_coverage_size, undefined, undefined, byi_read);
            } else {
                source_total_coverage_ibounds[0] = Math.ceil(source_fbounds[0]);
                source_total_coverage_ibounds[2] = source_fbounds[2];
                if (source_i_any_coverage_size[0] === 1 && source_i_any_coverage_size[1] === 2) {
                    callback(dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, undefined, byi_read);
                } else {
                    source_edge_distances[0] = source_total_coverage_ibounds[0] - source_fbounds[0];
                    source_edge_distances[2] = source_fbounds[2] - source_total_coverage_ibounds[2];
                    if (source_edge_distances[0] === 0) source_edge_distances[0] = 1;
                    if (source_edge_distances[2] === 0) source_edge_distances[2] = 1;
                    if (source_i_any_coverage_size[0] === 2 && source_i_any_coverage_size[1] === 1) {
                        edge_distances_proportions_of_total[0] = source_edge_distances[0] / dest_to_source_ratio[0];
                        edge_distances_proportions_of_total[2] = source_edge_distances[2] / dest_to_source_ratio[0];
                        callback(dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, undefined, byi_read);
                    } else if (source_i_any_coverage_size[0] === 2 && source_i_any_coverage_size[1] === 2) {
                        corner_areas_proportions_of_total[0] = source_edge_distances[0] * source_edge_distances[1] / fpx_area;
                        corner_areas_proportions_of_total[1] = source_edge_distances[2] * source_edge_distances[1] / fpx_area;
                        corner_areas_proportions_of_total[2] = source_edge_distances[0] * source_edge_distances[3] / fpx_area;
                        corner_areas_proportions_of_total[3] = source_edge_distances[2] * source_edge_distances[3] / fpx_area;
                        callback(dest_byi, source_i_any_coverage_size, undefined, corner_areas_proportions_of_total, byi_read);
                    } else {
                        edge_distances_proportions_of_total[0] = source_edge_distances[0] / fpx_area;
                        edge_distances_proportions_of_total[2] = source_edge_distances[2] / fpx_area;
                        corner_areas_proportions_of_total[0] = source_edge_distances[0] * source_edge_distances[1] / fpx_area;
                        corner_areas_proportions_of_total[1] = source_edge_distances[2] * source_edge_distances[1] / fpx_area;
                        corner_areas_proportions_of_total[2] = source_edge_distances[0] * source_edge_distances[3] / fpx_area;
                        corner_areas_proportions_of_total[3] = source_edge_distances[2] * source_edge_distances[3] / fpx_area;
                        callback(dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, byi_read);
                    }
                }
            }
            dest_byi += bypp;
        }
    }
}
each_source_dest_pixels_resized_limited_further_info = each_source_dest_pixels_resized_limited_further_info$inline;
const copy_px_24bipp = (ta_source, byi_read, ta_dest, byi_write) => {
    ta_dest[byi_write] = ta_source[byi_read++];
    ta_dest[byi_write + 1] = ta_source[byi_read++];
    ta_dest[byi_write + 2] = ta_source[byi_read++];
}
const read_1x2_weight_write_24bipp = (ta_source, bypr, byi_read, ta_dest, byi_write, weight_t, weight_b) => {
    let byi_read_below = byi_read + bypr;
    ta_dest[byi_write] = weight_t * ta_source[byi_read++] + weight_b * ta_source[byi_read_below++];
    ta_dest[byi_write + 1] = weight_t * ta_source[byi_read++] + weight_b * ta_source[byi_read_below++];
    ta_dest[byi_write + 2] = weight_t * ta_source[byi_read++] + weight_b * ta_source[byi_read_below++];
}
const read_1x2_weight_write_24bipp$ta4byis = (ta_source, ta4byis, ta_dest, byi_write, weight_t, weight_b) => {
    ta_dest[byi_write] = weight_t * ta_source[ta4byis[0]++] + weight_b * ta_source[ta4byis[2]++];
    ta_dest[byi_write + 1] = weight_t * ta_source[ta4byis[0]++] + weight_b * ta_source[ta4byis[2]++];
    ta_dest[byi_write + 2] = weight_t * ta_source[ta4byis[0]++] + weight_b * ta_source[ta4byis[2]++];
}
const read_2x1_weight_write_24bipp = (ta_source, byi_read, ta_dest, byi_write, weight_l, weight_r) => {
    let byi_read_right = byi_read + 3;
    ta_dest[byi_write] = weight_l * ta_source[byi_read++] + weight_r * ta_source[byi_read_right++];
    ta_dest[byi_write + 1] = weight_l * ta_source[byi_read++] + weight_r * ta_source[byi_read_right++];
    ta_dest[byi_write + 2] = weight_l * ta_source[byi_read++] + weight_r * ta_source[byi_read_right++];
}
const read_2x1_weight_write_24bipp$ta4byis = (ta_source, ta4byis, ta_dest, byi_write, weight_l, weight_r) => {
    ta_dest[byi_write] = weight_l * ta_source[ta4byis[0]++] + weight_r * ta_source[ta4byis[1]++];
    ta_dest[byi_write + 1] = weight_l * ta_source[ta4byis[0]++] + weight_r * ta_source[ta4byis[1]++];
    ta_dest[byi_write + 2] = weight_l * ta_source[ta4byis[0]++] + weight_r * ta_source[ta4byis[1]++];
}
const read_2x2_weight_write_24bipp = (ta_source, bypr, byi_read, ta_dest, byi_write, corner_weights_ltrb) => {
    let byi_read_right = byi_read + 3;
    let byi_read_below = byi_read + bypr;
    let byi_read_below_right = byi_read_below + 3;
    ta_dest[byi_write] = corner_weights_ltrb[0] * ta_source[byi_read++] + corner_weights_ltrb[1] * ta_source[byi_read_right++] + corner_weights_ltrb[2] * ta_source[byi_read_below++] + corner_weights_ltrb[3] * ta_source[byi_read_below_right++];
    ta_dest[byi_write + 1] = corner_weights_ltrb[0] * ta_source[byi_read++] + corner_weights_ltrb[1] * ta_source[byi_read_right++] + corner_weights_ltrb[2] * ta_source[byi_read_below++] + corner_weights_ltrb[3] * ta_source[byi_read_below_right++];
    ta_dest[byi_write + 2] = corner_weights_ltrb[0] * ta_source[byi_read++] + corner_weights_ltrb[1] * ta_source[byi_read_right++] + corner_weights_ltrb[2] * ta_source[byi_read_below++] + corner_weights_ltrb[3] * ta_source[byi_read_below_right++];
}
const read_2x2_weight_write_24bipp$locals = (ta_source, source_bypr, byi_read, 
    corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br,                    
    ta_dest, byi_write) => {
    let byi_read_right = byi_read + 3;
    let byi_read_below = byi_read + source_bypr;
    let byi_read_below_right = byi_read_below + 3;
    ta_dest[byi_write] = corner_p_tl * ta_source[byi_read++] + corner_p_tr * ta_source[byi_read_right++] + corner_p_bl * ta_source[byi_read_below++] + corner_p_br * ta_source[byi_read_below_right++];
    ta_dest[byi_write + 1] = corner_p_tl * ta_source[byi_read++] + corner_p_tr * ta_source[byi_read_right++] + corner_p_bl * ta_source[byi_read_below++] + corner_p_br * ta_source[byi_read_below_right++];
    ta_dest[byi_write + 2] = corner_p_tl * ta_source[byi_read++] + corner_p_tr * ta_source[byi_read_right++] + corner_p_bl * ta_source[byi_read_below++] + corner_p_br * ta_source[byi_read_below_right++];
}
const read_2x2_weight_write_24bipp$ta4byis = (ta_source, ta4byis, ta_dest, byi_write, corner_weights_ltrb) => {
    ta_dest[byi_write] = corner_weights_ltrb[0] * ta_source[ta4byis[0]++] + corner_weights_ltrb[1] * ta_source[ta4byis[1]++] + corner_weights_ltrb[2] * ta_source[ta4byis[2]++] + corner_weights_ltrb[3] * ta_source[ta4byis[3]++];
    ta_dest[byi_write + 1] = corner_weights_ltrb[0] * ta_source[ta4byis[0]++] + corner_weights_ltrb[1] * ta_source[ta4byis[1]++] + corner_weights_ltrb[2] * ta_source[ta4byis[2]++] + corner_weights_ltrb[3] * ta_source[ta4byis[3]++];
    ta_dest[byi_write + 2] = corner_weights_ltrb[0] * ta_source[ta4byis[0]++] + corner_weights_ltrb[1] * ta_source[ta4byis[1]++] + corner_weights_ltrb[2] * ta_source[ta4byis[2]++] + corner_weights_ltrb[3] * ta_source[ta4byis[3]++];
}
const read_2x2_weight_write_24bipp$2_weight_ints = (ta_source, bypr, byi_read, ta_dest, byi_write, ta_lt_props) => {
    const tl = l_prop * t_prop;
    const tr = (1 - l_prop) * t_prop;
    const bl = l_prop * (1 - t_prop);
    const br = (1 - l_prop) * (1 - t_prop);
    let byi_read_right = byi_read + 3;
    let byi_read_below = byi_read + bypr;
    let byi_read_below_right = byi_read_below + 3;
    ta_dest[byi_write] = l_prop * t_prop * ta_source[byi_read++] + (1 - l_prop) * t_prop * ta_source[byi_read_right++] + l_prop * (1 - t_prop) * ta_source[byi_read_below++] + (1 - l_prop) * (1 - t_prop) * ta_source[byi_read_below_right++];
    ta_dest[byi_write + 1] = l_prop * t_prop * ta_source[byi_read++] + (1 - l_prop) * t_prop * ta_source[byi_read_right++] + l_prop * (1 - t_prop) * ta_source[byi_read_below++] + (1 - l_prop) * (1 - t_prop) * ta_source[byi_read_below_right++];
    ta_dest[byi_write + 2] = l_prop * t_prop * ta_source[byi_read++] + (1 - l_prop) * t_prop * ta_source[byi_read_right++] + l_prop * (1 - t_prop) * ta_source[byi_read_below++] + (1 - l_prop) * (1 - t_prop) * ta_source[byi_read_below_right++];
}
const read_3x2_weight_write_24bipp = (ta_source, bypr, byi_read, edge_distances_proportions_of_total, corner_weights_ltrb, ta_dest, dest_byi) => {
    const bypp = 3;
    let byi_tl = byi_read;
    let byi_tm = byi_tl + bypp, byi_tr = byi_tm + bypp;
    let byi_bl = byi_tm + bypr, byi_bm = byi_bl + bypp, byi_br = byi_bm + bypp;
    ta_dest[dest_byi] =     ta_source[byi_tl++] * corner_weights_ltrb[0] + ta_source[byi_tm++] * edge_distances_proportions_of_total[1] + ta_source[byi_tr++] * corner_weights_ltrb[1] +
                            ta_source[byi_bl++] * corner_weights_ltrb[2] + ta_source[byi_bm++] * edge_distances_proportions_of_total[3] + ta_source[byi_br++] * corner_weights_ltrb[3];
    ta_dest[dest_byi + 1] = ta_source[byi_tl++] * corner_weights_ltrb[0] + ta_source[byi_tm++] * edge_distances_proportions_of_total[1] + ta_source[byi_tr++] * corner_weights_ltrb[1] +
                            ta_source[byi_bl++] * corner_weights_ltrb[2] + ta_source[byi_bm++] * edge_distances_proportions_of_total[3] + ta_source[byi_br++] * corner_weights_ltrb[3];
    ta_dest[dest_byi + 2] = ta_source[byi_tl++] * corner_weights_ltrb[0] + ta_source[byi_tm++] * edge_distances_proportions_of_total[1] + ta_source[byi_tr++] * corner_weights_ltrb[1] +
                            ta_source[byi_bl++] * corner_weights_ltrb[2] + ta_source[byi_bm++] * edge_distances_proportions_of_total[3] + ta_source[byi_br++] * corner_weights_ltrb[3];
}
const read_3x2_weight_write_24bipp$locals = (ta_source, bypr, byi_read, 
    edge_p_l, edge_p_t, edge_p_r, edge_p_b, 
    corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br,
    ta_dest, dest_byi) => {
    const bypp = 3;
    let byi_tl = byi_read;
    let byi_tm = byi_tl + bypp, byi_tr = byi_tm + bypp;
    let byi_bl = byi_tm + bypr, byi_bm = byi_bl + bypp, byi_br = byi_bm + bypp;
    ta_dest[dest_byi] =     ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br;
    ta_dest[dest_byi + 1] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br;
    ta_dest[dest_byi + 2] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br;
}
const read_2x3_weight_write_24bipp = (ta_source, bypr, byi_read, edge_distances_proportions_of_total, corner_weights_ltrb, ta_dest, dest_byi) => {
    const bypp = 3;
    let byi_tl = byi_read, byi_tr = byi_tl + bypp;
    let byi_ml = byi_tl + bypr, byi_mr = byi_ml + bypp;
    let byi_bl = byi_ml + bypr, byi_br = byi_bl + bypp;
    ta_dest[dest_byi] =     ta_source[byi_tl++] * corner_weights_ltrb[0] + ta_source[byi_tr++] * corner_weights_ltrb[1] +
                            ta_source[byi_ml++] * edge_distances_proportions_of_total[0] + ta_source[byi_mr++] * edge_distances_proportions_of_total[2] +
                            ta_source[byi_bl++] * corner_weights_ltrb[2] + ta_source[byi_br++] * corner_weights_ltrb[3]
    ta_dest[dest_byi + 1] = ta_source[byi_tl++] * corner_weights_ltrb[0] + ta_source[byi_tr++] * corner_weights_ltrb[1] +
                            ta_source[byi_ml++] * edge_distances_proportions_of_total[0] + ta_source[byi_mr++] * edge_distances_proportions_of_total[2] +
                            ta_source[byi_bl++] * corner_weights_ltrb[2] + ta_source[byi_br++] * corner_weights_ltrb[3]
    ta_dest[dest_byi + 2] = ta_source[byi_tl++] * corner_weights_ltrb[0] + ta_source[byi_tr++] * corner_weights_ltrb[1] +
                            ta_source[byi_ml++] * edge_distances_proportions_of_total[0] + ta_source[byi_mr++] * edge_distances_proportions_of_total[2] +
                            ta_source[byi_bl++] * corner_weights_ltrb[2] + ta_source[byi_br++] * corner_weights_ltrb[3]
}
const read_2x3_weight_write_24bipp$locals = (ta_source, bypr, byi_read, 
    edge_p_l, edge_p_t, edge_p_r, edge_p_b, 
    corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br,
    ta_dest, dest_byi) => {
    let byi_tl = byi_read, byi_tr = byi_tl + 3;
    let byi_ml = byi_tl + bypr, byi_mr = byi_ml + 3;
    let byi_bl = byi_ml + bypr, byi_br = byi_bl + 3;
    ta_dest[dest_byi] =     ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tr++] * corner_p_tr +
                            ta_source[byi_ml++] * edge_p_l + ta_source[byi_mr++] * edge_p_r +
                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_br++] * corner_p_br
    ta_dest[dest_byi + 1] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tr++] * corner_p_tr +
                            ta_source[byi_ml++] * edge_p_l + ta_source[byi_mr++] * edge_p_r +
                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_br++] * corner_p_br
    ta_dest[dest_byi + 2] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tr++] * corner_p_tr +
                            ta_source[byi_ml++] * edge_p_l + ta_source[byi_mr++] * edge_p_r +
                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_br++] * corner_p_br
}
const read_3x3_weight_write_24bipp = (ta_source, bypr, byi_read, edge_weights, corner_weights_ltrb, fpx_area_recip, ta_dest, dest_byi) => {
    const bypp = 3;
    let byi_tl = byi_read, byi_tm = byi_tl + bypp, byi_tr = byi_tm + bypp;
    let byi_ml = byi_tl + bypr, byi_mm = byi_ml + bypp, byi_mr = byi_mm + bypp;
    let byi_bl = byi_ml + bypr, byi_bm = byi_bl + bypp, byi_br = byi_bm + bypp;
    ta_dest[dest_byi] =     ta_source[byi_tl++] * corner_weights_ltrb[0] + ta_source[byi_tm++] * edge_weights[1] + ta_source[byi_tr++] * corner_weights_ltrb[1] +
                            ta_source[byi_ml++] * edge_weights[0] + ta_source[byi_mm++] * fpx_area_recip + ta_source[byi_mr++] * edge_weights[2] +
                            ta_source[byi_bl++] * corner_weights_ltrb[2] + ta_source[byi_bm++] * edge_weights[3] + ta_source[byi_br++] * corner_weights_ltrb[3]
    ta_dest[dest_byi + 1] = ta_source[byi_tl++] * corner_weights_ltrb[0] + ta_source[byi_tm++] * edge_weights[1] + ta_source[byi_tr++] * corner_weights_ltrb[1] +
                            ta_source[byi_ml++] * edge_weights[0] + ta_source[byi_mm++] * fpx_area_recip + ta_source[byi_mr++] * edge_weights[2] +
                            ta_source[byi_bl++] * corner_weights_ltrb[2] + ta_source[byi_bm++] * edge_weights[3] + ta_source[byi_br++] * corner_weights_ltrb[3]
    ta_dest[dest_byi + 2] = ta_source[byi_tl++] * corner_weights_ltrb[0] + ta_source[byi_tm++] * edge_weights[1] + ta_source[byi_tr++] * corner_weights_ltrb[1] +
                            ta_source[byi_ml++] * edge_weights[0] + ta_source[byi_mm++] * fpx_area_recip + ta_source[byi_mr++] * edge_weights[2] +
                            ta_source[byi_bl++] * corner_weights_ltrb[2] + ta_source[byi_bm++] * edge_weights[3] + ta_source[byi_br++] * corner_weights_ltrb[3]
}
const read_3x3_weight_write_24bipp$locals = (ta_source, bypr, byi_read, 
    edge_p_l, edge_p_t, edge_p_r, edge_p_b, 
    corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br,
    fpx_area_recip, 
    ta_dest, dest_byi) => {
    const bypp = 3;
    let byi_tl = byi_read, byi_tm = byi_tl + bypp, byi_tr = byi_tm + bypp;
    let byi_ml = byi_tl + bypr, byi_mm = byi_ml + bypp, byi_mr = byi_mm + bypp;
    let byi_bl = byi_ml + bypr, byi_bm = byi_bl + bypp, byi_br = byi_bm + bypp;
    ta_dest[dest_byi] =     ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                            ta_source[byi_ml++] * edge_p_l + ta_source[byi_mm++] * fpx_area_recip + ta_source[byi_mr++] * edge_p_r +
                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br
    ta_dest[dest_byi + 1] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                            ta_source[byi_ml++] * edge_p_l + ta_source[byi_mm++] * fpx_area_recip + ta_source[byi_mr++] * edge_p_r +
                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br
    ta_dest[dest_byi + 2] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                            ta_source[byi_ml++] * edge_p_l + ta_source[byi_mm++] * fpx_area_recip + ta_source[byi_mr++] * edge_p_r +
                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br
}
const read_gt3x3_weight_write_24bipp = (ta_source, bypr, byi_read, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_weights_ltrb, fpx_area_recip, ta_dest, dest_byi) => {
    const byi_tl = byi_read;
    let r = 0, g = 0, b = 0;
    let x, y;
    const end_hmiddle = source_i_any_coverage_size[0] - 1, end_vmiddle = source_i_any_coverage_size[1] - 1;
    r += ta_source[byi_read++] * corner_weights_ltrb[0];
    g += ta_source[byi_read++] * corner_weights_ltrb[0];
    b += ta_source[byi_read++] * corner_weights_ltrb[0];
    for (x = 1; x < end_hmiddle; x++) {
        r += ta_source[byi_read++] * edge_distances_proportions_of_total[1];
        g += ta_source[byi_read++] * edge_distances_proportions_of_total[1];
        b += ta_source[byi_read++] * edge_distances_proportions_of_total[1];
    }
    r += ta_source[byi_read++] * corner_weights_ltrb[1];
    g += ta_source[byi_read++] * corner_weights_ltrb[1];
    b += ta_source[byi_read++] * corner_weights_ltrb[1];
    for (y = 1; y < end_vmiddle; y++) {
        byi_read = byi_tl + y * bypr;
        r += ta_source[byi_read++] * edge_distances_proportions_of_total[0];
        g += ta_source[byi_read++] * edge_distances_proportions_of_total[0];
        b += ta_source[byi_read++] * edge_distances_proportions_of_total[0];
        for (x = 1; x < end_hmiddle; x++) {
            r += ta_source[byi_read++] * fpx_area_recip;
            g += ta_source[byi_read++] * fpx_area_recip;
            b += ta_source[byi_read++] * fpx_area_recip;
        }
        r += ta_source[byi_read++] * edge_distances_proportions_of_total[2];
        g += ta_source[byi_read++] * edge_distances_proportions_of_total[2];
        b += ta_source[byi_read++] * edge_distances_proportions_of_total[2];
    }
    byi_read = byi_tl + end_vmiddle * bypr;
    r += ta_source[byi_read++] * corner_weights_ltrb[2];
    g += ta_source[byi_read++] * corner_weights_ltrb[2];
    b += ta_source[byi_read++] * corner_weights_ltrb[2];
    for (x = 1; x < end_hmiddle; x++) {
        r += ta_source[byi_read++] * edge_distances_proportions_of_total[3];
        g += ta_source[byi_read++] * edge_distances_proportions_of_total[3];
        b += ta_source[byi_read++] * edge_distances_proportions_of_total[3];
    }
    r += ta_source[byi_read++] * corner_weights_ltrb[3];
    g += ta_source[byi_read++] * corner_weights_ltrb[3];
    b += ta_source[byi_read++] * corner_weights_ltrb[3];
    ta_dest[dest_byi] = Math.round(r);
    ta_dest[dest_byi + 1] = Math.round(g);
    ta_dest[dest_byi + 2] = Math.round(b);
}
const read_gt3x3_weight_write_24bipp$locals = (ta_source, bypr, byi_read, 
    any_coverage_w, any_coverage_h,
    edge_p_l, edge_p_t, edge_p_r, edge_p_b,
    corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br,
    fpx_area_recip, 
    ta_dest, dest_byi) => {
    const byi_tl = byi_read;
    let r = 0, g = 0, b = 0;
    let x, y;
    const end_hmiddle = any_coverage_w - 1, end_vmiddle = any_coverage_h - 1;
    r += ta_source[byi_read++] * corner_p_tl;
    g += ta_source[byi_read++] * corner_p_tl;
    b += ta_source[byi_read++] * corner_p_tl;
    for (x = 1; x < end_hmiddle; x++) {
        r += ta_source[byi_read++] * edge_p_t;
        g += ta_source[byi_read++] * edge_p_t;
        b += ta_source[byi_read++] * edge_p_t;
    }
    r += ta_source[byi_read++] * corner_p_tr;
    g += ta_source[byi_read++] * corner_p_tr;
    b += ta_source[byi_read++] * corner_p_tr;
    for (y = 1; y < end_vmiddle; y++) {
        byi_read = byi_tl + y * bypr;
        r += ta_source[byi_read++] * edge_p_l;
        g += ta_source[byi_read++] * edge_p_l;
        b += ta_source[byi_read++] * edge_p_l;
        for (x = 1; x < end_hmiddle; x++) {
            r += ta_source[byi_read++] * fpx_area_recip;
            g += ta_source[byi_read++] * fpx_area_recip;
            b += ta_source[byi_read++] * fpx_area_recip;
        }
        r += ta_source[byi_read++] * edge_p_r;
        g += ta_source[byi_read++] * edge_p_r;
        b += ta_source[byi_read++] * edge_p_r;
    }
    byi_read = byi_tl + end_vmiddle * bypr;
    r += ta_source[byi_read++] * corner_p_bl;
    g += ta_source[byi_read++] * corner_p_bl;
    b += ta_source[byi_read++] * corner_p_bl;
    for (x = 1; x < end_hmiddle; x++) {
        r += ta_source[byi_read++] * edge_p_b;
        g += ta_source[byi_read++] * edge_p_b;
        b += ta_source[byi_read++] * edge_p_b;
    }
    r += ta_source[byi_read++] * corner_p_br;
    g += ta_source[byi_read++] * corner_p_br;
    b += ta_source[byi_read++] * corner_p_br;
    ta_dest[dest_byi] = Math.round(r);
    ta_dest[dest_byi + 1] = Math.round(g);
    ta_dest[dest_byi + 2] = Math.round(b);
}
const __resize_ta_colorspace_24bipp$subpixel = (ta_source, source_colorspace, dest_size, ta_dest) => {
    const source_bypp = source_colorspace[2];
    const source_bypr = source_colorspace[3];
    const [f_px_w, f_px_h] = [source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]];
    let f_source_x, f_source_r;
    let i_source_l, i_source_lr_crossover;
    let f_source_y, f_source_b;
    let i_source_t, i_source_tb_crossover;
    let i_dest_x, i_dest_y;
    const ta_left_proportions = new Float32Array(dest_size[0]);
    const ta_top_proportions = new Float32Array(dest_size[1]);
    const ta_source_x = new Int16Array(dest_size[0]);
    const ta_source_y = new Int16Array(dest_size[1]);
    const ta_source_x_byi_component = new Int32Array(dest_size[0]);
    const ta_source_y_byi_component = new Int32Array(dest_size[1]);
    for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
        f_source_x = i_dest_x * f_px_w;
        f_source_r = f_source_x + f_px_w;
        i_source_l = Math.floor(f_source_x);
        i_source_lr_crossover = i_source_l + 1;
        ta_source_x[i_dest_x] = i_source_l;
        ta_source_x_byi_component[i_dest_x] = i_source_l * source_bypp;
        if (f_source_r < i_source_lr_crossover || i_source_l === f_source_x) {
            ta_left_proportions[i_dest_x] = 1;
        } else {
            ta_left_proportions[i_dest_x] = (i_source_lr_crossover - f_source_x) / f_px_w;
        }
    }
    for (i_dest_y = 0; i_dest_y < dest_size[1]; i_dest_y++) {
        f_source_y = i_dest_y * f_px_h;
        f_source_b = f_source_y + f_px_h;
        i_source_t = Math.floor(f_source_y);
        i_source_tb_crossover = i_source_t + 1;
        ta_source_y[i_dest_y] = i_source_t;
        ta_source_y_byi_component[i_dest_y] = i_source_t * source_bypr;
        if (f_source_b < i_source_tb_crossover || i_source_t === f_source_y) {
            ta_top_proportions[i_dest_y] = 1;
        } else {
            ta_top_proportions[i_dest_y] = (i_source_tb_crossover - f_source_y) / f_px_h;
        }
    }
    const ta_ltrb_edge_props = new Float32Array(4);
    let byi_source;
    let byi_write = 0;
    const ta_ltrb_corner_props = new Float32Array(4);
    for (i_dest_y = 0; i_dest_y < dest_size[1]; i_dest_y++) {
        ta_ltrb_edge_props[1] = ta_top_proportions[i_dest_y];
        ta_ltrb_edge_props[3] = 1 - ta_top_proportions[i_dest_y];
        for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
            ta_ltrb_edge_props[0] = ta_left_proportions[i_dest_x];
            ta_ltrb_edge_props[2] = 1 - ta_left_proportions[i_dest_x];
            byi_source = ta_source_x_byi_component[i_dest_x] + ta_source_y_byi_component[i_dest_y];
            if (ta_ltrb_edge_props[0] === 1) {
                if (ta_ltrb_edge_props[1] === 1) {
                    copy_px_24bipp(ta_source, byi_source, ta_dest, byi_write);
                } else {
                    read_1x2_weight_write_24bipp(ta_source, source_bypr, byi_source, ta_dest, byi_write, ta_ltrb_edge_props[1], ta_ltrb_edge_props[3]);
                }
            } else {
                if (ta_ltrb_edge_props[1] === 1) {
                    read_2x1_weight_write_24bipp(ta_source, byi_source, ta_dest, byi_write, ta_ltrb_edge_props[0], ta_ltrb_edge_props[2]);
                } else {
                    ta_ltrb_corner_props[0] = ta_ltrb_edge_props[0] * ta_ltrb_edge_props[1];
                    ta_ltrb_corner_props[1] = ta_ltrb_edge_props[2] * ta_ltrb_edge_props[1];
                    ta_ltrb_corner_props[2] = ta_ltrb_edge_props[0] * ta_ltrb_edge_props[3];
                    ta_ltrb_corner_props[3] = ta_ltrb_edge_props[2] * ta_ltrb_edge_props[3];
                    read_2x2_weight_write_24bipp(ta_source, source_bypr, byi_source, ta_dest, byi_write, ta_ltrb_corner_props);
                }
            }
            byi_write += 3;
        }
    }
}
const resize_ta_colorspace_24bipp$subpixel$inline = (ta_source, source_colorspace, dest_size, ta_dest) => {
    const source_bypp = source_colorspace[2];
    const source_bypr = source_colorspace[3];
    const [f_px_w, f_px_h] = [source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]];
    let f_source_x, f_source_r;
    let i_source_l, i_source_lr_crossover;
    let f_source_y, f_source_b;
    let i_source_t, i_source_tb_crossover;
    let i_dest_x, i_dest_y;
    const ta_left_proportions = new Float32Array(dest_size[0]);
    const ta_top_proportions = new Float32Array(dest_size[1]);
    const ta_source_x_byi_component = new Int32Array(dest_size[0]);
    for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
        f_source_x = i_dest_x * f_px_w;
        f_source_r = f_source_x + f_px_w;
        i_source_l = Math.floor(f_source_x);
        i_source_lr_crossover = i_source_l + 1;
        ta_source_x_byi_component[i_dest_x] = i_source_l * source_bypp;
        if (f_source_r < i_source_lr_crossover || i_source_l === f_source_x) {
            ta_left_proportions[i_dest_x] = 1;
        } else {
            ta_left_proportions[i_dest_x] = (i_source_lr_crossover - f_source_x) / f_px_w;
        }
    }
    let byi_source;
    let byi_write = 0;
    let byi_read_below, byi_read_right, byi_read_below_right;
    let edge_l, edge_t, edge_r;
    let corner_tl, corner_tr, corner_bl, corner_br;
    let y_byi;
    for (i_dest_y = 0; i_dest_y < dest_size[1]; i_dest_y++) {
        f_source_y = i_dest_y * f_px_h;
        f_source_b = f_source_y + f_px_h;
        i_source_t = Math.floor(f_source_y);
        i_source_tb_crossover = i_source_t + 1;
        y_byi = i_source_t * source_bypr;
        if (f_source_b < i_source_tb_crossover || i_source_t === f_source_y) {
            ta_top_proportions[i_dest_y] = 1;
        } else {
            ta_top_proportions[i_dest_y] = (i_source_tb_crossover - f_source_y) / f_px_h;
        }
        edge_t = ta_top_proportions[i_dest_y];
        
        if (edge_t === 1) {

            for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
                edge_l = ta_left_proportions[i_dest_x];
                edge_r = 1 - ta_left_proportions[i_dest_x];
                byi_source = ta_source_x_byi_component[i_dest_x] + y_byi;
                if (edge_l === 1) {
                    ta_dest[byi_write++] = ta_source[byi_source++];
                    ta_dest[byi_write++] = ta_source[byi_source++];
                    ta_dest[byi_write++] = ta_source[byi_source++];
                } else {
                    byi_read_right = byi_source + 3;
                    ta_dest[byi_write++] = edge_l * ta_source[byi_source++] + edge_r * ta_source[byi_read_right++];
                    ta_dest[byi_write++] = edge_l * ta_source[byi_source++] + edge_r * ta_source[byi_read_right++];
                    ta_dest[byi_write++] = edge_l * ta_source[byi_source++] + edge_r * ta_source[byi_read_right++];
                }
            }



        } else {
            const edge_b = 1 - ta_top_proportions[i_dest_y];
            for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
                edge_l = ta_left_proportions[i_dest_x];
                edge_r = 1 - ta_left_proportions[i_dest_x];
                byi_source = ta_source_x_byi_component[i_dest_x] + y_byi;
                if (edge_l === 1) {
                    byi_read_below = byi_source + source_bypr;
                    ta_dest[byi_write++] = edge_t * ta_source[byi_source++] + edge_b * ta_source[byi_read_below++];
                    ta_dest[byi_write++] = edge_t * ta_source[byi_source++] + edge_b * ta_source[byi_read_below++];
                    ta_dest[byi_write++] = edge_t * ta_source[byi_source++] + edge_b * ta_source[byi_read_below++];
                } else {
                    corner_tl = edge_l * edge_t;
                    corner_tr = edge_r * edge_t;
                    corner_bl = edge_l * edge_b;
                    corner_br = edge_r * edge_b;
                    byi_read_right = byi_source + 3;
                    byi_read_below = byi_source + source_bypr;
                    byi_read_below_right = byi_read_below + 3;
                    ta_dest[byi_write++] = corner_tl * ta_source[byi_source++] + corner_tr * ta_source[byi_read_right++] + corner_bl * ta_source[byi_read_below++] + corner_br * ta_source[byi_read_below_right++];
                    ta_dest[byi_write++] = corner_tl * ta_source[byi_source++] + corner_tr * ta_source[byi_read_right++] + corner_bl * ta_source[byi_read_below++] + corner_br * ta_source[byi_read_below_right++];
                    ta_dest[byi_write++] = corner_tl * ta_source[byi_source++] + corner_tr * ta_source[byi_read_right++] + corner_bl * ta_source[byi_read_below++] + corner_br * ta_source[byi_read_below_right++];
                }
            }
        }
        /*
        for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
            edge_l = ta_left_proportions[i_dest_x];
            edge_r = 1 - ta_left_proportions[i_dest_x];
            byi_source = ta_source_x_byi_component[i_dest_x] + y_byi;
            if (edge_l === 1) {
                if (edge_t === 1) {
                    ta_dest[byi_write++] = ta_source[byi_source++];
                    ta_dest[byi_write++] = ta_source[byi_source++];
                    ta_dest[byi_write++] = ta_source[byi_source++];
                } else {
                    byi_read_below = byi_source + source_bypr;
                    ta_dest[byi_write++] = edge_t * ta_source[byi_source++] + edge_b * ta_source[byi_read_below++];
                    ta_dest[byi_write++] = edge_t * ta_source[byi_source++] + edge_b * ta_source[byi_read_below++];
                    ta_dest[byi_write++] = edge_t * ta_source[byi_source++] + edge_b * ta_source[byi_read_below++];
                }
            } else {
                if (edge_t === 1) {
                    byi_read_right = byi_source + 3;
                    ta_dest[byi_write++] = edge_l * ta_source[byi_source++] + edge_r * ta_source[byi_read_right++];
                    ta_dest[byi_write++] = edge_l * ta_source[byi_source++] + edge_r * ta_source[byi_read_right++];
                    ta_dest[byi_write++] = edge_l * ta_source[byi_source++] + edge_r * ta_source[byi_read_right++];
                } else {
                    corner_tl = edge_l * edge_t;
                    corner_tr = edge_r * edge_t;
                    corner_bl = edge_l * edge_b;
                    corner_br = edge_r * edge_b;
                    byi_read_right = byi_source + 3;
                    byi_read_below = byi_source + source_bypr;
                    byi_read_below_right = byi_read_below + 3;
                    ta_dest[byi_write++] = corner_tl * ta_source[byi_source++] + corner_tr * ta_source[byi_read_right++] + corner_bl * ta_source[byi_read_below++] + corner_br * ta_source[byi_read_below_right++];
                    ta_dest[byi_write++] = corner_tl * ta_source[byi_source++] + corner_tr * ta_source[byi_read_right++] + corner_bl * ta_source[byi_read_below++] + corner_br * ta_source[byi_read_below_right++];
                    ta_dest[byi_write++] = corner_tl * ta_source[byi_source++] + corner_tr * ta_source[byi_read_right++] + corner_bl * ta_source[byi_read_below++] + corner_br * ta_source[byi_read_below_right++];
                }
            }
        }
            */
    }
}
const resize_ta_colorspace_24bipp$subpixel = resize_ta_colorspace_24bipp$subpixel$inline;
let __attempt__resize_ta_colorspace_24bipp$superpixel = (ta_source, source_colorspace, dest_size, ta_dest) => {
    console.log('resize_ta_colorspace_24bipp$superpixel');
    const source_bypp = source_colorspace[2];
    const source_bypr = source_colorspace[3];
    const [f_px_w, f_px_h] = [source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]];
    let f_source_x, f_source_r;
    let i_source_l, i_source_r;
    let f_source_y, f_source_b;
    let i_source_t, i_source_b;
    let i_dest_x, i_dest_y;
    let left_edge_dist, top_edge_dist, right_edge_dist, bottom_edge_dist;
    const ta_left_edge_segment_proportions = new Float32Array(dest_size[0]);
    const ta_top_edge_segment_proportions = new Float32Array(dest_size[1]);
    const ta_right_edge_segment_proportions = new Float32Array(dest_size[0]);
    const ta_bottom_edge_segment_proportions = new Float32Array(dest_size[1]);
    const ta_source_x = new Int16Array(dest_size[0]);
    const ta_source_y = new Int16Array(dest_size[1]);
    const ta_source_x_byi_component = new Int32Array(dest_size[0]);
    const ta_source_y_byi_component = new Int32Array(dest_size[1]);
    const ta_source_x_any_coverage_w = new Int16Array(dest_size[0]);
    const ta_source_y_any_coverage_h = new Int16Array(dest_size[1]);
    const source_i_any_coverage_size = new Int16Array(2);
    let fpx_area_recip = 1 / (f_px_w * f_px_h);
    for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
        f_source_x = i_dest_x * f_px_w;
        f_source_r = (i_dest_x + 1) * f_px_w;
        i_source_l = Math.floor(f_source_x);
        i_source_r = Math.ceil(f_source_r);
        ta_source_x[i_dest_x] = i_source_l;
        ta_source_x_byi_component[i_dest_x] = i_source_l * source_bypp;
        ta_source_x_any_coverage_w[i_dest_x] = i_source_r - i_source_l;
        left_edge_dist = f_source_x - i_source_l;
        if (left_edge_dist === 0) left_edge_dist = 1;
        right_edge_dist = i_source_r - f_source_r;
        if (right_edge_dist === 0) right_edge_dist = 1;
        ta_left_edge_segment_proportions[i_dest_x] = (left_edge_dist) * fpx_area_recip;
        ta_right_edge_segment_proportions[i_dest_x] = (right_edge_dist) * fpx_area_recip;
    }
    for (i_dest_y = 0; i_dest_y < dest_size[1]; i_dest_y++) {
        f_source_y = i_dest_y * f_px_h;
        f_source_b = (i_dest_y + 1) * f_px_h;
        i_source_t = Math.floor(f_source_y);
        i_source_b = Math.ceil(f_source_b);
        ta_source_y[i_dest_y] = i_source_t;
        ta_source_y_byi_component[i_dest_y] = i_source_t * source_bypr;
        ta_source_y_any_coverage_h[i_dest_y] = i_source_b - i_source_t;
        top_edge_dist = f_source_y - i_source_t;
        if (top_edge_dist === 0) top_edge_dist = 1;
        bottom_edge_dist = i_source_b - f_source_b;
        if (bottom_edge_dist === 0) bottom_edge_dist = 1;
        ta_top_edge_segment_proportions[i_dest_y] = (top_edge_dist) * fpx_area_recip;
        ta_bottom_edge_segment_proportions[i_dest_y] = (bottom_edge_dist) * fpx_area_recip;
    }
    const ta_ltrb_edge_props = new Float32Array(4);
    let byi_source;
    let byi_write = 0;
    const ta_ltrb_corner_props = new Float32Array(4);
    for (i_dest_y = 0; i_dest_y < dest_size[1]; i_dest_y++) {
        ta_ltrb_edge_props[1] = ta_top_edge_segment_proportions[i_dest_y];
        ta_ltrb_edge_props[3] = ta_bottom_edge_segment_proportions[i_dest_y];
        source_i_any_coverage_size[1] = ta_source_y_any_coverage_h[i_dest_y];
        for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
            source_i_any_coverage_size[0] = ta_source_x_any_coverage_w[i_dest_x];
            byi_source = ta_source_x_byi_component[i_dest_x] + ta_source_y_byi_component[i_dest_y];
            ta_ltrb_edge_props[0] = ta_left_edge_segment_proportions[i_dest_x];
            ta_ltrb_edge_props[2] = ta_right_edge_segment_proportions[i_dest_x];
            ta_ltrb_corner_props[0] = ta_ltrb_edge_props[0] * ta_ltrb_edge_props[1];
            ta_ltrb_corner_props[1] = ta_ltrb_edge_props[2] * ta_ltrb_edge_props[1];
            ta_ltrb_corner_props[2] = ta_ltrb_edge_props[0] * ta_ltrb_edge_props[3];
            ta_ltrb_corner_props[3] = ta_ltrb_edge_props[2] * ta_ltrb_edge_props[3];
            if (source_i_any_coverage_size[0] === 2) {
                if (source_i_any_coverage_size[1] === 2) {
                    read_2x2_weight_write_24bipp(ta_source, source_bypr, byi_source, ta_dest, byi_write, ta_ltrb_corner_props);
                } else if (source_i_any_coverage_size[1] === 3) {
                    read_2x3_weight_write_24bipp(ta_source, source_bypr, byi_source, ta_dest, byi_write, ta_ltrb_edge_props[1], ta_ltrb_edge_props[3]);
                } else {
                    read_gt3x3_weight_write_24bipp(ta_source, source_bypr, byi_source, source_i_any_coverage_size, ta_ltrb_edge_props, ta_ltrb_corner_props, fpx_area_recip, ta_dest, byi_write);
                }
            } else if (source_i_any_coverage_size[0] === 3) {
                if (source_i_any_coverage_size[1] === 2) {
                    read_3x2_weight_write_24bipp(ta_source, source_bypr, byi_source, ta_ltrb_edge_props, ta_ltrb_corner_props, ta_dest, byi_write);
                } else if (source_i_any_coverage_size[1] === 3) {
                    read_3x3_weight_write_24bipp(ta_source, source_bypr, byi_source, ta_ltrb_edge_props, ta_ltrb_corner_props, ta_dest, byi_write);
                } else {
                    read_gt3x3_weight_write_24bipp(ta_source, source_bypr, byi_source, source_i_any_coverage_size, ta_ltrb_edge_props, ta_ltrb_corner_props, fpx_area_recip, ta_dest, byi_write);
                }
            } else {
                read_gt3x3_weight_write_24bipp(ta_source, source_bypr, byi_source, source_i_any_coverage_size, ta_ltrb_edge_props, ta_ltrb_corner_props, fpx_area_recip, ta_dest, byi_write);
            }
            byi_write += 3;
        }
    }
}
const resize_ta_colorspace_24bipp$subpixel$ta4byis = (ta_source, source_colorspace, dest_size, ta_dest) => {
    const source_bypp = source_colorspace[2];
    const source_bypr = source_colorspace[3];
    const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
    const [f_px_w, f_px_h] = [source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]];
    let f_source_x, f_source_r;
    let i_source_l, i_source_lr_crossover;
    let f_source_y, f_source_b;
    let i_source_t, i_source_tb_crossover;
    let i_dest_x, i_dest_y;
    const ta_left_proportions = new Float32Array(dest_size[0]);
    const ta_top_proportions = new Float32Array(dest_size[1]);
    const ta_source_x = new Int16Array(dest_size[0]);
    const ta_source_y = new Int16Array(dest_size[1]);
    const ta_source_x_byi_component = new Int32Array(dest_size[0]);
    const ta_source_y_byi_component = new Int32Array(dest_size[1]);
    for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
        f_source_x = i_dest_x * f_px_w;
        f_source_r = f_source_x + f_px_w;
        i_source_l = Math.floor(f_source_x);
        i_source_lr_crossover = i_source_l + 1;
        ta_source_x[i_dest_x] = i_source_l;
        ta_source_x_byi_component[i_dest_x] = i_source_l * source_bypp;
        if (f_source_r < i_source_lr_crossover || i_source_l === f_source_x) {
            ta_left_proportions[i_dest_x] = 1;
        } else {
            ta_left_proportions[i_dest_x] = (i_source_lr_crossover - f_source_x) / f_px_w;
        }
    }
    for (i_dest_y = 0; i_dest_y < dest_size[0]; i_dest_y++) {
        f_source_y = i_dest_y * f_px_h;
        f_source_b = f_source_y + f_px_h;
        i_source_t = Math.floor(f_source_y);
        i_source_tb_crossover = i_source_t + 1;
        ta_source_y[i_dest_y] = i_source_t;
        ta_source_y_byi_component[i_dest_y] = i_source_t * source_bypr;
        if (f_source_b < i_source_tb_crossover || i_source_t === f_source_y) {
            ta_top_proportions[i_dest_y] = 1;
        } else {
            ta_top_proportions[i_dest_y] = (i_source_tb_crossover - f_source_y) / f_px_h;
        }
    }
    const ta_ltrb_edge_props = new Float32Array(4);
    let byi_source;
    let byi_write = 0;
    const ta_tl_weight_props = new Float32Array(2);
    const ta_byi_reads = new Int32Array(4);
    const ta_ltrb_corner_props = new Float32Array(4);
    for (i_dest_y = 0; i_dest_y < dest_size[1]; i_dest_y++) {
        ta_ltrb_edge_props[1] = ta_top_proportions[i_dest_y];
        ta_ltrb_edge_props[3] = 1 - ta_top_proportions[i_dest_y];
        for (i_dest_x = 0; i_dest_x < dest_size[0]; i_dest_x++) {
            ta_ltrb_edge_props[0] = ta_left_proportions[i_dest_x];
            ta_ltrb_edge_props[2] = 1 - ta_left_proportions[i_dest_x];
            ta_byi_reads[0] = ta_source_x_byi_component[i_dest_x] + ta_source_y_byi_component[i_dest_y];
            if (ta_ltrb_edge_props[0] === 1) {
                if (ta_ltrb_edge_props[1] === 1) {
                    copy_px_24bipp(ta_source, ta_byi_reads[0], ta_dest, byi_write);
                } else {
                    ta_byi_reads[2] = ta_byi_reads[0] + source_bypr;
                    read_1x2_weight_write_24bipp$ta4byis(ta_source, ta_byi_reads, ta_dest, byi_write, ta_ltrb_edge_props[1], ta_ltrb_edge_props[3]);
                }
            } else {
                if (ta_ltrb_edge_props[1] === 1) {
                    ta_byi_reads[1] = ta_byi_reads[0] + source_bypp;
                    read_2x1_weight_write_24bipp$ta4byis(ta_source, ta_byi_reads, ta_dest, byi_write, ta_ltrb_edge_props[0], ta_ltrb_edge_props[2]);
                } else {
                    ta_byi_reads[1] = ta_byi_reads[0] + source_bypp;
                    ta_byi_reads[2] = ta_byi_reads[0] + source_bypr;
                    ta_byi_reads[3] = ta_byi_reads[2] + source_bypp;
                    ta_ltrb_corner_props[0] = ta_ltrb_edge_props[0] * ta_ltrb_edge_props[1];
                    ta_ltrb_corner_props[1] = ta_ltrb_edge_props[2] * ta_ltrb_edge_props[1];
                    ta_ltrb_corner_props[2] = ta_ltrb_edge_props[0] * ta_ltrb_edge_props[3];
                    ta_ltrb_corner_props[3] = ta_ltrb_edge_props[2] * ta_ltrb_edge_props[3];
                    read_2x2_weight_write_24bipp$ta4byis(ta_source, ta_byi_reads, ta_dest, byi_write, ta_ltrb_corner_props);
                }
            }
            byi_write += 3;
        }
    }
}
const __resize_ta_colorspace_24bipp$superpixel = (ta_source, source_colorspace, dest_size, opt_ta_dest) => {
    const bypr = source_colorspace[3];
    const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
    const fpx_area_recip = 1 / (dest_to_source_ratio[0] * dest_to_source_ratio[1]);
    each_source_dest_pixels_resized_limited_further_info(source_colorspace, dest_size, (dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, byi_read) => {
        if (source_i_any_coverage_size[0] === 2 && source_i_any_coverage_size[1] === 2) {
            read_2x2_weight_write_24bipp(ta_source, bypr, byi_read, opt_ta_dest, dest_byi, corner_areas_proportions_of_total);
        } else if (source_i_any_coverage_size[0] === 2 && source_i_any_coverage_size[1] === 3) {
            read_2x3_weight_write_24bipp(ta_source, bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, opt_ta_dest, dest_byi);
        } else if (source_i_any_coverage_size[0] === 3 && source_i_any_coverage_size[1] === 2) {
            read_3x2_weight_write_24bipp(ta_source, bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, opt_ta_dest, dest_byi);
        } else if (source_i_any_coverage_size[0] === 3 && source_i_any_coverage_size[1] === 3) {
            read_3x3_weight_write_24bipp(ta_source, bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip, opt_ta_dest, dest_byi);
        } else {
            read_gt3x3_weight_write_24bipp(ta_source, bypr, byi_read, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip, opt_ta_dest, dest_byi);
        }
    });
}
const __resize_ta_colorspace_24bipp$superpixel$inline = (ta_source, source_colorspace, dest_size, opt_ta_dest) => {
    const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
    const fpx_area_recip = 1 / (dest_to_source_ratio[0] * dest_to_source_ratio[1]);
    const source_edge_distances = new Float32Array(4);
    const edge_distances_proportions_of_total = new Float32Array(4);
    const corner_areas_proportions_of_total = new Float32Array(4);
    const fpx_area = dest_to_source_ratio[0] * dest_to_source_ratio[1];
    const source_bypp = source_colorspace[2];
    const source_bypr = source_colorspace[3];
    const source_bipp = source_colorspace[4];
    const dest_colorspace = new Int32Array([dest_size[0], dest_size[1], source_bypp, source_bypp * dest_size[0], source_bipp, source_bipp * dest_size[0]]);
    const source_fbounds = new Float32Array(4);
    const source_ibounds = new Int16Array(4);
    const source_i_any_coverage_size = new Int16Array(2);
    const source_total_coverage_ibounds = new Int16Array(4);
    let byi_read;
    let dest_byi = 0;
    const width = dest_colorspace[0], height = dest_colorspace[1];
    let x, y;
    for (y = 0; y < height; y++) {
        source_fbounds[1] = y * dest_to_source_ratio[1];
        source_fbounds[3] = source_fbounds[1] + dest_to_source_ratio[1];
        source_ibounds[1] = source_fbounds[1];
        source_ibounds[3] = Math.ceil(source_fbounds[3]);
        source_i_any_coverage_size[1] = source_ibounds[3] - source_ibounds[1];
        source_total_coverage_ibounds[1] = Math.ceil(source_fbounds[1]);
        source_total_coverage_ibounds[3] = source_fbounds[3];
        source_edge_distances[1] = source_total_coverage_ibounds[1] - source_fbounds[1];
        source_edge_distances[3] = source_fbounds[3] - source_total_coverage_ibounds[3];
        if (source_edge_distances[1] === 0) source_edge_distances[1] = 1;
        if (source_edge_distances[3] === 0) source_edge_distances[3] = 1;
        edge_distances_proportions_of_total[1] = source_edge_distances[1] / fpx_area;
        edge_distances_proportions_of_total[3] = source_edge_distances[3] / fpx_area;
        for (x = 0; x < width; x++) {
            source_fbounds[0] = x * dest_to_source_ratio[0];
            source_fbounds[2] = source_fbounds[0] + dest_to_source_ratio[0];
            source_ibounds[0] = source_fbounds[0];
            source_ibounds[2] = Math.ceil(source_fbounds[2]);
            source_i_any_coverage_size[0] = source_ibounds[2] - source_ibounds[0];
            byi_read = source_ibounds[0] * source_bypp + source_ibounds[1] * source_bypr;
            source_total_coverage_ibounds[0] = Math.ceil(source_fbounds[0]); 
            source_total_coverage_ibounds[2] = Math.floor(source_fbounds[2]);
            source_edge_distances[0] = source_total_coverage_ibounds[0] - source_fbounds[0];
            source_edge_distances[2] = source_fbounds[2] - source_total_coverage_ibounds[2];
            if (source_edge_distances[0] === 0) source_edge_distances[0] = 1;
            if (source_edge_distances[2] === 0) source_edge_distances[2] = 1;
            corner_areas_proportions_of_total[0] = source_edge_distances[0] * source_edge_distances[1] / fpx_area;
            corner_areas_proportions_of_total[1] = source_edge_distances[2] * source_edge_distances[1] / fpx_area;
            corner_areas_proportions_of_total[2] = source_edge_distances[0] * source_edge_distances[3] / fpx_area;
            corner_areas_proportions_of_total[3] = source_edge_distances[2] * source_edge_distances[3] / fpx_area;
            if (source_i_any_coverage_size[0] > 3 ||  source_i_any_coverage_size[1] > 3) {
                edge_distances_proportions_of_total[0] = source_edge_distances[0] / fpx_area;
                edge_distances_proportions_of_total[2] = source_edge_distances[2] / fpx_area;
                read_gt3x3_weight_write_24bipp(ta_source, source_bypr, byi_read, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip, opt_ta_dest, dest_byi);
            } else {
                if (source_i_any_coverage_size[0] === 2 && source_i_any_coverage_size[1] === 2) {
                    read_2x2_weight_write_24bipp(ta_source, source_bypr, byi_read, opt_ta_dest, dest_byi, corner_areas_proportions_of_total);
                } else {
                    edge_distances_proportions_of_total[0] = source_edge_distances[0] / fpx_area;
                    edge_distances_proportions_of_total[2] = source_edge_distances[2] / fpx_area;
                    if (source_i_any_coverage_size[0] === 2 && source_i_any_coverage_size[1] === 3) {
                        read_2x3_weight_write_24bipp(ta_source, source_bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, opt_ta_dest, dest_byi);
                    } else if (source_i_any_coverage_size[0] === 3 && source_i_any_coverage_size[1] === 2) {
                        read_3x2_weight_write_24bipp(ta_source, source_bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, opt_ta_dest, dest_byi);
                    } else if (source_i_any_coverage_size[0] === 3 && source_i_any_coverage_size[1] === 3) {
                        read_3x3_weight_write_24bipp(ta_source, source_bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip, opt_ta_dest, dest_byi);
                    } else {
                        console.trace();
                        throw 'stop';
                    }
                }
            }
            dest_byi += source_bypp;
        }
    }
}
const resize_ta_colorspace_24bipp$superpixel$inline$locals = (ta_source, source_colorspace, dest_size, opt_ta_dest) => {
    const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
    const fpx_area_recip = 1 / (dest_to_source_ratio[0] * dest_to_source_ratio[1]);
    const [fpxw, fpxh] = [source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]];
    let edge_l, edge_t, edge_r, edge_b;
    let edge_p_l, edge_p_t, edge_p_r, edge_p_b;
    let corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br;
    const fpx_area = dest_to_source_ratio[0] * dest_to_source_ratio[1];
    const source_bypp = source_colorspace[2];
    const source_bypr = source_colorspace[3];
    const source_bipp = source_colorspace[4];
    const dest_colorspace = new Int32Array([dest_size[0], dest_size[1], source_bypp, source_bypp * dest_size[0], source_bipp, source_bipp * dest_size[0]]);
    let fbounds_l, fbounds_t, fbounds_r, fbounds_b;
    let ibounds_l, ibounds_t, ibounds_r, ibounds_b;
    let any_coverage_w, any_coverage_h;
    let total_coverage_l, total_coverage_t, total_coverage_r, total_coverage_b;
    let byi_read;
    let dest_byi = 0;
    const width = dest_colorspace[0], height = dest_colorspace[1];
    let x, y;
    for (y = 0; y < height; y++) {
        fbounds_t = y * fpxh;
        fbounds_b = fbounds_t + fpxh;
        ibounds_t = Math.floor(fbounds_t);
        ibounds_b = Math.ceil(fbounds_b);
        any_coverage_h = ibounds_b - ibounds_t;
        total_coverage_t = Math.ceil(fbounds_t);
        total_coverage_b = Math.floor(fbounds_b);
        edge_t = total_coverage_t - fbounds_t;
        edge_b = fbounds_b - total_coverage_b;
        if (edge_t === 0) edge_t = 1;
        if (edge_b === 0) edge_b = 1;
        edge_p_t = edge_t / fpx_area;
        edge_p_b = edge_b / fpx_area;
        fbounds_l = 0;
        fbounds_r = fpxw;
        for (x = 0; x < width; x++) {
            fbounds_l = x * fpxw;
            fbounds_r = (x + 1) * fpxw;
            ibounds_l = Math.floor(fbounds_l);
            ibounds_r = Math.ceil(fbounds_r);
            any_coverage_w = ibounds_r - ibounds_l;
            byi_read = ibounds_l * source_bypp + ibounds_t * source_bypr;
            total_coverage_l = Math.ceil(fbounds_l);
            total_coverage_r = Math.floor(fbounds_r);
            edge_l = total_coverage_l - fbounds_l;
            edge_r = fbounds_r - total_coverage_r;
            if (edge_l === 0) edge_l = 1;
            if (edge_r === 0) edge_r = 1;
            corner_p_tl = edge_l * edge_p_t;
            corner_p_tr = edge_r * edge_p_t;
            corner_p_bl = edge_l * edge_p_b;
            corner_p_br = edge_r * edge_p_b;
            if (any_coverage_w > 3 ||  any_coverage_h > 3) {
                edge_p_l = edge_l / fpx_area;
                edge_p_r = edge_r / fpx_area;
                read_gt3x3_weight_write_24bipp$locals(ta_source, source_bypr, byi_read,
                    any_coverage_w, any_coverage_h,
                    edge_p_l, edge_p_t, edge_p_r, edge_p_b,
                    corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br,
                    fpx_area_recip,
                    opt_ta_dest, dest_byi
                    )
            } else {
                if (any_coverage_w === 2 && any_coverage_h === 2) {
                    read_2x2_weight_write_24bipp$locals(ta_source, source_bypr, byi_read, 
                        corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br,
                        opt_ta_dest, dest_byi);
                } else {
                    edge_p_l = edge_l / fpx_area;
                    edge_p_r = edge_r / fpx_area;
                    if (any_coverage_w === 2 && any_coverage_h === 3) {
                        read_2x3_weight_write_24bipp$locals(ta_source, source_bypr, byi_read,
                            edge_p_l, edge_p_t, edge_p_r, edge_p_b,
                            corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br,
                            opt_ta_dest, dest_byi);
                    } else if (any_coverage_w === 3 && any_coverage_h === 2) {
                        read_3x2_weight_write_24bipp$locals(ta_source, source_bypr, byi_read,
                            edge_p_l, edge_p_t, edge_p_r, edge_p_b,
                            corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br,
                            opt_ta_dest, dest_byi);
                    } else if (any_coverage_w === 3 && any_coverage_h === 3) {
                        read_3x3_weight_write_24bipp$locals(ta_source, source_bypr, byi_read,
                            edge_p_l, edge_p_t, edge_p_r, edge_p_b,
                            corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br,
                            fpx_area_recip,
                            opt_ta_dest, dest_byi);
                    } else {
                        console.trace();
                        throw 'stop';
                    }
                }
            }
            dest_byi += source_bypp;
        }
    }
}
const resize_ta_colorspace_24bipp$superpixel$inline$locals$inline = (ta_source, source_colorspace, dest_size, opt_ta_dest) => {
    const ta_dest = opt_ta_dest;
    const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
    const fpx_area_recip = 1 / (dest_to_source_ratio[0] * dest_to_source_ratio[1]);
    const [fpxw, fpxh] = [source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]];
    let edge_l, edge_t, edge_r, edge_b;
    let edge_p_l, edge_p_t, edge_p_r, edge_p_b;
    let corner_p_tl, corner_p_tr, corner_p_bl, corner_p_br;
    const fpx_area = dest_to_source_ratio[0] * dest_to_source_ratio[1];
    const source_bypp = source_colorspace[2];
    const source_bypr = source_colorspace[3];
    const source_bipp = source_colorspace[4];
    const dest_colorspace = new Int32Array([dest_size[0], dest_size[1], source_bypp, source_bypp * dest_size[0], source_bipp, source_bipp * dest_size[0]]);
    let fbounds_l, fbounds_t, fbounds_r, fbounds_b;
    let ibounds_l, ibounds_t, ibounds_r, ibounds_b;
    let any_coverage_w, any_coverage_h;
    let total_coverage_l, total_coverage_t, total_coverage_r, total_coverage_b;
    let byi_read;
    let dest_byi = 0;
    const width = dest_colorspace[0], height = dest_colorspace[1];
    let x, y;
    let r = 0, g = 0, b = 0;
    let x_inner, y_inner;
    let byi_read_right, byi_read_below, byi_read_below_right;
    let byi_tl, byi_tm, byi_tr;
    let byi_ml, byi_mm, byi_mr;
    let byi_bl, byi_bm, byi_br;
    let end_hmiddle, end_vmiddle;
    for (y = 0; y < height; y++) {
        fbounds_t = y * fpxh;
        fbounds_b = fbounds_t + fpxh;
        ibounds_t = Math.floor(fbounds_t);
        ibounds_b = Math.ceil(fbounds_b);
        any_coverage_h = ibounds_b - ibounds_t;
        total_coverage_t = Math.ceil(fbounds_t);
        total_coverage_b = Math.floor(fbounds_b);
        edge_t = total_coverage_t - fbounds_t;
        edge_b = fbounds_b - total_coverage_b;
        if (edge_t === 0) edge_t = 1;
        if (edge_b === 0) edge_b = 1;
        edge_p_t = edge_t / fpx_area;
        edge_p_b = edge_b / fpx_area;
        fbounds_l = 0;
        fbounds_r = fpxw;
        for (x = 0; x < width; x++) {
            fbounds_l = x * fpxw;
            fbounds_r = (x + 1) * fpxw;
            ibounds_l = Math.floor(fbounds_l);
            ibounds_r = Math.ceil(fbounds_r);
            any_coverage_w = ibounds_r - ibounds_l;
            byi_read = ibounds_l * source_bypp + ibounds_t * source_bypr;
            total_coverage_l = Math.ceil(fbounds_l);
            total_coverage_r = Math.floor(fbounds_r);
            edge_l = total_coverage_l - fbounds_l;
            edge_r = fbounds_r - total_coverage_r;
            if (edge_l === 0) edge_l = 1;
            if (edge_r === 0) edge_r = 1;
            corner_p_tl = edge_l * edge_p_t;
            corner_p_tr = edge_r * edge_p_t;
            corner_p_bl = edge_l * edge_p_b;
            corner_p_br = edge_r * edge_p_b;
            if (any_coverage_w > 3 ||  any_coverage_h > 3) {
                edge_p_l = edge_l / fpx_area;
                edge_p_r = edge_r / fpx_area;
                byi_tl = byi_read;
                end_hmiddle = any_coverage_w - 1; end_vmiddle = any_coverage_h - 1;
                r = g = b = 0;
                r += ta_source[byi_read++] * corner_p_tl;
                g += ta_source[byi_read++] * corner_p_tl;
                b += ta_source[byi_read++] * corner_p_tl;
                for (x_inner = 1; x_inner < end_hmiddle; x_inner++) {
                    r += ta_source[byi_read++] * edge_p_t;
                    g += ta_source[byi_read++] * edge_p_t;
                    b += ta_source[byi_read++] * edge_p_t;
                }
                r += ta_source[byi_read++] * corner_p_tr;
                g += ta_source[byi_read++] * corner_p_tr;
                b += ta_source[byi_read++] * corner_p_tr;
                for (y_inner = 1; y_inner < end_vmiddle; y_inner++) {
                    byi_read = byi_tl + y_inner * source_bypr;
                    r += ta_source[byi_read++] * edge_p_l;
                    g += ta_source[byi_read++] * edge_p_l;
                    b += ta_source[byi_read++] * edge_p_l;
                    for (x_inner = 1; x_inner < end_hmiddle; x_inner++) {
                        r += ta_source[byi_read++] * fpx_area_recip;
                        g += ta_source[byi_read++] * fpx_area_recip;
                        b += ta_source[byi_read++] * fpx_area_recip;
                    }
                    r += ta_source[byi_read++] * edge_p_r;
                    g += ta_source[byi_read++] * edge_p_r;
                    b += ta_source[byi_read++] * edge_p_r;
                }
                byi_read = byi_tl + end_vmiddle * source_bypr;
                r += ta_source[byi_read++] * corner_p_bl;
                g += ta_source[byi_read++] * corner_p_bl;
                b += ta_source[byi_read++] * corner_p_bl;
                for (x_inner = 1; x_inner < end_hmiddle; x_inner++) {
                    r += ta_source[byi_read++] * edge_p_b;
                    g += ta_source[byi_read++] * edge_p_b;
                    b += ta_source[byi_read++] * edge_p_b;
                }
                r += ta_source[byi_read++] * corner_p_br;
                g += ta_source[byi_read++] * corner_p_br;
                b += ta_source[byi_read++] * corner_p_br;
                ta_dest[dest_byi] = Math.round(r);
                ta_dest[dest_byi + 1] = Math.round(g);
                ta_dest[dest_byi + 2] = Math.round(b);
            } else {
                if (any_coverage_w === 2 && any_coverage_h === 2) {
                    byi_read_right = byi_read + 3;
                    byi_read_below = byi_read + source_bypr;
                    byi_read_below_right = byi_read_below + 3;
                    ta_dest[dest_byi] = corner_p_tl * ta_source[byi_read++] + corner_p_tr * ta_source[byi_read_right++] + corner_p_bl * ta_source[byi_read_below++] + corner_p_br * ta_source[byi_read_below_right++];
                    ta_dest[dest_byi + 1] = corner_p_tl * ta_source[byi_read++] + corner_p_tr * ta_source[byi_read_right++] + corner_p_bl * ta_source[byi_read_below++] + corner_p_br * ta_source[byi_read_below_right++];
                    ta_dest[dest_byi + 2] = corner_p_tl * ta_source[byi_read++] + corner_p_tr * ta_source[byi_read_right++] + corner_p_bl * ta_source[byi_read_below++] + corner_p_br * ta_source[byi_read_below_right++];
                } else {
                    edge_p_l = edge_l / fpx_area;
                    edge_p_r = edge_r / fpx_area;
                    if (any_coverage_w === 2 && any_coverage_h === 3) {
                        byi_tl = byi_read; byi_tr = byi_tl + 3;
                        byi_ml = byi_tl + source_bypr; byi_mr = byi_ml + 3;
                        byi_bl = byi_ml + source_bypr; byi_br = byi_bl + 3;
                        ta_dest[dest_byi] =     ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tr++] * corner_p_tr +
                                                ta_source[byi_ml++] * edge_p_l + ta_source[byi_mr++] * edge_p_r +
                                                ta_source[byi_bl++] * corner_p_bl + ta_source[byi_br++] * corner_p_br
                        ta_dest[dest_byi + 1] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tr++] * corner_p_tr +
                                                ta_source[byi_ml++] * edge_p_l + ta_source[byi_mr++] * edge_p_r +
                                                ta_source[byi_bl++] * corner_p_bl + ta_source[byi_br++] * corner_p_br
                        ta_dest[dest_byi + 2] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tr++] * corner_p_tr +
                                                ta_source[byi_ml++] * edge_p_l + ta_source[byi_mr++] * edge_p_r +
                                                ta_source[byi_bl++] * corner_p_bl + ta_source[byi_br++] * corner_p_br
                    } else if (any_coverage_w === 3 && any_coverage_h === 2) {
                        byi_tl = byi_read;
                        byi_tm = byi_tl + 3; byi_tr = byi_tm + 3;
                        byi_bl = byi_tm + source_bypr; byi_bm = byi_bl + 3; byi_br = byi_bm + 3;
                        ta_dest[dest_byi] =     ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br;
                        ta_dest[dest_byi + 1] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br;
                        ta_dest[dest_byi + 2] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                                            ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br;
                    } else if (any_coverage_w === 3 && any_coverage_h === 3) {
                        byi_tl = byi_read; byi_tm = byi_tl + source_bypp; byi_tr = byi_tm + source_bypp;
                        byi_ml = byi_tl + source_bypr; byi_mm = byi_ml + source_bypp; byi_mr = byi_mm + source_bypp;
                        byi_bl = byi_ml + source_bypr; byi_bm = byi_bl + source_bypp; byi_br = byi_bm + source_bypp;
                        ta_dest[dest_byi] =     ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                                                ta_source[byi_ml++] * edge_p_l + ta_source[byi_mm++] * fpx_area_recip + ta_source[byi_mr++] * edge_p_r +
                                                ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br
                        ta_dest[dest_byi + 1] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                                                ta_source[byi_ml++] * edge_p_l + ta_source[byi_mm++] * fpx_area_recip + ta_source[byi_mr++] * edge_p_r +
                                                ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br
                        ta_dest[dest_byi + 2] = ta_source[byi_tl++] * corner_p_tl + ta_source[byi_tm++] * edge_p_t + ta_source[byi_tr++] * corner_p_tr +
                                                ta_source[byi_ml++] * edge_p_l + ta_source[byi_mm++] * fpx_area_recip + ta_source[byi_mr++] * edge_p_r +
                                                ta_source[byi_bl++] * corner_p_bl + ta_source[byi_bm++] * edge_p_b + ta_source[byi_br++] * corner_p_br
                    } else {
                        console.trace();
                        throw 'stop';
                    }
                }
            }
            dest_byi += source_bypp;
        }
    }
}
const resize_ta_colorspace_24bipp$superpixel = resize_ta_colorspace_24bipp$superpixel$inline$locals$inline;
const resize_ta_colorspace_24bipp$general = (ta_source, source_colorspace, dest_size, opt_ta_dest) => {
    const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
    const [width, height, bypp, bypr, bipp, bipr] = source_colorspace;
    const fpx_area_recip = 1 / (dest_to_source_ratio[0] * dest_to_source_ratio[1]);
    each_source_dest_pixels_resized_limited_further_info(source_colorspace, dest_size, (dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, byi_read) => {
        if (source_i_any_coverage_size[0] === 1) {
            if (source_i_any_coverage_size[1] === 1) {
                copy_px_24bipp(ta_source, byi_read, opt_ta_dest, dest_byi);
            } else if (source_i_any_coverage_size[1] === 2) {
                read_1x2_weight_write_24bipp(ta_source, bypr, byi_read, opt_ta_dest, dest_byi, edge_distances_proportions_of_total[1], edge_distances_proportions_of_total[3]);
            } else {
                console.log('source_i_any_coverage_size', source_i_any_coverage_size);
                console.trace();
                throw 'NYI';
            }
        } else if (source_i_any_coverage_size[0] === 2) {
            if (source_i_any_coverage_size[1] === 1) {
                read_2x1_weight_write_24bipp(ta_source, byi_read, opt_ta_dest, dest_byi, edge_distances_proportions_of_total[0], edge_distances_proportions_of_total[2]);
            } else if (source_i_any_coverage_size[1] === 2) {
                read_2x2_weight_write_24bipp(ta_source, bypr, byi_read, opt_ta_dest, dest_byi, corner_areas_proportions_of_total);
            } else {
                read_2x3_weight_write_24bipp(ta_source, bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, opt_ta_dest, dest_byi);
            }
        } else if (source_i_any_coverage_size[0] === 3) {
            if (source_i_any_coverage_size[1] === 1) {
                console.log('source_i_any_coverage_size', source_i_any_coverage_size);
                console.trace();
                throw 'NYI';
            } else if (source_i_any_coverage_size[1] === 2) {
                read_3x2_weight_write_24bipp(ta_source, bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, opt_ta_dest, dest_byi);
            } else if (source_i_any_coverage_size[1] === 3) {
                read_3x3_weight_write_24bipp(ta_source, bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip, opt_ta_dest, dest_byi);
            } else {
                read_gt3x3_weight_write_24bipp(ta_source, bypr, byi_read, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip, opt_ta_dest, dest_byi);
            }
        } else {
            read_gt3x3_weight_write_24bipp(ta_source, bypr, byi_read, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip, opt_ta_dest, dest_byi);
        }
    });
}
const resize_ta_colorspace_24bipp = (ta_source, source_colorspace, dest_size, opt_ta_dest) => {
    const dest_to_source_ratio = new Float32Array([source_colorspace[0] / dest_size[0], source_colorspace[1] / dest_size[1]]);
    if (dest_to_source_ratio[0] < 1 && dest_to_source_ratio[1] < 1) {
        return resize_ta_colorspace_24bipp$subpixel(ta_source, source_colorspace, dest_size, opt_ta_dest);
    } else if (dest_to_source_ratio[0] > 1 && dest_to_source_ratio[1] > 1) {
        return resize_ta_colorspace_24bipp$superpixel(ta_source, source_colorspace, dest_size, opt_ta_dest);
    } else {
        return resize_ta_colorspace_24bipp$general(ta_source, source_colorspace, dest_size, opt_ta_dest);
    }
}
const read_fpx_weight_write_24bipp = (dest_byi, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, byi_read) => {
    if (source_i_any_coverage_size[0] === 1) {
        if (source_i_any_coverage_size[1] === 1) {
            opt_ta_dest[dest_byi] = ta_source[byi_read++];
            opt_ta_dest[dest_byi + 1] = ta_source[byi_read++];
            opt_ta_dest[dest_byi + 2] = ta_source[byi_read++];
        } else if (source_i_any_coverage_size[1] === 2) {
            byi_read_below = byi_read + bypr;
            opt_ta_dest[dest_byi] = edge_distances_proportions_of_total[1] * ta_source[byi_read++] + edge_distances_proportions_of_total[3] * ta_source[byi_read_below++];
            opt_ta_dest[dest_byi + 1] = edge_distances_proportions_of_total[1] * ta_source[byi_read++] + edge_distances_proportions_of_total[3] * ta_source[byi_read_below++];
            opt_ta_dest[dest_byi + 2] = edge_distances_proportions_of_total[1] * ta_source[byi_read++] + edge_distances_proportions_of_total[3] * ta_source[byi_read_below++];
        } else {
            console.log('source_i_any_coverage_size', source_i_any_coverage_size);
            console.trace();
            throw 'NYI';
        }
    } else if (source_i_any_coverage_size[0] === 2) {
        if (source_i_any_coverage_size[1] === 1) {
            byi_read_right = byi_read + bypp;
            opt_ta_dest[dest_byi] = edge_distances_proportions_of_total[0] * ta_source[byi_read++] + edge_distances_proportions_of_total[2] * ta_source[byi_read_right++];
            opt_ta_dest[dest_byi + 1] = edge_distances_proportions_of_total[0] * ta_source[byi_read++] + edge_distances_proportions_of_total[2] * ta_source[byi_read_right++];
            opt_ta_dest[dest_byi + 2] = edge_distances_proportions_of_total[0] * ta_source[byi_read++] + edge_distances_proportions_of_total[2] * ta_source[byi_read_right++];
        } else if (source_i_any_coverage_size[1] === 2) {
            byi_read_right = byi_read + bypp;
            byi_read_below = byi_read + bypr;
            byi_read_below_right = byi_read_below + bypp;
            opt_ta_dest[dest_byi] = corner_areas_proportions_of_total[0] * ta_source[byi_read++] + corner_areas_proportions_of_total[1] * ta_source[byi_read_right++] + corner_areas_proportions_of_total[2] * ta_source[byi_read_below++] + corner_areas_proportions_of_total[3] * ta_source[byi_read_below_right++];
            opt_ta_dest[dest_byi + 1] = corner_areas_proportions_of_total[0] * ta_source[byi_read++] + corner_areas_proportions_of_total[1] * ta_source[byi_read_right++] + corner_areas_proportions_of_total[2] * ta_source[byi_read_below++] + corner_areas_proportions_of_total[3] * ta_source[byi_read_below_right++];
            opt_ta_dest[dest_byi + 2] = corner_areas_proportions_of_total[0] * ta_source[byi_read++] + corner_areas_proportions_of_total[1] * ta_source[byi_read_right++] + corner_areas_proportions_of_total[2] * ta_source[byi_read_below++] + corner_areas_proportions_of_total[3] * ta_source[byi_read_below_right++];
        } else {
            read_2x3_weight_write_24bipp(ta_source, bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, opt_ta_dest, dest_byi);
        }
    } else if (source_i_any_coverage_size[0] === 3) {
        if (source_i_any_coverage_size[1] === 1) {
            console.log('source_i_any_coverage_size', source_i_any_coverage_size);
            console.trace();
            throw 'NYI';
        } else if (source_i_any_coverage_size[1] === 2) {
            read_3x2_weight_write_24bipp(ta_source, bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, opt_ta_dest, dest_byi);
        } else if (source_i_any_coverage_size[1] === 3) {
            read_3x3_weight_write_24bipp(ta_source, bypr, byi_read, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip, opt_ta_dest, dest_byi);
        } else {
            read_gt3x3_weight_write_24bipp(ta_source, bypr, byi_read, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip, opt_ta_dest, dest_byi);
        }
    } else {
        read_gt3x3_weight_write_24bipp(ta_source, bypr, byi_read, source_i_any_coverage_size, edge_distances_proportions_of_total, corner_areas_proportions_of_total, fpx_area_recip, opt_ta_dest, dest_byi);
    }
}
const resize_ta_colorspace = (ta_source, source_colorspace, dest_size, opt_ta_dest) => {
    const bipp = source_colorspace[4];
    if (bipp === 1) {
        console.trace(); throw 'NYI';
    } else if (bipp === 8) {
        console.trace(); throw 'NYI';
    } else if (bipp === 24) {
        return resize_ta_colorspace_24bipp(ta_source, source_colorspace, dest_size, opt_ta_dest);
    } else if (bipp === 32) {
        console.trace(); throw 'NYI';
    } else {
        console.trace();
        throw 'unsupported bipp: ' + bipp;
    }
}
module.exports = {
    resize_ta_colorspace: resize_ta_colorspace,
    resize_ta_colorspace_24bipp: resize_ta_colorspace_24bipp,
    resize_ta_colorspace_24bipp$subpixel: resize_ta_colorspace_24bipp$subpixel
}

},{}],226:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45}],227:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"buffer":3,"dup":46}],228:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"./lang-mini":227,"dup":47}],229:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"../html-core/html-core":335,"dup":48}],230:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"dup":49}],231:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],232:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"dup":51,"lang-tools":364}],233:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"dup":52,"lang-tools":364,"obext":382}],234:[function(require,module,exports){
arguments[4][53][0].apply(exports,arguments)
},{"dup":53,"lang-tools":364,"obext":382}],235:[function(require,module,exports){
arguments[4][54][0].apply(exports,arguments)
},{"dup":54}],236:[function(require,module,exports){
arguments[4][55][0].apply(exports,arguments)
},{"../html-core/Control_Data":314,"../html-core/Control_Validation":315,"../html-core/Control_View":319,"dup":55,"lang-tools":364}],237:[function(require,module,exports){
arguments[4][56][0].apply(exports,arguments)
},{"./coverable":229,"./display":232,"./display-modes":231,"./drag_like_events":233,"./dragable":234,"./fast-touch-click":235,"./model_data_view_compositional_representation":236,"./popup":238,"./press-events":239,"./press-outside":240,"./pressed-state":241,"./resizable":242,"./selectable":243,"./selected-deletable":244,"./selected-resizable":245,"./selection-box-host":246,"./typed_data/date":247,"dup":56}],238:[function(require,module,exports){
arguments[4][57][0].apply(exports,arguments)
},{"../html-core/html-core":335,"dup":57}],239:[function(require,module,exports){
arguments[4][58][0].apply(exports,arguments)
},{"dup":58,"lang-tools":364}],240:[function(require,module,exports){
arguments[4][59][0].apply(exports,arguments)
},{"./press-events":239,"dup":59}],241:[function(require,module,exports){
arguments[4][60][0].apply(exports,arguments)
},{"./press-events":239,"dup":60,"obext":382}],242:[function(require,module,exports){
arguments[4][61][0].apply(exports,arguments)
},{"../html-core/control":334,"./drag_like_events":233,"dup":61,"lang-tools":364}],243:[function(require,module,exports){
arguments[4][62][0].apply(exports,arguments)
},{"dup":62,"lang-mini":379,"obext":382}],244:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./deletable":230,"dup":63,"obext":382}],245:[function(require,module,exports){
arguments[4][64][0].apply(exports,arguments)
},{"dup":64,"obext":382}],246:[function(require,module,exports){
arguments[4][65][0].apply(exports,arguments)
},{"../html-core/html-core":335,"dup":65,"obext":382}],247:[function(require,module,exports){
arguments[4][66][0].apply(exports,arguments)
},{"dup":66,"lang-tools":364}],248:[function(require,module,exports){




const controls = {
    Active_HTML_Document: require('./organised/1-standard/5-ui/Active_HTML_Document'),
    Arrow_Button: require('./organised/0-core/1-advanced/vector/arrow-button'),
    //Audio_Player: require('./audio-player'),
    Audio_Volume: require('./organised/1-standard/5-ui/audio-volume'),
    Button: require('./organised/0-core/0-basic/0-native-compositional/button'),
    Cell: require('./organised/0-core/0-basic/1-compositional/Cell'),
    // Maybe more advanced?
    Context_Menu: require('./organised/0-core/0-basic/1-compositional/context-menu'),
    //Control: 
    Color_Grid: require('./organised/0-core/0-basic/1-compositional/color-palette'),
    Color_Palette: require('./organised/0-core/0-basic/1-compositional/color-palette'),
    Checkbox: require('./organised/0-core/0-basic/0-native-compositional/checkbox'),
    Combo_Box: require('./organised/0-core/0-basic/1-compositional/combo-box'),
    Dropdown_Menu: require('./organised/0-core/0-basic/1-compositional/Dropdown_Menu'),
    // Not using (data-)connected controls.
    //Data_Grid: require('./connected/data-grid'),
    File_Upload: require('./organised/0-core/0-basic/0-native-compositional/file-upload'),
    Form_Field: require('./organised/1-standard/1-editor/form_field'),
    // maybe 0-basic/0-layout?
    //  A layout control may be / need to be displayed a little differently.
    Grid: require('./organised/0-core/0-basic/1-compositional/grid'),
    Grid_Cell: require('./organised/0-core/0-basic/1-compositional/grid').Cell,
    Horizontal_Menu: require('./organised/1-standard/5-ui/horizontal-menu'),
    Horizontal_Slider: require('./organised/1-standard/5-ui/horizontal-slider'),
    //Data_Item: require('./data-item'),
    Data_Row: require('./organised/1-standard/4-data/data-row'),
    Date_Picker: require('./organised/0-core/0-basic/0-native-compositional/date-picker'),
    Dropdown_List: require('./organised/0-core/0-basic/0-native-compositional/dropdown-list'),
    // Exclude the connected ones for the moment. Moment passed.
    // May not need to actually be 'connected'?
    //  Or other controls may get data connections too.
    File_Tree: require('./organised/1-standard/5-ui/file-tree'),
    File_Tree_Node: require('./organised/1-standard/5-ui/file-tree-node'),
    Icon: require('./organised/0-core/0-basic/0-native-compositional/icon'),
    Item: require('./organised/0-core/0-basic/1-compositional/item'),
    Item_Selector: require('./organised/0-core/0-basic/1-compositional/item-selector'),
    //Item_View: require('./old/item-view'),
    Left_Right_Arrows_Selector: require('./organised/1-standard/2-misc/left-right-arrows-selector'),
    //Vector: require('./vector'),
    Line_Chart: require('./organised/1-standard/5-ui/line-chart'),
    List: require('./organised/0-core/0-basic/1-compositional/list'),
    // could be in forms / standard forms.
    Login: require('./organised/0-core/1-advanced/login'),
    //Media_Scrubber: require('./media-scrubber'),
    Menu_Node: require('./organised/0-core/0-basic/1-compositional/menu-node'),
    Modal: require('./organised/1-standard/6-layout/modal'),
    Month_View: require('./organised/0-core/0-basic/1-compositional/month-view'),
    //Multi_Document_Interface: require('./multi-document-interface'),
    Multi_Layout_Mode: require('./organised/1-standard/6-layout/app/multi-layout-mode'),
    //Object_Editor: require('./editor/object'),
    Panel: require('./organised/1-standard/6-layout/panel'),
    Plus_Minus_Toggle_Button: require('./organised/0-core/0-basic/1-compositional/plus-minus-toggle-button'),
    Property_Editor: require('./organised/1-standard/1-editor/property_editor'),
    // More advanced functionality - may require more work to keep it with the right APIs.
    Popup_Menu_Button: require('./organised/0-core/1-advanced/popup-menu-button'),
    Radio_Button: require('./organised/0-core/0-basic/0-native-compositional/radio-button'),
    Radio_Button_Group: require('./organised/0-core/0-basic/1-compositional/radio-button-group'),
    //Resize_Handle: require('./organised/0-core/0-basic/_resize-handle'),
    Scroll_View: require('./organised/0-core/0-basic/1-compositional/scroll-view'),
    Scrollbar: require('./organised/0-core/0-basic/1-compositional/scrollbar'),
    Search_Bar: require('./organised/1-standard/5-ui/search-bar'),
    Select_Options: require('./organised/0-core/0-basic/0-native-compositional/Select_Options'),
    Single_Line: require('./organised/1-standard/6-layout/single-line'),
    Standard_Web_Page: require('./organised/1-standard/3-page/standard-web-page'),
    Start_Stop_Toggle_Button: require('./organised/1-standard/5-ui/start-stop-toggle-button'),
    String_Span: require('./organised/0-core/1-advanced/string-span'),
    Tabbed_Panel: require('./organised/1-standard/6-layout/tabbed-panel'),
    Text_Field: require('./organised/0-core/0-basic/1-compositional/Text_Field'),
    Text_Item: require('./organised/0-core/0-basic/1-compositional/text-item'),
    Text_Input: require('./organised/0-core/0-basic/0-native-compositional/Text_Input'),
    Tile_Slider: require('./organised/1-standard/6-layout/tile-slide'),
    // May be moved to vector?
    Timespan_Selector: require('./organised/0-core/0-basic/1-compositional/timespan-selector'),
    Title_Bar: require('./organised/1-standard/6-layout//title-bar'),
    Titled_Panel: require('./organised/1-standard/6-layout/titled-panel'),
    Toggle_Button: require('./organised/0-core/0-basic/1-compositional/toggle-button'),
    Toolbar: require('./organised/1-standard/5-ui/Toolbar'),
    Toolbox: require('./organised/1-standard/5-ui/toolbox'),
    Tree: require('./organised/1-standard/5-ui/tree'),
    Tree_Node: require('./organised/1-standard/5-ui/tree-node'),
    Vertical_Expander: require('./organised/1-standard/6-layout/vertical-expander'),
    Window: require('./organised/1-standard/6-layout/window'),//,
    //mx: require('../control_mixins/mx')
    Indicator: require('./organised/0-core/0-basic/1-compositional/Indicator'),
    Status_Indicator: require('./organised/0-core/0-basic/1-compositional/Status_Indicator'),
    Validation_Status_Indicator: require('./organised/0-core/0-basic/1-compositional/Validation_Status_Indicator')
}

// a show_validation_status mixin perhaps???
// though having a place in the control where it can display the validation status would be nice too.
//   The validation status of the view.model
//     view.model.validate perhaps ....?

// Though having the view model copy the data model, including data type and validation function.

//   Maybe do more applying validation status to Text_Input too?
//   Maybe make a control that contains both the DMVM Control as well as a validation status indicator.

// Being able to get a validation status indicator there for a control with as little top level code as possible will help.

// Could definitely do with improved html / xhtml like control parsing and composition.
//  Done the basics of it, may need to improve it to cover more cases.
//  Can use this to cut down on composition code.

// compose, render, activate, modify

module.exports = controls;
},{"./organised/0-core/0-basic/0-native-compositional/Select_Options":249,"./organised/0-core/0-basic/0-native-compositional/Text_Input":250,"./organised/0-core/0-basic/0-native-compositional/button":251,"./organised/0-core/0-basic/0-native-compositional/checkbox":252,"./organised/0-core/0-basic/0-native-compositional/date-picker":253,"./organised/0-core/0-basic/0-native-compositional/dropdown-list":254,"./organised/0-core/0-basic/0-native-compositional/file-upload":255,"./organised/0-core/0-basic/0-native-compositional/icon":256,"./organised/0-core/0-basic/0-native-compositional/radio-button":257,"./organised/0-core/0-basic/1-compositional/Cell":258,"./organised/0-core/0-basic/1-compositional/Dropdown_Menu":259,"./organised/0-core/0-basic/1-compositional/Indicator":260,"./organised/0-core/0-basic/1-compositional/Status_Indicator":261,"./organised/0-core/0-basic/1-compositional/Text_Field":262,"./organised/0-core/0-basic/1-compositional/Validation_Status_Indicator":263,"./organised/0-core/0-basic/1-compositional/color-palette":265,"./organised/0-core/0-basic/1-compositional/combo-box":266,"./organised/0-core/0-basic/1-compositional/context-menu":267,"./organised/0-core/0-basic/1-compositional/grid":268,"./organised/0-core/0-basic/1-compositional/item":270,"./organised/0-core/0-basic/1-compositional/item-selector":269,"./organised/0-core/0-basic/1-compositional/list":271,"./organised/0-core/0-basic/1-compositional/menu-node":272,"./organised/0-core/0-basic/1-compositional/month-view":273,"./organised/0-core/0-basic/1-compositional/plus-minus-toggle-button":274,"./organised/0-core/0-basic/1-compositional/radio-button-group":275,"./organised/0-core/0-basic/1-compositional/scroll-view":276,"./organised/0-core/0-basic/1-compositional/scrollbar":277,"./organised/0-core/0-basic/1-compositional/text-item":278,"./organised/0-core/0-basic/1-compositional/timespan-selector":279,"./organised/0-core/0-basic/1-compositional/toggle-button":280,"./organised/0-core/1-advanced/login":281,"./organised/0-core/1-advanced/popup-menu-button":282,"./organised/0-core/1-advanced/string-span":283,"./organised/0-core/1-advanced/vector/arrow-button":284,"./organised/1-standard/1-editor/form_field":285,"./organised/1-standard/1-editor/property_editor":286,"./organised/1-standard/2-misc/left-right-arrows-selector":287,"./organised/1-standard/3-page/standard-web-page":288,"./organised/1-standard/4-data/data-row":290,"./organised/1-standard/5-ui/Active_HTML_Document":291,"./organised/1-standard/5-ui/Toolbar":292,"./organised/1-standard/5-ui/audio-volume":293,"./organised/1-standard/5-ui/file-tree":295,"./organised/1-standard/5-ui/file-tree-node":294,"./organised/1-standard/5-ui/horizontal-menu":296,"./organised/1-standard/5-ui/horizontal-slider":297,"./organised/1-standard/5-ui/line-chart":298,"./organised/1-standard/5-ui/search-bar":299,"./organised/1-standard/5-ui/start-stop-toggle-button":300,"./organised/1-standard/5-ui/toolbox":301,"./organised/1-standard/5-ui/tree":303,"./organised/1-standard/5-ui/tree-node":302,"./organised/1-standard/6-layout//title-bar":310,"./organised/1-standard/6-layout/app/multi-layout-mode":304,"./organised/1-standard/6-layout/modal":305,"./organised/1-standard/6-layout/panel":306,"./organised/1-standard/6-layout/single-line":307,"./organised/1-standard/6-layout/tabbed-panel":308,"./organised/1-standard/6-layout/tile-slide":309,"./organised/1-standard/6-layout/titled-panel":311,"./organised/1-standard/6-layout/vertical-expander":312,"./organised/1-standard/6-layout/window":313}],249:[function(require,module,exports){
arguments[4][68][0].apply(exports,arguments)
},{"../../../../../html-core/html-core":335,"dup":68,"obext":382}],250:[function(require,module,exports){
arguments[4][69][0].apply(exports,arguments)
},{"../../../../../html-core/html-core":335,"dup":69,"obext":382}],251:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"../../../../../html-core/html-core":335,"dup":70}],252:[function(require,module,exports){
arguments[4][71][0].apply(exports,arguments)
},{"../../../../../html-core/html-core":335,"dup":71}],253:[function(require,module,exports){
arguments[4][72][0].apply(exports,arguments)
},{"../../../../../html-core/html-core":335,"dup":72,"obext":382}],254:[function(require,module,exports){
arguments[4][73][0].apply(exports,arguments)
},{"../../../../../html-core/html-core":335,"dup":73}],255:[function(require,module,exports){
arguments[4][74][0].apply(exports,arguments)
},{"../../../../../html-core/html-core":335,"../1-compositional/Text_Field":262,"./button":251,"dup":74}],256:[function(require,module,exports){
arguments[4][75][0].apply(exports,arguments)
},{"../../../../../html-core/html-core":335,"dup":75}],257:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"../../../../../html-core/html-core":335,"dup":76}],258:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"../../../../../control_mixins/selectable":243,"../../../../../html-core/html-core":335,"dup":77,"obext":382}],259:[function(require,module,exports){
arguments[4][78][0].apply(exports,arguments)
},{"../../../../../control_mixins/mx":237,"../../../../../html-core/html-core":335,"dup":78,"obext":382}],260:[function(require,module,exports){
arguments[4][79][0].apply(exports,arguments)
},{"../../../../../html-core/html-core":335,"dup":79}],261:[function(require,module,exports){
arguments[4][80][0].apply(exports,arguments)
},{"./Indicator":260,"dup":80}],262:[function(require,module,exports){
arguments[4][81][0].apply(exports,arguments)
},{"../../../../../control_mixins/mx":237,"../../../../../html-core/Data_Model_View_Model_Control":327,"../../../../../html-core/html-core":335,"../0-native-compositional/Text_Input":250,"./Validation_Status_Indicator":263,"./text-item":278,"dup":81,"lang-tools":364}],263:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"../../../../../html-core/Control_Validation":315,"./Status_Indicator":261,"dup":82}],264:[function(require,module,exports){
arguments[4][83][0].apply(exports,arguments)
},{"../../../../../html-core/html-core":335,"./grid":268,"dup":83,"obext":382}],265:[function(require,module,exports){
arguments[4][84][0].apply(exports,arguments)
},{"../../../../../html-core/arr_colors":331,"../../../../../html-core/html-core":335,"./color-grid":264,"dup":84,"obext":382}],266:[function(require,module,exports){
arguments[4][85][0].apply(exports,arguments)
},{"../../../../../html-core/html-core":335,"dup":85}],267:[function(require,module,exports){
arguments[4][86][0].apply(exports,arguments)
},{"../../../../../html-core/html-core":335,"./menu-node":272,"dup":86}],268:[function(require,module,exports){
arguments[4][87][0].apply(exports,arguments)
},{"../../../../../control_mixins/selectable":243,"../../../../../html-core/html-core":335,"./Cell":258,"dup":87,"obext":382}],269:[function(require,module,exports){
arguments[4][88][0].apply(exports,arguments)
},{"../../../../../control_mixins/popup":238,"../../../../../html-core/html-core":335,"./item":270,"./list":271,"dup":88}],270:[function(require,module,exports){
arguments[4][89][0].apply(exports,arguments)
},{"../../../../../html-core/html-core":335,"../0-native-compositional/icon":256,"dup":89,"obext":382}],271:[function(require,module,exports){
arguments[4][90][0].apply(exports,arguments)
},{"../../../../../control_mixins/selectable":243,"../../../../../html-core/html-core":335,"./item":270,"dup":90,"lang-tools":364}],272:[function(require,module,exports){
arguments[4][91][0].apply(exports,arguments)
},{"../../../../../html-core/html-core":335,"dup":91}],273:[function(require,module,exports){
arguments[4][92][0].apply(exports,arguments)
},{"../../../../../control_mixins/typed_data/date":247,"../../../../../html-core/html-core":335,"../../../1-standard/6-layout/tile-slide":309,"./grid":268,"dup":92}],274:[function(require,module,exports){
arguments[4][93][0].apply(exports,arguments)
},{"../../../../../html-core/html-core":335,"./toggle-button":280,"dup":93}],275:[function(require,module,exports){
arguments[4][94][0].apply(exports,arguments)
},{"../../../../../html-core/html-core":335,"../0-native-compositional/radio-button":257,"dup":94}],276:[function(require,module,exports){
arguments[4][95][0].apply(exports,arguments)
},{"../../../../../html-core/html-core":335,"./scrollbar":277,"dup":95}],277:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"../../../../../html-core/html-core":335,"../0-native-compositional/button":251,"dup":96}],278:[function(require,module,exports){
arguments[4][97][0].apply(exports,arguments)
},{"../../../../../html-core/html-core":335,"../../../../../html-core/text-node":339,"dup":97}],279:[function(require,module,exports){
arguments[4][98][0].apply(exports,arguments)
},{"../../../../../html-core/html-core":335,"dup":98}],280:[function(require,module,exports){
arguments[4][99][0].apply(exports,arguments)
},{"../../../../../html-core/html-core":335,"dup":99,"obext":382}],281:[function(require,module,exports){
arguments[4][100][0].apply(exports,arguments)
},{"../0-basic/1-compositional/Text_Field":262,"./../../../../html-core/html-core":335,"dup":100}],282:[function(require,module,exports){
arguments[4][101][0].apply(exports,arguments)
},{"../0-basic/0-native-compositional/button":251,"../0-basic/1-compositional/item":270,"./../../../../html-core/html-core":335,"dup":101}],283:[function(require,module,exports){
arguments[4][102][0].apply(exports,arguments)
},{"../0-basic/0-native-compositional/button":251,"./../../../../control_mixins/press-events":239,"./../../../../html-core/html-core":335,"dup":102,"obext":382}],284:[function(require,module,exports){
arguments[4][103][0].apply(exports,arguments)
},{"../../../../../html-core/html-core":335,"../../0-basic/0-native-compositional/button":251,"dup":103}],285:[function(require,module,exports){
/**
 * Form_Field - A composite control that combines label, input, and validation indicator
 * 
 * Features:
 * - Label with required indicator
 * - Input control (Text_Input, Checkbox, Dropdown_List, etc.)
 * - Validation status indicator
 * - Error message display
 * - Flexible input type support
 */

const Control = require('../../../../html-core/control');
const Text_Input = require('../../0-core/0-basic/0-native-compositional/Text_Input');
const Validation_Status_Indicator = require('../../0-core/0-basic/1-compositional/Validation_Status_Indicator');

class Form_Field extends Control {
    constructor(options = {}) {
        super(options);
        
        const { context } = options;
        
        // Configuration
        this.config = {
            label: options.label || '',
            name: options.name || '',
            type: options.type || 'text', // text, email, password, checkbox, select, textarea
            placeholder: options.placeholder || '',
            required: options.required || false,
            input_control: options.input_control || null, // Custom input control
            validator: options.validator || null
        };
        
        this.add_class('form-field');
        
        // Label container
        if (this.config.label) {
            this.label_container = new Control({ context, tag_name: 'div' });
            this.label_container.add_class('form-field-label-container');
            
            this.label = new Control({ context, tag_name: 'label' });
            this.label.add_class('form-field-label');
            this.label.add(this.config.label);
            
            if (this.config.required) {
                this.required_indicator = new Control({ context, tag_name: 'span' });
                this.required_indicator.add_class('required-indicator');
                this.required_indicator.add(' *');
                this.label.add(this.required_indicator);
            }
            
            this.label_container.add(this.label);
            this.add(this.label_container);
        }
        
        // Input container
        this.input_container = new Control({ context, tag_name: 'div' });
        this.input_container.add_class('form-field-input-container');
        
        // Create or use provided input control
        if (this.config.input_control) {
            this.input = this.config.input_control;
        } else {
            this.input = this._create_input_control(context);
        }
        
        this.input_container.add(this.input);
        
        // Validation indicator
        this.validation_indicator = new Validation_Status_Indicator({ context });
        this.validation_indicator.add_class('form-field-validation');
        this.input_container.add(this.validation_indicator);
        
        this.add(this.input_container);
        
        // Error message
        this.error_message = new Control({ context, tag_name: 'div' });
        this.error_message.add_class('form-field-error');
        this.add(this.error_message);
    }
    
    _create_input_control(context) {
        const { type, placeholder, name } = this.config;
        
        switch (type) {
            case 'text':
            case 'email':
            case 'password':
            case 'number':
            case 'url':
            case 'tel':
                const input = new Text_Input({ context });
                input.dom.attributes.type = type;
                input.dom.attributes.name = name;
                if (placeholder) input.dom.attributes.placeholder = placeholder;
                return input;
                
            case 'textarea':
                const textarea = new Control({ context, tag_name: 'textarea' });
                textarea.dom.attributes.name = name;
                if (placeholder) textarea.dom.attributes.placeholder = placeholder;
                textarea.add_class('form-textarea');
                return textarea;
                
            case 'checkbox':
                const checkbox = new Control({ context, tag_name: 'input' });
                checkbox.dom.attributes.type = 'checkbox';
                checkbox.dom.attributes.name = name;
                checkbox.add_class('form-checkbox');
                return checkbox;
                
            case 'select':
                const select = new Control({ context, tag_name: 'select' });
                select.dom.attributes.name = name;
                select.add_class('form-select');
                return select;
                
            default:
                return new Text_Input({ context });
        }
    }
    
    /**
     * Set the field value
     */
    set_value(value) {
        const { type } = this.config;
        
        if (type === 'checkbox') {
            this.input.dom.el.checked = !!value;
        } else if (type === 'select') {
            this.input.dom.el.value = value;
        } else {
            this.input.dom.el.value = value || '';
        }
    }
    
    /**
     * Get the field value
     */
    get_value() {
        const { type } = this.config;
        
        if (type === 'checkbox') {
            return this.input.dom.el.checked;
        } else {
            return this.input.dom.el.value;
        }
    }
    
    /**
     * Set validation state
     */
    set_validation(is_valid, error_message = '') {
        if (is_valid) {
            this.validation_indicator.set_status('valid');
            this.error_message.content.clear();
            this.remove_class('has-error');
        } else {
            this.validation_indicator.set_status('invalid');
            this.error_message.content.clear();
            this.error_message.add(error_message);
            this.add_class('has-error');
        }
    }
    
    /**
     * Clear validation state
     */
    clear_validation() {
        this.validation_indicator.set_status('neutral');
        this.error_message.content.clear();
        this.remove_class('has-error');
    }
    
    /**
     * Enable/disable the field
     */
    set_enabled(enabled) {
        this.input.dom.el.disabled = !enabled;
        if (enabled) {
            this.remove_class('disabled');
        } else {
            this.add_class('disabled');
        }
    }
}

module.exports = Form_Field;

},{"../../../../html-core/control":334,"../../0-core/0-basic/0-native-compositional/Text_Input":250,"../../0-core/0-basic/1-compositional/Validation_Status_Indicator":263}],286:[function(require,module,exports){
/**
 * Property_Editor - A panel for editing properties of selected items
 * 
 * Features:
 * - Dynamic property fields based on item type
 * - Label, placeholder, required, validation editing
 * - Real-time updates
 * - Type-specific editors
 */

const Panel = require('../6-layout/panel');
const Control = require('../../../../html-core/control');
const Text_Input = require('../../0-core/0-basic/0-native-compositional/Text_Input');
const Checkbox = require('../../0-core/0-basic/0-native-compositional/checkbox');

class Property_Editor extends Panel {
    constructor(options = {}) {
        super(options);
        
        this.add_class('property-editor');
        
        const { context } = this;
        
        // Header
        this.header = new Control({ context, tag_name: 'div' });
        this.header.add_class('property-editor-header');
        this.header_title = new Control({ context, tag_name: 'h3' });
        this.header_title.add('Properties');
        this.header.add(this.header_title);
        this.add(this.header);
        
        // Properties container
        this.properties_container = new Control({ context, tag_name: 'div' });
        this.properties_container.add_class('property-editor-properties');
        this.add(this.properties_container);
        
        // No selection message
        this.no_selection_message = new Control({ context, tag_name: 'div' });
        this.no_selection_message.add_class('property-editor-no-selection');
        this.no_selection_message.add('Select a field to edit its properties');
        this.properties_container.add(this.no_selection_message);
        
        this.current_item = null;
        this.property_fields = {};
    }
    
    /**
     * Load properties for an item
     */
    load_item(item, on_change) {
        this.current_item = item;
        this.on_change = on_change;
        this.property_fields = {};
        
        // Clear container
        this.properties_container.content.clear();
        
        if (!item) {
            this.properties_container.add(this.no_selection_message);
            return;
        }
        
        const { context } = this;
        const properties = item.properties || {};
        
        // Field Type (read-only)
        this._add_property_group(context, 'Field Type', properties.type || 'text', null, true);
        
        // Label
        this._add_property_group(context, 'Label', properties.label || '', (value) => {
            properties.label = value;
            if (this.on_change) this.on_change();
        });
        
        // Name/ID
        this._add_property_group(context, 'Name/ID', properties.name || '', (value) => {
            properties.name = value;
            if (this.on_change) this.on_change();
        });
        
        // Placeholder (for text inputs)
        if (['text', 'email', 'password', 'number', 'url', 'tel', 'textarea'].includes(properties.type)) {
            this._add_property_group(context, 'Placeholder', properties.placeholder || '', (value) => {
                properties.placeholder = value;
                if (this.on_change) this.on_change();
            });
        }
        
        // Required
        this._add_property_checkbox(context, 'Required', properties.required || false, (checked) => {
            properties.required = checked;
            if (this.on_change) this.on_change();
        });
        
        // Options (for select fields)
        if (properties.type === 'select') {
            this._add_property_group(context, 'Options (comma-separated)', 
                (properties.options || []).join(', '), 
                (value) => {
                    properties.options = value.split(',').map(s => s.trim()).filter(s => s);
                    if (this.on_change) this.on_change();
                }
            );
        }
        
        // Width
        this._add_property_group(context, 'Width (%)', properties.width || '100', (value) => {
            properties.width = value;
            if (this.on_change) this.on_change();
        });
        
        // Delete button
        const delete_btn = new Control({ context, tag_name: 'button' });
        delete_btn.add_class('property-editor-delete-btn');
        delete_btn.add('Delete Field');
        delete_btn.on('click', () => {
            if (this.on_delete) this.on_delete(item);
        });
        this.properties_container.add(delete_btn);
    }
    
    _add_property_group(context, label, value, on_change, read_only = false) {
        const group = new Control({ context, tag_name: 'div' });
        group.add_class('property-group');
        
        const label_el = new Control({ context, tag_name: 'label' });
        label_el.add_class('property-label');
        label_el.add(label);
        group.add(label_el);
        
        const input = new Text_Input({ context });
        input.add_class('property-input');
        input.dom.el.value = value;
        if (read_only) input.dom.el.disabled = true;
        
        if (on_change && !read_only) {
            input.on('input', () => {
                on_change(input.dom.el.value);
            });
        }
        
        group.add(input);
        this.properties_container.add(group);
        
        this.property_fields[label] = input;
        
        return group;
    }
    
    _add_property_checkbox(context, label, checked, on_change) {
        const group = new Control({ context, tag_name: 'div' });
        group.add_class('property-group');
        group.add_class('property-group-checkbox');
        
        const checkbox = new Checkbox({ context });
        checkbox.add_class('property-checkbox');
        checkbox.dom.el.checked = checked;
        
        if (on_change) {
            checkbox.on('change', () => {
                on_change(checkbox.dom.el.checked);
            });
        }
        
        const label_el = new Control({ context, tag_name: 'label' });
        label_el.add_class('property-label');
        label_el.add(label);
        
        group.add(checkbox);
        group.add(label_el);
        this.properties_container.add(group);
        
        this.property_fields[label] = checkbox;
        
        return group;
    }
    
    /**
     * Set the delete callback
     */
    set_on_delete(callback) {
        this.on_delete = callback;
    }
}

module.exports = Property_Editor;

},{"../../../../html-core/control":334,"../../0-core/0-basic/0-native-compositional/Text_Input":250,"../../0-core/0-basic/0-native-compositional/checkbox":252,"../6-layout/panel":306}],287:[function(require,module,exports){
arguments[4][104][0].apply(exports,arguments)
},{"../../../../html-core/html-core":335,"../../0-core/0-basic/1-compositional/item-selector":269,"../../0-core/1-advanced/vector/arrow-button":284,"dup":104}],288:[function(require,module,exports){
arguments[4][105][0].apply(exports,arguments)
},{"../../../../html-core/html-core":335,"dup":105}],289:[function(require,module,exports){
arguments[4][106][0].apply(exports,arguments)
},{"./../../../../html-core/html-core":335,"dup":106}],290:[function(require,module,exports){
arguments[4][107][0].apply(exports,arguments)
},{"./../../../../html-core/html-core":335,"./data-item":289,"dup":107}],291:[function(require,module,exports){
arguments[4][108][0].apply(exports,arguments)
},{"../../../../html-core/html-core":335,"dup":108}],292:[function(require,module,exports){
/**
 * Toolbar - A horizontal container for tool buttons and controls
 * 
 * Features:
 * - Horizontal layout with flexible items
 * - Separators between groups
 * - Icon + text buttons
 * - Tooltips
 */

const Control = require('../../../../html-core/control');
const Button = require('../../0-core/0-basic/0-native-compositional/button');

class Toolbar extends Control {
    constructor(options = {}) {
        super(options);
        
        this.add_class('toolbar');
        
        if (options.orientation === 'vertical') {
            this.add_class('toolbar-vertical');
        } else {
            this.add_class('toolbar-horizontal');
        }
        
        this.items = [];
    }
    
    /**
     * Add a button to the toolbar
     */
    addButton(config) {
        const { context } = this;
        const button = new Button({ context });
        button.add_class('toolbar-button');
        
        if (config.icon) {
            const icon = new Control({ context, tag_name: 'span' });
            icon.add_class('toolbar-button-icon');
            icon.add(config.icon);
            button.add(icon);
        }
        
        if (config.label) {
            const label = new Control({ context, tag_name: 'span' });
            label.add_class('toolbar-button-label');
            label.add(config.label);
            button.add(label);
        }
        
        if (config.tooltip) {
            button.dom.attributes.title = config.tooltip;
        }
        
        if (config.onClick) {
            button.on('click', config.onClick);
        }
        
        this.add(button);
        this.items.push(button);
        
        return button;
    }
    
    /**
     * Add a separator
     */
    addSeparator() {
        const { context } = this;
        const separator = new Control({ context, tag_name: 'div' });
        separator.add_class('toolbar-separator');
        this.add(separator);
        this.items.push(separator);
        return separator;
    }
    
    /**
     * Add a spacer (flexible space)
     */
    addSpacer() {
        const { context } = this;
        const spacer = new Control({ context, tag_name: 'div' });
        spacer.add_class('toolbar-spacer');
        this.add(spacer);
        this.items.push(spacer);
        return spacer;
    }
    
    /**
     * Add any custom control
     */
    addControl(control) {
        control.add_class('toolbar-item');
        this.add(control);
        this.items.push(control);
        return control;
    }
    
    /**
     * Clear all items
     */
    clear() {
        this.content.clear();
        this.items = [];
    }
}

module.exports = Toolbar;

},{"../../../../html-core/control":334,"../../0-core/0-basic/0-native-compositional/button":251}],293:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"./../../../../html-core/html-core":335,"./horizontal-slider":297,"dup":109}],294:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"./../../../../html-core/html-core":335,"./tree-node":302,"dup":110}],295:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./../../../../html-core/html-core":335,"./../../1-standard/5-ui/tree":303,"dup":111}],296:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"../../../../html-core/html-core":335,"../../0-core/0-basic/1-compositional/menu-node":272,"dup":112}],297:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"./../../../../control_mixins/dragable":234,"./../../../../html-core/html-core":335,"dup":113,"obext":382}],298:[function(require,module,exports){
arguments[4][114][0].apply(exports,arguments)
},{"../../../../html-core/html-core":335,"dup":114}],299:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"./../../../../html-core/html-core":335,"dup":115,"obext":382}],300:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"../../0-core/0-basic/1-compositional/toggle-button":280,"./../../../../html-core/html-core":335,"dup":116}],301:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"./../../../../html-core/html-core":335,"dup":117,"obext":382}],302:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./../../../../control_mixins/selectable":243,"./../../../../html-core/html-core":335,"./../../0-core/0-basic/1-compositional/plus-minus-toggle-button":274,"./../6-layout/vertical-expander":312,"dup":118,"obext":382}],303:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"./../../../../html-core/html-core":335,"./../6-layout/panel":306,"./../6-layout/title-bar":310,"./tree-node":302,"dup":119,"obext":382}],304:[function(require,module,exports){
arguments[4][120][0].apply(exports,arguments)
},{"../panel":306,"../tabbed-panel":308,"./../../../../../html-core/html-core":335,"dup":120}],305:[function(require,module,exports){
arguments[4][121][0].apply(exports,arguments)
},{"./../../../../html-core/html-core":335,"dup":121}],306:[function(require,module,exports){
arguments[4][122][0].apply(exports,arguments)
},{"./../../../../html-core/html-core":335,"dup":122}],307:[function(require,module,exports){
arguments[4][123][0].apply(exports,arguments)
},{"./../../../../html-core/html-core":335,"dup":123}],308:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"../../0-core/0-basic/0-native-compositional/radio-button":257,"../../0-core/0-basic/1-compositional/list":271,"../../0-core/0-basic/1-compositional/radio-button-group":275,"./../../../../control_mixins/selectable":243,"./../../../../html-core/html-core":335,"./panel":306,"dup":124}],309:[function(require,module,exports){
arguments[4][125][0].apply(exports,arguments)
},{"./../../../../html-core/html-core":335,"dup":125,"fnl":6}],310:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"./../../../../html-core/html-core":335,"dup":126}],311:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"./../../../../html-core/html-core":335,"./panel":306,"./title-bar":310,"dup":127}],312:[function(require,module,exports){
arguments[4][128][0].apply(exports,arguments)
},{"./../../../../html-core/html-core":335,"dup":128,"obext":382}],313:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"../../../../control_mixins/mx":237,"./../../../../html-core/html-core":335,"./../../../organised/1-standard/5-ui/horizontal-menu":296,"dup":129}],314:[function(require,module,exports){
arguments[4][130][0].apply(exports,arguments)
},{"./Data":326,"dup":130,"lang-tools":364}],315:[function(require,module,exports){
arguments[4][131][0].apply(exports,arguments)
},{"./Control_Validation_Data":316,"./Control_Validation_Target":317,"./Control_Validation_Validator":318,"./Validation_State":330,"dup":131,"lang-tools":364}],316:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"./Data":326,"dup":132,"lang-tools":364}],317:[function(require,module,exports){
arguments[4][133][0].apply(exports,arguments)
},{"dup":133,"lang-tools":364}],318:[function(require,module,exports){
arguments[4][134][0].apply(exports,arguments)
},{"dup":134,"lang-tools":364}],319:[function(require,module,exports){
arguments[4][135][0].apply(exports,arguments)
},{"./Control_View_Data":320,"./Control_View_Low_Level":321,"./Control_View_UI":323,"./Data":326,"dup":135,"lang-tools":364}],320:[function(require,module,exports){
arguments[4][136][0].apply(exports,arguments)
},{"./Control_Data":314,"dup":136}],321:[function(require,module,exports){
arguments[4][137][0].apply(exports,arguments)
},{"./Control_View_Low_Level_Data":322,"dup":137,"lang-tools":364}],322:[function(require,module,exports){
arguments[4][138][0].apply(exports,arguments)
},{"./Control_Data":314,"dup":138}],323:[function(require,module,exports){
arguments[4][139][0].apply(exports,arguments)
},{"./Control_View_UI_Low_Level":324,"dup":139,"lang-tools":364}],324:[function(require,module,exports){
arguments[4][140][0].apply(exports,arguments)
},{"./Control_View_UI_Low_Level_Data":325,"dup":140,"lang-tools":364}],325:[function(require,module,exports){
arguments[4][141][0].apply(exports,arguments)
},{"./Control_Data":314,"dup":141}],326:[function(require,module,exports){
arguments[4][142][0].apply(exports,arguments)
},{"dup":142,"lang-tools":364}],327:[function(require,module,exports){

const Ctrl_Enh = require('./control-enh');

const {Data_Object} = require('lang-tools');
const {ModelBinder, ComputedProperty, PropertyWatcher, BindingManager} = require('./ModelBinder');
const {Transformations, Validators} = require('./Transformations');

// Quite a lot of the standard controls should become this.
//   It should provide mechanisms for the app to efficiently process and pass on updates at the various different stages.
//   Want to work both with well defined app data models, as well has having them created simply / automatically to 
//     facilitate easy (to code) sharing of data between different parts of the app, and easy to code data persistance and update
//     operations.

// A server side data model could replay changes and then update the DB as necessary.
//   Could undo changes too (if history is stored).

// These two models would help a lot when it comes to the app state history.
//   eg don't undo maximising and minimising windows within the app, but also have a good way to save the state (automatically essentially).


// Can have fairly complex code on lower and especially mid levels, but the high level code should be simple and cleary express what's being done
//   though also allowing for shorthands that would not be as readable but would be more compact.
// Could maybe search and replace on building to use the shorthand forms instead, maybe even replace the functions with the
//   long form names (though that would likely be a day or two's work at least)

const Control_Data = require('./Control_Data');
const Control_View = require('./Control_View');

// Possibly not so much to do here right now???

// Maybe will use this to make some other controls more concise.

// Maybe make both Data_Model_View_Model_Control_Single_Value
//   and Data_Model_View_Model_Control_Multi_Value_Data_Object
//         so it would have properties available with string keys.
//   maybe also make some kind(s) of Collection or Array holding data models.



// Not totally sure what interface / conventions this should be using and expressing for the moment.
//   Would like to make it really easy to base controls that have both a data model and view model on this.

// May also be important sending or properly recreating the data / view model on the client-side.
//   Having them made in the constructor from lang-tools classes could be effective.
//     Then would be recreated automatically and identically on the client-side.

// Likely do want a Data_Value subclass that represents the application's Data_Model.
//   And this Data_Value subclass for the moment could just set up the functional data type as a validator.

// new Data_Value(value_to_wrap, data_type);






// Both want to get this Data base type control working, as well as get the pattern well finessed to implement
//   directly into a control.
// Then will be able to use either.
//   May then work on improved abstractions.


// Will make some kind of multi-model mixin.

// Data, View Data, Composition, Data Representation

// Maybe there are 5 different models there.



// Likely will deprecate this, and use the more complicated mixin, which currently is called in the ctrl-enh constructor.
//   Will try making it available and useful at a low level, but may later restrict when it gets used / set up for perf reasons.
//   However, the more complex system of multiple models may help controls to be specified and used much more easily.
//     Lower and mid levels will handle complexity, high level code can be really clear and concise about the data and its
//       representation using controls in the GUI.



// Likely want to retire this soon...?
// Possibly redo the Text_Field control or whichever controls use this for the moment.
//   Though making use of the compositional model makes a lot more sense for the moment.





class Data_Model_View_Model_Control extends Ctrl_Enh {
    constructor(...a) {
        super(...a);

        const spec = a[0] || {};
        
        // Initialize binding manager
        this._binding_manager = new BindingManager(this);
        // Possibly set up both models here, but should look out for data and view models in the spec.

        // Also, look out for it in pre_activate I think. Would be good to reconnect those models here.

        // Would also need to add the appropriate .dom.attributes['data-jsgui-view-model']
        //                                        .dom.attributes['data-jsgui-data-model']

        // 
        //console.log('');
        //console.log('construct Data_Model_View_Model_Control');


        const {context} = this;

        // spec.view
        // spec.data

        // and would both need 'model' properties???
        //   does seem best for the moment to make it really explicit.

        // But then recognising and passing on changes...?
        //   Should work when not activated if possible.

        // Though seems like it would need a bit more code in the higher level classes.
        // Possibly more in intialisation, telling it what property names to use.
        //   Though could default to 'value' to allow easy sharing between 2 or more objects where it's just one
        //     value that gets shared.


        // Probably need to set up fields / change events on the model objects.

        // Could try it with 'value' hardcoded here???

        //  Or take the 'fields' in the spec???

        // With the Text_Field (and Text_Input) will need to have it change the Data Model appropriately.
        //   Maybe could have a decent default for it, but explicitly set it as well with a short string eg 'onexit' or 'exit' or 'leave'
        // But would more likely want an 'cancel | confirm' non-modal popup, and control the positioning of that popup.
        //   Likely to want it just below in this example.

        // This can likely be very effective....


        if (spec.data) {
            this.data = new Control_Data();
            if (spec.data.model) {
                this.data.model = spec.data.model;

                this.data.model.on('change', e => {
                    console.log('Data_Model_View_Model_Control this.data.model change e:', e);

                    // Set the view model here???


                })

                this.dom.attributes['data-jsgui-data-model'] = this.data.model._id();
            }
        }
        if (spec.view) {
            this.view = new Control_View();

            // 

            // data-jsgui-view-data-model
            //   does seem like it would be worth being able to get that....
            //     (even back from the context)
            //   but maybe the view data model should (only) be internal to this (for the moment?)

            // Maybe do need to / best to register these controls in the context.
            //  


            if (!spec.view.data) {
                // create new view data model.

                const view_data_model = new Data_Object({context});
                this.view.data = {
                    model: view_data_model
                }
            } else {
                this.view.data = spec.view.data;

                if (!this.view.data.model) {
                    this.view.data.model = new Data_Object({context});
                }

            }



            if (this.view.data.model) {

                this.view.data.model.on('change', e => {
                    console.log('Data_Model_View_Model_Control this.view.data.model change e:', e);
                })

                this.dom.attributes['data-jsgui-view-data-model'] = this.view.data.model._id();
            }
            // Could create other internal view.data???





            // view.data.model????
            if (spec.view.model) {
                this.view.model = spec.view.model;
                this.view.model.on('change', e => {
                    console.log('Data_Model_View_Model_Control this.view.model change e:', e);
                });
                this.dom.attributes['data-jsgui-view-model'] = this.view.model._id();
            }

            // Otherwise create new internal view model?

            

        }

        //console.log('Data_Model_View_Model_Control !!this.dom.el', !!this.dom.el);

        if (this.dom.el) {

            const context_keys = Array.from(Object.keys(this.context));
            //console.log('context_keys', context_keys);

            const context_map_controls_keys = Array.from(Object.keys(this.context.map_controls));
            //console.log('context_map_controls_keys', context_map_controls_keys);

            if (this.dom.el.hasAttribute('data-jsgui-data-model')) {
                const data_model_jsgui_id = this.dom.el.getAttribute('data-jsgui-data-model');

                //console.log('Data_Model_View_Model_Control data_model_jsgui_id:', data_model_jsgui_id);

                const data_model = this.context.map_controls[data_model_jsgui_id];

                //console.log('Data_Model_View_Model_Control !!data_model', !!data_model);

                if (data_model) {
                    this.data = this.data || new Control_Data({context});

                    //console.log('Data_Model_View_Model_Control pre assign this.data.model');
                    //console.log('data_model', data_model);
                    this.data.model = data_model;
                    //console.log('post assign this.data.model\n');
                }

                


                // Then set up the syncing here????

                //   If the data model changes, set the .value field....?


                data_model.on('change', e => {
                    //console.log('Data_Model_View_Model_Control data_model change', e);
                })
            }


            // And if it does not have that attribute, create its own internal view model.




            if (this.dom.el.hasAttribute('data-jsgui-view-model')) {
                this.view = this.view || new Control_View({context});
                const view_model_jsgui_id = this.dom.el.getAttribute('data-jsgui-view-model');

                //console.log('Data_Model_View_Model_Control view_model_jsgui_id:', view_model_jsgui_id);

                // then get it from the context.

                const view_model = this.context.map_controls[view_model_jsgui_id];

                if (!!view_model) {
                    this.view.model = view_model;

                    view_model.on('change', e => {
                        //console.log('Data_Model_View_Model_Control view_model change', e);
                    });
                } else {
                    //console.log('Data_Model_View_Model_Control missing view_model (not found at this.context.map_controls[view_model_jsgui_id])');
                }

                
                

                // Load the view model at the very beginning???


                // But in the activated part it would need to change the model???
                //   Not necessarily.
                //   It could change that in respond to the field changing.
                //     Then would change the view model in response to the that data model change.
                //     Then would update the DOM in response to the view model change (would have to be the responsibility of the
                //       specific control I think???)

                


            } else {
                //console.log('Data_Model_View_Model_Control with el lacks view model, need to make one');
                this.view = this.view || {};
                this.view.model = new Data_Object({
                    context
                });



            }
        }
    }
    pre_activate() {
        super.pre_activate();


        // re-assign the .data.model and .view.model if they are available....

        // These models would need to exist within the Page_Context.
        //   That probably should be the case, working isomorphically.
        //     Model creation would be within the Page_Context.





        console.log('Data_Model_View_Model_Control pre_activate complete');

        // should be able to access own data_model???


    }
    
    /**
     * Create a binding between data model and view model
     * @param {Object} bindings - Property binding definitions
     * @param {Object} options - Binding options
     * @example
     * this.bind({
     *     'date': {
     *         to: 'formattedDate',
     *         transform: (date) => formatDate(date, 'YYYY-MM-DD'),
     *         reverse: (str) => parseDate(str)
     *     }
     * });
     */
    bind(bindings, options = {}) {
        if (!this.data || !this.data.model) {
            console.warn('Data_Model_View_Model_Control.bind: No data.model available');
            return null;
        }
        
        if (!this.view || !this.view.data || !this.view.data.model) {
            console.warn('Data_Model_View_Model_Control.bind: No view.data.model available');
            return null;
        }
        
        return this._binding_manager.bind(
            this.data.model,
            this.view.data.model,
            bindings,
            options
        );
    }
    
    /**
     * Create a computed property on a model
     * @param {Object} model - Target model (data.model or view.data.model)
     * @param {Array|string} dependencies - Property names to watch
     * @param {Function} computeFn - Function to compute the value
     * @param {Object} options - Options including propertyName
     * @example
     * this.computed(this.view.data.model, ['firstName', 'lastName'], 
     *     (first, last) => `${first} ${last}`,
     *     { propertyName: 'fullName' }
     * );
     */
    computed(model, dependencies, computeFn, options = {}) {
        return this._binding_manager.createComputed(model, dependencies, computeFn, options);
    }
    
    /**
     * Watch a property for changes
     * @param {Object} model - Model to watch
     * @param {string} property - Property name to watch
     * @param {Function} callback - Callback function (newVal, oldVal) => void
     * @param {Object} options - Watch options
     * @example
     * this.watch(this.data.model, 'selectedItem', (newVal, oldVal) => {
     *     console.log('Selection changed:', oldVal, '→', newVal);
     * });
     */
    watch(model, property, callback, options = {}) {
        return this._binding_manager.watch(model, property, callback, options);
    }
    
    /**
     * Get transformations library
     */
    get transforms() {
        return Transformations;
    }
    
    /**
     * Get validators library
     */
    get validators() {
        return Validators;
    }
    
    /**
     * Inspect all bindings for debugging
     */
    inspectBindings() {
        return this._binding_manager.inspect();
    }
    
    /**
     * Cleanup bindings when control is destroyed
     */
    destroy() {
        if (this._binding_manager) {
            this._binding_manager.cleanup();
        }
        if (super.destroy) {
            super.destroy();
        }
    }
}

module.exports = Data_Model_View_Model_Control;
},{"./Control_Data":314,"./Control_View":319,"./ModelBinder":328,"./Transformations":329,"./control-enh":333,"lang-tools":364}],328:[function(require,module,exports){
const { Data_Object, Data_Value, tof, each } = require('lang-tools');

/**
 * ModelBinder - Provides declarative two-way data binding between models
 * 
 * Key Features:
 * - Bidirectional binding between data model and view model
 * - Transformation functions for data conversion
 * - Support for computed properties
 * - Automatic cleanup of event listeners
 * - Debugging and inspection capabilities
 * 
 * @example
 * const binder = new ModelBinder(dataModel, viewModel, {
 *     'date': {
 *         to: 'formattedDate',
 *         transform: (date) => formatDate(date),
 *         reverse: (str) => parseDate(str)
 *     }
 * });
 */
class ModelBinder {
    constructor(sourceModel, targetModel, bindings = {}, options = {}) {
        this.sourceModel = sourceModel;
        this.targetModel = targetModel;
        this.bindings = bindings;
        this.options = Object.assign({
            bidirectional: true,
            immediate: true,
            debug: false
        }, options);
        
        this._listeners = [];
        this._active = false;
        
        if (this.options.immediate) {
            this.activate();
        }
    }
    
    /**
     * Activate all bindings
     */
    activate() {
        if (this._active) return;
        this._active = true;
        
        each(this.bindings, (binding, sourceProp) => {
            this._setupBinding(sourceProp, binding);
        });
        
        if (this.options.debug) {
            console.log('[ModelBinder] Activated bindings:', Object.keys(this.bindings));
        }
    }
    
    /**
     * Deactivate all bindings and cleanup listeners
     */
    deactivate() {
        if (!this._active) return;
        this._active = false;
        
        this._listeners.forEach(({ model, event, handler }) => {
            if (model && model.off) {
                model.off(event, handler);
            }
        });
        
        this._listeners = [];
        
        if (this.options.debug) {
            console.log('[ModelBinder] Deactivated bindings');
        }
    }
    
    /**
     * Setup a single binding between source and target properties
     * @private
     */
    _setupBinding(sourceProp, binding) {
        const targetProp = typeof binding === 'string' ? binding : binding.to;
        const transform = binding.transform;
        const reverse = binding.reverse;
        const condition = binding.condition;
        
        // Initial sync from source to target
        if (this.sourceModel[sourceProp] !== undefined) {
            const value = this.sourceModel[sourceProp];
            const transformedValue = transform ? transform(value) : value;
            
            if (!condition || condition(value)) {
                this.targetModel[targetProp] = transformedValue;
            }
        }
        
        // Setup source → target binding
        const sourceHandler = (e) => {
            if (e.name === sourceProp) {
                const value = e.value;
                const transformedValue = transform ? transform(value) : value;
                
                if (!condition || condition(value)) {
                    this.targetModel[targetProp] = transformedValue;
                    
                    if (this.options.debug) {
                        console.log(`[ModelBinder] ${sourceProp} → ${targetProp}:`, value, '→', transformedValue);
                    }
                }
            }
        };
        
        this.sourceModel.on('change', sourceHandler);
        this._listeners.push({
            model: this.sourceModel,
            event: 'change',
            handler: sourceHandler
        });
        
        // Setup target → source binding (if bidirectional)
        if (this.options.bidirectional && reverse) {
            const targetHandler = (e) => {
                if (e.name === targetProp) {
                    const value = e.value;
                    const reversedValue = reverse(value);
                    
                    if (!condition || condition(reversedValue)) {
                        this.sourceModel[sourceProp] = reversedValue;
                        
                        if (this.options.debug) {
                            console.log(`[ModelBinder] ${targetProp} ← ${sourceProp}:`, value, '←', reversedValue);
                        }
                    }
                }
            };
            
            this.targetModel.on('change', targetHandler);
            this._listeners.push({
                model: this.targetModel,
                event: 'change',
                handler: targetHandler
            });
        }
    }
    
    /**
     * Update a specific binding manually
     */
    updateBinding(sourceProp) {
        const binding = this.bindings[sourceProp];
        if (!binding) return;
        
        const targetProp = typeof binding === 'string' ? binding : binding.to;
        const transform = binding.transform;
        
        const value = this.sourceModel[sourceProp];
        const transformedValue = transform ? transform(value) : value;
        this.targetModel[targetProp] = transformedValue;
    }
    
    /**
     * Get current binding state for inspection
     */
    inspect() {
        const state = {};
        
        each(this.bindings, (binding, sourceProp) => {
            const targetProp = typeof binding === 'string' ? binding : binding.to;
            state[sourceProp] = {
                target: targetProp,
                sourceValue: this.sourceModel[sourceProp],
                targetValue: this.targetModel[targetProp],
                hasTransform: !!binding.transform,
                hasReverse: !!binding.reverse,
                bidirectional: this.options.bidirectional && !!binding.reverse
            };
        });
        
        return state;
    }
}

/**
 * ComputedProperty - A property that automatically updates based on dependencies
 * 
 * @example
 * const fullName = new ComputedProperty(
 *     model,
 *     ['firstName', 'lastName'],
 *     (first, last) => `${first} ${last}`
 * );
 */
class ComputedProperty {
    constructor(model, dependencies, computeFn, options = {}) {
        this.model = model;
        this.dependencies = Array.isArray(dependencies) ? dependencies : [dependencies];
        this.computeFn = computeFn;
        this.options = Object.assign({
            propertyName: 'computed',
            immediate: true,
            debug: false
        }, options);
        
        this._listeners = [];
        this._active = false;
        this._lastValue = undefined;
        
        if (this.options.immediate) {
            this.activate();
        }
    }
    
    activate() {
        if (this._active) return;
        this._active = true;
        
        // Compute initial value
        this.compute();
        
        // Setup listeners for dependencies
        const handler = (e) => {
            if (this.dependencies.includes(e.name)) {
                this.compute();
            }
        };
        
        this.model.on('change', handler);
        this._listeners.push({ model: this.model, event: 'change', handler });
        
        if (this.options.debug) {
            console.log('[ComputedProperty] Activated for dependencies:', this.dependencies);
        }
    }
    
    deactivate() {
        if (!this._active) return;
        this._active = false;
        
        this._listeners.forEach(({ model, event, handler }) => {
            if (model && model.off) {
                model.off(event, handler);
            }
        });
        
        this._listeners = [];
    }
    
    compute() {
        const args = this.dependencies.map(dep => this.model[dep]);
        const newValue = this.computeFn(...args);
        
        if (newValue !== this._lastValue) {
            this._lastValue = newValue;
            this.model[this.options.propertyName] = newValue;
            
            if (this.options.debug) {
                console.log('[ComputedProperty] Updated:', this.options.propertyName, '=', newValue);
            }
        }
        
        return newValue;
    }
    
    get value() {
        return this._lastValue;
    }
}

/**
 * PropertyWatcher - Watch for changes to specific properties
 * 
 * @example
 * const watcher = new PropertyWatcher(model, 'selectedItem', (newVal, oldVal) => {
 *     console.log('Selection changed:', oldVal, '→', newVal);
 * });
 */
class PropertyWatcher {
    constructor(model, property, callback, options = {}) {
        this.model = model;
        this.property = property;
        this.callback = callback;
        this.options = Object.assign({
            immediate: false,
            deep: false,
            debug: false
        }, options);
        
        this._handler = null;
        this._active = false;
        
        this.activate();
    }
    
    activate() {
        if (this._active) return;
        this._active = true;
        
        // Call immediately if requested
        if (this.options.immediate && this.model[this.property] !== undefined) {
            this.callback(this.model[this.property], undefined);
        }
        
        // Setup change listener
        this._handler = (e) => {
            if (e.name === this.property) {
                this.callback(e.value, e.old);
                
                if (this.options.debug) {
                    console.log('[PropertyWatcher] Property changed:', this.property, e.old, '→', e.value);
                }
            }
        };
        
        this.model.on('change', this._handler);
    }
    
    deactivate() {
        if (!this._active) return;
        this._active = false;
        
        if (this._handler && this.model.off) {
            this.model.off('change', this._handler);
        }
        
        this._handler = null;
    }
}

/**
 * BindingManager - Manages multiple bindings for a control
 */
class BindingManager {
    constructor(control) {
        this.control = control;
        this.binders = [];
        this.computed = [];
        this.watchers = [];
    }
    
    /**
     * Create a new binding between models
     */
    bind(sourceModel, targetModel, bindings, options) {
        const binder = new ModelBinder(sourceModel, targetModel, bindings, options);
        this.binders.push(binder);
        return binder;
    }
    
    /**
     * Create a computed property
     */
    createComputed(model, dependencies, computeFn, options) {
        const computed = new ComputedProperty(model, dependencies, computeFn, options);
        this.computed.push(computed);
        return computed;
    }
    
    /**
     * Watch a property for changes
     */
    watch(model, property, callback, options) {
        const watcher = new PropertyWatcher(model, property, callback, options);
        this.watchers.push(watcher);
        return watcher;
    }
    
    /**
     * Cleanup all bindings
     */
    cleanup() {
        this.binders.forEach(b => b.deactivate());
        this.computed.forEach(c => c.deactivate());
        this.watchers.forEach(w => w.deactivate());
        
        this.binders = [];
        this.computed = [];
        this.watchers = [];
    }
    
    /**
     * Get inspection data for all bindings
     */
    inspect() {
        return {
            binders: this.binders.map(b => b.inspect()),
            computed: this.computed.map(c => ({
                propertyName: c.options.propertyName,
                dependencies: c.dependencies,
                value: c.value
            })),
            watchers: this.watchers.map(w => ({
                property: w.property,
                active: w._active
            }))
        };
    }
}

module.exports = {
    ModelBinder,
    ComputedProperty,
    PropertyWatcher,
    BindingManager
};

},{"lang-tools":364}],329:[function(require,module,exports){
const { tof } = require('lang-tools');

/**
 * Transformation utilities for data binding
 * Provides common formatters, parsers, and validators for use in ModelBinder
 */

const Transformations = {
    /**
     * Date transformations
     */
    date: {
        /**
         * Format a Date object to ISO string
         */
        toISO: (date) => {
            if (!date) return '';
            if (date instanceof Date) return date.toISOString();
            return new Date(date).toISOString();
        },
        
        /**
         * Format a Date object to locale string
         */
        toLocale: (date, locale = 'en-US', options = {}) => {
            if (!date) return '';
            if (date instanceof Date) return date.toLocaleDateString(locale, options);
            return new Date(date).toLocaleDateString(locale, options);
        },
        
        /**
         * Format a Date object to custom format
         */
        format: (date, format = 'YYYY-MM-DD') => {
            if (!date) return '';
            const d = date instanceof Date ? date : new Date(date);
            
            const map = {
                YYYY: d.getFullYear(),
                MM: String(d.getMonth() + 1).padStart(2, '0'),
                DD: String(d.getDate()).padStart(2, '0'),
                HH: String(d.getHours()).padStart(2, '0'),
                mm: String(d.getMinutes()).padStart(2, '0'),
                ss: String(d.getSeconds()).padStart(2, '0')
            };
            
            return format.replace(/YYYY|MM|DD|HH|mm|ss/g, matched => map[matched]);
        },
        
        /**
         * Parse a date string
         */
        parse: (str) => {
            if (!str) return null;
            const date = new Date(str);
            return isNaN(date.getTime()) ? null : date;
        },
        
        /**
         * Parse a date from custom format
         */
        parseFormat: (str, format = 'YYYY-MM-DD') => {
            if (!str) return null;
            
            const parts = {
                YYYY: { start: format.indexOf('YYYY'), length: 4 },
                MM: { start: format.indexOf('MM'), length: 2 },
                DD: { start: format.indexOf('DD'), length: 2 }
            };
            
            const year = parseInt(str.substr(parts.YYYY.start, parts.YYYY.length));
            const month = parseInt(str.substr(parts.MM.start, parts.MM.length)) - 1;
            const day = parseInt(str.substr(parts.DD.start, parts.DD.length));
            
            return new Date(year, month, day);
        }
    },
    
    /**
     * Number transformations
     */
    number: {
        /**
         * Format number to string with decimals
         */
        toFixed: (num, decimals = 2) => {
            if (num === null || num === undefined) return '';
            return Number(num).toFixed(decimals);
        },
        
        /**
         * Format number with thousands separator
         */
        toLocale: (num, locale = 'en-US', options = {}) => {
            if (num === null || num === undefined) return '';
            return Number(num).toLocaleString(locale, options);
        },
        
        /**
         * Format number as currency
         */
        toCurrency: (num, currency = 'USD', locale = 'en-US') => {
            if (num === null || num === undefined) return '';
            return Number(num).toLocaleString(locale, {
                style: 'currency',
                currency: currency
            });
        },
        
        /**
         * Format number as percentage
         */
        toPercent: (num, decimals = 0) => {
            if (num === null || num === undefined) return '';
            return (Number(num) * 100).toFixed(decimals) + '%';
        },
        
        /**
         * Parse number from string
         */
        parse: (str) => {
            if (str === null || str === undefined || str === '') return null;
            const num = parseFloat(String(str).replace(/[^0-9.-]/g, ''));
            return isNaN(num) ? null : num;
        },
        
        /**
         * Parse integer from string
         */
        parseInt: (str) => {
            if (str === null || str === undefined || str === '') return null;
            const num = parseInt(String(str).replace(/[^0-9-]/g, ''));
            return isNaN(num) ? null : num;
        },
        
        /**
         * Clamp number between min and max
         */
        clamp: (min, max) => (num) => {
            return Math.max(min, Math.min(max, Number(num)));
        }
    },
    
    /**
     * String transformations
     */
    string: {
        /**
         * Convert to uppercase
         */
        toUpper: (str) => {
            return str ? String(str).toUpperCase() : '';
        },
        
        /**
         * Convert to lowercase
         */
        toLower: (str) => {
            return str ? String(str).toLowerCase() : '';
        },
        
        /**
         * Capitalize first letter
         */
        capitalize: (str) => {
            if (!str) return '';
            const s = String(str);
            return s.charAt(0).toUpperCase() + s.slice(1).toLowerCase();
        },
        
        /**
         * Capitalize each word
         */
        titleCase: (str) => {
            if (!str) return '';
            return String(str).split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                .join(' ');
        },
        
        /**
         * Trim whitespace
         */
        trim: (str) => {
            return str ? String(str).trim() : '';
        },
        
        /**
         * Truncate string to length
         */
        truncate: (maxLength, suffix = '...') => (str) => {
            if (!str) return '';
            const s = String(str);
            if (s.length <= maxLength) return s;
            return s.substr(0, maxLength - suffix.length) + suffix;
        },
        
        /**
         * Default value if empty
         */
        default: (defaultValue) => (str) => {
            return str ? String(str) : defaultValue;
        }
    },
    
    /**
     * Boolean transformations
     */
    boolean: {
        /**
         * Convert to boolean
         */
        toBool: (value) => {
            if (value === null || value === undefined) return false;
            if (typeof value === 'boolean') return value;
            if (typeof value === 'number') return value !== 0;
            const str = String(value).toLowerCase();
            return str === 'true' || str === '1' || str === 'yes';
        },
        
        /**
         * Convert to yes/no string
         */
        toYesNo: (value) => {
            return Transformations.boolean.toBool(value) ? 'Yes' : 'No';
        },
        
        /**
         * Convert to on/off string
         */
        toOnOff: (value) => {
            return Transformations.boolean.toBool(value) ? 'On' : 'Off';
        },
        
        /**
         * Invert boolean
         */
        not: (value) => {
            return !Transformations.boolean.toBool(value);
        }
    },
    
    /**
     * Array transformations
     */
    array: {
        /**
         * Join array to string
         */
        join: (separator = ', ') => (arr) => {
            if (!Array.isArray(arr)) return '';
            return arr.join(separator);
        },
        
        /**
         * Get array length
         */
        length: (arr) => {
            return Array.isArray(arr) ? arr.length : 0;
        },
        
        /**
         * Filter array
         */
        filter: (predicate) => (arr) => {
            if (!Array.isArray(arr)) return [];
            return arr.filter(predicate);
        },
        
        /**
         * Map array
         */
        map: (mapper) => (arr) => {
            if (!Array.isArray(arr)) return [];
            return arr.map(mapper);
        },
        
        /**
         * Get first element
         */
        first: (arr) => {
            return Array.isArray(arr) && arr.length > 0 ? arr[0] : null;
        },
        
        /**
         * Get last element
         */
        last: (arr) => {
            return Array.isArray(arr) && arr.length > 0 ? arr[arr.length - 1] : null;
        },
        
        /**
         * Sort array
         */
        sort: (compareFn) => (arr) => {
            if (!Array.isArray(arr)) return [];
            return [...arr].sort(compareFn);
        }
    },
    
    /**
     * Object transformations
     */
    object: {
        /**
         * Get property value
         */
        get: (propertyPath) => (obj) => {
            if (!obj) return null;
            const parts = propertyPath.split('.');
            let value = obj;
            for (const part of parts) {
                if (value === null || value === undefined) return null;
                value = value[part];
            }
            return value;
        },
        
        /**
         * Check if object has property
         */
        has: (property) => (obj) => {
            return obj && obj.hasOwnProperty(property);
        },
        
        /**
         * Get object keys
         */
        keys: (obj) => {
            return obj ? Object.keys(obj) : [];
        },
        
        /**
         * Get object values
         */
        values: (obj) => {
            return obj ? Object.values(obj) : [];
        }
    },
    
    /**
     * Compose multiple transformations
     */
    compose: (...fns) => {
        return (value) => {
            return fns.reduce((acc, fn) => fn(acc), value);
        };
    },
    
    /**
     * Identity transformation (returns input unchanged)
     */
    identity: (value) => value,
    
    /**
     * Default value transformation
     */
    defaultTo: (defaultValue) => (value) => {
        return value !== null && value !== undefined ? value : defaultValue;
    },
    
    /**
     * Conditional transformation
     */
    when: (condition, thenTransform, elseTransform = Transformations.identity) => {
        return (value) => {
            return condition(value) ? thenTransform(value) : elseTransform(value);
        };
    },
    
    /**
     * Create a bidirectional transformation pair
     */
    bidirectional: (forward, reverse) => {
        return {
            transform: forward,
            reverse: reverse
        };
    }
};

/**
 * Validators - Common validation functions
 */
const Validators = {
    /**
     * Required field validator
     */
    required: (value) => {
        if (value === null || value === undefined) return false;
        if (typeof value === 'string' && value.trim() === '') return false;
        if (Array.isArray(value) && value.length === 0) return false;
        return true;
    },
    
    /**
     * Email validator
     */
    email: (value) => {
        if (!value) return true; // Empty is valid, use required for mandatory
        const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return re.test(String(value));
    },
    
    /**
     * URL validator
     */
    url: (value) => {
        if (!value) return true;
        try {
            new URL(value);
            return true;
        } catch {
            return false;
        }
    },
    
    /**
     * Number range validator
     */
    range: (min, max) => (value) => {
        const num = Number(value);
        if (isNaN(num)) return false;
        return num >= min && num <= max;
    },
    
    /**
     * String length validator
     */
    length: (min, max) => (value) => {
        if (!value) return true;
        const len = String(value).length;
        return len >= min && len <= max;
    },
    
    /**
     * Pattern validator
     */
    pattern: (regex) => (value) => {
        if (!value) return true;
        return regex.test(String(value));
    },
    
    /**
     * Custom validator
     */
    custom: (fn) => fn
};

module.exports = {
    Transformations,
    Validators
};

},{"lang-tools":364}],330:[function(require,module,exports){
arguments[4][144][0].apply(exports,arguments)
},{"dup":144,"lang-tools":364}],331:[function(require,module,exports){
arguments[4][145][0].apply(exports,arguments)
},{"dup":145}],332:[function(require,module,exports){
arguments[4][146][0].apply(exports,arguments)
},{"./text-node":339,"dup":146,"lang-tools":364,"obext":382}],333:[function(require,module,exports){
arguments[4][147][0].apply(exports,arguments)
},{"../control_mixins/model_data_view_compositional_representation":236,"./control-core":332,"./text-node":339,"dup":147,"fnl":6,"jsgui3-gfx-core":195,"lang-tools":364}],334:[function(require,module,exports){
arguments[4][148][0].apply(exports,arguments)
},{"./Data_Model_View_Model_Control":327,"dup":148}],335:[function(require,module,exports){
arguments[4][149][0].apply(exports,arguments)
},{"./Control_Data":314,"./Control_View":319,"./Data_Model_View_Model_Control":327,"./page-context":336,"./parse-mount":337,"./selection-scope":338,"./text-node":339,"dup":149,"lang-tools":364}],336:[function(require,module,exports){
arguments[4][150][0].apply(exports,arguments)
},{"./selection-scope":338,"dup":150,"lang-tools":364}],337:[function(require,module,exports){
arguments[4][151][0].apply(exports,arguments)
},{"dup":151,"htmlparser":8,"lang-tools":364}],338:[function(require,module,exports){
arguments[4][152][0].apply(exports,arguments)
},{"./control":334,"dup":152,"lang-tools":364}],339:[function(require,module,exports){
arguments[4][153][0].apply(exports,arguments)
},{"dup":153,"lang-tools":364}],340:[function(require,module,exports){
arguments[4][154][0].apply(exports,arguments)
},{"./control_mixins/mx":237,"./controls/controls":248,"./html-core/html-core":335,"./resource/compilation-resource":369,"./resource/compiler-resource":370,"./resource/data-kv-resource":371,"./resource/data-transform-resource":372,"./resource/pool":373,"./resource/resource":374,"./router/router":375,"dup":154,"jsgui3-gfx-core":195}],341:[function(require,module,exports){
arguments[4][163][0].apply(exports,arguments)
},{"./old/Collection":357,"dup":163}],342:[function(require,module,exports){
arguments[4][164][0].apply(exports,arguments)
},{"dup":164,"lang-mini":379}],343:[function(require,module,exports){
arguments[4][165][0].apply(exports,arguments)
},{"./old/Data_Object":358,"dup":165}],344:[function(require,module,exports){
arguments[4][166][0].apply(exports,arguments)
},{"./new/Data_Value":347,"dup":166}],345:[function(require,module,exports){
arguments[4][167][0].apply(exports,arguments)
},{"dup":167}],346:[function(require,module,exports){
arguments[4][168][0].apply(exports,arguments)
},{"../Data_Model":342,"./Immutable_Data_Model":349,"./setup_base_data_value_value_property":354,"./tools":356,"dup":168,"lang-mini":379}],347:[function(require,module,exports){
arguments[4][169][0].apply(exports,arguments)
},{"../Data_Model":342,"./Base_Data_Value":346,"./Immutable_Data_Model":349,"./Immutable_Data_Value":350,"./Value_Set_Attempt":353,"./setup_data_value_data_type_set":355,"./tools":356,"dup":169,"lang-mini":379}],348:[function(require,module,exports){
arguments[4][170][0].apply(exports,arguments)
},{"../Data_Model":342,"./Immutable_Data_Model":349,"./tools":356,"dup":170,"lang-mini":379}],349:[function(require,module,exports){
arguments[4][171][0].apply(exports,arguments)
},{"../Data_Model":342,"dup":171}],350:[function(require,module,exports){
arguments[4][172][0].apply(exports,arguments)
},{"../Data_Model":342,"./Immutable_Base_Data_Value":348,"./Immutable_Data_Model":349,"./tools":356,"dup":172,"lang-mini":379}],351:[function(require,module,exports){
arguments[4][173][0].apply(exports,arguments)
},{"dup":173}],352:[function(require,module,exports){
arguments[4][174][0].apply(exports,arguments)
},{"./Validation_Result":351,"dup":174}],353:[function(require,module,exports){
arguments[4][175][0].apply(exports,arguments)
},{"dup":175}],354:[function(require,module,exports){
arguments[4][176][0].apply(exports,arguments)
},{"./Validation_Success":352,"dup":176}],355:[function(require,module,exports){
arguments[4][177][0].apply(exports,arguments)
},{"../Data_Model":342,"./Base_Data_Value":346,"./Immutable_Data_Model":349,"./Immutable_Data_Value":350,"./Value_Set_Attempt":353,"./tools":356,"dup":177,"lang-mini":379}],356:[function(require,module,exports){
arguments[4][178][0].apply(exports,arguments)
},{"../Data_Model":342,"dup":178,"lang-mini":379}],357:[function(require,module,exports){
arguments[4][179][0].apply(exports,arguments)
},{"../../sorted-kvs":367,"./Data_Object":358,"./Data_Value":359,"dup":179,"lang-mini":379}],358:[function(require,module,exports){
arguments[4][180][0].apply(exports,arguments)
},{"../Data_Model":342,"../Mini_Context":345,"./Data_Value":359,"dup":180,"lang-mini":379}],359:[function(require,module,exports){
arguments[4][181][0].apply(exports,arguments)
},{"../Data_Model":342,"dup":181,"lang-mini":379}],360:[function(require,module,exports){
arguments[4][182][0].apply(exports,arguments)
},{"./stiffarray":361,"dup":182}],361:[function(require,module,exports){
arguments[4][183][0].apply(exports,arguments)
},{"dup":183}],362:[function(require,module,exports){
arguments[4][184][0].apply(exports,arguments)
},{"dup":184,"lang-mini":379}],363:[function(require,module,exports){
arguments[4][185][0].apply(exports,arguments)
},{"dup":185}],364:[function(require,module,exports){
arguments[4][186][0].apply(exports,arguments)
},{"././Data_Model/Data_Model":342,"././Data_Model/Data_Value":344,"././Data_Model/new/Immutable_Data_Model":349,"././Data_Model/new/Immutable_Data_Value":350,"./Data_Model/Data_Object":343,"./Data_Model/new/tools":356,"./Data_Model/old/Collection":357,"./b-plus-tree/b-plus-tree":360,"./collective":362,"./doubly-linked-list":363,"./ordered-kvs":365,"./ordered-string-list":366,"./sorted-kvs":367,"./util":368,"dup":186,"lang-mini":379}],365:[function(require,module,exports){
arguments[4][187][0].apply(exports,arguments)
},{"./doubly-linked-list":363,"dup":187}],366:[function(require,module,exports){
arguments[4][188][0].apply(exports,arguments)
},{"dup":188}],367:[function(require,module,exports){
arguments[4][189][0].apply(exports,arguments)
},{"./b-plus-tree/b-plus-tree":360,"dup":189,"lang-mini":379}],368:[function(require,module,exports){
arguments[4][190][0].apply(exports,arguments)
},{"./Data_Model/Collection":341,"dup":190,"lang-mini":379}],369:[function(require,module,exports){
arguments[4][155][0].apply(exports,arguments)
},{"./data-transform-resource":372,"dup":155}],370:[function(require,module,exports){
arguments[4][156][0].apply(exports,arguments)
},{"./data-transform-resource":372,"dup":156}],371:[function(require,module,exports){
arguments[4][157][0].apply(exports,arguments)
},{"./pool":373,"./resource":374,"dup":157,"lang-tools":364}],372:[function(require,module,exports){
arguments[4][158][0].apply(exports,arguments)
},{"./pool":373,"./resource":374,"dup":158,"lang-tools":364}],373:[function(require,module,exports){
arguments[4][159][0].apply(exports,arguments)
},{"dup":159,"lang-tools":364}],374:[function(require,module,exports){
arguments[4][160][0].apply(exports,arguments)
},{"./pool":373,"dup":160,"lang-tools":364}],375:[function(require,module,exports){
arguments[4][161][0].apply(exports,arguments)
},{"./routing-tree":376,"dup":161,"lang-tools":364,"url-parse":386}],376:[function(require,module,exports){
arguments[4][162][0].apply(exports,arguments)
},{"dup":162}],377:[function(require,module,exports){
const jsgui = require('jsgui3-html');

const {Blank_HTML_Document} = jsgui;

// Want to make this as automatic and low-cost as possible to use.

// Also need to get the building of client code working properly.
//  When starting the server...?
//  Want really easy and simple top-level syntax.

// Maybe this should be in the 'client' part of the system...?
//   Due to ease of referencing it...?


// jsgui3-server-controls perhaps???

// jsgui3-client perhaps???

// May be worth doing more about 'server controls' or server-only functionality for the controls that will not get bundled / served
//   to the clients.

// jsgui3-html-server-control ???

// But basically want some server-side functionality, but it's still a control that gets rendered and sent to the client.
//   Could see about marking the server functions specifically.


// Moving this to jsgui3-html or jsgui3-client would make most sense.
//   jsgui3-client.
//     Could have an explanation as to why a Server_Control is in the 'client' module.








class Active_HTML_Document extends Blank_HTML_Document {



    constructor(spec = {}) {
        //console.log('Client_HTML_Document');
        super(spec);
        //spec.context.ctrl_document = this;
        this.active();
    }

    // Seems a bit like 'view features'.

    'include_js'(url) {
        /*
        Add it to the end of the body instead.
        */
        //var head = this.get('head');
        const body = this.get('body');
        var script = new jsgui.script({
            //<script type="text/JavaScript" src="abc.js"></script>
            'context': this.context
        });
        var dom = script.dom;
        var domAttributes = dom.attributes;
        domAttributes.type = 'text/javascript';
        domAttributes.src = url;
        body.add(script);
    }

    'include_css'(url) {
        var head = this.get('head');
        var link = new jsgui.link({
            //<script type="text/JavaScript" src="abc.js"></script>
            'context': this.context
        })
        // <script data-main="scripts/main" src="scripts/require.js"></script>
        var dom = link.dom;
        var domAttributes = dom.attributes;
        domAttributes['rel'] = 'stylesheet';
        domAttributes['type'] = 'text/css';
        //domAttributes.set('src', '/js/require.js');
        domAttributes['href'] = url;
        head.content.add(link);
    }

    'include_jsgui_client'(js_file_require_data_main) {
        js_file_require_data_main = js_file_require_data_main || '/js/web/jsgui-html-client';
        var head = this.head;
        var body = this.body;
        var script = new jsgui.script({
            //<script type="text/JavaScript" src="abc.js"></script>
            'context': this.context
        })
        var domAttributes = script.dom.attributes;
        domAttributes.set({
            'type': 'text/javascript',
            'src': '/js/web/require.js',
            'data-main': js_file_require_data_main
        });
        body.add(script);
    }
    'include_client_css'() {
        var head = this.get('head');
        var link = new jsgui.link({
            //<script type="text/JavaScript" src="abc.js"></script>
            'context': this.context
        });
        var domAttributes = link.dom.attributes;
        domAttributes.rel = 'stylesheet';
        domAttributes.type = 'text/css';
        domAttributes.href = '/css/basic.css';
        head.content.add(link);
        // <link rel="stylesheet" type="text/css" href="theme.css">
    }
    // also need to include jsgui client css
}

module.exports = Active_HTML_Document;
},{"jsgui3-html":340}],378:[function(require,module,exports){
(function (Buffer){(function (){
// Late 2023 - Should include field from obext as well?

// Bring more data functionality to a lower level...?
//   Have more of a platform to support Data_Model, Data_Value and Data_Object with.

// data.schema?
// data.model.schema???

// Would be worth integrating various parts together here and with Data_Model, Data_Object, Data_Value


const running_in_browser = typeof window !== 'undefined';
const running_in_node = !running_in_browser;
let Readable_Stream, Writable_Stream, Transform_Stream;
const get_stream = () => {
	if (running_in_node) {
		return (() => {
			const str_libname = ('str') + ('eam');
			const stream = require(str_libname);
			Readable_Stream = stream.Readable;
			Writable_Stream = stream.Writable;
			Transform_Stream = stream.Transform;
			return stream;
		})();
	} else {
		return undefined;
	}
}
const stream = get_stream();
const each = (collection, fn, context) => {
	if (collection) {
		if (collection.__type == 'collection') {
			return collection.each(fn, context);
		}
		let ctu = true;
		let stop = function () {
			ctu = false;
		};
		if (is_array(collection)) {
			let res = [],
				res_item;
			for (let c = 0, l = collection.length; c < l; c++) {
				res_item;
				if (ctu == false) break;
				if (context) {
					res_item = fn.call(context, collection[c], c, stop);
				} else {
					res_item = fn(collection[c], c, stop);
				}
				res.push(res_item);
			}
			return res;
		} else {
			let name, res = {};
			for (name in collection) {
				if (ctu === false) break;
				if (context) {
					res[name] = fn.call(context, collection[name], name, stop);
				} else {
					res[name] = fn(collection[name], name, stop);
				}
			}
			return res;
		}
	}
};
const is_array = Array.isArray;
const is_dom_node = function isDomNode(obj) {
	return (!!obj && typeof obj.nodeType !== 'undefined' && typeof obj.childNodes !== 'undefined');
};
const get_truth_map_from_arr = function (arr) {
	let res = {};
	each(arr, function (v, i) {
		res[v] = true;
	});
	return res;
};
const get_arr_from_truth_map = function (truth_map) {
	let res = [];
	each(truth_map, function (v, i) {
		res.push(i);
	});
	return res;
};
const get_map_from_arr = function (arr) {
	let res = {};
	for (let c = 0, l = arr.length; c < l; c++) {
		res[arr[c]] = c;
	}
	return res;
}
const arr_like_to_arr = function (arr_like) {
	let res = new Array(arr_like.length);
	for (let c = 0, l = arr_like.length; c < l; c++) {
		res[c] = arr_like[c];
	};
	return res;
};
const is_ctrl = function (obj) {
	return (typeof obj !== 'undefined' && obj !== null && is_defined(obj.__type_name) && is_defined(obj.content) && is_defined(obj.dom));
};
const map_loaded_type_fn_checks = {},
	map_loaded_type_abbreviations = {
		'object': 'o',
		'number': 'n',
		'string': 's',
		'function': 'f',
		'boolean': 'b',
		'undefined': 'u',
		'array': 'a',
		'arguments': 'A',
		'date': 'd',
		'regex': 'r',
		'error': 'e',
		'buffer': 'B',
		'promise': 'p',
		'observable': 'O',
		'readable_stream': 'R',
		'writable_stream': 'W',
		'data_value': 'V'
	};
let using_type_plugins = false;
const invert = (obj) => {
	if (!is_array(obj)) {
		let res = {};
		each(obj, (v, k) => {
			res[v] = k;
		})
		return res;
	} else {
		console.trace();
		throw 'invert(obj) not supported on arrays'
	}
}
const map_loaded_type_names = invert(map_loaded_type_abbreviations);
const load_type = (name, abbreviation, fn_detect_instance) => {
	map_loaded_type_fn_checks[name] = fn_detect_instance;
	map_loaded_type_names[abbreviation] = name;
	map_loaded_type_abbreviations[name] = abbreviation;
	using_type_plugins = true;
}
const tof = (obj, t1) => {
	let res = t1 || typeof obj;
	if (using_type_plugins) {
		let res;
		each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
			if (fn_check(obj)) {
				res = name;
				stop();
			}
		});
		if (res) {
			return res;
		}
	}
	if (res === 'number' || res === 'string' || res === 'function' || res === 'boolean') {
		return res;
	}
	if (res === 'object') {
		if (typeof obj !== 'undefined') {
			if (obj === null) {
				return 'null';
			}
			if (obj.__type) {
				return obj.__type;
			} else if (obj.__type_name) {
				return obj.__type_name;
			} else {
				if (obj instanceof Promise) {
					return 'promise';
				}
				if (is_ctrl(obj)) {
					return 'control';
				}
				if (obj instanceof Date) {
					return 'date';
				}
				if (is_array(obj)) {
					return 'array';
				} else {
					if (obj instanceof Error) {
						res = 'error';
					} else if (obj instanceof RegExp) res = 'regex';
					if (typeof window === 'undefined') {
						if (obj && obj.readInt8) res = 'buffer';
					}
				}
				return res;
			}
		} else {
			return 'undefined';
		}
	}
	return res;
};
const tf = (obj) => {
	let res = typeof obj;
	if (using_type_plugins) {
		let res;
		each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
			if (fn_check(obj)) {
				res = map_loaded_type_abbreviations[name];
				stop();
			}
		});
		if (res) {
			return res;
		}
	}
	if (res === 'number' || res === 'string' || res === 'function' || res === 'boolean' || res === 'undefined') {
		return res[0];
	} else {
		if (obj === null) {
			return 'N';
		} else {
			if (running_in_node) {
				if (obj instanceof Readable_Stream) {
					return 'R';
				} else if (obj instanceof Writable_Stream) {
					return 'W';
				} else if (obj instanceof Transform_Stream) {
					return 'T';
				}
			}
			if (typeof Buffer !== 'undefined' && obj instanceof Buffer) {
				return 'B';
			} else if (obj instanceof Promise) {
				return 'p';
			} else if (obj instanceof Date) {
				return 'd';
			} else if (is_array(obj)) {
				return 'a';
			} else {
				if (obj._is_observable === true) {
					return 'O';
				} else {
					if (typeof obj.callee === 'function') {
						return 'A';
					} else if (obj instanceof Error) {
						return 'e';
					} else if (obj instanceof RegExp) return 'r';
					return 'o';
				}
			}
			return res;
		}
	}
	console.trace();
	console.log('item', item);
	throw 'type not found';
	return res;
};
const atof = (arr) => {
	let res = new Array(arr.length);
	for (let c = 0, l = arr.length; c < l; c++) {
		res[c] = tof(arr[c]);
	}
	return res;
};
const is_defined = (value) => {
		return typeof (value) != 'undefined';
	},
	isdef = is_defined;
const stringify = JSON.stringify;

// Older version???

let _get_item_sig = (i, arr_depth) => {
	let res;
	let t1 = typeof i;
	if (t1 === 'string') {
		res = 's';
	} else if (t1 === 'number') {
		res = 'n';
	} else if (t1 === 'boolean') {
		res = 'b';
	} else if (t1 === 'function') {
		res = 'f';
	} else {
		let t = tof(i, t1);
		if (t === 'array') {
			if (arr_depth) {
				res = '['
				for (let c = 0, l = i.length; c < l; c++) {
					if (c > 0) res = res + ',';
					res = res + get_item_sig(i[c], arr_depth - 1);
				}
				res = res + ']';
			} else {
				res = 'a';
			}
		} else if (t === 'control') {
			res = 'c';
		} else if (t === 'date') {
			res = 'd';
		} else if (t === 'observable') {
			res = 'O';
		} else if (t === 'regex') {
			res = 'r';
		} else if (t === 'buffer') {
			res = 'B';
		} else if (t === 'readable_stream') {
			res = 'R';
		} else if (t === 'writable_stream') {
			res = 'W';
		} else if (t === 'object') {
			res = 'o';
		} else if (t === 'undefined') {
			res = 'u';
		} else {
			if (t === 'collection_index') {
				return 'X';
			} else if (t === 'data_object') {
				if (i._abstract) {
					res = '~D';
				} else {
					res = 'D';
				}
			} else {
				if (t === 'data_value') {
					if (i._abstract) {
						res = '~V';
					} else {
						res = 'V';
					}
				} else if (t === 'null') {
					res = '!';
				} else if (t === 'collection') {
					if (i._abstract) {
						res = '~C';
					} else {
						res = 'C';
					}
				} else {
					res = '?';
				}
			}
		}
	}
	return res;
};
const get_item_sig = (item, arr_depth) => {
	if (arr_depth) {
		return _get_item_sig(item, arr_depth);
	}
	const t = tof(item);

	if (map_loaded_type_abbreviations[t]) {
		return map_loaded_type_abbreviations[t];
	} else {
		let bt = typeof item;
		if (bt === 'object') {
			if (is_array(item)) {
				return 'a';
			} else {
				return 'o';
			}
		} else {
			console.log('map_loaded_type_abbreviations type name not found', t);
			console.log('bt', bt);
			console.trace();
			throw 'stop';
		}
	}
}
const get_a_sig = (a) => {
	let c = 0,
		l = a.length;

	//console.log('is_array(a)', is_array(a));
	//console.log('a', a);
	//console.log('get_a_sig l', l);
	let res = '[';
	let first = true;
	for (c = 0; c < l; c++) {
		if (!first) {
			res = res + ',';
		} else {
			first = false;
		}
		res = res + get_item_sig(a[c]);
	}
	res = res + ']';
	return res;
}
const deep_sig = (item, max_depth = -1, depth = 0) => {
	const t = tf(item);
	let res = '';
	if (t === 'a') {
		const l = item.length;
		if (max_depth === -1 || depth <= max_depth) {
			res = res + '[';
			let first = true;
			for (let c = 0; c < l; c++) {
				if (!first) res = res + ',';
				res = res + deep_sig(item[c], max_depth, depth + 1);
				first = false;
			}
			res = res + ']';
		} else {
			return 'a';
		}
	} else if (t === 'A') {
		const l = item.length;
		let first = true;
		for (let c = 0; c < l; c++) {
			if (!first) res = res + ',';
			res = res + deep_sig(item[c], max_depth, depth + 1);
			first = false;
		}
	} else if (t === 'o') {
		if (max_depth === -1 || depth <= max_depth) {
			let res = '{';
			let first = true;
			each(item, (v, k) => {
				if (!first) res = res + ',';
				res = res + '"' + k + '":' + deep_sig(v, max_depth, depth + 1);
				first = false;
			});
			res = res + '}';
			return res;
		} else {
			return 'o';
		}
	} else {
		res = res + t;
	}
	return res;
}
const trim_sig_brackets = function (sig) {
	if (tof(sig) === 'string') {
		if (sig.charAt(0) == '[' && sig.charAt(sig.length - 1) == ']') {
			return sig.substring(1, sig.length - 1);
		} else {
			return sig;
		}
	}
};
const arr_trim_undefined = function (arr_like) {
	let res = [];
	let last_defined = -1;
	let t, v;
	for (let c = 0, l = arr_like.length; c < l; c++) {
		v = arr_like[c];
		t = tof(v);
		if (t == 'undefined') {} else {
			last_defined = c;
		}
	}
	for (let c = 0, l = arr_like.length; c < l; c++) {
		if (c <= last_defined) {
			res.push(arr_like[c]);
		}
	}
	return res;
};

// Could see about simply integrating data types into fp....?
//   That could mean habing get_item_sig return sigs for those data types.
//     Would need to define signature abbreviations for them.





const functional_polymorphism = function (options, fn) {
	let a0 = arguments;
	if (a0.length === 1) {
		fn = a0[0];
		options = null;
	}
	let arr_slice = Array.prototype.slice;
	let arr, sig, a2, l, a;
	return function () {
		a = arguments;
		l = a.length;
		if (l === 1) {
			sig = get_item_sig([a[0]], 1);
			a2 = [a[0]];
			a2.l = 1;
			return fn.call(this, a2, sig);
		} else if (l > 1) {
			arr = arr_trim_undefined(arr_slice.call(a, 0));
			sig = get_item_sig(arr, 1);
			arr.l = arr.length;
			return fn.call(this, arr, sig);
		} else if (a.length === 0) {
			arr = new Array(0);
			arr.l = 0;
			return fn.call(this, arr, '[]');
		}
	}
};
const fp = functional_polymorphism;
const parse_sig = (str_sig, opts = {}) => {
	const sig2 = str_sig.split(', ').join(',');
	const sig_items = sig2.split(',');
	const res = [];
	each(sig_items, sig_item => {
		if (sig_item.length === 1) {
			let type_name = map_loaded_type_names[sig_item];
			res.push({
				abbreviation: sig_item,
				type_name: type_name
			});
		} else {
			let suffix_modifiers;
			let zero_or_more = false;
			let one_or_more = false;
			let type_name = sig_item;
			const obj_res = {
				type_name: type_name
			}
			const distil_suffix_modifiers = () => {
				let last_char = type_name.substr(type_name.length - 1);
				if (last_char === '*') {
					type_name = type_name.substr(0, type_name.length - 1);
					zero_or_more = true;
					obj_res.zero_or_more = true;
					obj_res.modifiers = obj_res.modifiers || [];
					obj_res.modifiers.push('*');
					distil_suffix_modifiers();
				} else if (last_char === '+') {
					type_name = type_name.substr(0, type_name.length - 1);
					one_or_more = true;
					obj_res.one_or_more = true;
					obj_res.modifiers = obj_res.modifiers || [];
					obj_res.modifiers.push('+');
					distil_suffix_modifiers();
				} else {}
			}
			distil_suffix_modifiers();
			obj_res.type_name = type_name;
			res.push(obj_res);
		}
	});
	return res;
}
const mfp_not_sigs = get_truth_map_from_arr(['pre', 'default', 'post']);
const mfp_unparse_sig = arr_sig => {
	let res = '[';
	let first = true;
	each(arr_sig, sig_item => {
		if (!first) {
			res = res + ',';
		}
		res = res + sig_item.abbreviation;
		first = false;
	})
	res = res + ']';
	return res;
}
const map_grammar_def_abbreviations = {
	'string': 's',
	'number': 'n',
	'boolean': 'b',
	's': 's',
	'n': 'n',
	'b': 'b'
}
const log = () => {};
const combinations = (arr, arr_idxs_to_ignore) => {
	const map_ignore_idxs = {};
	if (arr_idxs_to_ignore) {
		each(arr_idxs_to_ignore, idx_to_ignore => {
			map_ignore_idxs[idx_to_ignore] = true;
		});
	}
	const res = [];
	const l = arr.length;
	const arr_idxs_num_options = new Uint32Array(l);
	each(arr, (arr_item1, i1) => {
		arr_idxs_num_options[i1] = arr_item1.length;
	});
	const arr_current_option_idxs = (new Uint32Array(l)).fill(0);
	const result_from_indexes = (arr, arg_indexes) => {
		const res = new Array(l);
		if (arg_indexes.length === l) {
			for (var c = 0; c < l; c++) {
				res[c] = arr[c][arg_indexes[c]];
			}
		} else {
			console.trace();
			throw 'Arguments length mismatch';
		}
		return res;
	}
	const incr = () => {
		for (c = l - 1; c >= 0; c--) {
			const ival = arr_current_option_idxs[c];
			const max = arr_idxs_num_options[c] - 1;
			if (ival < max) {
				arr_current_option_idxs[c]++;
				break;
			} else {
				if (c === 0) {
					return false;
				} else {
					arr_current_option_idxs.fill(0, c);
				}
			}
		}
		return true;
	}
	let vals = result_from_indexes(arr, arr_current_option_idxs);
	res.push(vals);
	while (incr()) {
		let vals = result_from_indexes(arr, arr_current_option_idxs);
		res.push(vals);
	}
	return res;
}
const map_native_types = {
	'string': true,
	'boolean': true,
	'number': true,
	'object': true
}
const map_native_type_sigs = {
	's': true,
	'n': true,
	'o': true,
	'a': true,
	'd': true
}


// Late 2023 - mfp may be a good basis to proceed with more data-type aware idioms.
//   Want to use it for mid-level precise and concise code where possible.
//     May use it or its conventions in implementing some higher level (incl mid level) things.

// Would be worth setting up and testing (maybe also benchmarking) Data_Value objects that specifically represent numbers between
//  -180 and 180. Also integrating such Data_Value objects within a Data_Object or other Data_Model.
// Maybe want some kind of _, $, or dm or _dm type shorthand for things that are very useful.
//   Though it does make sense to abstractify things that get used a lot to make it mroe concise.
//     Also worth designing and then using the concise idioms.

// mfp seems like some code that could be redone / changed and parts used elsewhere to implement the mid and high level
//   APIs as wanted.





const mfp = function () {

	// mfp looks complex. may need to look into what it's for and can do.
	//   Looks like an old work-in-progress.
	//     Should look into benchmarking its usage in different places.

	const a1 = arguments;
	const sig1 = get_a_sig(a1);
	let options = {};
	let fn_pre, provided_map_sig_fns, inner_map_sig_fns = {},
		inner_map_parsed_sigs = {},
		arr_sig_parsed_sig_fns = [],
		fn_post;
	let tm_sig_fns;
	let fn_default;
	let single_fn;
	let req_sig_single_fn;
	if (sig1 === '[o]') {
		provided_map_sig_fns = a1[0];
	} else if (sig1 === '[o,o]') {
		options = a1[0];
		provided_map_sig_fns = a1[1];
	} else if (sig1 === '[o,f]') {
		options = a1[0];
		single_fn = a1[1];
	} else if (sig1 === '[o,s,f]') {
		options = a1[0];
		req_sig_single_fn = a1[1];
		single_fn = a1[2];
		provided_map_sig_fns = {};
		provided_map_sig_fns[req_sig_single_fn] = single_fn;
	} else if (sig1 === '[f,o]') {
		single_fn = a1[0];
		options = a1[1];
	} else if (sig1 === '[f]') {
		single_fn = a1[0];
	} else {
		console.log('sig1', sig1);
		console.trace();
		throw 'mfp NYI';
	}
	let {
		single,
		name,
		grammar,
		verb,
		noun,
		return_type,
		return_subtype,
		pure,
		main,
		skip
	} = options;
	let parsed_grammar;
	let identify, validate;
	let dsig = deep_sig;
	(() => {
		if (provided_map_sig_fns) {
			if (provided_map_sig_fns.default) fn_default = provided_map_sig_fns.default;
			each(provided_map_sig_fns, (fn, sig) => {
				if (typeof fn === 'function') {
					if (!mfp_not_sigs[sig]) {
						const parsed_sig = parse_sig(sig);
						const arr_args_with_modifiers = [];
						const arr_args_all_modification_versions = [];
						each(parsed_sig, (arg, i) => {
							arr_args_all_modification_versions[i] = [];
							if (arg.modifiers) {
								const arg_num_modifiers = arg.modifiers.length;
								if (arg_num_modifiers > 1) {
									throw 'Use of more than 1 modifier is currently unsupported.';
								} else if (arg_num_modifiers === 1) {
									arr_args_with_modifiers.push([i, arg]);
									const single_modifier = arg.modifiers[0];
									if (single_modifier === '*') {
										arr_args_all_modification_versions[i].push('');
										arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
										const plural_name = grammar.maps.sing_plur[arg.type_name];
										arr_args_all_modification_versions[i].push(plural_name);
									}
									if (single_modifier === '+') {
										arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
										const plural_name = grammar.maps.sing_plur[arg.type_name];
										arr_args_all_modification_versions[i].push(plural_name);
									}
									if (single_modifier === '?') {
										arr_args_all_modification_versions[i].push('');
										arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
									}
								}
							} else {
								arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
							}
						});
						const combo_args = combinations(arr_args_all_modification_versions);
						const combo_sigs = [];
						let i_first_of_last_undefined = -1;
						each(combo_args, arg_set => {
							let combo_sig = '';
							each(arg_set, (arg, i) => {
								let lsigb4 = combo_sig.length;
								if (i > 0) {
									combo_sig = combo_sig + ',';
								}
								if (arg === '') {
									combo_sig = combo_sig + 'u';
									if (i_first_of_last_undefined === -1) {
										i_first_of_last_undefined = lsigb4;
									}
								} else {
									combo_sig = combo_sig + arg;
									i_first_of_last_undefined = -1;
								}
							})
							if (i_first_of_last_undefined > 0) {
								const combo_sig_no_last_undefined = combo_sig.substr(0, i_first_of_last_undefined);
								combo_sigs.push(combo_sig_no_last_undefined);
							}
							combo_sigs.push(combo_sig);
						})
						if (combo_sigs.length > 0) {
							each(combo_sigs, combo_sig => {
								inner_map_sig_fns[combo_sig] = fn;
							});
						} else {
							inner_map_sig_fns[sig] = fn;
						}
						inner_map_parsed_sigs[sig] = parsed_sig;
						arr_sig_parsed_sig_fns.push([sig, parsed_sig, fn]);
					} else {
						console.log('ommiting, not parsing sig', sig);
					}
				} else {
					console.log('fn', fn);
					console.trace();
					throw 'Expected: function';
				};
			});
		}
		each(inner_map_sig_fns, (fn, sig) => {
			tm_sig_fns = tm_sig_fns || {};
			tm_sig_fns[sig] = true;
		});
	})();
	const res = function () {
		const a2 = arguments;
		const l2 = a2.length;
		console.log('');
		console.log('calling mfp function');
		console.log('--------------------');
		console.log('');
		let mfp_fn_call_deep_sig;
		let ltof = tof;
		const lsig = dsig;
		let ltf = tf;
		mfp_fn_call_deep_sig = lsig(a2);
		let do_skip = false;
		if (skip) {
			if (skip(a2)) {
				do_skip = true;
			} else {}
		}
		if (!do_skip) {
			if (inner_map_sig_fns[mfp_fn_call_deep_sig]) {
				return inner_map_sig_fns[mfp_fn_call_deep_sig].apply(this, a2);
			} else {
				let idx_last_fn = -1;
				let idx_last_obj = -1;
				each(a2, (arg, i_arg) => {
					i_arg = parseInt(i_arg, 10);
					const targ = tf(arg);
					if (targ === 'o') {
						idx_last_obj = i_arg;
					}
					if (targ === 'f') {
						idx_last_fn = i_arg;
					}
				})
				const last_arg_is_fn = idx_last_fn > -1 && idx_last_fn === a2.length - 1;
				const last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 1;
				const second_last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 2;
				let possible_options_obj;
				if (last_arg_is_obj) possible_options_obj = a2[idx_last_obj];
				const new_args_arrangement = [];
				for (let f = 0; f < idx_last_obj; f++) {
					new_args_arrangement.push(a2[f]);
				}
				each(possible_options_obj, (value, key) => {
					new_args_arrangement.push(value);
				});
				let naa_sig = lsig(new_args_arrangement);
				naa_sig = naa_sig.substring(1, naa_sig.length - 1);
				if (inner_map_sig_fns[naa_sig]) {
					return inner_map_sig_fns[naa_sig].apply(this, new_args_arrangement);
				} else {
					if (fn_default) {
						return fn_default.call(this, a2, mfp_fn_call_deep_sig);
					} else {
						if (single_fn) {
							console.log('pre apply single_fn');
							return single_fn.apply(this, a2);
						} else {
							console.log('Object.keys(inner_map_parsed_sigs)', Object.keys(inner_map_parsed_sigs));
							console.trace();
							console.log('mfp_fn_call_deep_sig', mfp_fn_call_deep_sig);
							console.log('provided_map_sig_fns', provided_map_sig_fns);
							if (provided_map_sig_fns) log('Object.keys(provided_map_sig_fns)', Object.keys(provided_map_sig_fns));
							console.log('Object.keys(inner_map_sig_fns)', Object.keys(inner_map_sig_fns));
							console.trace();
							throw 'no signature match found. consider using a default signature. mfp_fn_call_deep_sig: ' + mfp_fn_call_deep_sig;
						}
					}
				}
			}
		}
	}
	const _ = {}
	if (name) _.name = name;
	if (single) _.single = single;
	if (skip) _.skip = skip;
	if (grammar) _.grammar = grammar;
	if (typeof options !== 'undefined' && options.async) _.async = options.async;
	if (main === true) _.main = true;
	if (return_type) _.return_type = return_type;
	if (return_subtype) _.return_subtype = return_subtype;
	if (pure) _.pure = pure;
	if (tm_sig_fns) _.map_sigs = tm_sig_fns;
	if (Object.keys(_).length > 0) {
		res._ = _;
	}
	return res;
}
const convert = (input, conversion_schema) => {}
let arrayify = fp(function (a, sig) {
	let param_index, num_parallel = 1,
		delay = 0,
		fn;
	let res;
	let process_as_fn = function () {
		res = function () {
			let a = arr_like_to_arr(arguments),
				ts = atof(a),
				t = this;
			let last_arg = a[a.length - 1];
			if (tof(last_arg) == 'function') {
				if (typeof param_index !== 'undefined' && ts[param_index] == 'array') {
					let res = [];
					let fns = [];
					each(a[param_index], function (v, i) {
						let new_params = a.slice(0, a.length - 1);
						new_params[param_index] = v;
						fns.push([t, fn, new_params]);
					});
					call_multiple_callback_functions(fns, num_parallel, delay, (err, res) => {
						if (err) {
							console.trace();
							throw err;
						} else {
							let a = [];
							a = a.concat.apply(a, res);
							let callback = last_arg;
							callback(null, a);
						}
					})
				} else {
					return fn.apply(t, a);
				}
			} else {
				if (typeof param_index !== 'undefined' && ts[param_index] == 'array') {
					let res = [];
					for (let c = 0, l = a[param_index].length; c < l; c++) {
						a[param_index] = arguments[param_index][c];
						let result = fn.apply(t, a);
						res.push(result);
					}
					return res;
				} else {
					return fn.apply(t, a);
				}
			}
		};
	}
	if (sig == '[o]') {
		let res = [];
		each(a[0], function (v, i) {
			res.push([v, i]);
		});
	} else if (sig == '[f]') {
		param_index = 0, fn = a[0];
		process_as_fn();
	} else if (sig == '[n,f]') {
		param_index = a[0], fn = a[1];
		process_as_fn();
	} else if (sig == '[n,n,f]') {
		param_index = a[0], num_parallel = a[1], fn = a[2];
		process_as_fn();
	} else if (sig == '[n,n,n,f]') {
		param_index = a[0], num_parallel = a[1], delay = a[2], fn = a[3];
		process_as_fn();
	}
	return res;
});
let mapify = (target) => {
	let tt = tof(target);
	if (tt == 'function') {
		let res = fp(function (a, sig) {
			let that = this;
			if (sig == '[o]') {
				let map = a[0];
				each(map, function (v, i) {
					target.call(that, v, i);
				});
			} else if (sig == '[o,f]') {
				let map = a[0];
				let callback = a[1];
				let fns = [];
				each(map, function (v, i) {
					fns.push([target, [v, i]]);
				});
				call_multi(fns, function (err_multi, res_multi) {
					if (err_multi) {
						callback(err_multi);
					} else {
						callback(null, res_multi);
					}
				});
			} else if (a.length >= 2) {
				target.apply(this, a);
			}
		});
		return res;
	} else if (tt == 'array') {
		let res = {};
		if (arguments.length == 1) {
			if (is_arr_of_strs(target)) {
				each(target, function (v, i) {
					res[v] = true;
				});
			} else {
				each(target, function (v, i) {
					res[v[0]] = v[1];
				});
			}
		} else {
			let by_property_name = arguments[1];
			each(target, function (v, i) {
				res[v[by_property_name]] = v;
			});
		}
		return res;
	}
};
let clone = fp((a, sig) => {
	let obj = a[0];
	if (a.l === 1) {
		if (obj && typeof obj.clone === 'function') {
			return obj.clone();
		} else {
			let t = tof(obj);
			if (t === 'array') {
				let res = [];
				each(obj, v => {
					res.push(clone(v));
				});
				return res;
			} else if (t === 'undefined') {
				return undefined;
			} else if (t === 'string') {
				return obj;
			} else if (t === 'number') {
				return obj;
			} else if (t === 'function') {
				return obj;
			} else if (t === 'boolean') {
				return obj;
			} else if (t === 'null') {
				return obj;
			} else {
				return Object.assign({}, obj);
			}
		}
	} else if (a.l === 2 && tof(a[1]) === 'number') {
		let res = [];
		for (let c = 0; c < a[1]; c++) {
			res.push(clone(obj));
		}
		return res;
	}
});
let set_vals = function (obj, map) {
	each(map, function (v, i) {
		obj[i] = v;
	});
};
let ll_set = (obj, prop_name, prop_value) => {
	let arr = prop_name.split('.');
	let c = 0,
		l = arr.length;
	let i = obj._ || obj,
		s;
	while (c < l) {
		s = arr[c];
		if (typeof i[s] == 'undefined') {
			if (c - l == -1) {
				i[s] = prop_value;
			} else {
				i[s] = {};
			}
		} else {
			if (c - l == -1) {
				i[s] = prop_value;
			}
		}
		i = i[s];
		c++;
	};
	return prop_value;
};
let ll_get = (a0, a1) => {
	if (a0 && a1) {
		let i = a0._ || a0;
		if (a1 == '.') {
			if (typeof i['.'] == 'undefined') {
				return undefined;
			} else {
				return i['.'];
			}
		} else {
			let arr = a1.split('.');
			let c = 0,
				l = arr.length,
				s;
			while (c < l) {
				s = arr[c];
				if (typeof i[s] == 'undefined') {
					if (c - l == -1) {} else {
						throw 'object ' + s + ' not found';
					}
				} else {
					if (c - l == -1) {
						return i[s];
					}
				}
				i = i[s];
				c++;
			}
		}
	}
};
let truth = function (value) {
	return value === true;
};
let iterate_ancestor_classes = (obj, callback) => {
	let ctu = true;
	let stop = () => {
		ctu = false;
	}
	callback(obj, stop);
	if (obj._superclass && ctu) {
		iterate_ancestor_classes(obj._superclass, callback);
	}
}
let is_arr_of_t = function (obj, type_name) {
	let t = tof(obj),
		tv;
	if (t === 'array') {
		let res = true;
		each(obj, function (v, i) {
			tv = tof(v);
			if (tv != type_name) res = false;
		});
		return res;
	} else {
		return false;
	}
}
let is_arr_of_arrs = function (obj) {
	return is_arr_of_t(obj, 'array');
}
let is_arr_of_strs = function (obj) {
	return is_arr_of_t(obj, 'string');
}
let input_processors = {};
let output_processors = {};
let call_multiple_callback_functions = fp(function (a, sig) {
	let arr_functions_params_pairs, callback, return_params = false;
	let delay;
	let num_parallel = 1;
	if (a.l === 1) {
	} else if (a.l === 2) {
		arr_functions_params_pairs = a[0];
		callback = a[1];
	} else if (a.l === 3) {
		if (sig === '[a,n,f]') {
			arr_functions_params_pairs = a[0];
			num_parallel = a[1];
			callback = a[2];
		} else if (sig === '[n,a,f]') {
			arr_functions_params_pairs = a[1];
			num_parallel = a[0];
			callback = a[2];
		} else if (sig === '[a,f,b]') {
			arr_functions_params_pairs = a[0];
			callback = a[1];
			return_params = a[2];
		}
	} else if (a.l === 4) {
		if (sig === '[a,n,n,f]') {
			arr_functions_params_pairs = a[0];
			num_parallel = a[1];
			delay = a[2];
			callback = a[3];
		} else if (sig == '[n,n,a,f]') {
			arr_functions_params_pairs = a[2];
			num_parallel = a[0];
			delay = a[1];
			callback = a[3];
		}
	}
	let res = [];
	let l = arr_functions_params_pairs.length;
	let c = 0;
	let count_unfinished = l;
	let num_currently_executing = 0;
	let process = delay => {
		num_currently_executing++;
		let main = () => {
			let pair = arr_functions_params_pairs[c];
			let context;
			let fn, params, fn_callback;
			let pair_sig = get_item_sig(pair);
			let t_pair = tof(pair);
			if (t_pair == 'function') {
				fn = pair;
				params = [];
			} else {
				if (pair) {
					if (pair.length == 1) {}
					if (pair.length == 2) {
						if (tof(pair[1]) == 'function') {
							context = pair[0];
							fn = pair[1];
							params = [];
						} else {
							fn = pair[0];
							params = pair[1];
						}
					}
					if (pair.length == 3) {
						if (tof(pair[0]) === 'function' && tof(pair[1]) === 'array' && tof(pair[2]) === 'function') {
							fn = pair[0];
							params = pair[1];
							fn_callback = pair[2];
						}
						if (tof(pair[1]) === 'function' && tof(pair[2]) === 'array') {
							context = pair[0];
							fn = pair[1];
							params = pair[2];
						}
					}
					if (pair.length == 4) {
						context = pair[0];
						fn = pair[1];
						params = pair[2];
						fn_callback = pair[3];
					}
				} else {}
			}
			let i = c;
			c++;
			let cb = (err, res2) => {
				num_currently_executing--;
				count_unfinished--;
				if (err) {
					let stack = new Error().stack;
					callback(err);
				} else {
					if (return_params) {
						res[i] = [params, res2];
					} else {
						res[i] = res2;
					}
					if (fn_callback) {
						fn_callback(null, res2);
					}
					if (c < l) {
						if (num_currently_executing < num_parallel) {
							process(delay);
						}
					} else {
						if (count_unfinished <= 0) {
							callback(null, res);
						}
					}
				}
			};
			let arr_to_call = params || [];
			arr_to_call.push(cb);
			if (fn) {
				if (context) {
					fn.apply(context, arr_to_call);
				} else {
					fn.apply(this, arr_to_call);
				}
			} else {}
		}
		if (arr_functions_params_pairs[c]) {
			if (delay) {
				setTimeout(main, delay);
			} else {
				main();
			}
		}
	}
	if (arr_functions_params_pairs.length > 0) {
		while ((c < l) && (num_currently_executing < num_parallel)) {
			if (delay) {
				process(delay * c);
			} else {
				process();
			}
		}
	} else {
		if (callback) {}
	}
});
let multi = call_multiple_callback_functions;
let call_multi = call_multiple_callback_functions;
let Fns = function (arr) {
	let fns = arr || [];
	fns.go = function (parallel, delay, callback) {
		let a = arguments;
		let al = a.length;
		if (al == 1) {
			call_multi(fns, a[0]);
		}
		if (al == 2) {
			call_multi(parallel, fns, delay);
		}
		if (al == 3) {
			call_multi(parallel, delay, fns, callback);
		}
	}
	return fns;
}
let native_constructor_tof = function (value) {
	if (value === String) {
		return 'String';
	}
	if (value === Number) {
		return 'Number';
	}
	if (value === Boolean) {
		return 'Boolean';
	}
	if (value === Array) {
		return 'Array';
	}
	if (value === Object) {
		return 'Object';
	}
}
let sig_match = function (sig1, sig2) {
	let sig1_inner = sig1.substr(1, sig1.length - 2);
	let sig2_inner = sig2.substr(1, sig2.length - 2);
	if (sig1_inner.indexOf('[') > -1 || sig1_inner.indexOf(']') > -1 || sig2_inner.indexOf('[') > -1 || sig2_inner.indexOf(']') > -1) {
		throw 'sig_match only supports flat signatures.';
	}
	let sig1_parts = sig1_inner.split(',');
	let sig2_parts = sig2_inner.split(',');
	let res = true;
	if (sig1_parts.length == sig2_parts.length) {
		let c = 0,
			l = sig1_parts.length,
			i1, i2;
		while (res && c < l) {
			i1 = sig1_parts[c];
			i2 = sig2_parts[c];
			if (i1 === i2) {} else {
				if (i1 !== '?') {
					res = false;
				}
			}
			c++;
		}
		return res;
	} else {
		return false;
	}
}
let remove_sig_from_arr_shell = function (sig) {
	if (sig[0] == '[' && sig[sig.length - 1] == ']') {
		return sig.substring(1, sig.length - 1);
	}
	return sig;
};
let str_arr_mapify = function (fn) {
	let res = fp(function (a, sig) {
		if (a.l == 1) {
			if (sig == '[s]') {
				let s_pn = a[0].split(' ');
				if (s_pn.length > 1) {
					return res.call(this, s_pn);
				} else {
					return fn.call(this, a[0]);
				}
			}
			if (tof(a[0]) == 'array') {
				let res2 = {},
					that = this;
				each(a[0], function (v, i) {
					res2[v] = fn.call(that, v);
				});
				return res2;
			}
		}
	});
	return res;
};
let to_arr_strip_keys = (obj) => {
	let res = [];
	each(obj, v => {
		res.push(v);
	});
	return res;
}
let arr_objs_to_arr_keys_values_table = (arr_objs) => {
	let keys = Object.keys(arr_objs[0]);
	let arr_items = [],
		arr_values;
	each(arr_objs, (item) => {
		arr_items.push(to_arr_strip_keys(item));
	});
	return [keys, arr_items];
}
let set_arr_tree_value = (arr_tree, arr_path, value) => {
	let item_current = arr_tree;
	let last_item_current, last_path_item;
	each(arr_path, (path_item) => {
		last_item_current = item_current;
		item_current = item_current[path_item];
		last_path_item = path_item;
	});
	last_item_current[last_path_item] = value;
}
let get_arr_tree_value = (arr_tree, arr_path) => {
	let item_current = arr_tree;
	each(arr_path, (path_item) => {
		item_current = item_current[path_item];
	});
	return item_current;
}
let deep_arr_iterate = (arr, path = [], callback) => {
	if (arguments.length === 2) {
		callback = path;
		path = [];
	}
	each(arr, (item, i) => {
		let c_path = clone(path);
		c_path.push(i);
		let t = tof(item);
		if (t === 'array') {
			deep_arr_iterate(item, c_path, callback);
		} else {
			callback(c_path, item);
		}
	})
}
let prom = (fn) => {
	let fn_res = function () {
		const a = arguments;
		const t_a_last = typeof a[a.length - 1];
		if (t_a_last === 'function') {
			fn.apply(this, a);
		} else {
			return new Promise((resolve, reject) => {
				[].push.call(a, (err, res) => {
					if (err) {
						reject(err);
					} else {
						resolve(res);
					}
				});
				fn.apply(this, a);
			})
		}
	}
	return fn_res;
}
const vectorify = n_fn => {
	let fn_res = fp(function (a, sig) {
		if (a.l > 2) {
			throw 'stop - need to check.'
			let res = a[0];
			for (let c = 1, l = a.l; c < l; c++) {
				res = fn_res(res, a[c]);
			}
			return res;
		} else {
			if (sig === '[n,n]') {
				return n_fn(a[0], a[1]);
			} else {
				const ats = atof(a);
				if (ats[0] === 'array') {
					if (ats[1] === 'number') {
						const res = [],
							n = a[1],
							l = a[0].length
						let c;
						for (c = 0; c < l; c++) {
							res.push(fn_res(a[0][c], n));
						}
						return res;
					} else if (ats[1] === 'array') {
						if (ats[0].length !== ats[1].length) {
							throw 'vector array lengths mismatch';
						} else {
							const l = a[0].length, res = new Array(l),
								arr2 = a[1];
							for (let c = 0; c < l; c++) {
								res[c] = fn_res(a[0][c], arr2[c]);
							}
							return res;
						}
					}
				}
			}
		};
	});
	return fn_res;
};
const n_add = (n1, n2) => n1 + n2,
	n_subtract = (n1, n2) => n1 - n2,
	n_multiply = (n1, n2) => n1 * n2,
	n_divide = (n1, n2) => n1 / n2;
const v_add = vectorify(n_add),
	v_subtract = vectorify(n_subtract),
	v_multiply = vectorify(n_multiply),
	v_divide = vectorify(n_divide);
const vector_magnitude = function (vector) {
	// may calculate magnitudes of larger dimension vectors too.
	// alert(tof(vector[0]));
	// alert(vector[0] ^ 2);
	var res = Math.sqrt((Math.pow(vector[0], 2)) + (Math.pow(vector[1], 2)));
	return res;
};
const distance_between_points = function (points) {
	var offset = v_subtract(points[1], points[0]);
	//console.log('offset ' + stringify(offset));
	return vector_magnitude(offset);
}
// ui8c?
//  ui8x???  for both?
//  
// Getting into some lower level types here.
//   Consider specifying endianness for numbers.
// Specify things from the basics.
//   Have the descriptions make sense in English and programatically.
//   Have it understand the descriptions of data types including signifiers and representations.
// srtype.add_representation(...)
//   .representations.add
// or 'rep' function.
//  rep(str_tsig_name, definition of representaion / instructions)
const map_tas_by_type = {
	'c': Uint8ClampedArray,
	'ui8': Uint8Array,
	'i16': Int16Array,
	'i32': Int32Array,
	'ui16': Uint16Array,
	'ui32': Uint32Array,
	'f32': Float32Array,
	'f64': Float64Array
}
const get_typed_array = function () {
	const a = arguments;
	let length, input_array;
	const type = a[0];
	if (is_array(a[1])) {
		input_array = a[1];
	} else {
		length = a[1];
	}
	const ctr = map_tas_by_type[type];
	if (ctr) {
		if (input_array) {
			return ctr(input_array);
		} else if (length) {
			return ctr(length);
		}
	}
}

// Grammar class may be a bit tricky / complex.
//   Maybe it will help because it can be used to define objects easily???
//   Maybe need to get into much more detail??? Maybe a quick and efficient piece of grammar code could work here.

class Grammar {
	constructor(spec) {
		const eg_spec = {
			name: 'User Auth Grammar'
		}
		const {
			name
		} = spec;
		this.name = name;
		const eg_indexing = () => {
			let map_sing_plur = {};
			let map_plur_sing = {};
			let map_sing_def = {};
			let map_sig_sing = {};
			let map_sig0_sing = {};
			let map_sig1_sing = {};
			let map_sig2_sing = {};
		}
		this.maps = {
			sing_plur: {},
			plur_sing: {},
			sing_def: {},
			deep_sig_sing: {},
			obj_sig_sing: {},
			sig_levels_sing: {}
		}
		this.load_grammar(spec.def);
	}
	load_grammar(grammar_def) {
		const {
			sing_plur,
			plur_sing,
			sing_def,
			sig_levels_sing,
			deep_sig_sing,
			obj_sig_sing
		} = this.maps;
		const resolve_def = (def) => {
			const td = tf(def);
			if (td === 'a') {
				const res = [];
				each(def, def_item => {
					res.push(resolve_def(def_item));
				});
				return res;
			} else if (td === 's') {
				if (def === 'string') {
					return 'string';
				} else if (def === 'number') {
					return 'number';
				} else if (def === 'boolean') {
					return 'boolean';
				} else {
					const found_sing_def = sing_def[def];
					return found_sing_def;
				}
			} else if (td === 'n') {
				console.trace();
				throw 'NYI';
			} else if (td === 'b') {
				console.trace();
				throw 'NYI';
			}
		}
		const resolved_def_to_sig = (resolved_def, level = 0) => {
			const trd = tf(resolved_def);
			if (trd === 's') {
				if (resolved_def === 'string') {
					return 's'
				} else if (resolved_def === 'number') {
					return 'n'
				} else if (resolved_def === 'boolean') {
					return 'b'
				}
			} else if (trd === 'a') {
				let res = '';
				if (level === 0) {} else {
					res = res + '[';
				}
				each(resolved_def, (item, c) => {
					if (c > 0) {
						res = res + ',';
					}
					res = res + resolved_def_to_sig(item, level + 1);
				});
				if (level === 0) {} else {
					res = res + ']';
				}
				return res;
			} else {
				console.trace();
				throw 'NYI';
			}
			return res;
		}
		each(grammar_def, (def1, sing_word) => {
			const {
				def,
				plural
			} = def1;
			sing_def[sing_word] = def;
			sing_plur[sing_word] = plural;
			plur_sing[plural] = sing_word;
			const tdef = tf(def);
			const resolved_def = resolve_def(def);
			const resolved_def_sig = resolved_def_to_sig(resolved_def);
			deep_sig_sing[resolved_def_sig] = deep_sig_sing[resolved_def_sig] || [];
			deep_sig_sing[resolved_def_sig].push(sing_word);
			let def_is_all_custom_types = true;
			each(def, (def_item, c, stop) => {
				const tdi = tf(def_item);
				if (tdi === 's') {
					if (sing_def[def_item]) {} else {
						def_is_all_custom_types = false;
						stop();
					}
				} else {
					def_is_all_custom_types = false;
					stop();
				}
			});
			let obj_sig;
			if (def_is_all_custom_types) {
				obj_sig = '{';
				each(def, (def_item, c, stop) => {
					if (c > 0) {
						obj_sig = obj_sig + ',';
					}
					const resolved = resolve_def(def_item);
					const abr_resolved = resolved_def_to_sig(resolved);
					obj_sig = obj_sig + '"' + def_item + '":'
					obj_sig = obj_sig + abr_resolved;
				});
				obj_sig = obj_sig + '}';
			}
			if (obj_sig) {
				obj_sig_sing[obj_sig] = obj_sig_sing[obj_sig] || [];
				obj_sig_sing[obj_sig].push(sing_word);
			}
		})
	}
	tof(item) {
		const {
			sing_plur,
			plur_sing,
			sing_def,
			sig_levels_sing,
			deep_sig_sing,
			obj_sig_sing
		} = this.maps;
		const titem = tf(item);
		console.log('titem', titem);
		if (titem === 'a') {
			let all_arr_items_type;
			each(item, (subitem, c, stop) => {
				const subitem_type = this.tof(subitem);
				console.log('subitem_type', subitem_type);
				if (c === 0) {
					all_arr_items_type = subitem_type;
				} else {
					if (all_arr_items_type === subitem_type) {} else {
						all_arr_items_type = null;
						stop();
					}
				}
			});
			if (all_arr_items_type) {
				console.log('has all_arr_items_type', all_arr_items_type);
				if (!map_native_types[all_arr_items_type]) {
					const res = sing_plur[all_arr_items_type];
					return res;
				}
			} else {
				console.log('no all_arr_items_type');
			}
		} else {
			return tof(item);
		}
		const item_deep_sig = deep_sig(item);
		console.log('Grammar tof() item_deep_sig', item_deep_sig);
		let arr_sing;
		if (titem === 'a') {
			const unenclosed_sig = item_deep_sig.substring(1, item_deep_sig.length - 1);
			console.log('unenclosed_sig', unenclosed_sig);
			arr_sing = deep_sig_sing[unenclosed_sig];
		} else {
			arr_sing = deep_sig_sing[item_deep_sig];
		}
		if (arr_sing) {
			if (arr_sing.length === 1) {
				return arr_sing[0];
			} else {
				console.trace();
				throw 'NYI';
			}
		}
	}
	sig(item, max_depth = -1, depth = 0) {
		const {
			sing_plur,
			plur_sing,
			sing_def,
			sig_levels_sing,
			deep_sig_sing,
			obj_sig_sing
		} = this.maps;
		const extended_sig = item => {
			const ti = tf(item);
			let res = '';
			let same_grammar_type;
			const record_subitem_sigs = item => {
				same_grammar_type = undefined;
				let same_sig = undefined;
				each(item, (subitem, c) => {
					if (c > 0) {
						res = res + ',';
					}
					const sig_subitem = this.sig(subitem, max_depth, depth + 1);
					if (same_sig === undefined) {
						same_sig = sig_subitem;
					} else {
						if (sig_subitem !== same_sig) {
							same_sig = false;
							same_grammar_type = false;
						}
					}
					if (same_sig) {
						if (sing_def[sig_subitem]) {
							if (same_grammar_type === undefined) {
								same_grammar_type = sig_subitem;
							} else {
								if (same_grammar_type === sig_subitem) {} else {
									same_grammar_type = false;
								}
							}
						} else {}
					}
					res = res + sig_subitem;
				});
			}
			if (ti === 'A') {
				record_subitem_sigs(item);
				return res;
			} else if (ti === 'a') {
				record_subitem_sigs(item);
				if (same_grammar_type) {
					const plur_name = sing_plur[same_grammar_type];
					return plur_name;
				} else {
					const found_obj_type = obj_sig_sing[res];
					const found_deep_sig_type = deep_sig_sing[res];
					let found_type_sing;
					if (found_deep_sig_type) {
						if (found_deep_sig_type.length === 1) {
							found_type_sing = found_deep_sig_type[0];
						}
					}
					if (found_type_sing) {
						return found_type_sing;
					} else {
						const enclosed_res = '[' + res + ']';
						return enclosed_res;
					}
				}
			} else if (ti === 'o') {
				if (max_depth === -1 || depth <= max_depth) {
					res = res + '{';
					let first = true;
					each(item, (value, key) => {
						const vsig = this.sig(value, max_depth, depth + 1);
						if (!first) {
							res = res + ',';
						} else {
							first = false;
						}
						res = res + '"' + key + '":' + vsig;
					});
					res = res + '}';
					return res;
				} else {
					return 'o';
				}
			} else if (ti === 's' || ti === 'n' || ti === 'b') {
				return ti;
			} else {
				return ti;
			}
		}
		return extended_sig(item);
	}
	single_forms_sig(item) {
		const {
			sing_plur,
			plur_sing,
			sing_def,
			sig_levels_sing,
			deep_sig_sing,
			obj_sig_sing
		} = this.maps;
		let sig = this.sig(item);
		let s_sig = sig.split(',');
		const arr_res = [];
		each(s_sig, (sig_item, c) => {
			const sing = plur_sing[sig_item] || sig_item;
			arr_res.push(sing);
		});
		const res = arr_res.join(',');
		return res;
	}
}
class Evented_Class {
	'constructor'() {
		Object.defineProperty(this, '_bound_events', {
			value: {}
		});
	}
	'raise_event'() {
		let a = Array.prototype.slice.call(arguments),
			sig = get_a_sig(a);
		a.l = a.length;
		let target = this;
		let c, l, res;
		if (sig === '[s]') {
			let target = this;
			let event_name = a[0];
			let bgh = this._bound_general_handler;
			let be = this._bound_events;
			res = [];
			if (bgh) {
				for (c = 0, l = bgh.length; c < l; c++) {
					res.push(bgh[c].call(target, event_name));
				}
			}
			if (be) {
				let bei = be[event_name];
				if (tof(bei) == 'array') {
					for (c = 0, l = bei.length; c < l; c++) {
						res.push(bei[c].call(target));
					}
					return res;
				}
			}
		}
		if (sig === '[s,a]') {
			let be = this._bound_events;
			let bgh = this._bound_general_handler;
			let event_name = a[0];
			res = [];
			if (bgh) {
				for (c = 0, l = bgh.length; c < l; c++) {
					res.push(bgh[c].call(target, event_name, a[1]));
				}
			}
			if (be) {
				let bei = be[event_name];
				if (tof(bei) === 'array') {
					for (c = 0, l = bei.length; c < l; c++) {
						res.push(bei[c].call(target, a[1]));
					}
				}
			}
		}
		if (sig === '[s,b]' || sig === '[s,s]' || sig === '[s,n]' || sig === '[s,B]' || sig === '[s,O]' || sig === '[s,e]') {
			let be = this._bound_events;
			let bgh = this._bound_general_handler;
			let event_name = a[0];
			res = [];
			if (bgh) {
				for (c = 0, l = bgh.length; c < l; c++) {
					res.push(bgh[c].call(target, event_name, a[1]));
				}
			}
			if (be) {
				let bei = be[event_name];
				if (tof(bei) === 'array') {
					for (c = 0, l = bei.length; c < l; c++) {
						res.push(bei[c].call(target, a[1]));
					}
				}
			}
		}
		if (sig === '[s,o]' || sig === '[s,?]') {
			let be = this._bound_events;
			let bgh = this._bound_general_handler;
			let event_name = a[0];
			res = [];
			if (bgh) {
				for (c = 0, l = bgh.length; c < l; c++) {
					res.push(bgh[c].call(target, event_name, a[1]));
				}
			}
			if (be) {
				let bei = be[event_name];
				if (tof(bei) === 'array') {
					for (c = 0, l = bei.length; c < l; c++) {
						res.push(bei[c].call(target, a[1]));
					}
				}
			}
		} else {
			if (a.l > 2) {
				let event_name = a[0];
				let additional_args = [];
				let bgh_args = [event_name];
				for (c = 1, l = a.l; c < l; c++) {
					additional_args.push(a[c]);
					bgh_args.push(a[c]);
				}
				let be = this._bound_events;
				let bgh = this._bound_general_handler;
				res = [];
				if (bgh) {
					for (c = 0, l = bgh.length; c < l; c++) {
						res.push(bgh[c].apply(target, bgh_args));
					}
				}
				if (be) {
					let bei = be[event_name];
					if (tof(bei) == 'array') {
						if (bei.length > 0) {
							for (c = 0, l = bei.length; c < l; c++) {
								if (bei[c]) res.push(bei[c].apply(target, additional_args));
							}
							return res;
						} else {
							return res;
						}
					}
				}
			} else {}
		}
		return res;
	}
	'add_event_listener'() {
		const {
			event_events
		} = this;
		let a = Array.prototype.slice.call(arguments),
			sig = get_a_sig(a);
		if (sig === '[f]') {
			this._bound_general_handler = this._bound_general_handler || [];
			if (is_array(this._bound_general_handler)) {
				this._bound_general_handler.push(a[0]);
			};
		}
		if (sig === '[s,f]') {
			let event_name = a[0],
				fn_listener = a[1];
			if (!this._bound_events[event_name]) this._bound_events[event_name] = [];
			let bei = this._bound_events[event_name];
			if (is_array(bei)) {
				bei.push(fn_listener);
				if (event_events) {
					this.raise('add-event-listener', {
						'name': event_name
					})
				}
			} else {
				console.trace();
				throw 'Expected: array';
			}
		}
		return this;
	}
	'remove_event_listener'(event_name, fn_listener) {
		const {
			event_events
		} = this;
		if (this._bound_events) {
			let bei = this._bound_events[event_name] || [];
			if (is_array(bei)) {
				let c = 0,
					l = bei.length,
					found = false;
				while (!found && c < l) {
					if (bei[c] === fn_listener) {
						found = true;
					} else {
						c++;
					}
				}
				if (found) {
					bei.splice(c, 1);
					if (event_events) {
						this.raise('remove-event-listener', {
							'name': event_name
						});
					}
				}
			} else {
				console.trace();
				throw 'Expected: array';
			}
		}
		return this;
	}
	get bound_named_event_counts() {
		const res = {};
		if (this._bound_events) {
			const keys = Object.keys(this._bound_events);
			each(keys, key => {
				res[key] = this._bound_events[key].length;
			})
		}
		return res;
	}
	'one'(event_name, fn_handler) {
		let inner_handler = function (e) {
			fn_handler.call(this, e);
			this.off(event_name, inner_handler);
		};
		this.on(event_name, inner_handler);
	}
	'changes'(obj_changes) {
		if (!this.map_changes) {
			this.map_changes = {};
		}
		each(obj_changes, (handler, name) => {
			this.map_changes[name] = this.map_changes[name] || [];
			this.map_changes[name].push(handler);
		})
		if (!this._using_changes) {
			this._using_changes = true;
			this.on('change', e_change => {
				const {
					name,
					value
				} = e_change;
				if (this.map_changes[name]) {
					each(this.map_changes[name], h_change => {
						h_change(value);
					})
				}
			})
		}
	}
};
const p = Evented_Class.prototype;
p.raise = p.raise_event;
p.trigger = p.raise_event;
p.subscribe = p.add_event_listener;
p.on = p.add_event_listener;
p.off = p.remove_event_listener;
const eventify = obj => {
	const bound_events = {};
	const add_event_listener = (name, handler) => {
		if (handler === undefined && typeof name === 'function') {
			handler = name;
			name = '';
		}
		if (!bound_events[name]) bound_events[name] = [];
		bound_events[name].push(handler);
	}
	const remove_event_listener = (name, handler) => {
		if (bound_events[name]) {
			const i = bound_events[name].indexOf(handler);
			if (i > -1) {
				bound_events[name].splice(i, 1);
			}
		}
	}
	const raise_event = (name, optional_param) => {
		const arr_named_events = bound_events[name];
		if (arr_named_events !== undefined) {
			if (optional_param !== undefined) {
				const l = arr_named_events.length;
				for (let c = 0; c < l; c++) {
					arr_named_events[c].call(obj, optional_param);
				}
			} else {
				const l = arr_named_events.length;
				for (let c = 0; c < l; c++) {
					arr_named_events[c].call(obj);
				}
			}
		}
	}
	obj.on = obj.add_event_listener = add_event_listener;
	obj.off = obj.remove_event_listener = remove_event_listener;
	obj.raise = obj.raise_event = raise_event;
	return obj;
}

// Assign_From_Spec_Class


// Assign_From_Spec_Evented_Class




class Publisher extends Evented_Class {
	constructor(spec = {}) {
		super({});
		this.one('ready', () => {
			this.is_ready = true;
		})
	}
	get when_ready () {
		return new Promise((solve, jettison) => {
			if (this.is_ready === true) {
				solve();
			} else {
				this.one('ready', () => {
					solve();
				})
			}
		})
	}
}

const prop = (...a) => {

	// Using (predefined?) data types here?

	// ...args?
	let s = get_a_sig(a);
	const raise_change_events = true;
	const ifn = item => typeof item === "function";

	if (s === "[a]") {
		each(a[0], item_params => {
			prop.apply(this, item_params);
		});
	} else {
		if (a.length === 2) {
			if (ia(a[1])) {
				const target = a[0];
				each(a[1], item => {
					if (ia(item)) {
						throw "NYI 468732";
					} else {
						prop(target, item);
					}
				});
			} else {
				const ta1 = tof(a[1]);
				if (ta1 === "string") {
					[obj, prop_name] = a;
				} else {
					throw "NYI 468732b";
				}
			}
		} else if (a.length > 2) {
			if (is_array(a[0])) {
				// the rest of the properties applied to the array of items.
				throw "stop";
				let objs = a.shift();
				each(objs, obj => {
					prop.apply(this, [obj].concat(item_params)); // bug
				});
			} else {
				let obj, prop_name, default_value, fn_onchange, fn_transform, fn_on_ready, options;
				const load_options = options => {
					prop_name = prop_name || options.name || options.prop_name;
					fn_onchange =
						options.fn_onchange || options.onchange || options.change;
					fn_transform =
						options.fn_transform || options.ontransform || options.transform;
					fn_on_ready = options.ready || options.on_ready;
					default_value = default_value || options.default_value || options.default;
				};
				if (a.length === 2) {
					[obj, options] = a;
					load_options(options);
				} else if (a.length === 3) {
					if (ifn(a[2])) {
						[obj, prop_name, fn_onchange] = a;
					} else {
						if (a[2].change || a[2].ready) {
							load_options(a[2]);

							[obj, prop_name] = a;
						} else {
							[obj, prop_name, default_value] = a;
						}
					}
					//[obj, prop_name, default_value, fn_transform] = a;
				} else if (a.length === 4) {
					if (ifn(a[2]) && ifn(a[3])) {
						[obj, prop_name, fn_transform, fn_onchange] = a;
					} else if (ifn(a[3])) {
						[obj, prop_name, default_value, fn_onchange] = a;
					} else {
						[obj, prop_name, default_value, options] = a;
						load_options(options);
					}
				} else if (a.length === 5) {
					[obj, prop_name, default_value, fn_transform, fn_onchange] = a;
				}
				let _prop_value;

				if (typeof default_value !== 'undefined') _prop_value = default_value;
				// And a silent set function that does not raise the change event.
				const _silent_set = value => {
					let _value;
					if (fn_transform) {
						_value = fn_transform(value);
					} else {
						_value = value;
					}
					_prop_value = _value;
				}
				const _set = value => {
					let _value;
					if (fn_transform) {
						_value = fn_transform(value);
					} else {
						_value = value;
					}
					let old = _prop_value;
					_prop_value = _value;
					if (fn_onchange) {
						fn_onchange({
							old: old,
							value: _prop_value
						});
					}
					if (obj.raise && raise_change_events) {
						obj.raise("change", {
							name: prop_name,
							old: old,
							value: _prop_value
						});
					}
				};
				if (is_defined(default_value)) {
					_prop_value = default_value;
				}
				const t_prop_name = tf(prop_name);
				if (t_prop_name === 's') {

					Object.defineProperty(obj, prop_name, {
						get() {
							return _prop_value;
						},
						set(value) {
							_set(value);
						}
					});

				} else if (t_prop_name === 'a') {
					const l = prop_name.length;
					//console.log('prop_name', prop_name);
					let item_prop_name;
					for (let c = 0; c < l; c++) {
						item_prop_name = prop_name[c];
						//console.log('item_prop_name', item_prop_name);
						Object.defineProperty(obj, item_prop_name, {
							get() {
								return _prop_value;
							},
							set(value) {
								_set(value);
							}
						});
					}
				} else {
					throw 'Unexpected name type: ' + t_prop_name;
				}
				if (fn_on_ready) {
					fn_on_ready({
						silent_set: _silent_set
					})
				}
			}
		}
	}
};



class Data_Type {

}

class Functional_Data_Type extends Data_Type {
    constructor(spec) {

		/*
		named_property_access: true,
		property_names: ['latitude', 'longitude'],
		// And the property types as well being the same in this case?
		abbreviated_property_names: ['lat', 'long'],
		numbered_property_access: true, // Maybe that's good enough to make it like an array when there are 2 properties.

		*/
        
        // fns for: validate as exact type...?
        // convert from whatever it is to that exact type (if possible)
        //   string and binary conversions.
        //   eg a convert_load type operation.

        // it's super / parent type.
        super(spec);

        if (spec.supertype) this.supertype = spec.supertype;
        if (spec.name) this.name = spec.name;
        if (spec.abbreviated_name) this.abbreviated_name = spec.abbreviated_name;
		if (spec.named_property_access) this.named_property_access = spec.named_property_access;
		if (spec.numbered_property_access) this.numbered_property_access = spec.numbered_property_access;
		if (spec.property_names) this.property_names = spec.property_names;
		if (spec.property_data_types) this.property_data_types = spec.property_data_types;
		if (spec.wrap_properties) this.wrap_properties = spec.wrap_properties;
		if (spec.wrap_value_inner_values) this.wrap_value_inner_values = spec.wrap_value_inner_values;
		if (spec.value_js_type) this.value_js_type = spec.value_js_type;
		// value_js_type

		// wrap_value as well????
		//   Though the value kind-of is itself.
		//    maybe .inner_js_value is much clearer here?
		// wrap_value_inner_values



		if (spec.abbreviated_property_names) this.abbreviated_property_names = spec.abbreviated_property_names;
        if (spec.validate) this.validate = spec.validate;
        if (spec.validate_explain) this.validate_explain = spec.validate_explain;
		if (spec.parse_string) this.parse_string = spec.parse_string;
		if (spec.parse) this.parse = spec.parse;

		// But also want it to be able to accept undefined value (usually???)




        // and abbreviated name
        // spec.validate (needs to be perfect...)

        // spec.load_from(...?)
        // spec.poly_load??

        // spec.input transformers???
        //   transform from other identified types...?

        // For the moment, we don't want too many and too complex functions.

    }
}

//lang.Data_Type = Data_Type;
//lang.Functional_Data_Type = Functional_Data_Type;



// And let's define some....

// And a correct value...?
//   Eg if a number is not valid because it has too many decimal points, it could be corrected.
//     Or even an int that's too large, outside a range, corrected to fit in that range.

// So making a Data_Value stick to using these Data_Types could be helpful.

// For the moment this is really simple and should work fine for some things.

// Allow undefined????
//   Or better to have that on a different level.
//     Maybe does make sense as an option here.

//     Or consider it and do it later.


Functional_Data_Type.number = new Functional_Data_Type({
    name: 'number',
    abbreviated_name: 'n',
    validate: x => {
        return !isNaN(x);
    },
	parse_string(str) {
		const p = parseFloat(str);
		// then is it a number???

		// then is its string the same....?
		if (p + '' === str) {
			const parsed_is_valid = this.validate(p);
			if (parsed_is_valid) {
				return p;
			}
		}


	}
});

Functional_Data_Type.integer = new Functional_Data_Type({
    name: 'integer',
    abbreviated_name: 'int',
    validate: x => {
        return Number.isInteger(x);
    },
	parse_string(str) {
		const p = parseInt(str);
		// then is it a number???

		// then is its string the same....?
		if (p + '' === str) {
			const parsed_is_valid = this.validate(p);
			if (parsed_is_valid) {
				return p;
			}
		}


	}
});

// Need fdts for things like a [lat, long] array.
//   Maybe see about making it (easily) from composite data types.
//     Pair(Lat, Long) or similar
//     Maybe want it defined in a few lines of string grammar if it's easy.
//       Would make for a simple API - but would require parsing a custom language.








// Would be worth getting into creating conventions and idioms for higher level code.
//   Though first getting data type systems working right would help.
//     Making them easy to use.

const field = (...a) => {

	// Will also want to set data types of fields....

	// Uses obj._
	//   Seems quite simple, powerful, flexible.
	//     However, would like a different way of doing it too, could use a local variable defined within the 'field' function.

	// Want to incorporate data types, maybe grammar too.

	// Could use fp for this as well????
	//   See about really concise function definitions.

	//  Also want to see about some benchmarks too.
	//    Eg rendering a large page server side 10 times.

	const raise_change_events = true;

	const ifn = item => typeof item === "function";

	let s = get_a_sig(a);
	if (s === "[a]") {
		// prop????
		each(a[0], item_params => {
			prop.apply(this, item_params);
		});
	} else {
		if (a.length > 1) {
			if (is_array(a[0])) {

				throw 'stop - need to fix';
				// the rest of the properties applied to the array of items.

				// But field.apply here...???
				let objs = a.shift();
				each(objs, obj => {
					field.apply(this, [obj].concat(item_params));
				});
			} else {
				// Maybe will have a Data_Type....

				let obj, prop_name, data_type, default_value, fn_transform;
				//let raise_change_events = opts.raise_change_events;
				if (a.length === 2) {
					[obj, prop_name] = a;
				} else if (a.length === 3) {

					// And also check a[2] for being a Data_Type.

					if (a[2] instanceof Data_Type) {
						[obj, prop_name, data_type, default_value] = a;
					} else {
						if (ifn(a[2])) {
							[obj, prop_name, fn_transform] = a;
						} else {
							[obj, prop_name, default_value] = a;
						}
					}


					
				} else if (a.length === 4) {

					// field(this, 'value', this.data_type, spec.value);

					if (a[2] instanceof Data_Type) {
						[obj, prop_name, data_type, default_value] = a;
					} else {
						[obj, prop_name, default_value, fn_transform] = a;
					}

					
				}

				if (obj !== undefined) {

					// Setting with a data_model or data_value ????


					Object.defineProperty(obj, prop_name, {
						get() {
							if (is_defined(obj._)) {
								return obj._[prop_name];
							} else {
								return undefined;
							}
							//return _prop_value;
						},
						set(value) {
							//console.log('setting prop: ' + prop_name);

							// Get an immutable copy of it???

							let old = (obj._ = obj._ || {})[prop_name];

							// Want better tof that can deal with Data_Model, Data_Value
							// Maybe Data_String, Data_Array, Data_Object, Data_Number???

							// Could make some more specifically typed ones....






							// value must be an array of length 2.

							// And what's the typeof value???



							// Upgrade the field set procedure.






							if (old !== value) {

								let is_valid = true;
								if (data_type) {

									const t_value = typeof value;

									is_valid = data_type.validate(value);

									// if not valid directly, can we parse it from a string???

									if (t_value === 'string') {
										const parsed_value = data_type.parse_string(value);
										is_valid = data_type.validate(parsed_value);

										if (is_valid) value = parsed_value;
									}

									console.log('t_value', t_value);

									// but also some type of stringifying the value....





								}
								if (is_valid) {

									let _value;
									if (fn_transform) {
										//try {
										_value = fn_transform(value);
										//} catch (err) {
										//    throw err;
										//}
									} else {
	
	
	
										_value = value;
									}
									obj._[prop_name] = _value;
									if (raise_change_events) {
										obj.raise("change", {
											name: prop_name,
											old: old,
											value: _value
										});
									}
								}
							} else {
								//console.log('old === value');
								//console.log('old', old);
								//console.log('value', value);
							}
						}
					});
					if (is_defined(default_value)) {
						let is_valid = true;
						if (data_type) {
							is_valid = data_type.validate(default_value);
						}
						if (is_valid) {
							(obj._ = obj._ || {})[prop_name] = default_value;
						}
					}
				} else {
					throw 'stop';
				}
			}
		}
	}
};



// Probably need an 'equals' function.
//   Would make use of .equals and .hash functions / properties when available.

// Though Data_Value.toString and toJSON may be most useful sooner...

// lang-tools should have the equals function that supports Data_Value (maybe Data_Model in general).

const lang_mini_props = {
	each,
	is_array,
	is_dom_node,
	is_ctrl,
	clone,
	get_truth_map_from_arr,
	tm: get_truth_map_from_arr,
	get_arr_from_truth_map,
	arr_trim_undefined,
	get_map_from_arr,
	arr_like_to_arr,
	tof,
	atof,
	tf,
	load_type,
	is_defined,
	def: is_defined,
	Grammar,
	stringify,
	functional_polymorphism,
	fp,
	mfp,
	arrayify,
	mapify,
	str_arr_mapify,
	get_a_sig,
	deep_sig,
	get_item_sig,
	set_vals,
	truth,
	trim_sig_brackets,
	ll_set,
	ll_get,
	iterate_ancestor_classes,
	is_arr_of_t,
	is_arr_of_arrs,
	is_arr_of_strs,
	input_processors,
	output_processors,
	call_multiple_callback_functions,
	call_multi,
	multi: call_multi,
	native_constructor_tof,
	Fns,
	sig_match,
	remove_sig_from_arr_shell,
	to_arr_strip_keys,
	arr_objs_to_arr_keys_values_table,
	set_arr_tree_value,
	get_arr_tree_value,
	deep_arr_iterate,
	prom,
	combinations,
	combos: combinations,
	Evented_Class,
	eventify,
	vectorify,
	v_add,
	v_subtract,
	v_multiply,
	v_divide,
	vector_magnitude,
	distance_between_points,
	get_typed_array,
	gta: get_typed_array,
	Publisher,
	field,
	prop,
	Data_Type,
	Functional_Data_Type
};

const lang_mini = new Evented_Class();
Object.assign(lang_mini, lang_mini_props);
lang_mini.note = (str_name, str_state, obj_properties) => {
	obj_properties = obj_properties || {};
	obj_properties.name = str_name;
	obj_properties.state = str_state;
	lang_mini.raise('note', obj_properties)
}
module.exports = lang_mini;

// Bring in grammar / compound types to this typedef type thing.
//   Types in the fields. 

// Detecting invalid view model states.
//   Validating according to the spec of the data basically.

// Defining data types and models with a gui....




if (require.main === module) {



	/*
	function test_evented_class(test_data) {
		const create_empty_test_res = () => {
		  return {
			passed: [],
			failed: []
		  };
		};
	  
		// Initialize res object with empty arrays
		const res = create_empty_test_res();
	  
		// Test each event in test_data
		for (let i = 0; i < test_data.length; i++) {
		  const { event_name, event_data } = test_data[i];
	  
		  // Test adding the event
		  const evented_class = new Evented_Class();
		  evented_class.add_event_listener(event_name, (data) => {
			if (data === event_data) {
			  res.passed.push(event_name);
			} else {
			  res.failed.push(event_name);
			}
		  });
	  
		  // Test raising the event
		  evented_class.raise_event(event_name, event_data);
		}
	  
		// Return test results
		return res;
	  }
	  */

	  const test_data = [
		{
			event_name: 'foo',
			event_data: 'hello'
		},
		{
			event_name: 'bar',
			event_data: 'world'
		},
		{
			event_name: 'baz',
			event_data: true
		}
	];
	
	const create_empty_test_res = () => ({
		passed: [],
		failed: []
	});

	  
	  function test_evented_class(test_data) {
		const res = create_empty_test_res();
	
		// Create a new instance of Evented_Class
		const evented_class = new Evented_Class();
	
		// Test each event in the test data
		test_data.forEach(test_event => {
			const event_name = test_event.event_name;
			const event_data = test_event.event_data;
	
			// Define a listener for the event
			const listener = data => {
				if (data === event_data) {
					// The event was raised with the expected data
					res.passed.push(event_name);
				} else {
					// The event was raised with the wrong data
					res.failed.push(event_name);
				}
			};
	
			// Add the listener to the evented class
			evented_class.on(event_name, listener);
	
			// Raise the event
			evented_class.raise_event(event_name, event_data);
		});
	
		return res;
	}
	


	const result = test_evented_class(test_data);

	// Print the results of the test
	console.log('Passed:', result.passed);
	console.log('Failed:', result.failed);


}
}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":3}],379:[function(require,module,exports){
const lang = require('./lang-mini');

const {each, tof} = lang;


// and lang types...
//  Will use a Type class.
//   Number_Type etc. String_Type perhaps.
//     and then restrictions. JSON_Type is a String_Type.



// Could have first implementation of types here even....
//   Maybe don't use classes for them?
//     Or do because they are so integrated into the language now.

// Representation_Type
//   eg represents a color (in specific way?) How it represents it...?
//     ?? represents a 24bit rgb color ??
//       why not? should be possible.


// Some / all of oext would be nice within lang-mini...?

// oext seems to work with types though, or would benefit from types.
//   No, oext does not have much for types, moving field and prop from oext here, need to get the data types working with Data_Object
//   and Data_Value. 





// Maybe move to lang-tools?
//   fp() may benefit from integration with this.



// What the type represents.
// What it signifies?

// But then how it's represented?


// Not really about storing the data in memory or transmitting it.
//   But saying it's 24 bit color is kind of about its representation.
//   Still that's what it's called.

// Type_Signifier seems better. Now it's called that.

// Wider signification than just JS.


// Type_Signifier_Component ????

// Type_Signifier perhaps. Signifier_Type???

class Type_Signifier {
    // Name
    constructor(spec = {}) {

        const name = spec.name;

        // And use fields / quicker way to define these?

        Object.defineProperty(this, 'name', {
            get() {
                return name;
            }
        });

        const parent = spec.parent;

        Object.defineProperty(this, 'parent', {
            get() {
                return parent;
            }
        });

        const map_reserved_property_names = {
            name: true,
            parent: true
        }

        const _ = {};

        each(spec, (value, name) => {
            if (map_reserved_property_names[name]) {

            } else {
                _[name] = value;
            }
        });



        // And other fields too....


    }
    extend(o_extension) {

        const o = {
            parent: this
        }
        Object.assign(o, o_extension);
        const res = new Type_Signifier(o_extension);
        return res;


    }
    //  Other options?
    //  Disambiguiation? Descriptive text?
    //    Or is naming them the main thing there?

    // Color representation
    //   And that is simple, does not go into internal representation.

}




// A representation for what is signified.
//   This way if the programmer gets stuck about 'the' representation to make, they can make a decent representation, make it default,
//     and move on for the moment.


// Can be multiple allowed representations for a type.
//   Binary data, JSON
//   Compressed, uncompressed, maybe encrypted too.


// Probably don't need subclasses for string or binary representations.
//  Make this able to deal with both.
//  String (kind of) is binary but likely uses UTF-8.

class Type_Representation {
    // Name
    //  Other options?
    //  Disambiguiation? Descriptive text?
    //    Or is naming them the main thing there?

    // Color representation
    //   And that is simple, does not go into internal representation.

    // This should be able to represent types and lang features not available to JS.
    //   Names may be optional? May be autogenerated and quite long?



    constructor(spec = {}) {

        // May be used on a lower level where the most suitable representation is selected.

        // Generally:
        //  string incl json
        //  binary

        // bridge the gap between numeric and binary.
        //   make this ta-friendly and aware.

        // represent components within a typed array? closely packed data structure?
        

        const name = spec.name;
        Object.defineProperty(this, 'name', {
            get() {
                return name;
            }
        });

        const parent = spec.parent;
        Object.defineProperty(this, 'parent', {
            get() {
                return parent;
            }
        });

        // Then the other fields?
        //  Could have named fields.
        //  Could have ordered fields?

        const _ = {};

        const map_reserved_property_names = {
            'name': true
        };

        //  Even the number of bits being in here...?

        each(spec, (value, name) => {
            if (map_reserved_property_names[name]) {

            } else {
                _[name] = value;

                // Could define the property here.
                //  Read only (for the moment)

                Object.defineProperty(this, name, {
                    get() {
                        return _[name];
                    },
                    enumerable: true
                });


            }
        });
        // Then a proxy to get other properties?
    }
    extend(o_extension) {

        const o = {
            parent: this
        }
        Object.assign(o, o_extension);
        const res = new Type_Representation(o_extension);
        return res;


    }

}

// Will spell out some things in a quite verbose vanilla-js way here.
//   Some higher level code will use types and other lang functionality to be less verbose and closer to English / the direct concepts.

// Joins together 1 signifier and multiple representations.
//   Name of item will be the signifier's name.

class Signifier_Representations_Type {
    constructor(spec = {}) {
        // 2 params in constructor? (signifier, arr_reps)???
        //  could check for that.

        if (spec.signifier && spec.representations) {

            let signifier, arr_representations;

            //if (spec.signifier) {
            if (spec.signifier instanceof Type_Signifier) {
                signifier = spec.signifier;
            } else {
                throw 'expected spec.signifier to be a Type_Signifier instance';
            }
            //}

            if (tof(spec.representations) === 'array') {
                let pass = true;
                each(spec.representations, (representation, idx, stop) => {
                    if (!(representation instanceof Type_Representation)) {
                        pass = false;
                        stop();
                    }
                })
                if (pass) {
                    arr_representations = spec.representations;
                } else {
                    throw 'Expected spec.representations to be an array of Type_Representation instances.';
                }
            }





        } else {
            throw 'Expected spec.signifier and spec.representations'
        }

        



    }
}






// And could be subclasses of signification types...???

// ui8 type signification?
//   OK to signify that type, could indeed be represented with different actual values.
//    such as as a string of decimal or hex digits.


// Will have some basic / core types within lang-mini.
//   Will not have a large amount of code.


// Thematic types perhaps....
//   seems like there could be overlap as well, eg image and document, text and document
//   color, date/time, image, video, text, document, font, number, integer, floating point, string
//     Type signifier could have theme property instead of or as well as name?
//       Then representation of one thing as another. Represent a color as a number.

// One advantage of putting in its own module is possible smaller file size.
//   Though could possibly use lang-mini functionality as a platform for signifier and representer types.
//   Type_Representer perhaps, not Type_Representation???
//     Representation is probably the more accurate / better reading word.




const st_color = new Type_Signifier({'name': 'color'});

// Signify an image. Signify a JPEG image. Etc.

// then make a new one that extends st_color
//   as in, a subtype.
const st_24bit_color = st_color.extend({'bits': 24});
// Other types of 3 component color?

//const st_24bit_rgb_color = st_24bit_color.extend({'components': ['red', 'green', 'blue']});
const st_24bit_rgb_color = st_24bit_color.extend({'components': ['red byte', 'green byte', 'blue byte']});
//  or it already knows that these are bytes, when its 3 components in 24 bits.

// st_24bit_rgb_color is only a signifier of 24 bit rgb color.
//  Then there can be an implementation of it.
//  Or a type (or class etc) could indicate it can handle it.

// Type representation index could help.
//   Query by name could return multiple items....
//     Could have a property for the default representation with the name being searched for.






// And have info about the properties by which it is represented?

const tr_string = new Type_Representation({'name': 'string'});
const tr_binary = new Type_Representation({'name': 'binary'}); // And could include number....
// Numbers maybe extend binary.

// And tr_ui8 even perhaps....




// represent it as a binary sequence.
//   Then could use more application specific tools like a Buffer or Typed Array.

// Or extend the string type representation?

// = tr_binary.extend();
// trep maybe. and tsig or tsign.

// Will make / finish some lower level components that interact with some specifically typed data.
//   May well be worth doing more under 'grammar', getting type signifiers and type representations into the system.
//     So far, types have been type representations. Now, they can be a signifier along with multiple representations.
// A 'tags' type system of properties could help. Make it easy to specify / set up types.

// Representation = Implementation (kind of)
//   Or an interface.

// Could use a Representation as an interface, in some cases.
//   Inner representations as well
//   Eg single color channel has a representation
//     Would have a color name.
//       Could even have a wavelength measurement for the color.

// color channel 8 bit
//   could use some language interpretation even. Some language processing could have the system 'understand' simple phrases describing
//   type representations.

// Actually using struct syntax for C++ or rust would be really good.
//   Rust structs don't require fixed length strings in definition.

// A struct being a Type_Representation, or Representational_Type.
//   Dates can and do operate on different calendars.
//     Same thing being signified, but with a different representation.
// Diffent ways of representing strings and text. Now emojis too, they are part of unicode, and they keep getting updated.

// Text characters are images that represent a letter or something else.
//   They are symbols.


















const rt_bin_24bit_rgb_color = new Type_Representation({
    // A binary type representation.
    'signifier': st_24bit_rgb_color,
    'bytes': [
        [0, 'red', 'ui8'],
        [1, 'green', 'ui8'],
        [2, 'blue', 'ui8']
    ]
});

// Maybe do some work on a concise format for defining these types.
// Maybe worth using or allowing the exact same syntax as C++ and/or rust for these stucts.
//  Possibly some kind of syntax import. An example of how the same type of information can have different representations.




// And an editor control could use a representation in terms of how it represents the data being edited to the user.

// Binary type representation
const rt_hex_24bit_rgb_color = new Type_Representation({
    // Likely some kind of string template.
    //  Or a function?
    //  Best to keep this function free here.
    //  Or maybe make a few quite standard ones.
    'signifier': st_24bit_rgb_color,

    // Or could just have the sequence / template literal even.

    'bytes': [
        [0, '#', 'char'],
        [1, 'hex(red)', 'string(2)'],
        [3, 'hex(green)', 'string(2)'],
        [5, 'hex(blue)', 'string(2)']
    ]
});

// Year could be negative.
const st_date = new Type_Signifier({'name': 'date', 'components': ['day uint', 'month uint', 'year int']});
// And datetime signification.

// Approximate date ie date +- x years.


// Just the date.



//  or don't have the component types here?

// String representation type.
//  String_Type_Representation

// Lots of different ways to represent a type.

// Or say that they are numeric strings as well....

// But a string char possibly takes more than 1 byte! Maybe not as defined here.
//  String of int?
//  Go into more details about how dates are represented?

// Could consider JPEG to be a representation of Image.
//   May want / need to think in terms of segments or blocks...
//    segment_name = 'block' even. So it at least knows the right technical term.
//   JPEG can have different versions, or subrepresentations.
//     Type representations can have a supertype. That can be used with JPEG and then their versions are subtypes.
//       A bit like the super-JPEG is a type representation of its own - except its got the details of the syntax.
//     Want to make the overall system flexible in terms of what it represesnts, a fairly simple base structure.


// Maybe make sections that define the representations just after the signifiers.
//   Could have a fair few basic things defined.

// Type Signifiers and Type Representations
//   Think it could become an interesting book / programming topic.
//   Could have implementations in a few languages too. Maybe suggestions for future languages and versions of them.

// Make it its own module even?
//   Could work better at a lower level.

// srtypes module perhaps, or just srtype.
// Coding with the distinction between signified and represented types could be really useful.
//   Be able to handle serialization and deserialization (or format changes in some cases) 'for free', that is once the definitions
//     have been made, the system will be able to convert between them (maybe requires some conversion functions to be written)
//   System will have decent default type conversions.

// Probably worth having set of 'standard' type definitions.
//   System needs to be flexible so that they can be amended.












const rt_string_date_uk_ddmmyy = new Type_Representation({
    'signifier': st_date,
    'bytes': [
        [0, '#', 'char'],
        [1, 'day', 'string(2)'],
        [3, '/', 'char'],
        [4, 'month', 'string(2)'],
        [6, '/', 'char'],
        [7, 'year', 'string(2)']
    ]
});

// Extra rules or restrictions? Defaults eg year 38 is 2038 etc...


// A types registry could help.
//  Registry of signified types
//  Registry of type representations.
//   Meaning 1 'type' in this system can be represented in multiple different ways.

// Then the infrastructure within control declaration...
//   Though likely will use the .model and .view mixins for this.
//   Views (or controls?) will be made so that the model is a specific representation of a signified type.
//     Or one a a few supported representations.
//     Eg a color palette working for monochrome (8bit color depth).
//       Or a color palette could allow selection of multiple colors.

// Color_Chooser perhaps being simpler?
//   Color_Palette seems like it should be able to deal with a bunch of different ways in which the data could be represented
//     either in the app as the user interacts with it, in app memory, in transmission, in storage.










// There could be quite a lot of these type representations.



// Can have plenty of ways of representing a date. Fewer ways of signifying one.


// To signify something is in some ways less than to represent it.
//   Signification is only about saying that it is there.

// Maybe have a nice UI app to set up the signifier / representer links.





// A moderate amount of data type representation info would help get JSGUI controls working nicely on the specific types
//   of data they are supposed to interact with.

// Ways of getting the data in and out of typed arrays
//   Typed array (or buffer?) access for these data types?

// Could make some nice GUI components (controls) for selecing / editing dates and colors.
//   Can do it in a way that avoids code repetition.
//   Make it so that the controls are able to represent the type on the screen.





 
// These types seem most useful for the types that the user interacts with and putting the type knowledge into the GUI.

// Type registry makes sense too.
//  jsgui.types perhaps / lang.types
//   An index of types? Collection of them?

// Also registry of controls that are set up for dealing with specific types?
//   Being able to identify and use variety of representations.

// May integrate this into image format work - or make this good so that image format work can use this as a platform.









// and then day, month, year components




// day, month year



// or 'hexdigit(2)' maybe.

// And the Control could conveniently show and allow editing of values using different representations.
//   Such as a hex representation, or hex representations for comonents.

// A Control could be aware of, and use both representations of a Data_Type.
//   Color Palette seems like the right place to use that more advanced and general purpose functionality.
//     Will work well for some imaging tools as well too.


// More functional composition of controls could be cool....
//   But let's make / improve the color palette.
//     Moving the data outside it could work too.
//     Consts directory. Or basis. Basics.



// Have a class / instance of one that tracks ie is a DB for the type representations and significations.











// Then put that within an array? 32 bit number used as 24 bit?


// Though it may be most/least significant in some cases.




// Then create a representation of 24 bit rgb color where it's the 3 components as bytes.
//   Could be deduced from what we have already. May be easy enough to get from the Type_Signifier to this.
//     However, will then have representations of the individual components too....
//     Perhaps represent the whole thing as a string. eg #RRGGBB color for HTML. Or as items in an array.
//       Even representing them as items within a typed array.


// Allowing multiple representations of the same things.
//   Representation sets - so we know which representations as (almost? totally?) interchangable.
//   Can choose different default representations depending on performance.

// Or implementation sets? Prefer representation here to describe how the types are represented rather than other connotations
//   such as code for operators.

//console.log('st_color', st_color);

lang.Type_Signifier = Type_Signifier;
lang.Type_Representation = Type_Representation;




// Let's make something a little simpler and focused on representing the types of data in Data_Model classes.
//   Control is such a class through inheritance, it extends Data_Object.

// nfdt new functional data type function....?







// The representation type is a way to represent something
//   What is being represented? That is all within a signifier type.

// Or Implementation_Type? As in that is concrete in terms of how it is represented.
// Representation_Implementation_Type???







module.exports = lang;
},{"./lang-mini":378}],380:[function(require,module,exports){
(function (Buffer){(function (){
// Late 2023 - Should include field from obext as well?

// Bring more data functionality to a lower level...?
//   Have more of a platform to support Data_Model, Data_Value and Data_Object with.

// data.schema?
// data.model.schema???

// Would be worth integrating various parts together here and with Data_Model, Data_Object, Data_Value


const running_in_browser = typeof window !== 'undefined';
const running_in_node = !running_in_browser;
let Readable_Stream, Writable_Stream, Transform_Stream;
const get_stream = () => {
	if (running_in_node) {
		return (() => {
			const str_libname = ('str') + ('eam');
			const stream = require(str_libname);
			Readable_Stream = stream.Readable;
			Writable_Stream = stream.Writable;
			Transform_Stream = stream.Transform;
			return stream;
		})();
	} else {
		return undefined;
	}
}
const stream = get_stream();
const each = (collection, fn, context) => {
	if (collection) {
		if (collection.__type == 'collection') {
			return collection.each(fn, context);
		}
		let ctu = true;
		let stop = function () {
			ctu = false;
		};
		if (is_array(collection)) {
			let res = [],
				res_item;
			for (let c = 0, l = collection.length; c < l; c++) {
				res_item;
				if (ctu == false) break;
				if (context) {
					res_item = fn.call(context, collection[c], c, stop);
				} else {
					res_item = fn(collection[c], c, stop);
				}
				res.push(res_item);
			}
			return res;
		} else {
			let name, res = {};
			for (name in collection) {
				if (ctu === false) break;
				if (context) {
					res[name] = fn.call(context, collection[name], name, stop);
				} else {
					res[name] = fn(collection[name], name, stop);
				}
			}
			return res;
		}
	}
};
const is_array = Array.isArray;
const is_dom_node = function isDomNode(obj) {
	return (!!obj && typeof obj.nodeType !== 'undefined' && typeof obj.childNodes !== 'undefined');
};
const get_truth_map_from_arr = function (arr) {
	let res = {};
	each(arr, function (v, i) {
		res[v] = true;
	});
	return res;
};
const get_arr_from_truth_map = function (truth_map) {
	let res = [];
	each(truth_map, function (v, i) {
		res.push(i);
	});
	return res;
};
const get_map_from_arr = function (arr) {
	let res = {};
	for (let c = 0, l = arr.length; c < l; c++) {
		res[arr[c]] = c;
	}
	return res;
}
const arr_like_to_arr = function (arr_like) {
	let res = new Array(arr_like.length);
	for (let c = 0, l = arr_like.length; c < l; c++) {
		res[c] = arr_like[c];
	};
	return res;
};
const is_ctrl = function (obj) {
	return (typeof obj !== 'undefined' && obj !== null && is_defined(obj.__type_name) && is_defined(obj.content) && is_defined(obj.dom));
};
const map_loaded_type_fn_checks = {},
	map_loaded_type_abbreviations = {
		'object': 'o',
		'number': 'n',
		'string': 's',
		'function': 'f',
		'boolean': 'b',
		'undefined': 'u',
		'array': 'a',
		'arguments': 'A',
		'date': 'd',
		'regex': 'r',
		'error': 'e',
		'buffer': 'B',
		'promise': 'p',
		'observable': 'O',
		'readable_stream': 'R',
		'writable_stream': 'W',
		'data_value': 'V'
	};
let using_type_plugins = false;
const invert = (obj) => {
	if (!is_array(obj)) {
		let res = {};
		each(obj, (v, k) => {
			res[v] = k;
		})
		return res;
	} else {
		console.trace();
		throw 'invert(obj) not supported on arrays'
	}
}
const map_loaded_type_names = invert(map_loaded_type_abbreviations);
const load_type = (name, abbreviation, fn_detect_instance) => {
	map_loaded_type_fn_checks[name] = fn_detect_instance;
	map_loaded_type_names[abbreviation] = name;
	map_loaded_type_abbreviations[name] = abbreviation;
	using_type_plugins = true;
}
const tof = (obj, t1) => {
	let res = t1 || typeof obj;
	if (using_type_plugins) {
		let res;
		each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
			if (fn_check(obj)) {
				res = name;
				stop();
			}
		});
		if (res) {
			return res;
		}
	}
	if (res === 'number' || res === 'string' || res === 'function' || res === 'boolean') {
		return res;
	}
	if (res === 'object') {
		if (typeof obj !== 'undefined') {
			if (obj === null) {
				return 'null';
			}
			if (obj.__type) {
				return obj.__type;
			} else if (obj.__type_name) {
				return obj.__type_name;
			} else {
				if (obj instanceof Promise) {
					return 'promise';
				}
				if (is_ctrl(obj)) {
					return 'control';
				}
				if (obj instanceof Date) {
					return 'date';
				}
				if (is_array(obj)) {
					return 'array';
				} else {
					if (obj instanceof Error) {
						res = 'error';
					} else if (obj instanceof RegExp) res = 'regex';
					if (typeof window === 'undefined') {
						if (obj && obj.readInt8) res = 'buffer';
					}
				}
				return res;
			}
		} else {
			return 'undefined';
		}
	}
	return res;
};
const tf = (obj) => {
	let res = typeof obj;
	if (using_type_plugins) {
		let res;
		each(map_loaded_type_fn_checks, (fn_check, name, stop) => {
			if (fn_check(obj)) {
				res = map_loaded_type_abbreviations[name];
				stop();
			}
		});
		if (res) {
			return res;
		}
	}
	if (res === 'number' || res === 'string' || res === 'function' || res === 'boolean' || res === 'undefined') {
		return res[0];
	} else {
		if (obj === null) {
			return 'N';
		} else {
			if (running_in_node) {
				if (obj instanceof Readable_Stream) {
					return 'R';
				} else if (obj instanceof Writable_Stream) {
					return 'W';
				} else if (obj instanceof Transform_Stream) {
					return 'T';
				}
			}
			if (typeof Buffer !== 'undefined' && obj instanceof Buffer) {
				return 'B';
			} else if (obj instanceof Promise) {
				return 'p';
			} else if (obj instanceof Date) {
				return 'd';
			} else if (is_array(obj)) {
				return 'a';
			} else {
				if (obj._is_observable === true) {
					return 'O';
				} else {
					if (typeof obj.callee === 'function') {
						return 'A';
					} else if (obj instanceof Error) {
						return 'e';
					} else if (obj instanceof RegExp) return 'r';
					return 'o';
				}
			}
			return res;
		}
	}
	console.trace();
	console.log('item', item);
	throw 'type not found';
	return res;
};
const atof = (arr) => {
	let res = new Array(arr.length);
	for (let c = 0, l = arr.length; c < l; c++) {
		res[c] = tof(arr[c]);
	}
	return res;
};
const is_defined = (value) => {
		return typeof (value) != 'undefined';
	},
	isdef = is_defined;
const stringify = JSON.stringify;

// Older version???

let _get_item_sig = (i, arr_depth) => {
	let res;
	let t1 = typeof i;
	if (t1 === 'string') {
		res = 's';
	} else if (t1 === 'number') {
		res = 'n';
	} else if (t1 === 'boolean') {
		res = 'b';
	} else if (t1 === 'function') {
		res = 'f';
	} else {
		let t = tof(i, t1);
		if (t === 'array') {
			if (arr_depth) {
				res = '['
				for (let c = 0, l = i.length; c < l; c++) {
					if (c > 0) res = res + ',';
					res = res + get_item_sig(i[c], arr_depth - 1);
				}
				res = res + ']';
			} else {
				res = 'a';
			}
		} else if (t === 'control') {
			res = 'c';
		} else if (t === 'date') {
			res = 'd';
		} else if (t === 'observable') {
			res = 'O';
		} else if (t === 'regex') {
			res = 'r';
		} else if (t === 'buffer') {
			res = 'B';
		} else if (t === 'readable_stream') {
			res = 'R';
		} else if (t === 'writable_stream') {
			res = 'W';
		} else if (t === 'object') {
			res = 'o';
		} else if (t === 'undefined') {
			res = 'u';
		} else {
			if (t === 'collection_index') {
				return 'X';
			} else if (t === 'data_object') {
				if (i._abstract) {
					res = '~D';
				} else {
					res = 'D';
				}
			} else {
				if (t === 'data_value') {
					if (i._abstract) {
						res = '~V';
					} else {
						res = 'V';
					}
				} else if (t === 'null') {
					res = '!';
				} else if (t === 'collection') {
					if (i._abstract) {
						res = '~C';
					} else {
						res = 'C';
					}
				} else {
					res = '?';
				}
			}
		}
	}
	return res;
};
const get_item_sig = (item, arr_depth) => {
	if (arr_depth) {
		return _get_item_sig(item, arr_depth);
	}
	const t = tof(item);

	if (map_loaded_type_abbreviations[t]) {
		return map_loaded_type_abbreviations[t];
	} else {
		let bt = typeof item;
		if (bt === 'object') {
			if (is_array(item)) {
				return 'a';
			} else {
				return 'o';
			}
		} else {
			console.log('map_loaded_type_abbreviations type name not found', t);
			console.log('bt', bt);
			console.trace();
			throw 'stop';
		}
	}
}
const get_a_sig = (a) => {
	let c = 0,
		l = a.length;

	//console.log('is_array(a)', is_array(a));
	//console.log('a', a);
	//console.log('get_a_sig l', l);
	let res = '[';
	let first = true;
	for (c = 0; c < l; c++) {
		if (!first) {
			res = res + ',';
		} else {
			first = false;
		}
		res = res + get_item_sig(a[c]);
	}
	res = res + ']';
	return res;
}
const deep_sig = (item, max_depth = -1, depth = 0) => {
	const t = tf(item);
	let res = '';
	if (t === 'a') {
		const l = item.length;
		if (max_depth === -1 || depth <= max_depth) {
			res = res + '[';
			let first = true;
			for (let c = 0; c < l; c++) {
				if (!first) res = res + ',';
				res = res + deep_sig(item[c], max_depth, depth + 1);
				first = false;
			}
			res = res + ']';
		} else {
			return 'a';
		}
	} else if (t === 'A') {
		const l = item.length;
		let first = true;
		for (let c = 0; c < l; c++) {
			if (!first) res = res + ',';
			res = res + deep_sig(item[c], max_depth, depth + 1);
			first = false;
		}
	} else if (t === 'o') {
		if (max_depth === -1 || depth <= max_depth) {
			let res = '{';
			let first = true;
			each(item, (v, k) => {
				if (!first) res = res + ',';
				res = res + '"' + k + '":' + deep_sig(v, max_depth, depth + 1);
				first = false;
			});
			res = res + '}';
			return res;
		} else {
			return 'o';
		}
	} else {
		res = res + t;
	}
	return res;
}
const trim_sig_brackets = function (sig) {
	if (tof(sig) === 'string') {
		if (sig.charAt(0) == '[' && sig.charAt(sig.length - 1) == ']') {
			return sig.substring(1, sig.length - 1);
		} else {
			return sig;
		}
	}
};
const arr_trim_undefined = function (arr_like) {
	let res = [];
	let last_defined = -1;
	let t, v;
	for (let c = 0, l = arr_like.length; c < l; c++) {
		v = arr_like[c];
		t = tof(v);
		if (t == 'undefined') {} else {
			last_defined = c;
		}
	}
	for (let c = 0, l = arr_like.length; c < l; c++) {
		if (c <= last_defined) {
			res.push(arr_like[c]);
		}
	}
	return res;
};

// Could see about simply integrating data types into fp....?
//   That could mean habing get_item_sig return sigs for those data types.
//     Would need to define signature abbreviations for them.





const functional_polymorphism = function (options, fn) {
	let a0 = arguments;
	if (a0.length === 1) {
		fn = a0[0];
		options = null;
	}
	let arr_slice = Array.prototype.slice;
	let arr, sig, a2, l, a;
	return function () {
		a = arguments;
		l = a.length;
		if (l === 1) {
			sig = get_item_sig([a[0]], 1);
			a2 = [a[0]];
			a2.l = 1;
			return fn.call(this, a2, sig);
		} else if (l > 1) {
			arr = arr_trim_undefined(arr_slice.call(a, 0));
			sig = get_item_sig(arr, 1);
			arr.l = arr.length;
			return fn.call(this, arr, sig);
		} else if (a.length === 0) {
			arr = new Array(0);
			arr.l = 0;
			return fn.call(this, arr, '[]');
		}
	}
};
const fp = functional_polymorphism;
const parse_sig = (str_sig, opts = {}) => {
	const sig2 = str_sig.split(', ').join(',');
	const sig_items = sig2.split(',');
	const res = [];
	each(sig_items, sig_item => {
		if (sig_item.length === 1) {
			let type_name = map_loaded_type_names[sig_item];
			res.push({
				abbreviation: sig_item,
				type_name: type_name
			});
		} else {
			let suffix_modifiers;
			let zero_or_more = false;
			let one_or_more = false;
			let type_name = sig_item;
			const obj_res = {
				type_name: type_name
			}
			const distil_suffix_modifiers = () => {
				let last_char = type_name.substr(type_name.length - 1);
				if (last_char === '*') {
					type_name = type_name.substr(0, type_name.length - 1);
					zero_or_more = true;
					obj_res.zero_or_more = true;
					obj_res.modifiers = obj_res.modifiers || [];
					obj_res.modifiers.push('*');
					distil_suffix_modifiers();
				} else if (last_char === '+') {
					type_name = type_name.substr(0, type_name.length - 1);
					one_or_more = true;
					obj_res.one_or_more = true;
					obj_res.modifiers = obj_res.modifiers || [];
					obj_res.modifiers.push('+');
					distil_suffix_modifiers();
				} else {}
			}
			distil_suffix_modifiers();
			obj_res.type_name = type_name;
			res.push(obj_res);
		}
	});
	return res;
}
const mfp_not_sigs = get_truth_map_from_arr(['pre', 'default', 'post']);
const mfp_unparse_sig = arr_sig => {
	let res = '[';
	let first = true;
	each(arr_sig, sig_item => {
		if (!first) {
			res = res + ',';
		}
		res = res + sig_item.abbreviation;
		first = false;
	})
	res = res + ']';
	return res;
}
const map_grammar_def_abbreviations = {
	'string': 's',
	'number': 'n',
	'boolean': 'b',
	's': 's',
	'n': 'n',
	'b': 'b'
}
const log = () => {};
const combinations = (arr, arr_idxs_to_ignore) => {
	const map_ignore_idxs = {};
	if (arr_idxs_to_ignore) {
		each(arr_idxs_to_ignore, idx_to_ignore => {
			map_ignore_idxs[idx_to_ignore] = true;
		});
	}
	const res = [];
	const l = arr.length;
	const arr_idxs_num_options = new Uint32Array(l);
	each(arr, (arr_item1, i1) => {
		arr_idxs_num_options[i1] = arr_item1.length;
	});
	const arr_current_option_idxs = (new Uint32Array(l)).fill(0);
	const result_from_indexes = (arr, arg_indexes) => {
		const res = new Array(l);
		if (arg_indexes.length === l) {
			for (var c = 0; c < l; c++) {
				res[c] = arr[c][arg_indexes[c]];
			}
		} else {
			console.trace();
			throw 'Arguments length mismatch';
		}
		return res;
	}
	const incr = () => {
		for (c = l - 1; c >= 0; c--) {
			const ival = arr_current_option_idxs[c];
			const max = arr_idxs_num_options[c] - 1;
			if (ival < max) {
				arr_current_option_idxs[c]++;
				break;
			} else {
				if (c === 0) {
					return false;
				} else {
					arr_current_option_idxs.fill(0, c);
				}
			}
		}
		return true;
	}
	let vals = result_from_indexes(arr, arr_current_option_idxs);
	res.push(vals);
	while (incr()) {
		let vals = result_from_indexes(arr, arr_current_option_idxs);
		res.push(vals);
	}
	return res;
}
const map_native_types = {
	'string': true,
	'boolean': true,
	'number': true,
	'object': true
}
const map_native_type_sigs = {
	's': true,
	'n': true,
	'o': true,
	'a': true,
	'd': true
}


// Late 2023 - mfp may be a good basis to proceed with more data-type aware idioms.
//   Want to use it for mid-level precise and concise code where possible.
//     May use it or its conventions in implementing some higher level (incl mid level) things.

// Would be worth setting up and testing (maybe also benchmarking) Data_Value objects that specifically represent numbers between
//  -180 and 180. Also integrating such Data_Value objects within a Data_Object or other Data_Model.
// Maybe want some kind of _, $, or dm or _dm type shorthand for things that are very useful.
//   Though it does make sense to abstractify things that get used a lot to make it mroe concise.
//     Also worth designing and then using the concise idioms.

// mfp seems like some code that could be redone / changed and parts used elsewhere to implement the mid and high level
//   APIs as wanted.





const mfp = function () {

	// mfp looks complex. may need to look into what it's for and can do.
	//   Looks like an old work-in-progress.
	//     Should look into benchmarking its usage in different places.

	const a1 = arguments;
	const sig1 = get_a_sig(a1);
	let options = {};
	let fn_pre, provided_map_sig_fns, inner_map_sig_fns = {},
		inner_map_parsed_sigs = {},
		arr_sig_parsed_sig_fns = [],
		fn_post;
	let tm_sig_fns;
	let fn_default;
	let single_fn;
	let req_sig_single_fn;
	if (sig1 === '[o]') {
		provided_map_sig_fns = a1[0];
	} else if (sig1 === '[o,o]') {
		options = a1[0];
		provided_map_sig_fns = a1[1];
	} else if (sig1 === '[o,f]') {
		options = a1[0];
		single_fn = a1[1];
	} else if (sig1 === '[o,s,f]') {
		options = a1[0];
		req_sig_single_fn = a1[1];
		single_fn = a1[2];
		provided_map_sig_fns = {};
		provided_map_sig_fns[req_sig_single_fn] = single_fn;
	} else if (sig1 === '[f,o]') {
		single_fn = a1[0];
		options = a1[1];
	} else if (sig1 === '[f]') {
		single_fn = a1[0];
	} else {
		console.log('sig1', sig1);
		console.trace();
		throw 'mfp NYI';
	}
	let {
		single,
		name,
		grammar,
		verb,
		noun,
		return_type,
		return_subtype,
		pure,
		main,
		skip
	} = options;
	let parsed_grammar;
	let identify, validate;
	let dsig = deep_sig;
	(() => {
		if (provided_map_sig_fns) {
			if (provided_map_sig_fns.default) fn_default = provided_map_sig_fns.default;
			each(provided_map_sig_fns, (fn, sig) => {
				if (typeof fn === 'function') {
					if (!mfp_not_sigs[sig]) {
						const parsed_sig = parse_sig(sig);
						const arr_args_with_modifiers = [];
						const arr_args_all_modification_versions = [];
						each(parsed_sig, (arg, i) => {
							arr_args_all_modification_versions[i] = [];
							if (arg.modifiers) {
								const arg_num_modifiers = arg.modifiers.length;
								if (arg_num_modifiers > 1) {
									throw 'Use of more than 1 modifier is currently unsupported.';
								} else if (arg_num_modifiers === 1) {
									arr_args_with_modifiers.push([i, arg]);
									const single_modifier = arg.modifiers[0];
									if (single_modifier === '*') {
										arr_args_all_modification_versions[i].push('');
										arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
										const plural_name = grammar.maps.sing_plur[arg.type_name];
										arr_args_all_modification_versions[i].push(plural_name);
									}
									if (single_modifier === '+') {
										arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
										const plural_name = grammar.maps.sing_plur[arg.type_name];
										arr_args_all_modification_versions[i].push(plural_name);
									}
									if (single_modifier === '?') {
										arr_args_all_modification_versions[i].push('');
										arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
									}
								}
							} else {
								arr_args_all_modification_versions[i].push(arg.abbreviation || arg.type_name);
							}
						});
						const combo_args = combinations(arr_args_all_modification_versions);
						const combo_sigs = [];
						let i_first_of_last_undefined = -1;
						each(combo_args, arg_set => {
							let combo_sig = '';
							each(arg_set, (arg, i) => {
								let lsigb4 = combo_sig.length;
								if (i > 0) {
									combo_sig = combo_sig + ',';
								}
								if (arg === '') {
									combo_sig = combo_sig + 'u';
									if (i_first_of_last_undefined === -1) {
										i_first_of_last_undefined = lsigb4;
									}
								} else {
									combo_sig = combo_sig + arg;
									i_first_of_last_undefined = -1;
								}
							})
							if (i_first_of_last_undefined > 0) {
								const combo_sig_no_last_undefined = combo_sig.substr(0, i_first_of_last_undefined);
								combo_sigs.push(combo_sig_no_last_undefined);
							}
							combo_sigs.push(combo_sig);
						})
						if (combo_sigs.length > 0) {
							each(combo_sigs, combo_sig => {
								inner_map_sig_fns[combo_sig] = fn;
							});
						} else {
							inner_map_sig_fns[sig] = fn;
						}
						inner_map_parsed_sigs[sig] = parsed_sig;
						arr_sig_parsed_sig_fns.push([sig, parsed_sig, fn]);
					} else {
						console.log('ommiting, not parsing sig', sig);
					}
				} else {
					console.log('fn', fn);
					console.trace();
					throw 'Expected: function';
				};
			});
		}
		each(inner_map_sig_fns, (fn, sig) => {
			tm_sig_fns = tm_sig_fns || {};
			tm_sig_fns[sig] = true;
		});
	})();
	const res = function () {
		const a2 = arguments;
		const l2 = a2.length;
		console.log('');
		console.log('calling mfp function');
		console.log('--------------------');
		console.log('');
		let mfp_fn_call_deep_sig;
		let ltof = tof;
		const lsig = dsig;
		let ltf = tf;
		mfp_fn_call_deep_sig = lsig(a2);
		let do_skip = false;
		if (skip) {
			if (skip(a2)) {
				do_skip = true;
			} else {}
		}
		if (!do_skip) {
			if (inner_map_sig_fns[mfp_fn_call_deep_sig]) {
				return inner_map_sig_fns[mfp_fn_call_deep_sig].apply(this, a2);
			} else {
				let idx_last_fn = -1;
				let idx_last_obj = -1;
				each(a2, (arg, i_arg) => {
					i_arg = parseInt(i_arg, 10);
					const targ = tf(arg);
					if (targ === 'o') {
						idx_last_obj = i_arg;
					}
					if (targ === 'f') {
						idx_last_fn = i_arg;
					}
				})
				const last_arg_is_fn = idx_last_fn > -1 && idx_last_fn === a2.length - 1;
				const last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 1;
				const second_last_arg_is_obj = idx_last_obj > -1 && idx_last_obj === a2.length - 2;
				let possible_options_obj;
				if (last_arg_is_obj) possible_options_obj = a2[idx_last_obj];
				const new_args_arrangement = [];
				for (let f = 0; f < idx_last_obj; f++) {
					new_args_arrangement.push(a2[f]);
				}
				each(possible_options_obj, (value, key) => {
					new_args_arrangement.push(value);
				});
				let naa_sig = lsig(new_args_arrangement);
				naa_sig = naa_sig.substring(1, naa_sig.length - 1);
				if (inner_map_sig_fns[naa_sig]) {
					return inner_map_sig_fns[naa_sig].apply(this, new_args_arrangement);
				} else {
					if (fn_default) {
						return fn_default.call(this, a2, mfp_fn_call_deep_sig);
					} else {
						if (single_fn) {
							console.log('pre apply single_fn');
							return single_fn.apply(this, a2);
						} else {
							console.log('Object.keys(inner_map_parsed_sigs)', Object.keys(inner_map_parsed_sigs));
							console.trace();
							console.log('mfp_fn_call_deep_sig', mfp_fn_call_deep_sig);
							console.log('provided_map_sig_fns', provided_map_sig_fns);
							if (provided_map_sig_fns) log('Object.keys(provided_map_sig_fns)', Object.keys(provided_map_sig_fns));
							console.log('Object.keys(inner_map_sig_fns)', Object.keys(inner_map_sig_fns));
							console.trace();
							throw 'no signature match found. consider using a default signature. mfp_fn_call_deep_sig: ' + mfp_fn_call_deep_sig;
						}
					}
				}
			}
		}
	}
	const _ = {}
	if (name) _.name = name;
	if (single) _.single = single;
	if (skip) _.skip = skip;
	if (grammar) _.grammar = grammar;
	if (typeof options !== 'undefined' && options.async) _.async = options.async;
	if (main === true) _.main = true;
	if (return_type) _.return_type = return_type;
	if (return_subtype) _.return_subtype = return_subtype;
	if (pure) _.pure = pure;
	if (tm_sig_fns) _.map_sigs = tm_sig_fns;
	if (Object.keys(_).length > 0) {
		res._ = _;
	}
	return res;
}
const convert = (input, conversion_schema) => {}
let arrayify = fp(function (a, sig) {
	let param_index, num_parallel = 1,
		delay = 0,
		fn;
	let res;
	let process_as_fn = function () {
		res = function () {
			let a = arr_like_to_arr(arguments),
				ts = atof(a),
				t = this;
			let last_arg = a[a.length - 1];
			if (tof(last_arg) == 'function') {
				if (typeof param_index !== 'undefined' && ts[param_index] == 'array') {
					let res = [];
					let fns = [];
					each(a[param_index], function (v, i) {
						let new_params = a.slice(0, a.length - 1);
						new_params[param_index] = v;
						fns.push([t, fn, new_params]);
					});
					call_multiple_callback_functions(fns, num_parallel, delay, (err, res) => {
						if (err) {
							console.trace();
							throw err;
						} else {
							let a = [];
							a = a.concat.apply(a, res);
							let callback = last_arg;
							callback(null, a);
						}
					})
				} else {
					return fn.apply(t, a);
				}
			} else {
				if (typeof param_index !== 'undefined' && ts[param_index] == 'array') {
					let res = [];
					for (let c = 0, l = a[param_index].length; c < l; c++) {
						a[param_index] = arguments[param_index][c];
						let result = fn.apply(t, a);
						res.push(result);
					}
					return res;
				} else {
					return fn.apply(t, a);
				}
			}
		};
	}
	if (sig == '[o]') {
		let res = [];
		each(a[0], function (v, i) {
			res.push([v, i]);
		});
	} else if (sig == '[f]') {
		param_index = 0, fn = a[0];
		process_as_fn();
	} else if (sig == '[n,f]') {
		param_index = a[0], fn = a[1];
		process_as_fn();
	} else if (sig == '[n,n,f]') {
		param_index = a[0], num_parallel = a[1], fn = a[2];
		process_as_fn();
	} else if (sig == '[n,n,n,f]') {
		param_index = a[0], num_parallel = a[1], delay = a[2], fn = a[3];
		process_as_fn();
	}
	return res;
});
let mapify = (target) => {
	let tt = tof(target);
	if (tt == 'function') {
		let res = fp(function (a, sig) {
			let that = this;
			if (sig == '[o]') {
				let map = a[0];
				each(map, function (v, i) {
					target.call(that, v, i);
				});
			} else if (sig == '[o,f]') {
				let map = a[0];
				let callback = a[1];
				let fns = [];
				each(map, function (v, i) {
					fns.push([target, [v, i]]);
				});
				call_multi(fns, function (err_multi, res_multi) {
					if (err_multi) {
						callback(err_multi);
					} else {
						callback(null, res_multi);
					}
				});
			} else if (a.length >= 2) {
				target.apply(this, a);
			}
		});
		return res;
	} else if (tt == 'array') {
		let res = {};
		if (arguments.length == 1) {
			if (is_arr_of_strs(target)) {
				each(target, function (v, i) {
					res[v] = true;
				});
			} else {
				each(target, function (v, i) {
					res[v[0]] = v[1];
				});
			}
		} else {
			let by_property_name = arguments[1];
			each(target, function (v, i) {
				res[v[by_property_name]] = v;
			});
		}
		return res;
	}
};
let clone = fp((a, sig) => {
	let obj = a[0];
	if (a.l === 1) {
		if (obj && typeof obj.clone === 'function') {
			return obj.clone();
		} else {
			let t = tof(obj);
			if (t === 'array') {
				let res = [];
				each(obj, v => {
					res.push(clone(v));
				});
				return res;
			} else if (t === 'undefined') {
				return undefined;
			} else if (t === 'string') {
				return obj;
			} else if (t === 'number') {
				return obj;
			} else if (t === 'function') {
				return obj;
			} else if (t === 'boolean') {
				return obj;
			} else if (t === 'null') {
				return obj;
			} else {
				return Object.assign({}, obj);
			}
		}
	} else if (a.l === 2 && tof(a[1]) === 'number') {
		let res = [];
		for (let c = 0; c < a[1]; c++) {
			res.push(clone(obj));
		}
		return res;
	}
});
let set_vals = function (obj, map) {
	each(map, function (v, i) {
		obj[i] = v;
	});
};
let ll_set = (obj, prop_name, prop_value) => {
	let arr = prop_name.split('.');
	let c = 0,
		l = arr.length;
	let i = obj._ || obj,
		s;
	while (c < l) {
		s = arr[c];
		if (typeof i[s] == 'undefined') {
			if (c - l == -1) {
				i[s] = prop_value;
			} else {
				i[s] = {};
			}
		} else {
			if (c - l == -1) {
				i[s] = prop_value;
			}
		}
		i = i[s];
		c++;
	};
	return prop_value;
};
let ll_get = (a0, a1) => {
	if (a0 && a1) {
		let i = a0._ || a0;
		if (a1 == '.') {
			if (typeof i['.'] == 'undefined') {
				return undefined;
			} else {
				return i['.'];
			}
		} else {
			let arr = a1.split('.');
			let c = 0,
				l = arr.length,
				s;
			while (c < l) {
				s = arr[c];
				if (typeof i[s] == 'undefined') {
					if (c - l == -1) {} else {
						throw 'object ' + s + ' not found';
					}
				} else {
					if (c - l == -1) {
						return i[s];
					}
				}
				i = i[s];
				c++;
			}
		}
	}
};
let truth = function (value) {
	return value === true;
};
let iterate_ancestor_classes = (obj, callback) => {
	let ctu = true;
	let stop = () => {
		ctu = false;
	}
	callback(obj, stop);
	if (obj._superclass && ctu) {
		iterate_ancestor_classes(obj._superclass, callback);
	}
}
let is_arr_of_t = function (obj, type_name) {
	let t = tof(obj),
		tv;
	if (t === 'array') {
		let res = true;
		each(obj, function (v, i) {
			tv = tof(v);
			if (tv != type_name) res = false;
		});
		return res;
	} else {
		return false;
	}
}
let is_arr_of_arrs = function (obj) {
	return is_arr_of_t(obj, 'array');
}
let is_arr_of_strs = function (obj) {
	return is_arr_of_t(obj, 'string');
}
let input_processors = {};
let output_processors = {};
let call_multiple_callback_functions = fp(function (a, sig) {
	let arr_functions_params_pairs, callback, return_params = false;
	let delay;
	let num_parallel = 1;
	if (a.l === 1) {
	} else if (a.l === 2) {
		arr_functions_params_pairs = a[0];
		callback = a[1];
	} else if (a.l === 3) {
		if (sig === '[a,n,f]') {
			arr_functions_params_pairs = a[0];
			num_parallel = a[1];
			callback = a[2];
		} else if (sig === '[n,a,f]') {
			arr_functions_params_pairs = a[1];
			num_parallel = a[0];
			callback = a[2];
		} else if (sig === '[a,f,b]') {
			arr_functions_params_pairs = a[0];
			callback = a[1];
			return_params = a[2];
		}
	} else if (a.l === 4) {
		if (sig === '[a,n,n,f]') {
			arr_functions_params_pairs = a[0];
			num_parallel = a[1];
			delay = a[2];
			callback = a[3];
		} else if (sig == '[n,n,a,f]') {
			arr_functions_params_pairs = a[2];
			num_parallel = a[0];
			delay = a[1];
			callback = a[3];
		}
	}
	let res = [];
	let l = arr_functions_params_pairs.length;
	let c = 0;
	let count_unfinished = l;
	let num_currently_executing = 0;
	let process = delay => {
		num_currently_executing++;
		let main = () => {
			let pair = arr_functions_params_pairs[c];
			let context;
			let fn, params, fn_callback;
			let pair_sig = get_item_sig(pair);
			let t_pair = tof(pair);
			if (t_pair == 'function') {
				fn = pair;
				params = [];
			} else {
				if (pair) {
					if (pair.length == 1) {}
					if (pair.length == 2) {
						if (tof(pair[1]) == 'function') {
							context = pair[0];
							fn = pair[1];
							params = [];
						} else {
							fn = pair[0];
							params = pair[1];
						}
					}
					if (pair.length == 3) {
						if (tof(pair[0]) === 'function' && tof(pair[1]) === 'array' && tof(pair[2]) === 'function') {
							fn = pair[0];
							params = pair[1];
							fn_callback = pair[2];
						}
						if (tof(pair[1]) === 'function' && tof(pair[2]) === 'array') {
							context = pair[0];
							fn = pair[1];
							params = pair[2];
						}
					}
					if (pair.length == 4) {
						context = pair[0];
						fn = pair[1];
						params = pair[2];
						fn_callback = pair[3];
					}
				} else {}
			}
			let i = c;
			c++;
			let cb = (err, res2) => {
				num_currently_executing--;
				count_unfinished--;
				if (err) {
					let stack = new Error().stack;
					callback(err);
				} else {
					if (return_params) {
						res[i] = [params, res2];
					} else {
						res[i] = res2;
					}
					if (fn_callback) {
						fn_callback(null, res2);
					}
					if (c < l) {
						if (num_currently_executing < num_parallel) {
							process(delay);
						}
					} else {
						if (count_unfinished <= 0) {
							callback(null, res);
						}
					}
				}
			};
			let arr_to_call = params || [];
			arr_to_call.push(cb);
			if (fn) {
				if (context) {
					fn.apply(context, arr_to_call);
				} else {
					fn.apply(this, arr_to_call);
				}
			} else {}
		}
		if (arr_functions_params_pairs[c]) {
			if (delay) {
				setTimeout(main, delay);
			} else {
				main();
			}
		}
	}
	if (arr_functions_params_pairs.length > 0) {
		while ((c < l) && (num_currently_executing < num_parallel)) {
			if (delay) {
				process(delay * c);
			} else {
				process();
			}
		}
	} else {
		if (callback) {}
	}
});
let multi = call_multiple_callback_functions;
let call_multi = call_multiple_callback_functions;
let Fns = function (arr) {
	let fns = arr || [];
	fns.go = function (parallel, delay, callback) {
		let a = arguments;
		let al = a.length;
		if (al == 1) {
			call_multi(fns, a[0]);
		}
		if (al == 2) {
			call_multi(parallel, fns, delay);
		}
		if (al == 3) {
			call_multi(parallel, delay, fns, callback);
		}
	}
	return fns;
}
let native_constructor_tof = function (value) {
	if (value === String) {
		return 'String';
	}
	if (value === Number) {
		return 'Number';
	}
	if (value === Boolean) {
		return 'Boolean';
	}
	if (value === Array) {
		return 'Array';
	}
	if (value === Object) {
		return 'Object';
	}
}
let sig_match = function (sig1, sig2) {
	let sig1_inner = sig1.substr(1, sig1.length - 2);
	let sig2_inner = sig2.substr(1, sig2.length - 2);
	if (sig1_inner.indexOf('[') > -1 || sig1_inner.indexOf(']') > -1 || sig2_inner.indexOf('[') > -1 || sig2_inner.indexOf(']') > -1) {
		throw 'sig_match only supports flat signatures.';
	}
	let sig1_parts = sig1_inner.split(',');
	let sig2_parts = sig2_inner.split(',');
	let res = true;
	if (sig1_parts.length == sig2_parts.length) {
		let c = 0,
			l = sig1_parts.length,
			i1, i2;
		while (res && c < l) {
			i1 = sig1_parts[c];
			i2 = sig2_parts[c];
			if (i1 === i2) {} else {
				if (i1 !== '?') {
					res = false;
				}
			}
			c++;
		}
		return res;
	} else {
		return false;
	}
}
let remove_sig_from_arr_shell = function (sig) {
	if (sig[0] == '[' && sig[sig.length - 1] == ']') {
		return sig.substring(1, sig.length - 1);
	}
	return sig;
};
let str_arr_mapify = function (fn) {
	let res = fp(function (a, sig) {
		if (a.l == 1) {
			if (sig == '[s]') {
				let s_pn = a[0].split(' ');
				if (s_pn.length > 1) {
					return res.call(this, s_pn);
				} else {
					return fn.call(this, a[0]);
				}
			}
			if (tof(a[0]) == 'array') {
				let res2 = {},
					that = this;
				each(a[0], function (v, i) {
					res2[v] = fn.call(that, v);
				});
				return res2;
			}
		}
	});
	return res;
};
let to_arr_strip_keys = (obj) => {
	let res = [];
	each(obj, v => {
		res.push(v);
	});
	return res;
}
let arr_objs_to_arr_keys_values_table = (arr_objs) => {
	let keys = Object.keys(arr_objs[0]);
	let arr_items = [],
		arr_values;
	each(arr_objs, (item) => {
		arr_items.push(to_arr_strip_keys(item));
	});
	return [keys, arr_items];
}
let set_arr_tree_value = (arr_tree, arr_path, value) => {
	let item_current = arr_tree;
	let last_item_current, last_path_item;
	each(arr_path, (path_item) => {
		last_item_current = item_current;
		item_current = item_current[path_item];
		last_path_item = path_item;
	});
	last_item_current[last_path_item] = value;
}
let get_arr_tree_value = (arr_tree, arr_path) => {
	let item_current = arr_tree;
	each(arr_path, (path_item) => {
		item_current = item_current[path_item];
	});
	return item_current;
}
let deep_arr_iterate = (arr, path = [], callback) => {
	if (arguments.length === 2) {
		callback = path;
		path = [];
	}
	each(arr, (item, i) => {
		let c_path = clone(path);
		c_path.push(i);
		let t = tof(item);
		if (t === 'array') {
			deep_arr_iterate(item, c_path, callback);
		} else {
			callback(c_path, item);
		}
	})
}
let prom = (fn) => {
	let fn_res = function () {
		const a = arguments;
		const t_a_last = typeof a[a.length - 1];
		if (t_a_last === 'function') {
			fn.apply(this, a);
		} else {
			return new Promise((resolve, reject) => {
				[].push.call(a, (err, res) => {
					if (err) {
						reject(err);
					} else {
						resolve(res);
					}
				});
				fn.apply(this, a);
			})
		}
	}
	return fn_res;
}
const vectorify = n_fn => {
	let fn_res = fp(function (a, sig) {
		if (a.l > 2) {
			throw 'stop - need to check.'
			let res = a[0];
			for (let c = 1, l = a.l; c < l; c++) {
				res = fn_res(res, a[c]);
			}
			return res;
		} else {
			if (sig === '[n,n]') {
				return n_fn(a[0], a[1]);
			} else {
				const ats = atof(a);
				if (ats[0] === 'array') {
					if (ats[1] === 'number') {
						const res = [],
							n = a[1],
							l = a[0].length
						let c;
						for (c = 0; c < l; c++) {
							res.push(fn_res(a[0][c], n));
						}
						return res;
					}
					if (ats[1] === 'array') {
						if (ats[0].length !== ats[1].length) {
							throw 'vector array lengths mismatch';
						} else {
							const l = a[0].length, res = new Array(l),
								arr2 = a[1];
							for (let c = 0; c < l; c++) {
								res[c] = fn_res(a[0][c], arr2[c]);
							}
							return res;
						}
					}
				}
			}
		};
	});
	return fn_res;
};
const n_add = (n1, n2) => n1 + n2,
	n_subtract = (n1, n2) => n1 - n2,
	n_multiply = (n1, n2) => n1 * n2,
	n_divide = (n1, n2) => n1 / n2;
const v_add = vectorify(n_add),
	v_subtract = vectorify(n_subtract),
	v_multiply = vectorify(n_multiply),
	v_divide = vectorify(n_divide);
const vector_magnitude = function (vector) {
	// may calculate magnitudes of larger dimension vectors too.
	// alert(tof(vector[0]));
	// alert(vector[0] ^ 2);
	var res = Math.sqrt((Math.pow(vector[0], 2)) + (Math.pow(vector[1], 2)));
	return res;
};
const distance_between_points = function (points) {
	var offset = v_subtract(points[1], points[0]);
	//console.log('offset ' + stringify(offset));
	return vector_magnitude(offset);
}
// ui8c?
//  ui8x???  for both?
//  
// Getting into some lower level types here.
//   Consider specifying endianness for numbers.
// Specify things from the basics.
//   Have the descriptions make sense in English and programatically.
//   Have it understand the descriptions of data types including signifiers and representations.
// srtype.add_representation(...)
//   .representations.add
// or 'rep' function.
//  rep(str_tsig_name, definition of representaion / instructions)
const map_tas_by_type = {
	'c': Uint8ClampedArray,
	'ui8': Uint8Array,
	'i16': Int16Array,
	'i32': Int32Array,
	'ui16': Uint16Array,
	'ui32': Uint32Array,
	'f32': Float32Array,
	'f64': Float64Array
}
const get_typed_array = function () {
	const a = arguments;
	let length, input_array;
	const type = a[0];
	if (is_array(a[1])) {
		input_array = a[1];
	} else {
		length = a[1];
	}
	const ctr = map_tas_by_type[type];
	if (ctr) {
		if (input_array) {
			return ctr(input_array);
		} else if (length) {
			return ctr(length);
		}
	}
}

// Grammar class may be a bit tricky / complex.
//   Maybe it will help because it can be used to define objects easily???
//   Maybe need to get into much more detail??? Maybe a quick and efficient piece of grammar code could work here.

class Grammar {
	constructor(spec) {
		const eg_spec = {
			name: 'User Auth Grammar'
		}
		const {
			name
		} = spec;
		this.name = name;
		const eg_indexing = () => {
			let map_sing_plur = {};
			let map_plur_sing = {};
			let map_sing_def = {};
			let map_sig_sing = {};
			let map_sig0_sing = {};
			let map_sig1_sing = {};
			let map_sig2_sing = {};
		}
		this.maps = {
			sing_plur: {},
			plur_sing: {},
			sing_def: {},
			deep_sig_sing: {},
			obj_sig_sing: {},
			sig_levels_sing: {}
		}
		this.load_grammar(spec.def);
	}
	load_grammar(grammar_def) {
		const {
			sing_plur,
			plur_sing,
			sing_def,
			sig_levels_sing,
			deep_sig_sing,
			obj_sig_sing
		} = this.maps;
		const resolve_def = (def) => {
			const td = tf(def);
			if (td === 'a') {
				const res = [];
				each(def, def_item => {
					res.push(resolve_def(def_item));
				});
				return res;
			} else if (td === 's') {
				if (def === 'string') {
					return 'string';
				} else if (def === 'number') {
					return 'number';
				} else if (def === 'boolean') {
					return 'boolean';
				} else {
					const found_sing_def = sing_def[def];
					return found_sing_def;
				}
			} else if (td === 'n') {
				console.trace();
				throw 'NYI';
			} else if (td === 'b') {
				console.trace();
				throw 'NYI';
			}
		}
		const resolved_def_to_sig = (resolved_def, level = 0) => {
			const trd = tf(resolved_def);
			if (trd === 's') {
				if (resolved_def === 'string') {
					return 's'
				} else if (resolved_def === 'number') {
					return 'n'
				} else if (resolved_def === 'boolean') {
					return 'b'
				}
			} else if (trd === 'a') {
				let res = '';
				if (level === 0) {} else {
					res = res + '[';
				}
				each(resolved_def, (item, c) => {
					if (c > 0) {
						res = res + ',';
					}
					res = res + resolved_def_to_sig(item, level + 1);
				});
				if (level === 0) {} else {
					res = res + ']';
				}
				return res;
			} else {
				console.trace();
				throw 'NYI';
			}
			return res;
		}
		each(grammar_def, (def1, sing_word) => {
			const {
				def,
				plural
			} = def1;
			sing_def[sing_word] = def;
			sing_plur[sing_word] = plural;
			plur_sing[plural] = sing_word;
			const tdef = tf(def);
			const resolved_def = resolve_def(def);
			const resolved_def_sig = resolved_def_to_sig(resolved_def);
			deep_sig_sing[resolved_def_sig] = deep_sig_sing[resolved_def_sig] || [];
			deep_sig_sing[resolved_def_sig].push(sing_word);
			let def_is_all_custom_types = true;
			each(def, (def_item, c, stop) => {
				const tdi = tf(def_item);
				if (tdi === 's') {
					if (sing_def[def_item]) {} else {
						def_is_all_custom_types = false;
						stop();
					}
				} else {
					def_is_all_custom_types = false;
					stop();
				}
			});
			let obj_sig;
			if (def_is_all_custom_types) {
				obj_sig = '{';
				each(def, (def_item, c, stop) => {
					if (c > 0) {
						obj_sig = obj_sig + ',';
					}
					const resolved = resolve_def(def_item);
					const abr_resolved = resolved_def_to_sig(resolved);
					obj_sig = obj_sig + '"' + def_item + '":'
					obj_sig = obj_sig + abr_resolved;
				});
				obj_sig = obj_sig + '}';
			}
			if (obj_sig) {
				obj_sig_sing[obj_sig] = obj_sig_sing[obj_sig] || [];
				obj_sig_sing[obj_sig].push(sing_word);
			}
		})
	}
	tof(item) {
		const {
			sing_plur,
			plur_sing,
			sing_def,
			sig_levels_sing,
			deep_sig_sing,
			obj_sig_sing
		} = this.maps;
		const titem = tf(item);
		console.log('titem', titem);
		if (titem === 'a') {
			let all_arr_items_type;
			each(item, (subitem, c, stop) => {
				const subitem_type = this.tof(subitem);
				console.log('subitem_type', subitem_type);
				if (c === 0) {
					all_arr_items_type = subitem_type;
				} else {
					if (all_arr_items_type === subitem_type) {} else {
						all_arr_items_type = null;
						stop();
					}
				}
			});
			if (all_arr_items_type) {
				console.log('has all_arr_items_type', all_arr_items_type);
				if (!map_native_types[all_arr_items_type]) {
					const res = sing_plur[all_arr_items_type];
					return res;
				}
			} else {
				console.log('no all_arr_items_type');
			}
		} else {
			return tof(item);
		}
		const item_deep_sig = deep_sig(item);
		console.log('Grammar tof() item_deep_sig', item_deep_sig);
		let arr_sing;
		if (titem === 'a') {
			const unenclosed_sig = item_deep_sig.substring(1, item_deep_sig.length - 1);
			console.log('unenclosed_sig', unenclosed_sig);
			arr_sing = deep_sig_sing[unenclosed_sig];
		} else {
			arr_sing = deep_sig_sing[item_deep_sig];
		}
		if (arr_sing) {
			if (arr_sing.length === 1) {
				return arr_sing[0];
			} else {
				console.trace();
				throw 'NYI';
			}
		}
	}
	sig(item, max_depth = -1, depth = 0) {
		const {
			sing_plur,
			plur_sing,
			sing_def,
			sig_levels_sing,
			deep_sig_sing,
			obj_sig_sing
		} = this.maps;
		const extended_sig = item => {
			const ti = tf(item);
			let res = '';
			let same_grammar_type;
			const record_subitem_sigs = item => {
				same_grammar_type = undefined;
				let same_sig = undefined;
				each(item, (subitem, c) => {
					if (c > 0) {
						res = res + ',';
					}
					const sig_subitem = this.sig(subitem, max_depth, depth + 1);
					if (same_sig === undefined) {
						same_sig = sig_subitem;
					} else {
						if (sig_subitem !== same_sig) {
							same_sig = false;
							same_grammar_type = false;
						}
					}
					if (same_sig) {
						if (sing_def[sig_subitem]) {
							if (same_grammar_type === undefined) {
								same_grammar_type = sig_subitem;
							} else {
								if (same_grammar_type === sig_subitem) {} else {
									same_grammar_type = false;
								}
							}
						} else {}
					}
					res = res + sig_subitem;
				});
			}
			if (ti === 'A') {
				record_subitem_sigs(item);
				return res;
			} else if (ti === 'a') {
				record_subitem_sigs(item);
				if (same_grammar_type) {
					const plur_name = sing_plur[same_grammar_type];
					return plur_name;
				} else {
					const found_obj_type = obj_sig_sing[res];
					const found_deep_sig_type = deep_sig_sing[res];
					let found_type_sing;
					if (found_deep_sig_type) {
						if (found_deep_sig_type.length === 1) {
							found_type_sing = found_deep_sig_type[0];
						}
					}
					if (found_type_sing) {
						return found_type_sing;
					} else {
						const enclosed_res = '[' + res + ']';
						return enclosed_res;
					}
				}
			} else if (ti === 'o') {
				if (max_depth === -1 || depth <= max_depth) {
					res = res + '{';
					let first = true;
					each(item, (value, key) => {
						const vsig = this.sig(value, max_depth, depth + 1);
						if (!first) {
							res = res + ',';
						} else {
							first = false;
						}
						res = res + '"' + key + '":' + vsig;
					});
					res = res + '}';
					return res;
				} else {
					return 'o';
				}
			} else if (ti === 's' || ti === 'n' || ti === 'b') {
				return ti;
			} else {
				return ti;
			}
		}
		return extended_sig(item);
	}
	single_forms_sig(item) {
		const {
			sing_plur,
			plur_sing,
			sing_def,
			sig_levels_sing,
			deep_sig_sing,
			obj_sig_sing
		} = this.maps;
		let sig = this.sig(item);
		let s_sig = sig.split(',');
		const arr_res = [];
		each(s_sig, (sig_item, c) => {
			const sing = plur_sing[sig_item] || sig_item;
			arr_res.push(sing);
		});
		const res = arr_res.join(',');
		return res;
	}
}
class Evented_Class {
	'constructor'() {
		Object.defineProperty(this, '_bound_events', {
			value: {}
		});
	}
	'raise_event'() {
		let a = Array.prototype.slice.call(arguments),
			sig = get_a_sig(a);
		a.l = a.length;
		let target = this;
		let c, l, res;
		if (sig === '[s]') {
			let target = this;
			let event_name = a[0];
			let bgh = this._bound_general_handler;
			let be = this._bound_events;
			res = [];
			if (bgh) {
				for (c = 0, l = bgh.length; c < l; c++) {
					res.push(bgh[c].call(target, event_name));
				}
			}
			if (be) {
				let bei = be[event_name];
				if (tof(bei) == 'array') {
					for (c = 0, l = bei.length; c < l; c++) {
						res.push(bei[c].call(target));
					}
					return res;
				}
			}
		}
		if (sig === '[s,a]') {
			let be = this._bound_events;
			let bgh = this._bound_general_handler;
			let event_name = a[0];
			res = [];
			if (bgh) {
				for (c = 0, l = bgh.length; c < l; c++) {
					res.push(bgh[c].call(target, event_name, a[1]));
				}
			}
			if (be) {
				let bei = be[event_name];
				if (tof(bei) === 'array') {
					for (c = 0, l = bei.length; c < l; c++) {
						res.push(bei[c].call(target, a[1]));
					}
				}
			}
		}
		if (sig === '[s,b]' || sig === '[s,s]' || sig === '[s,n]' || sig === '[s,B]' || sig === '[s,O]' || sig === '[s,e]') {
			let be = this._bound_events;
			let bgh = this._bound_general_handler;
			let event_name = a[0];
			res = [];
			if (bgh) {
				for (c = 0, l = bgh.length; c < l; c++) {
					res.push(bgh[c].call(target, event_name, a[1]));
				}
			}
			if (be) {
				let bei = be[event_name];
				if (tof(bei) === 'array') {
					for (c = 0, l = bei.length; c < l; c++) {
						res.push(bei[c].call(target, a[1]));
					}
				}
			}
		}
		if (sig === '[s,o]' || sig === '[s,?]') {
			let be = this._bound_events;
			let bgh = this._bound_general_handler;
			let event_name = a[0];
			res = [];
			if (bgh) {
				for (c = 0, l = bgh.length; c < l; c++) {
					res.push(bgh[c].call(target, event_name, a[1]));
				}
			}
			if (be) {
				let bei = be[event_name];
				if (tof(bei) === 'array') {
					for (c = 0, l = bei.length; c < l; c++) {
						res.push(bei[c].call(target, a[1]));
					}
				}
			}
		} else {
			if (a.l > 2) {
				let event_name = a[0];
				let additional_args = [];
				let bgh_args = [event_name];
				for (c = 1, l = a.l; c < l; c++) {
					additional_args.push(a[c]);
					bgh_args.push(a[c]);
				}
				let be = this._bound_events;
				let bgh = this._bound_general_handler;
				res = [];
				if (bgh) {
					for (c = 0, l = bgh.length; c < l; c++) {
						res.push(bgh[c].apply(target, bgh_args));
					}
				}
				if (be) {
					let bei = be[event_name];
					if (tof(bei) == 'array') {
						if (bei.length > 0) {
							for (c = 0, l = bei.length; c < l; c++) {
								if (bei[c]) res.push(bei[c].apply(target, additional_args));
							}
							return res;
						} else {
							return res;
						}
					}
				}
			} else {}
		}
		return res;
	}
	'add_event_listener'() {
		const {
			event_events
		} = this;
		let a = Array.prototype.slice.call(arguments),
			sig = get_a_sig(a);
		if (sig === '[f]') {
			this._bound_general_handler = this._bound_general_handler || [];
			if (is_array(this._bound_general_handler)) {
				this._bound_general_handler.push(a[0]);
			};
		}
		if (sig === '[s,f]') {
			let event_name = a[0],
				fn_listener = a[1];
			if (!this._bound_events[event_name]) this._bound_events[event_name] = [];
			let bei = this._bound_events[event_name];
			if (is_array(bei)) {
				bei.push(fn_listener);
				if (event_events) {
					this.raise('add-event-listener', {
						'name': event_name
					})
				}
			} else {
				console.trace();
				throw 'Expected: array';
			}
		}
		return this;
	}
	'remove_event_listener'(event_name, fn_listener) {
		const {
			event_events
		} = this;
		if (this._bound_events) {
			let bei = this._bound_events[event_name] || [];
			if (is_array(bei)) {
				let c = 0,
					l = bei.length,
					found = false;
				while (!found && c < l) {
					if (bei[c] === fn_listener) {
						found = true;
					} else {
						c++;
					}
				}
				if (found) {
					bei.splice(c, 1);
					if (event_events) {
						this.raise('remove-event-listener', {
							'name': event_name
						});
					}
				}
			} else {
				console.trace();
				throw 'Expected: array';
			}
		}
		return this;
	}
	get bound_named_event_counts() {
		const res = {};
		if (this._bound_events) {
			const keys = Object.keys(this._bound_events);
			each(keys, key => {
				res[key] = this._bound_events[key].length;
			})
		}
		return res;
	}
	'one'(event_name, fn_handler) {
		let inner_handler = function (e) {
			fn_handler.call(this, e);
			this.off(event_name, inner_handler);
		};
		this.on(event_name, inner_handler);
	}
	'changes'(obj_changes) {
		if (!this.map_changes) {
			this.map_changes = {};
		}
		each(obj_changes, (handler, name) => {
			this.map_changes[name] = this.map_changes[name] || [];
			this.map_changes[name].push(handler);
		})
		if (!this._using_changes) {
			this._using_changes = true;
			this.on('change', e_change => {
				const {
					name,
					value
				} = e_change;
				if (this.map_changes[name]) {
					each(this.map_changes[name], h_change => {
						h_change(value);
					})
				}
			})
		}
	}
};
const p = Evented_Class.prototype;
p.raise = p.raise_event;
p.trigger = p.raise_event;
p.subscribe = p.add_event_listener;
p.on = p.add_event_listener;
p.off = p.remove_event_listener;
const eventify = obj => {
	const bound_events = {};
	const add_event_listener = (name, handler) => {
		if (handler === undefined && typeof name === 'function') {
			handler = name;
			name = '';
		}
		if (!bound_events[name]) bound_events[name] = [];
		bound_events[name].push(handler);
	}
	const remove_event_listener = (name, handler) => {
		if (bound_events[name]) {
			const i = bound_events[name].indexOf(handler);
			if (i > -1) {
				bound_events[name].splice(i, 1);
			}
		}
	}
	const raise_event = (name, optional_param) => {
		const arr_named_events = bound_events[name];
		if (arr_named_events !== undefined) {
			if (optional_param !== undefined) {
				const l = arr_named_events.length;
				for (let c = 0; c < l; c++) {
					arr_named_events[c].call(obj, optional_param);
				}
			} else {
				const l = arr_named_events.length;
				for (let c = 0; c < l; c++) {
					arr_named_events[c].call(obj);
				}
			}
		}
	}
	obj.on = obj.add_event_listener = add_event_listener;
	obj.off = obj.remove_event_listener = remove_event_listener;
	obj.raise = obj.raise_event = raise_event;
	return obj;
}

// Assign_From_Spec_Class


// Assign_From_Spec_Evented_Class




class Publisher extends Evented_Class {
	constructor(spec = {}) {
		super({});
		this.one('ready', () => {
			this.is_ready = true;
		})
	}
	get when_ready () {
		return new Promise((solve, jettison) => {
			if (this.is_ready === true) {
				solve();
			} else {
				this.one('ready', () => {
					solve();
				})
			}
		})
	}
}

const prop = (...a) => {

	// Using (predefined?) data types here?

	// ...args?
	let s = get_a_sig(a);
	const raise_change_events = true;
	const ifn = item => typeof item === "function";

	if (s === "[a]") {
		each(a[0], item_params => {
			prop.apply(this, item_params);
		});
	} else {
		if (a.length === 2) {
			if (ia(a[1])) {
				const target = a[0];
				each(a[1], item => {
					if (ia(item)) {
						throw "NYI 468732";
					} else {
						prop(target, item);
					}
				});
			} else {
				const ta1 = tof(a[1]);
				if (ta1 === "string") {
					[obj, prop_name] = a;
				} else {
					throw "NYI 468732b";
				}
			}
		} else if (a.length > 2) {
			if (is_array(a[0])) {
				// the rest of the properties applied to the array of items.
				throw "stop";
				let objs = a.shift();
				each(objs, obj => {
					prop.apply(this, [obj].concat(item_params)); // bug
				});
			} else {
				let obj, prop_name, default_value, fn_onchange, fn_transform, fn_on_ready, options;
				const load_options = options => {
					prop_name = prop_name || options.name || options.prop_name;
					fn_onchange =
						options.fn_onchange || options.onchange || options.change;
					fn_transform =
						options.fn_transform || options.ontransform || options.transform;
					fn_on_ready = options.ready || options.on_ready;
					default_value = default_value || options.default_value || options.default;
				};
				if (a.length === 2) {
					[obj, options] = a;
					load_options(options);
				} else if (a.length === 3) {
					if (ifn(a[2])) {
						[obj, prop_name, fn_onchange] = a;
					} else {
						if (a[2].change || a[2].ready) {
							load_options(a[2]);

							[obj, prop_name] = a;
						} else {
							[obj, prop_name, default_value] = a;
						}
					}
					//[obj, prop_name, default_value, fn_transform] = a;
				} else if (a.length === 4) {
					if (ifn(a[2]) && ifn(a[3])) {
						[obj, prop_name, fn_transform, fn_onchange] = a;
					} else if (ifn(a[3])) {
						[obj, prop_name, default_value, fn_onchange] = a;
					} else {
						[obj, prop_name, default_value, options] = a;
						load_options(options);
					}
				} else if (a.length === 5) {
					[obj, prop_name, default_value, fn_transform, fn_onchange] = a;
				}
				let _prop_value;

				if (typeof default_value !== 'undefined') _prop_value = default_value;
				// And a silent set function that does not raise the change event.
				const _silent_set = value => {
					let _value;
					if (fn_transform) {
						_value = fn_transform(value);
					} else {
						_value = value;
					}
					_prop_value = _value;
				}
				const _set = value => {
					let _value;
					if (fn_transform) {
						_value = fn_transform(value);
					} else {
						_value = value;
					}
					let old = _prop_value;
					_prop_value = _value;
					if (fn_onchange) {
						fn_onchange({
							old: old,
							value: _prop_value
						});
					}
					if (obj.raise && raise_change_events) {
						obj.raise("change", {
							name: prop_name,
							old: old,
							value: _prop_value
						});
					}
				};
				if (is_defined(default_value)) {
					_prop_value = default_value;
				}
				const t_prop_name = tf(prop_name);
				if (t_prop_name === 's') {

					Object.defineProperty(obj, prop_name, {
						get() {
							return _prop_value;
						},
						set(value) {
							_set(value);
						}
					});

				} else if (t_prop_name === 'a') {
					const l = prop_name.length;
					//console.log('prop_name', prop_name);
					let item_prop_name;
					for (let c = 0; c < l; c++) {
						item_prop_name = prop_name[c];
						//console.log('item_prop_name', item_prop_name);
						Object.defineProperty(obj, item_prop_name, {
							get() {
								return _prop_value;
							},
							set(value) {
								_set(value);
							}
						});
					}
				} else {
					throw 'Unexpected name type: ' + t_prop_name;
				}
				if (fn_on_ready) {
					fn_on_ready({
						silent_set: _silent_set
					})
				}
			}
		}
	}
};



class Data_Type {

}

class Functional_Data_Type extends Data_Type {
    constructor(spec) {

		/*
		named_property_access: true,
		property_names: ['latitude', 'longitude'],
		// And the property types as well being the same in this case?
		abbreviated_property_names: ['lat', 'long'],
		numbered_property_access: true, // Maybe that's good enough to make it like an array when there are 2 properties.

		*/
        
        // fns for: validate as exact type...?
        // convert from whatever it is to that exact type (if possible)
        //   string and binary conversions.
        //   eg a convert_load type operation.

        // it's super / parent type.
        super(spec);

        if (spec.supertype) this.supertype = spec.supertype;
        if (spec.name) this.name = spec.name;
        if (spec.abbreviated_name) this.abbreviated_name = spec.abbreviated_name;
		if (spec.named_property_access) this.named_property_access = spec.named_property_access;
		if (spec.numbered_property_access) this.numbered_property_access = spec.numbered_property_access;
		if (spec.property_names) this.property_names = spec.property_names;
		if (spec.property_data_types) this.property_data_types = spec.property_data_types;
		if (spec.wrap_properties) this.wrap_properties = spec.wrap_properties;
		if (spec.wrap_value_inner_values) this.wrap_value_inner_values = spec.wrap_value_inner_values;
		if (spec.value_js_type) this.value_js_type = spec.value_js_type;
		// value_js_type

		// wrap_value as well????
		//   Though the value kind-of is itself.
		//    maybe .inner_js_value is much clearer here?
		// wrap_value_inner_values



		if (spec.abbreviated_property_names) this.abbreviated_property_names = spec.abbreviated_property_names;
        if (spec.validate) this.validate = spec.validate;
        if (spec.validate_explain) this.validate_explain = spec.validate_explain;
		if (spec.parse_string) this.parse_string = spec.parse_string;
		if (spec.parse) this.parse = spec.parse;

		// But also want it to be able to accept undefined value (usually???)




        // and abbreviated name
        // spec.validate (needs to be perfect...)

        // spec.load_from(...?)
        // spec.poly_load??

        // spec.input transformers???
        //   transform from other identified types...?

        // For the moment, we don't want too many and too complex functions.

    }
}

//lang.Data_Type = Data_Type;
//lang.Functional_Data_Type = Functional_Data_Type;



// And let's define some....

// And a correct value...?
//   Eg if a number is not valid because it has too many decimal points, it could be corrected.
//     Or even an int that's too large, outside a range, corrected to fit in that range.

// So making a Data_Value stick to using these Data_Types could be helpful.

// For the moment this is really simple and should work fine for some things.

// Allow undefined????
//   Or better to have that on a different level.
//     Maybe does make sense as an option here.

//     Or consider it and do it later.


Functional_Data_Type.number = new Functional_Data_Type({
    name: 'number',
    abbreviated_name: 'n',
    validate: x => {
        return !isNaN(x);
    },
	parse_string(str) {
		const p = parseFloat(str);
		// then is it a number???

		// then is its string the same....?
		if (p + '' === str) {
			const parsed_is_valid = this.validate(p);
			if (parsed_is_valid) {
				return p;
			}
		}


	}
});

Functional_Data_Type.integer = new Functional_Data_Type({
    name: 'integer',
    abbreviated_name: 'int',
    validate: x => {
        return Number.isInteger(x);
    },
	parse_string(str) {
		const p = parseInt(str);
		// then is it a number???

		// then is its string the same....?
		if (p + '' === str) {
			const parsed_is_valid = this.validate(p);
			if (parsed_is_valid) {
				return p;
			}
		}


	}
});

// Need fdts for things like a [lat, long] array.
//   Maybe see about making it (easily) from composite data types.
//     Pair(Lat, Long) or similar
//     Maybe want it defined in a few lines of string grammar if it's easy.
//       Would make for a simple API - but would require parsing a custom language.








// Would be worth getting into creating conventions and idioms for higher level code.
//   Though first getting data type systems working right would help.
//     Making them easy to use.

const field = (...a) => {

	// Will also want to set data types of fields....

	// Uses obj._
	//   Seems quite simple, powerful, flexible.
	//     However, would like a different way of doing it too, could use a local variable defined within the 'field' function.

	// Want to incorporate data types, maybe grammar too.

	// Could use fp for this as well????
	//   See about really concise function definitions.

	//  Also want to see about some benchmarks too.
	//    Eg rendering a large page server side 10 times.

	const raise_change_events = true;

	const ifn = item => typeof item === "function";

	let s = get_a_sig(a);
	if (s === "[a]") {
		// prop????
		each(a[0], item_params => {
			prop.apply(this, item_params);
		});
	} else {
		if (a.length > 1) {
			if (is_array(a[0])) {

				throw 'stop - need to fix';
				// the rest of the properties applied to the array of items.

				// But field.apply here...???
				let objs = a.shift();
				each(objs, obj => {
					field.apply(this, [obj].concat(item_params));
				});
			} else {
				// Maybe will have a Data_Type....

				let obj, prop_name, data_type, default_value, fn_transform;
				//let raise_change_events = opts.raise_change_events;
				if (a.length === 2) {
					[obj, prop_name] = a;
				} else if (a.length === 3) {

					// And also check a[2] for being a Data_Type.

					if (a[2] instanceof Data_Type) {
						[obj, prop_name, data_type, default_value] = a;
					} else {
						if (ifn(a[2])) {
							[obj, prop_name, fn_transform] = a;
						} else {
							[obj, prop_name, default_value] = a;
						}
					}


					
				} else if (a.length === 4) {

					// field(this, 'value', this.data_type, spec.value);

					if (a[2] instanceof Data_Type) {
						[obj, prop_name, data_type, default_value] = a;
					} else {
						[obj, prop_name, default_value, fn_transform] = a;
					}

					
				}

				if (obj !== undefined) {



					Object.defineProperty(obj, prop_name, {
						get() {
							if (is_defined(obj._)) {
								return obj._[prop_name];
							} else {
								return undefined;
							}
							//return _prop_value;
						},
						set(value) {
							//console.log('setting prop: ' + prop_name);
							let old = (obj._ = obj._ || {})[prop_name];
							// value must be an array of length 2.


							if (old !== value) {

								let is_valid = true;
								if (data_type) {

									is_valid = data_type.validate(value);

									// if not valid directly, can we parse it from a string???

									if (typeof value === 'string') {
										const parsed_value = data_type.parse_string(value);
										is_valid = data_type.validate(parsed_value);

										if (is_valid) value = parsed_value;
									}



								}
								if (is_valid) {

									let _value;
									if (fn_transform) {
										//try {
										_value = fn_transform(value);
										//} catch (err) {
										//    throw err;
										//}
									} else {
	
	
	
										_value = value;
									}
									obj._[prop_name] = _value;
									if (raise_change_events) {
										obj.raise("change", {
											name: prop_name,
											old: old,
											value: _value
										});
									}
								}
							}
						}
					});
					if (is_defined(default_value)) {
						let is_valid = true;
						if (data_type) {
							is_valid = data_type.validate(default_value);
						}
						if (is_valid) {
							(obj._ = obj._ || {})[prop_name] = default_value;
						}
					}
				} else {
					throw 'stop';
				}
			}
		}
	}
};



// Probably need an 'equals' function.
//   Would make use of .equals and .hash functions / properties when available.

// Though Data_Value.toString and toJSON may be most useful sooner...

// lang-tools should have the equals function that supports Data_Value (maybe Data_Model in general).

const lang_mini_props = {
	each,
	is_array,
	is_dom_node,
	is_ctrl,
	clone,
	get_truth_map_from_arr,
	tm: get_truth_map_from_arr,
	get_arr_from_truth_map,
	arr_trim_undefined,
	get_map_from_arr,
	arr_like_to_arr,
	tof,
	atof,
	tf,
	load_type,
	is_defined,
	def: is_defined,
	Grammar,
	stringify,
	functional_polymorphism,
	fp,
	mfp,
	arrayify,
	mapify,
	str_arr_mapify,
	get_a_sig,
	deep_sig,
	get_item_sig,
	set_vals,
	truth,
	trim_sig_brackets,
	ll_set,
	ll_get,
	iterate_ancestor_classes,
	is_arr_of_t,
	is_arr_of_arrs,
	is_arr_of_strs,
	input_processors,
	output_processors,
	call_multiple_callback_functions,
	call_multi,
	multi: call_multi,
	native_constructor_tof,
	Fns,
	sig_match,
	remove_sig_from_arr_shell,
	to_arr_strip_keys,
	arr_objs_to_arr_keys_values_table,
	set_arr_tree_value,
	get_arr_tree_value,
	deep_arr_iterate,
	prom,
	combinations,
	combos: combinations,
	Evented_Class,
	eventify,
	vectorify,
	v_add,
	v_subtract,
	v_multiply,
	v_divide,
	vector_magnitude,
	distance_between_points,
	get_typed_array,
	gta: get_typed_array,
	Publisher,
	field,
	prop,
	Data_Type,
	Functional_Data_Type
};

const lang_mini = new Evented_Class();
Object.assign(lang_mini, lang_mini_props);
lang_mini.note = (str_name, str_state, obj_properties) => {
	obj_properties = obj_properties || {};
	obj_properties.name = str_name;
	obj_properties.state = str_state;
	lang_mini.raise('note', obj_properties)
}
module.exports = lang_mini;

// Bring in grammar / compound types to this typedef type thing.
//   Types in the fields. 

// Detecting invalid view model states.
//   Validating according to the spec of the data basically.

// Defining data types and models with a gui....




if (require.main === module) {



	/*
	function test_evented_class(test_data) {
		const create_empty_test_res = () => {
		  return {
			passed: [],
			failed: []
		  };
		};
	  
		// Initialize res object with empty arrays
		const res = create_empty_test_res();
	  
		// Test each event in test_data
		for (let i = 0; i < test_data.length; i++) {
		  const { event_name, event_data } = test_data[i];
	  
		  // Test adding the event
		  const evented_class = new Evented_Class();
		  evented_class.add_event_listener(event_name, (data) => {
			if (data === event_data) {
			  res.passed.push(event_name);
			} else {
			  res.failed.push(event_name);
			}
		  });
	  
		  // Test raising the event
		  evented_class.raise_event(event_name, event_data);
		}
	  
		// Return test results
		return res;
	  }
	  */

	  const test_data = [
		{
			event_name: 'foo',
			event_data: 'hello'
		},
		{
			event_name: 'bar',
			event_data: 'world'
		},
		{
			event_name: 'baz',
			event_data: true
		}
	];
	
	const create_empty_test_res = () => ({
		passed: [],
		failed: []
	});

	  
	  function test_evented_class(test_data) {
		const res = create_empty_test_res();
	
		// Create a new instance of Evented_Class
		const evented_class = new Evented_Class();
	
		// Test each event in the test data
		test_data.forEach(test_event => {
			const event_name = test_event.event_name;
			const event_data = test_event.event_data;
	
			// Define a listener for the event
			const listener = data => {
				if (data === event_data) {
					// The event was raised with the expected data
					res.passed.push(event_name);
				} else {
					// The event was raised with the wrong data
					res.failed.push(event_name);
				}
			};
	
			// Add the listener to the evented class
			evented_class.on(event_name, listener);
	
			// Raise the event
			evented_class.raise_event(event_name, event_data);
		});
	
		return res;
	}
	


	const result = test_evented_class(test_data);

	// Print the results of the test
	console.log('Passed:', result.passed);
	console.log('Failed:', result.failed);


}
}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":3}],381:[function(require,module,exports){
arguments[4][379][0].apply(exports,arguments)
},{"./lang-mini":380,"dup":379}],382:[function(require,module,exports){
// Field
// Prop

// put this in lang-mini?

// Validate and transform in one function?
//  Throws an exception then it's a validation error.

// Relatively simple and powerful functionality here.
//   Could put within lang-mini????


const {
	each,
	get_a_sig,
	def,
	is_array,
	tof,
	tf
} = require("lang-mini");

const ifn = item => typeof item === "function";
const ia = is_array;

const get_instance = function () {

	const opts = {
		raise_change_events: true
	}


	// Maybe use MFP for this too?
	//  Worth benchmarking before and after. mfp not benchmarked yet.

	const states = (obj, states) => {
		// set the states
		// set / get the state by name
		// set / get the states by index
		// alternate / toggle between states
	};

	// add the db field data


	// uses ._[name]

	// Maybe move field to lang-mini.
	//   Maybe want to be able to apply 


	// Should make the prop_name work as an array for aliases.

	// But field makes use of 'prop'.
	//   Moving this entirely to lang-mini may help. Then in lang-mini can integrate it with data type and grammar.


	// Field has a nicer / simpler API than prop it seems, but it internally makes use of prop.
	//   May look further into using prop....

	// raise_change_events being an option....?

	


	const get_set = (obj, prop_name, fn_get, fn_set) => {
		const def = {
			// Using shorthand method names (ES2015 feature).
			// This is equivalent to:
			// get: function() { return bValue; },
			// set: function(newValue) { bValue = newValue; },
			get: fn_get,
			set: fn_set,
			enumerable: true,
			configurable: false
		}

		const t_prop_name = tf(prop_name);
		if (t_prop_name === 'a') {
			each(prop_name, name => Object.defineProperty(obj, name, def));
		} else if (t_prop_name === 's') {
			Object.defineProperty(obj, prop_name, def);
		} else {
			console.trace();
			throw 'Unexpected prop_name, must be array or string';
		}


	}

	//


	// Should make the prop_name work as an array for aliases.
	const read_only = (obj, prop_name, fn_get) => {
		/*
		  Object.defineProperty(obj, prop_name, {
		      get() {
		          return fn_get();
		      }
		  });
		  */

		Object.defineProperty(obj, prop_name, {
			enumerable: true,
			get: fn_get
		});
	};


	// prop is a bit like field. Somewhat more complicated. Not sure how much it gets used in jsgui3 or other code.
	//   Maybe change / improve it.
	//     Seems like very large overlap with 'field', could introduce more capabilities like tranformation functions.
	//   field.validator = 
	//   field.input_transformer = 
	//   field.input.transformer = ...
	//   field.input.validator = ....

	// field.security = ....?
	//   which users have access? which components in the webapp have access?



	const prop = (...a) => {
		// ...args?
		let s = get_a_sig(a);
		if (s === "[a]") {
			each(a[0], item_params => {
				prop.apply(this, item_params);
			});
		} else {
			if (a.length === 2) {
				if (ia(a[1])) {
					const target = a[0];
					each(a[1], item => {
						if (ia(item)) {
							throw "NYI 468732";
						} else {
							prop(target, item);
						}
					});
				} else {
					const ta1 = tof(a[1]);
					if (ta1 === "string") {
						[obj, prop_name] = a;
					} else {
						throw "NYI 468732b";
					}
				}
			} else if (a.length > 2) {
				if (ia(a[0])) {
					// the rest of the properties applied to the array of items.
					throw "stop";
					let objs = a.shift();
					each(objs, obj => {
						prop.apply(this, [obj].concat(item_params)); // bug
					});
				} else {
					let obj, prop_name, default_value, fn_onchange, fn_transform, fn_on_ready, options;
					const load_options = options => {
						prop_name = prop_name || options.name || options.prop_name;
						fn_onchange =
							options.fn_onchange || options.onchange || options.change;
						fn_transform =
							options.fn_transform || options.ontransform || options.transform;
						fn_on_ready = options.ready || options.on_ready;
						default_value = default_value || options.default_value || options.default;
					};
					if (a.length === 2) {
						[obj, options] = a;
						load_options(options);
					} else if (a.length === 3) {
						if (ifn(a[2])) {
							[obj, prop_name, fn_onchange] = a;
						} else {

							if (a[2] !== undefined && (a[2].change || a[2].ready)) {
								load_options(a[2]);

								[obj, prop_name] = a;
							} else {
								[obj, prop_name, default_value] = a;
							}
						}
						//[obj, prop_name, default_value, fn_transform] = a;
					} else if (a.length === 4) {
						if (ifn(a[2]) && ifn(a[3])) {
							[obj, prop_name, fn_transform, fn_onchange] = a;
						} else if (ifn(a[3])) {
							[obj, prop_name, default_value, fn_onchange] = a;
						} else {
							[obj, prop_name, default_value, options] = a;
							load_options(options);
						}
					} else if (a.length === 5) {
						[obj, prop_name, default_value, fn_transform, fn_onchange] = a;
					}
					let _prop_value;

					if (typeof default_value !== 'undefined') _prop_value = default_value;
					// And a silent set function that does not raise the change event.
					const _silent_set = value => {
						let _value;
						if (fn_transform) {
							_value = fn_transform(value);
						} else {
							_value = value;
						}
						_prop_value = _value;
					}
					const _set = value => {
						let _value;
						if (fn_transform) {
							_value = fn_transform(value);
						} else {
							_value = value;
						}
						let old = _prop_value;
						_prop_value = _value;
						if (fn_onchange) {
							fn_onchange({
								old: old,
								value: _prop_value
							});
						}
						if (obj.raise && opts.raise_change_events) {
							obj.raise("change", {
								name: prop_name,
								old: old,
								value: _prop_value
							});
						}
					};
					if (def(default_value)) {
						_prop_value = default_value;
					}
					const t_prop_name = tf(prop_name);
					if (t_prop_name === 's') {

						Object.defineProperty(obj, prop_name, {
							get() {
								return _prop_value;
							},
							set(value) {
								_set(value);
							}
						});

					} else if (t_prop_name === 'a') {
						const l = prop_name.length;
						//console.log('prop_name', prop_name);
						let item_prop_name;
						for (let c = 0; c < l; c++) {
							item_prop_name = prop_name[c];
							//console.log('item_prop_name', item_prop_name);
							Object.defineProperty(obj, item_prop_name, {
								get() {
									return _prop_value;
								},
								set(value) {
									_set(value);
								}
							});
						}
					} else {
						throw 'Unexpected name type: ' + t_prop_name;
					}
					if (fn_on_ready) {
						fn_on_ready({
							silent_set: _silent_set
						})
					}
				}
			}
		}
	};

	const field = (...a) => {

		// Uses obj._
		//   Seems quite simple, powerful, flexible.
		//     However, would like a different way of doing it too, could use a local variable defined within the 'field' function.



		let s = get_a_sig(a);
		if (s === "[a]") {
			// prop????
			each(a[0], item_params => {
				prop.apply(this, item_params);
			});
		} else {
			if (a.length > 1) {
				if (ia(a[0])) {
					// the rest of the properties applied to the array of items.
					let objs = a.shift();
					each(objs, obj => {
						prop.apply(this, [obj].concat(item_params));
					});
				} else {
					let obj, prop_name, default_value, fn_transform;
					let raise_change_events = opts.raise_change_events;
					if (a.length === 2) {
						[obj, prop_name] = a;
					} else if (a.length === 3) {
						if (ifn(a[2])) {
							[obj, prop_name, fn_transform] = a;
						} else {
							[obj, prop_name, default_value] = a;
						}
					} else if (a.length === 4) {
						[obj, prop_name, default_value, fn_transform] = a;
					}

					if (obj !== undefined) {
						Object.defineProperty(obj, prop_name, {
							get() {
								if (def(obj._)) {
									return obj._[prop_name];
								} else {
									return undefined;
								}
								//return _prop_value;
							},
							set(value) {
								//console.log('setting prop: ' + prop_name);
								let old = (obj._ = obj._ || {})[prop_name];
								// value must be an array of length 2.
								let _value;
								if (fn_transform) {
									//try {
									_value = fn_transform(value);
									//} catch (err) {
									//    throw err;
									//}
								} else {
									_value = value;
								}
								obj._[prop_name] = _value;
								if (raise_change_events) {
									obj.raise("change", {
										name: prop_name,
										old: old,
										value: _value
									});
								}
							}
						});
						if (def(default_value)) {
							(obj._ = obj._ || {})[prop_name] = default_value;
						}
					} else {
						throw 'stop';
					}
				}
			}
		}
	};

	// could return a function get_instance, with those functions merged.
	return {
		opts, // module level options
		prop,
		field,
		read_only,
		ro: read_only,
		get_set,
		gs: get_set
	};
};
module.exports = get_instance();




},{"lang-mini":381}],383:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],384:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?#&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encode(key);
      value = encode(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],385:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],386:[function(require,module,exports){
(function (global){(function (){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/
  , CRHTLF = /[\n\r\t]/g
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
  , port = /:\d+$/
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i
  , windowsDriveLetter = /^[a-zA-Z]:/;

/**
 * Remove control characters and whitespace from the beginning of a string.
 *
 * @param {Object|String} str String to trim.
 * @returns {String} A new string representing `str` stripped of control
 *     characters and whitespace from its beginning.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(controlOrWhitespace, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address, url) {     // Sanitize what is left of the address
    return isSpecial(url.protocol) ? address.replace(/\\/g, '/') : address;
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d*)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof global !== 'undefined') globalVar = global;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * Check whether a protocol scheme is special.
 *
 * @param {String} The protocol scheme of the URL
 * @return {Boolean} `true` if the protocol scheme is special, else `false`
 * @private
 */
function isSpecial(scheme) {
  return (
    scheme === 'file:' ||
    scheme === 'ftp:' ||
    scheme === 'http:' ||
    scheme === 'https:' ||
    scheme === 'ws:' ||
    scheme === 'wss:'
  );
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @param {Object} location
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address, location) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, '');
  location = location || {};

  var match = protocolre.exec(address);
  var protocol = match[1] ? match[1].toLowerCase() : '';
  var forwardSlashes = !!match[2];
  var otherSlashes = !!match[3];
  var slashesCount = 0;
  var rest;

  if (forwardSlashes) {
    if (otherSlashes) {
      rest = match[2] + match[3] + match[4];
      slashesCount = match[2].length + match[3].length;
    } else {
      rest = match[2] + match[4];
      slashesCount = match[2].length;
    }
  } else {
    if (otherSlashes) {
      rest = match[3] + match[4];
      slashesCount = match[3].length;
    } else {
      rest = match[4]
    }
  }

  if (protocol === 'file:') {
    if (slashesCount >= 2) {
      rest = rest.slice(2);
    }
  } else if (isSpecial(protocol)) {
    rest = match[4];
  } else if (protocol) {
    if (forwardSlashes) {
      rest = rest.slice(2);
    }
  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
    rest = match[4];
  }

  return {
    protocol: protocol,
    slashes: forwardSlashes || isSpecial(protocol),
    slashesCount: slashesCount,
    rest: rest
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, '');

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '', location);
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (
    extracted.protocol === 'file:' && (
      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||
    (!extracted.slashes &&
      (extracted.protocol ||
        extracted.slashesCount < 2 ||
        !isSpecial(url.protocol)))
  ) {
    instructions[3] = [/(.*)/, 'pathname'];
  }

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address, url);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      index = parse === '@'
        ? address.lastIndexOf(parse)
        : address.indexOf(parse);

      if (~index) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // Default to a / for pathname if none exists. This normalizes the URL
  // to always have a /
  //
  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {
    url.pathname = '/' + url.pathname;
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';

  if (url.auth) {
    index = url.auth.indexOf(':');

    if (~index) {
      url.username = url.auth.slice(0, index);
      url.username = encodeURIComponent(decodeURIComponent(url.username));

      url.password = url.auth.slice(index + 1);
      url.password = encodeURIComponent(decodeURIComponent(url.password))
    } else {
      url.username = encodeURIComponent(decodeURIComponent(url.auth));
    }

    url.auth = url.password ? url.username +':'+ url.password : url.username;
  }

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (port.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    case 'username':
    case 'password':
      url[part] = encodeURIComponent(value);
      break;

    case 'auth':
      var index = value.indexOf(':');

      if (~index) {
        url.username = value.slice(0, index);
        url.username = encodeURIComponent(decodeURIComponent(url.username));

        url.password = value.slice(index + 1);
        url.password = encodeURIComponent(decodeURIComponent(url.password));
      } else {
        url.username = encodeURIComponent(decodeURIComponent(value));
      }
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.auth = url.password ? url.username +':'+ url.password : url.username;

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , host = url.host
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result =
    protocol +
    ((url.protocol && url.slashes) || isSpecial(url.protocol) ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  } else if (url.password) {
    result += ':'+ url.password;
    result += '@';
  } else if (
    url.protocol !== 'file:' &&
    isSpecial(url.protocol) &&
    !host &&
    url.pathname !== '/'
  ) {
    //
    // Add back the empty userinfo, otherwise the original invalid URL
    // might be transformed into a valid one with `url.pathname` as host.
    //
    result += '@';
  }

  //
  // Trailing colon is removed from `url.host` when it is parsed. If it still
  // ends with a colon, then add back the trailing colon that was removed. This
  // prevents an invalid URL from being transformed into a valid one.
  //
  if (host[host.length - 1] === ':' || (port.test(url.hostname) && !url.port)) {
    host += ':';
  }

  result += host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"querystringify":384,"requires-port":385}]},{},[1]);
